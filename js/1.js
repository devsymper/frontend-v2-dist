(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/ag-grid-enterprise/dist/ag-grid-enterprise.cjs.js":
/*!************************************************************************!*\
  !*** ./node_modules/ag-grid-enterprise/dist/ag-grid-enterprise.cjs.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * ag-grid-enterprise - ag-Grid Enterprise Features * @version v25.1.0\n * @link http://www.ag-grid.com/\n' * @license Commercial\n */\n\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar agGridCommunity = __webpack_require__(/*! ag-grid-community */ \"./node_modules/ag-grid-community/dist/ag-grid-community.cjs.js\");\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LicenseManager = /** @class */ (function (_super) {\n    __extends(LicenseManager, _super);\n    function LicenseManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.watermarkMessage = undefined;\n        return _this;\n    }\n    LicenseManager_1 = LicenseManager;\n    LicenseManager.prototype.validateLicense = function () {\n        return\n        if (agGridCommunity._.missingOrEmpty(LicenseManager_1.licenseKey)) {\n            this.outputMissingLicenseKey();\n        }\n        else if (LicenseManager_1.licenseKey.length > 32) {\n            var _a = LicenseManager_1.extractLicenseComponents(LicenseManager_1.licenseKey), md5 = _a.md5, license = _a.license, version = _a.version, isTrial = _a.isTrial;\n            if (md5 === this.md5.md5(license)) {\n                if (agGridCommunity._.exists(version) && version) {\n                    this.validateLicenseKeyForVersion(version, !!isTrial, license);\n                }\n                else {\n                    this.validateLegacyKey(license);\n                }\n            }\n            else {\n                this.outputInvalidLicenseKey();\n            }\n        }\n        else {\n            this.outputInvalidLicenseKey();\n        }\n    };\n    LicenseManager.extractExpiry = function (license) {\n        var restrictionHashed = license.substring(license.lastIndexOf('_') + 1, license.length);\n        return new Date(parseInt(LicenseManager_1.decode(restrictionHashed), 10));\n    };\n    LicenseManager.extractLicenseComponents = function (licenseKey) {\n        // when users copy the license key from a PDF extra zero width characters are sometimes copied too\n        // carriage returns and line feeds are problematic too\n        // all of which causes license key validation to fail - strip these out\n        var cleanedLicenseKey = licenseKey.replace(/[\\u200B-\\u200D\\uFEFF]/g, '');\n        cleanedLicenseKey = cleanedLicenseKey.replace(/\\r?\\n|\\r/g, '');\n        var hashStart = cleanedLicenseKey.length - 32;\n        var md5 = cleanedLicenseKey.substring(hashStart);\n        var license = cleanedLicenseKey.substring(0, hashStart);\n        var _a = LicenseManager_1.extractBracketedInformation(cleanedLicenseKey), version = _a[0], isTrial = _a[1];\n        return { md5: md5, license: license, version: version, isTrial: isTrial };\n    };\n    LicenseManager.prototype.getLicenseDetails = function (licenseKey) {\n        var _a = LicenseManager_1.extractLicenseComponents(licenseKey), md5 = _a.md5, license = _a.license, version = _a.version, isTrial = _a.isTrial;\n        var valid = (md5 === this.md5.md5(license));\n        var expiry = null;\n        if (valid) {\n            expiry = LicenseManager_1.extractExpiry(license);\n            valid = !isNaN(expiry.getTime());\n        }\n        return {\n            licenseKey: licenseKey,\n            valid: valid,\n            expiry: valid ? LicenseManager_1.formatDate(expiry) : null,\n            version: version ? version : 'legacy',\n            isTrial: isTrial\n        };\n    };\n    LicenseManager.prototype.isDisplayWatermark = function () {\n        return !agGridCommunity._.missingOrEmpty(this.watermarkMessage);\n    };\n    LicenseManager.prototype.getWatermarkMessage = function () {\n        return this.watermarkMessage || '';\n    };\n    LicenseManager.formatDate = function (date) {\n        var monthNames = [\n            'January', 'February', 'March',\n            'April', 'May', 'June', 'July',\n            'August', 'September', 'October',\n            'November', 'December'\n        ];\n        var day = date.getDate();\n        var monthIndex = date.getMonth();\n        var year = date.getFullYear();\n        return day + ' ' + monthNames[monthIndex] + ' ' + year;\n    };\n    LicenseManager.getGridReleaseDate = function () {\n        return new Date(parseInt(LicenseManager_1.decode(LicenseManager_1.RELEASE_INFORMATION), 10));\n    };\n    LicenseManager.decode = function (input) {\n        var keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var t = '';\n        var n, r, i;\n        var s, o, u, a;\n        var f = 0;\n        var e = input.replace(/[^A-Za-z0-9+/=]/g, '');\n        while (f < e.length) {\n            s = keystr.indexOf(e.charAt(f++));\n            o = keystr.indexOf(e.charAt(f++));\n            u = keystr.indexOf(e.charAt(f++));\n            a = keystr.indexOf(e.charAt(f++));\n            n = s << 2 | o >> 4;\n            r = (o & 15) << 4 | u >> 2;\n            i = (u & 3) << 6 | a;\n            t = t + String.fromCharCode(n);\n            if (u != 64) {\n                t = t + String.fromCharCode(r);\n            }\n            if (a != 64) {\n                t = t + String.fromCharCode(i);\n            }\n        }\n        t = LicenseManager_1.utf8_decode(t);\n        return t;\n    };\n    LicenseManager.utf8_decode = function (input) {\n        input = input.replace(/rn/g, 'n');\n        var t = '';\n        for (var n = 0; n < input.length; n++) {\n            var r = input.charCodeAt(n);\n            if (r < 128) {\n                t += String.fromCharCode(r);\n            }\n            else if (r > 127 && r < 2048) {\n                t += String.fromCharCode(r >> 6 | 192);\n                t += String.fromCharCode(r & 63 | 128);\n            }\n            else {\n                t += String.fromCharCode(r >> 12 | 224);\n                t += String.fromCharCode(r >> 6 & 63 | 128);\n                t += String.fromCharCode(r & 63 | 128);\n            }\n        }\n        return t;\n    };\n    LicenseManager.setLicenseKey = function (licenseKey) {\n        LicenseManager_1.licenseKey = licenseKey;\n    };\n    LicenseManager.extractBracketedInformation = function (licenseKey) {\n        var matches = licenseKey.split('[')\n            .filter(function (v) {\n            return v.indexOf(']') > -1;\n        })\n            .map(function (value) {\n            return value.split(']')[0];\n        });\n        if (!matches || matches.length === 0) {\n            return [null, null];\n        }\n        var isTrial = matches.filter(function (match) { return match === 'TRIAL'; }).length === 1;\n        var version = matches.filter(function (match) { return match.indexOf(\"v\") === 0; }).map(function (match) { return match.replace(/^v/, \"\"); })[0];\n        return [version, isTrial];\n    };\n    LicenseManager.prototype.validateLicenseKeyForVersion = function (version, isTrial, license) {\n        if (version !== '2') {\n            return;\n        }\n        if (isTrial) {\n            this.validateForTrial(license);\n        }\n        else {\n            this.validateLegacyKey(license);\n        }\n    };\n    LicenseManager.prototype.validateLegacyKey = function (license) {\n        var gridReleaseDate = LicenseManager_1.getGridReleaseDate();\n        var expiry = LicenseManager_1.extractExpiry(license);\n        var valid = false;\n        var current = false;\n        if (!isNaN(expiry.getTime())) {\n            valid = true;\n            current = (gridReleaseDate < expiry);\n        }\n        if (!valid) {\n            this.outputInvalidLicenseKey();\n        }\n        else if (!current) {\n            var formattedExpiryDate = LicenseManager_1.formatDate(expiry);\n            var formattedReleaseDate = LicenseManager_1.formatDate(gridReleaseDate);\n            this.outputIncompatibleVersion(formattedExpiryDate, formattedReleaseDate);\n        }\n    };\n    LicenseManager.prototype.validateForTrial = function (license) {\n        var expiry = LicenseManager_1.extractExpiry(license);\n        var now = new Date();\n        var valid = false;\n        var current = false;\n        if (!isNaN(expiry.getTime())) {\n            valid = true;\n            current = (expiry > now);\n        }\n        if (!valid) {\n            this.outputInvalidLicenseKey();\n        }\n        else if (!current) {\n            var formattedExpiryDate = LicenseManager_1.formatDate(expiry);\n            this.outputExpiredTrialKey(formattedExpiryDate);\n        }\n    };\n    LicenseManager.prototype.outputInvalidLicenseKey = function () {\n        console.error('*****************************************************************************************************************');\n        console.error('***************************************** AG Grid Enterprise License ********************************************');\n        console.error('********************************************* Invalid License ***************************************************');\n        console.error('* Your license for AG Grid Enterprise is not valid - please contact info@ag-grid.com to obtain a valid license. *');\n        console.error('*****************************************************************************************************************');\n        console.error('*****************************************************************************************************************');\n        this.watermarkMessage = \"Invalid License\";\n    };\n    LicenseManager.prototype.outputExpiredTrialKey = function (formattedExpiryDate) {\n        console.error('****************************************************************************************************************');\n        console.error('***************************************** AG Grid Enterprise License *******************************************');\n        console.error('*****************************************   Trial Period Expired.    *******************************************');\n        console.error(\"* Your license for AG Grid Enterprise expired on \" + formattedExpiryDate + \".                                                *\");\n        console.error('* Please email info@ag-grid.com to purchase a license.                                                         *');\n        console.error('****************************************************************************************************************');\n        console.error('****************************************************************************************************************');\n        this.watermarkMessage = \"Trial Period Expired\";\n    };\n    LicenseManager.prototype.outputMissingLicenseKey = function () {\n        console.error('****************************************************************************************************************');\n        console.error('***************************************** AG Grid Enterprise License *******************************************');\n        console.error('****************************************** License Key Not Found ***********************************************');\n        console.error('* All AG Grid Enterprise features are unlocked.                                                                *');\n        console.error('* This is an evaluation only version, it is not licensed for development projects intended for production.     *');\n        console.error('* If you want to hide the watermark, please email info@ag-grid.com for a trial license.                        *');\n        console.error('****************************************************************************************************************');\n        console.error('****************************************************************************************************************');\n        this.watermarkMessage = \"For Trial Use Only\";\n    };\n    LicenseManager.prototype.outputIncompatibleVersion = function (formattedExpiryDate, formattedReleaseDate) {\n        console.error('****************************************************************************************************************************');\n        console.error('****************************************************************************************************************************');\n        console.error('*                                             AG Grid Enterprise License                                                   *');\n        console.error('*                           License not compatible with installed version of AG Grid Enterprise.                           *');\n        console.error('*                                                                                                                          *');\n        console.error(\"* Your AG Grid License entitles you to all versions of AG Grid that we release within the time covered by your license     *\");\n        console.error(\"* - typically we provide one year licenses which entitles you to all releases / updates of AG Grid within that year.       *\");\n        console.error(\"* Your license has an end (expiry) date which stops the license key working with versions of AG Grid released after the    *\");\n        console.error(\"* license end date. The license key that you have expires on \" + formattedExpiryDate + \", however the version of AG Grid you    *\");\n        console.error(\"* are trying to use was released on \" + formattedReleaseDate + \".                                                               *\");\n        console.error('*                                                                                                                          *');\n        console.error('* Please contact info@ag-grid.com to renew your subscription to new versions and get a new license key to work with this   *');\n        console.error('* version of AG Grid.                                                                                                      *');\n        console.error('****************************************************************************************************************************');\n        console.error('****************************************************************************************************************************');\n        this.watermarkMessage = \"License Expired\";\n    };\n    var LicenseManager_1;\n    LicenseManager.RELEASE_INFORMATION = 'MTYxMzQ2MjUzMTEzNw==';\n    __decorate([\n        agGridCommunity.Autowired('md5')\n    ], LicenseManager.prototype, \"md5\", void 0);\n    __decorate([\n        agGridCommunity.PreConstruct\n    ], LicenseManager.prototype, \"validateLicense\", null);\n    LicenseManager = LicenseManager_1 = __decorate([\n        agGridCommunity.Bean('licenseManager')\n    ], LicenseManager);\n    return LicenseManager;\n}(agGridCommunity.BeanStub));\n\nvar __extends$1 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MD5 = /** @class */ (function (_super) {\n    __extends$1(MD5, _super);\n    function MD5() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.ieCompatibility = false;\n        return _this;\n    }\n    MD5.prototype.init = function () {\n        this.ieCompatibility = (this.md5('hello') != '5d41402abc4b2a76b9719d911017c592');\n    };\n    MD5.prototype.md5cycle = function (x, k) {\n        var a = x[0], b = x[1], c = x[2], d = x[3];\n        a = this.ff(a, b, c, d, k[0], 7, -680876936);\n        d = this.ff(d, a, b, c, k[1], 12, -389564586);\n        c = this.ff(c, d, a, b, k[2], 17, 606105819);\n        b = this.ff(b, c, d, a, k[3], 22, -1044525330);\n        a = this.ff(a, b, c, d, k[4], 7, -176418897);\n        d = this.ff(d, a, b, c, k[5], 12, 1200080426);\n        c = this.ff(c, d, a, b, k[6], 17, -1473231341);\n        b = this.ff(b, c, d, a, k[7], 22, -45705983);\n        a = this.ff(a, b, c, d, k[8], 7, 1770035416);\n        d = this.ff(d, a, b, c, k[9], 12, -1958414417);\n        c = this.ff(c, d, a, b, k[10], 17, -42063);\n        b = this.ff(b, c, d, a, k[11], 22, -1990404162);\n        a = this.ff(a, b, c, d, k[12], 7, 1804603682);\n        d = this.ff(d, a, b, c, k[13], 12, -40341101);\n        c = this.ff(c, d, a, b, k[14], 17, -1502002290);\n        b = this.ff(b, c, d, a, k[15], 22, 1236535329);\n        a = this.gg(a, b, c, d, k[1], 5, -165796510);\n        d = this.gg(d, a, b, c, k[6], 9, -1069501632);\n        c = this.gg(c, d, a, b, k[11], 14, 643717713);\n        b = this.gg(b, c, d, a, k[0], 20, -373897302);\n        a = this.gg(a, b, c, d, k[5], 5, -701558691);\n        d = this.gg(d, a, b, c, k[10], 9, 38016083);\n        c = this.gg(c, d, a, b, k[15], 14, -660478335);\n        b = this.gg(b, c, d, a, k[4], 20, -405537848);\n        a = this.gg(a, b, c, d, k[9], 5, 568446438);\n        d = this.gg(d, a, b, c, k[14], 9, -1019803690);\n        c = this.gg(c, d, a, b, k[3], 14, -187363961);\n        b = this.gg(b, c, d, a, k[8], 20, 1163531501);\n        a = this.gg(a, b, c, d, k[13], 5, -1444681467);\n        d = this.gg(d, a, b, c, k[2], 9, -51403784);\n        c = this.gg(c, d, a, b, k[7], 14, 1735328473);\n        b = this.gg(b, c, d, a, k[12], 20, -1926607734);\n        a = this.hh(a, b, c, d, k[5], 4, -378558);\n        d = this.hh(d, a, b, c, k[8], 11, -2022574463);\n        c = this.hh(c, d, a, b, k[11], 16, 1839030562);\n        b = this.hh(b, c, d, a, k[14], 23, -35309556);\n        a = this.hh(a, b, c, d, k[1], 4, -1530992060);\n        d = this.hh(d, a, b, c, k[4], 11, 1272893353);\n        c = this.hh(c, d, a, b, k[7], 16, -155497632);\n        b = this.hh(b, c, d, a, k[10], 23, -1094730640);\n        a = this.hh(a, b, c, d, k[13], 4, 681279174);\n        d = this.hh(d, a, b, c, k[0], 11, -358537222);\n        c = this.hh(c, d, a, b, k[3], 16, -722521979);\n        b = this.hh(b, c, d, a, k[6], 23, 76029189);\n        a = this.hh(a, b, c, d, k[9], 4, -640364487);\n        d = this.hh(d, a, b, c, k[12], 11, -421815835);\n        c = this.hh(c, d, a, b, k[15], 16, 530742520);\n        b = this.hh(b, c, d, a, k[2], 23, -995338651);\n        a = this.ii(a, b, c, d, k[0], 6, -198630844);\n        d = this.ii(d, a, b, c, k[7], 10, 1126891415);\n        c = this.ii(c, d, a, b, k[14], 15, -1416354905);\n        b = this.ii(b, c, d, a, k[5], 21, -57434055);\n        a = this.ii(a, b, c, d, k[12], 6, 1700485571);\n        d = this.ii(d, a, b, c, k[3], 10, -1894986606);\n        c = this.ii(c, d, a, b, k[10], 15, -1051523);\n        b = this.ii(b, c, d, a, k[1], 21, -2054922799);\n        a = this.ii(a, b, c, d, k[8], 6, 1873313359);\n        d = this.ii(d, a, b, c, k[15], 10, -30611744);\n        c = this.ii(c, d, a, b, k[6], 15, -1560198380);\n        b = this.ii(b, c, d, a, k[13], 21, 1309151649);\n        a = this.ii(a, b, c, d, k[4], 6, -145523070);\n        d = this.ii(d, a, b, c, k[11], 10, -1120210379);\n        c = this.ii(c, d, a, b, k[2], 15, 718787259);\n        b = this.ii(b, c, d, a, k[9], 21, -343485551);\n        x[0] = this.add32(a, x[0]);\n        x[1] = this.add32(b, x[1]);\n        x[2] = this.add32(c, x[2]);\n        x[3] = this.add32(d, x[3]);\n    };\n    MD5.prototype.cmn = function (q, a, b, x, s, t) {\n        a = this.add32(this.add32(a, q), this.add32(x, t));\n        return this.add32((a << s) | (a >>> (32 - s)), b);\n    };\n    MD5.prototype.ff = function (a, b, c, d, x, s, t) {\n        return this.cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    };\n    MD5.prototype.gg = function (a, b, c, d, x, s, t) {\n        return this.cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    };\n    MD5.prototype.hh = function (a, b, c, d, x, s, t) {\n        return this.cmn(b ^ c ^ d, a, b, x, s, t);\n    };\n    MD5.prototype.ii = function (a, b, c, d, x, s, t) {\n        return this.cmn(c ^ (b | (~d)), a, b, x, s, t);\n    };\n    MD5.prototype.md51 = function (s) {\n        var n = s.length;\n        var state = [1732584193, -271733879, -1732584194, 271733878];\n        var i;\n        for (i = 64; i <= s.length; i += 64) {\n            this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < s.length; i++) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            this.md5cycle(state, tail);\n            for (i = 0; i < 16; i++) {\n                tail[i] = 0;\n            }\n        }\n        tail[14] = n * 8;\n        this.md5cycle(state, tail);\n        return state;\n    };\n    /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5\n     * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and\n     * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character\n     * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?\n     * There is no way to standardize text to something like UTF-8 before transformation; speed cost is\n     * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start\n     * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.\n     */\n    MD5.prototype.md5blk = function (s) {\n        var md5blks = [];\n        /* Andy King said do it this way. */\n        for (var i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i)\n                + (s.charCodeAt(i + 1) << 8)\n                + (s.charCodeAt(i + 2) << 16)\n                + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    };\n    MD5.prototype.rhex = function (n) {\n        var hex_chr = '0123456789abcdef'.split('');\n        var s = '', j = 0;\n        for (; j < 4; j++) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]\n                + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    };\n    MD5.prototype.hex = function (x) {\n        for (var i = 0; i < x.length; i++) {\n            x[i] = this.rhex(x[i]);\n        }\n        return x.join('');\n    };\n    MD5.prototype.md5 = function (s) {\n        return this.hex(this.md51(s));\n    };\n    MD5.prototype.add32 = function (a, b) {\n        return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);\n    };\n    /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that\n     need the idiotic second function, generated by an if clause.  */\n    MD5.prototype.add32Std = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    };\n    MD5.prototype.add32Compat = function (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF), msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n    __decorate$1([\n        agGridCommunity.PostConstruct\n    ], MD5.prototype, \"init\", null);\n    MD5 = __decorate$1([\n        agGridCommunity.Bean('md5')\n    ], MD5);\n    return MD5;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WatermarkComp = /** @class */ (function (_super) {\n    __extends$2(WatermarkComp, _super);\n    function WatermarkComp() {\n        return _super.call(this, \"<div class=\\\"ag-watermark\\\">\\n                    <div ref=\\\"eLicenseTextRef\\\" class=\\\"ag-watermark-text\\\"></div>\\n               </div>\") || this;\n    }\n    WatermarkComp.prototype.postConstruct = function () {\n        var _this = this;\n        var show = this.shouldDisplayWatermark();\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-hidden', !show);\n        if (show) {\n            this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage();\n            window.setTimeout(function () { return _this.addCssClass('ag-opacity-zero'); }, 0);\n            window.setTimeout(function () { return _this.addCssClass('ag-hidden'); }, 5000);\n        }\n    };\n    WatermarkComp.prototype.shouldDisplayWatermark = function () {\n        var isDisplayWatermark = this.licenseManager.isDisplayWatermark();\n        var isWhiteListURL = location.hostname.match('^127\\.0\\.0\\.1|localhost|www\\.ag-grid\\.com$') != null;\n        var isForceWatermark = location.pathname ? location.pathname.indexOf('forceWatermark') !== -1 : false;\n        return isForceWatermark || (isDisplayWatermark && !isWhiteListURL);\n    };\n    __decorate$2([\n        agGridCommunity.Autowired('licenseManager')\n    ], WatermarkComp.prototype, \"licenseManager\", void 0);\n    __decorate$2([\n        agGridCommunity.RefSelector('eLicenseTextRef')\n    ], WatermarkComp.prototype, \"eLicenseTextRef\", void 0);\n    __decorate$2([\n        agGridCommunity.PostConstruct\n    ], WatermarkComp.prototype, \"postConstruct\", null);\n    return WatermarkComp;\n}(agGridCommunity.Component));\n\nvar EnterpriseCoreModule = {\n    moduleName: agGridCommunity.ModuleNames.EnterpriseCoreModule,\n    beans: [LicenseManager, MD5],\n    agStackComponents: [\n        { componentName: 'AgWatermark', componentClass: WatermarkComp }\n    ]\n};\n\nvar __extends$3 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ExpandState;\n(function (ExpandState) {\n    ExpandState[ExpandState[\"EXPANDED\"] = 0] = \"EXPANDED\";\n    ExpandState[ExpandState[\"COLLAPSED\"] = 1] = \"COLLAPSED\";\n    ExpandState[ExpandState[\"INDETERMINATE\"] = 2] = \"INDETERMINATE\";\n})(ExpandState || (ExpandState = {}));\nvar PrimaryColsHeaderPanel = /** @class */ (function (_super) {\n    __extends$3(PrimaryColsHeaderPanel, _super);\n    function PrimaryColsHeaderPanel() {\n        return _super.call(this, PrimaryColsHeaderPanel.TEMPLATE) || this;\n    }\n    PrimaryColsHeaderPanel.prototype.postConstruct = function () {\n        var _this = this;\n        this.createExpandIcons();\n        this.addManagedListener(this.eExpand, 'click', this.onExpandClicked.bind(this));\n        this.addManagedListener(this.eExpand, 'keydown', function (e) {\n            if (e.keyCode === agGridCommunity.KeyCode.SPACE) {\n                _this.onExpandClicked();\n            }\n        });\n        this.addManagedListener(this.eSelect.getInputElement(), 'click', this.onSelectClicked.bind(this));\n        this.eFilterTextField.onValueChange(function () { return _this.onFilterTextChanged(); });\n        this.addManagedListener(this.eFilterTextField.getInputElement(), 'keypress', this.onMiniFilterKeyPress.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eSelect.setInputAriaLabel(translate('ariaColumnSelectAll', 'Toggle Select All Columns'));\n        this.eFilterTextField.setInputAriaLabel(translate('ariaFilterColumnsInput', 'Filter Columns Input'));\n    };\n    PrimaryColsHeaderPanel.prototype.init = function (params) {\n        this.params = params;\n        if (this.columnController.isReady()) {\n            this.showOrHideOptions();\n        }\n    };\n    PrimaryColsHeaderPanel.prototype.createExpandIcons = function () {\n        this.eExpand.appendChild((this.eExpandChecked = agGridCommunity._.createIconNoSpan('columnSelectOpen', this.gridOptionsWrapper)));\n        this.eExpand.appendChild((this.eExpandUnchecked = agGridCommunity._.createIconNoSpan('columnSelectClosed', this.gridOptionsWrapper)));\n        this.eExpand.appendChild((this.eExpandIndeterminate = agGridCommunity._.createIconNoSpan('columnSelectIndeterminate', this.gridOptionsWrapper)));\n        this.setExpandState(ExpandState.EXPANDED);\n    };\n    // we only show expand / collapse if we are showing columns\n    PrimaryColsHeaderPanel.prototype.showOrHideOptions = function () {\n        var showFilter = !this.params.suppressColumnFilter;\n        var showSelect = !this.params.suppressColumnSelectAll;\n        var showExpand = !this.params.suppressColumnExpandAll;\n        var groupsPresent = this.columnController.isPrimaryColumnGroupsPresent();\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));\n        agGridCommunity._.setDisplayed(this.eFilterTextField.getGui(), showFilter);\n        agGridCommunity._.setDisplayed(this.eSelect.getGui(), showSelect);\n        agGridCommunity._.setDisplayed(this.eExpand, showExpand && groupsPresent);\n    };\n    PrimaryColsHeaderPanel.prototype.onFilterTextChanged = function () {\n        var _this = this;\n        if (!this.onFilterTextChangedDebounced) {\n            this.onFilterTextChangedDebounced = agGridCommunity._.debounce(function () {\n                var filterText = _this.eFilterTextField.getValue();\n                _this.dispatchEvent({ type: \"filterChanged\", filterText: filterText });\n            }, PrimaryColsHeaderPanel.DEBOUNCE_DELAY);\n        }\n        this.onFilterTextChangedDebounced();\n    };\n    PrimaryColsHeaderPanel.prototype.onMiniFilterKeyPress = function (e) {\n        var _this = this;\n        if (agGridCommunity._.isKeyPressed(e, agGridCommunity.KeyCode.ENTER)) {\n            // we need to add a delay that corresponds to the filter text debounce delay to ensure\n            // the text filtering has happened, otherwise all columns will be deselected\n            setTimeout(function () { return _this.onSelectClicked(); }, PrimaryColsHeaderPanel.DEBOUNCE_DELAY);\n        }\n    };\n    PrimaryColsHeaderPanel.prototype.onSelectClicked = function () {\n        this.dispatchEvent({ type: this.selectState ? 'unselectAll' : 'selectAll' });\n    };\n    PrimaryColsHeaderPanel.prototype.onExpandClicked = function () {\n        this.dispatchEvent({ type: this.expandState === ExpandState.EXPANDED ? 'collapseAll' : 'expandAll' });\n    };\n    PrimaryColsHeaderPanel.prototype.setExpandState = function (state) {\n        this.expandState = state;\n        agGridCommunity._.setDisplayed(this.eExpandChecked, this.expandState === ExpandState.EXPANDED);\n        agGridCommunity._.setDisplayed(this.eExpandUnchecked, this.expandState === ExpandState.COLLAPSED);\n        agGridCommunity._.setDisplayed(this.eExpandIndeterminate, this.expandState === ExpandState.INDETERMINATE);\n    };\n    PrimaryColsHeaderPanel.prototype.setSelectionState = function (state) {\n        this.selectState = state;\n        this.eSelect.setValue(this.selectState);\n    };\n    PrimaryColsHeaderPanel.DEBOUNCE_DELAY = 300;\n    PrimaryColsHeaderPanel.TEMPLATE = \"<div class=\\\"ag-column-select-header\\\" role=\\\"presentation\\\" tabindex=\\\"-1\\\">\\n            <div ref=\\\"eExpand\\\" class=\\\"ag-column-select-header-icon\\\" tabindex=\\\"0\\\"></div>\\n            <ag-checkbox ref=\\\"eSelect\\\" class=\\\"ag-column-select-header-checkbox\\\"></ag-checkbox>\\n            <ag-input-text-field class=\\\"ag-column-select-header-filter-wrapper\\\" ref=\\\"eFilterTextField\\\"></ag-input-text-field>\\n        </div>\";\n    __decorate$3([\n        agGridCommunity.Autowired('columnController')\n    ], PrimaryColsHeaderPanel.prototype, \"columnController\", void 0);\n    __decorate$3([\n        agGridCommunity.RefSelector('eExpand')\n    ], PrimaryColsHeaderPanel.prototype, \"eExpand\", void 0);\n    __decorate$3([\n        agGridCommunity.RefSelector('eSelect')\n    ], PrimaryColsHeaderPanel.prototype, \"eSelect\", void 0);\n    __decorate$3([\n        agGridCommunity.RefSelector('eFilterTextField')\n    ], PrimaryColsHeaderPanel.prototype, \"eFilterTextField\", void 0);\n    __decorate$3([\n        agGridCommunity.PostConstruct\n    ], PrimaryColsHeaderPanel.prototype, \"postConstruct\", null);\n    return PrimaryColsHeaderPanel;\n}(agGridCommunity.Component));\n\nvar ColumnModelItem = /** @class */ (function () {\n    function ColumnModelItem(displayName, columnOrGroup, dept, group, expanded) {\n        if (group === void 0) { group = false; }\n        this.eventService = new agGridCommunity.EventService();\n        this.displayName = displayName;\n        this.dept = dept;\n        this.group = group;\n        if (group) {\n            this.columnGroup = columnOrGroup;\n            this.expanded = expanded;\n            this.children = [];\n        }\n        else {\n            this.column = columnOrGroup;\n        }\n    }\n    ColumnModelItem.prototype.isGroup = function () { return this.group; };\n    ColumnModelItem.prototype.getDisplayName = function () { return this.displayName; };\n    ColumnModelItem.prototype.getColumnGroup = function () { return this.columnGroup; };\n    ColumnModelItem.prototype.getColumn = function () { return this.column; };\n    ColumnModelItem.prototype.getDept = function () { return this.dept; };\n    ColumnModelItem.prototype.isExpanded = function () { return !!this.expanded; };\n    ColumnModelItem.prototype.getChildren = function () { return this.children; };\n    ColumnModelItem.prototype.isPassesFilter = function () { return this.passesFilter; };\n    ColumnModelItem.prototype.setExpanded = function (expanded) {\n        if (expanded === this.expanded) {\n            return;\n        }\n        this.expanded = expanded;\n        this.eventService.dispatchEvent({ type: ColumnModelItem.EVENT_EXPANDED_CHANGED });\n    };\n    ColumnModelItem.prototype.setPassesFilter = function (passesFilter) {\n        this.passesFilter = passesFilter;\n    };\n    ColumnModelItem.prototype.addEventListener = function (eventType, listener) {\n        this.eventService.addEventListener(eventType, listener);\n    };\n    ColumnModelItem.prototype.removeEventListener = function (eventType, listener) {\n        this.eventService.removeEventListener(eventType, listener);\n    };\n    ColumnModelItem.EVENT_EXPANDED_CHANGED = 'expandedChanged';\n    return ColumnModelItem;\n}());\n\nvar __extends$4 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelColumnGroupComp = /** @class */ (function (_super) {\n    __extends$4(ToolPanelColumnGroupComp, _super);\n    function ToolPanelColumnGroupComp(modelItem, allowDragging, eventType, focusWrapper) {\n        var _this = _super.call(this) || this;\n        _this.modelItem = modelItem;\n        _this.allowDragging = allowDragging;\n        _this.eventType = eventType;\n        _this.focusWrapper = focusWrapper;\n        _this.processingColumnStateChange = false;\n        _this.modelItem = modelItem;\n        _this.columnGroup = modelItem.getColumnGroup();\n        _this.columnDept = modelItem.getDept();\n        _this.allowDragging = allowDragging;\n        return _this;\n    }\n    ToolPanelColumnGroupComp.prototype.init = function () {\n        this.setTemplate(ToolPanelColumnGroupComp.TEMPLATE);\n        this.eDragHandle = agGridCommunity._.createIconNoSpan('columnDrag', this.gridOptionsWrapper);\n        agGridCommunity._.addCssClass(this.eDragHandle, 'ag-drag-handle');\n        agGridCommunity._.addCssClass(this.eDragHandle, 'ag-column-select-column-group-drag-handle');\n        this.cbSelect.getGui().insertAdjacentElement('afterend', this.eDragHandle);\n        this.displayName = this.columnController.getDisplayNameForOriginalColumnGroup(null, this.columnGroup, this.eventType);\n        if (agGridCommunity._.missing(this.displayName)) {\n            this.displayName = '>>';\n        }\n        this.eLabel.innerHTML = this.displayName ? this.displayName : '';\n        this.setupExpandContract();\n        this.addCssClass('ag-column-select-indent-' + this.columnDept);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.eLabel, 'click', this.onLabelClicked.bind(this));\n        this.addManagedListener(this.cbSelect, agGridCommunity.AgCheckbox.EVENT_CHANGED, this.onCheckboxChanged.bind(this));\n        this.addManagedListener(this.modelItem, ColumnModelItem.EVENT_EXPANDED_CHANGED, this.onExpandChanged.bind(this));\n        this.addManagedListener(this.focusWrapper, 'keydown', this.handleKeyDown.bind(this));\n        this.setOpenClosedIcons();\n        this.setupDragging();\n        this.onColumnStateChanged();\n        this.addVisibilityListenersToAllChildren();\n        this.refreshAriaExpanded();\n        this.refreshAriaLabel();\n        this.setupTooltip();\n        agGridCommunity.CssClassApplier.addToolPanelClassesFromColDef(this.columnGroup.getColGroupDef(), this.getGui(), this.gridOptionsWrapper, null, this.columnGroup);\n    };\n    ToolPanelColumnGroupComp.prototype.setupTooltip = function () {\n        var _this = this;\n        var colGroupDef = this.columnGroup.getColGroupDef();\n        if (!colGroupDef) {\n            return;\n        }\n        var refresh = function () {\n            var newTooltipText = colGroupDef.headerTooltip;\n            _this.setTooltip(newTooltipText);\n        };\n        refresh();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, refresh);\n    };\n    ToolPanelColumnGroupComp.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'columnToolPanelColumnGroup';\n        return res;\n    };\n    ToolPanelColumnGroupComp.prototype.handleKeyDown = function (e) {\n        switch (e.keyCode) {\n            case agGridCommunity.KeyCode.LEFT:\n                e.preventDefault();\n                this.modelItem.setExpanded(false);\n                break;\n            case agGridCommunity.KeyCode.RIGHT:\n                e.preventDefault();\n                this.modelItem.setExpanded(true);\n                break;\n            case agGridCommunity.KeyCode.SPACE:\n                e.preventDefault();\n                if (this.isSelectable()) {\n                    this.onSelectAllChanged(!this.isSelected());\n                }\n                break;\n        }\n    };\n    ToolPanelColumnGroupComp.prototype.addVisibilityListenersToAllChildren = function () {\n        var _this = this;\n        this.columnGroup.getLeafColumns().forEach(function (column) {\n            _this.addManagedListener(column, agGridCommunity.Column.EVENT_VISIBLE_CHANGED, _this.onColumnStateChanged.bind(_this));\n            _this.addManagedListener(column, agGridCommunity.Column.EVENT_VALUE_CHANGED, _this.onColumnStateChanged.bind(_this));\n            _this.addManagedListener(column, agGridCommunity.Column.EVENT_PIVOT_CHANGED, _this.onColumnStateChanged.bind(_this));\n            _this.addManagedListener(column, agGridCommunity.Column.EVENT_ROW_GROUP_CHANGED, _this.onColumnStateChanged.bind(_this));\n        });\n    };\n    ToolPanelColumnGroupComp.prototype.setupDragging = function () {\n        var _this = this;\n        if (!this.allowDragging) {\n            agGridCommunity._.setDisplayed(this.eDragHandle, false);\n            return;\n        }\n        var dragSource = {\n            type: agGridCommunity.DragSourceType.ToolPanel,\n            eElement: this.eDragHandle,\n            dragItemName: this.displayName,\n            getDragItem: function () { return _this.createDragItem(); }\n        };\n        this.dragAndDropService.addDragSource(dragSource, true);\n        this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource); });\n    };\n    ToolPanelColumnGroupComp.prototype.createDragItem = function () {\n        var visibleState = {};\n        this.columnGroup.getLeafColumns().forEach(function (col) {\n            visibleState[col.getId()] = col.isVisible();\n        });\n        return {\n            columns: this.columnGroup.getLeafColumns(),\n            visibleState: visibleState\n        };\n    };\n    ToolPanelColumnGroupComp.prototype.setupExpandContract = function () {\n        this.eGroupClosedIcon.appendChild(agGridCommunity._.createIcon('columnSelectClosed', this.gridOptionsWrapper, null));\n        this.eGroupOpenedIcon.appendChild(agGridCommunity._.createIcon('columnSelectOpen', this.gridOptionsWrapper, null));\n        this.addManagedListener(this.eGroupClosedIcon, 'click', this.onExpandOrContractClicked.bind(this));\n        this.addManagedListener(this.eGroupOpenedIcon, 'click', this.onExpandOrContractClicked.bind(this));\n        var touchListener = new agGridCommunity.TouchListener(this.eColumnGroupIcons, true);\n        this.addManagedListener(touchListener, agGridCommunity.TouchListener.EVENT_TAP, this.onExpandOrContractClicked.bind(this));\n        this.addDestroyFunc(touchListener.destroy.bind(touchListener));\n    };\n    ToolPanelColumnGroupComp.prototype.onLabelClicked = function () {\n        var nextState = !this.cbSelect.getValue();\n        this.onChangeCommon(nextState);\n    };\n    ToolPanelColumnGroupComp.prototype.onCheckboxChanged = function (event) {\n        this.onChangeCommon(event.selected);\n    };\n    ToolPanelColumnGroupComp.prototype.getVisibleLeafColumns = function () {\n        var childColumns = [];\n        var extractCols = function (children) {\n            children.forEach(function (child) {\n                if (!child.isPassesFilter()) {\n                    return;\n                }\n                if (child.isGroup()) {\n                    extractCols(child.getChildren());\n                }\n                else {\n                    childColumns.push(child.getColumn());\n                }\n            });\n        };\n        extractCols(this.modelItem.getChildren());\n        return childColumns;\n    };\n    ToolPanelColumnGroupComp.prototype.onChangeCommon = function (nextState) {\n        this.refreshAriaLabel();\n        if (this.processingColumnStateChange) {\n            return;\n        }\n        this.modelItemUtils.selectAllChildren(this.modelItem.getChildren(), nextState, this.eventType);\n    };\n    ToolPanelColumnGroupComp.prototype.refreshAriaLabel = function () {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        var state = this.cbSelect.getValue() ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden');\n        var label = translate('ariaColumnGroupToggleVisibility', 'column group toggle visibility');\n        agGridCommunity._.setAriaLabel(this.focusWrapper, this.displayName + \" \" + label + \" (\" + state + \")\");\n    };\n    ToolPanelColumnGroupComp.prototype.onColumnStateChanged = function () {\n        var selectedValue = this.workOutSelectedValue();\n        var readOnlyValue = this.workOutReadOnlyValue();\n        this.processingColumnStateChange = true;\n        this.cbSelect.setValue(selectedValue);\n        this.cbSelect.setReadOnly(readOnlyValue);\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-column-select-column-group-readonly', readOnlyValue);\n        this.processingColumnStateChange = false;\n    };\n    ToolPanelColumnGroupComp.prototype.workOutSelectedValue = function () {\n        var _this = this;\n        var pivotMode = this.columnController.isPivotMode();\n        var visibleLeafColumns = this.getVisibleLeafColumns();\n        var checkedCount = 0;\n        var uncheckedCount = 0;\n        visibleLeafColumns.forEach(function (column) {\n            if (!pivotMode && column.getColDef().lockVisible) {\n                return;\n            }\n            if (_this.isColumnChecked(column, pivotMode)) {\n                checkedCount++;\n            }\n            else {\n                uncheckedCount++;\n            }\n        });\n        if (checkedCount > 0 && uncheckedCount > 0) {\n            return undefined;\n        }\n        else {\n            return checkedCount > 0;\n        }\n    };\n    ToolPanelColumnGroupComp.prototype.workOutReadOnlyValue = function () {\n        var pivotMode = this.columnController.isPivotMode();\n        var colsThatCanAction = 0;\n        this.columnGroup.getLeafColumns().forEach(function (col) {\n            if (pivotMode) {\n                if (col.isAnyFunctionAllowed()) {\n                    colsThatCanAction++;\n                }\n            }\n            else {\n                if (!col.getColDef().lockVisible) {\n                    colsThatCanAction++;\n                }\n            }\n        });\n        return colsThatCanAction === 0;\n    };\n    ToolPanelColumnGroupComp.prototype.isColumnChecked = function (column, pivotMode) {\n        if (pivotMode) {\n            var pivoted = column.isPivotActive();\n            var grouped = column.isRowGroupActive();\n            var aggregated = column.isValueActive();\n            return pivoted || grouped || aggregated;\n        }\n        else {\n            return column.isVisible();\n        }\n    };\n    ToolPanelColumnGroupComp.prototype.onExpandOrContractClicked = function () {\n        var oldState = this.modelItem.isExpanded();\n        this.modelItem.setExpanded(!oldState);\n    };\n    ToolPanelColumnGroupComp.prototype.onExpandChanged = function () {\n        this.setOpenClosedIcons();\n        this.refreshAriaExpanded();\n    };\n    ToolPanelColumnGroupComp.prototype.setOpenClosedIcons = function () {\n        var folderOpen = this.modelItem.isExpanded();\n        agGridCommunity._.setDisplayed(this.eGroupClosedIcon, !folderOpen);\n        agGridCommunity._.setDisplayed(this.eGroupOpenedIcon, folderOpen);\n    };\n    ToolPanelColumnGroupComp.prototype.refreshAriaExpanded = function () {\n        agGridCommunity._.setAriaExpanded(this.focusWrapper, this.modelItem.isExpanded());\n    };\n    ToolPanelColumnGroupComp.prototype.getDisplayName = function () {\n        return this.displayName;\n    };\n    ToolPanelColumnGroupComp.prototype.onSelectAllChanged = function (value) {\n        var cbValue = this.cbSelect.getValue();\n        var readOnly = this.cbSelect.isReadOnly();\n        if (!readOnly && ((value && !cbValue) || (!value && cbValue))) {\n            this.cbSelect.toggle();\n        }\n    };\n    ToolPanelColumnGroupComp.prototype.isSelected = function () {\n        return this.cbSelect.getValue();\n    };\n    ToolPanelColumnGroupComp.prototype.isSelectable = function () {\n        return !this.cbSelect.isReadOnly();\n    };\n    ToolPanelColumnGroupComp.prototype.setSelected = function (selected) {\n        this.cbSelect.setValue(selected, true);\n    };\n    ToolPanelColumnGroupComp.TEMPLATE = \"<div class=\\\"ag-column-select-column-group\\\" aria-hidden=\\\"true\\\">\\n            <span class=\\\"ag-column-group-icons\\\" ref=\\\"eColumnGroupIcons\\\" >\\n                <span class=\\\"ag-column-group-closed-icon\\\" ref=\\\"eGroupClosedIcon\\\"></span>\\n                <span class=\\\"ag-column-group-opened-icon\\\" ref=\\\"eGroupOpenedIcon\\\"></span>\\n            </span>\\n            <ag-checkbox ref=\\\"cbSelect\\\" class=\\\"ag-column-select-checkbox\\\"></ag-checkbox>\\n            <span class=\\\"ag-column-select-column-label\\\" ref=\\\"eLabel\\\"></span>\\n        </div>\";\n    __decorate$4([\n        agGridCommunity.Autowired('columnController')\n    ], ToolPanelColumnGroupComp.prototype, \"columnController\", void 0);\n    __decorate$4([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], ToolPanelColumnGroupComp.prototype, \"dragAndDropService\", void 0);\n    __decorate$4([\n        agGridCommunity.Autowired('modelItemUtils')\n    ], ToolPanelColumnGroupComp.prototype, \"modelItemUtils\", void 0);\n    __decorate$4([\n        agGridCommunity.RefSelector('cbSelect')\n    ], ToolPanelColumnGroupComp.prototype, \"cbSelect\", void 0);\n    __decorate$4([\n        agGridCommunity.RefSelector('eLabel')\n    ], ToolPanelColumnGroupComp.prototype, \"eLabel\", void 0);\n    __decorate$4([\n        agGridCommunity.RefSelector('eGroupOpenedIcon')\n    ], ToolPanelColumnGroupComp.prototype, \"eGroupOpenedIcon\", void 0);\n    __decorate$4([\n        agGridCommunity.RefSelector('eGroupClosedIcon')\n    ], ToolPanelColumnGroupComp.prototype, \"eGroupClosedIcon\", void 0);\n    __decorate$4([\n        agGridCommunity.RefSelector('eColumnGroupIcons')\n    ], ToolPanelColumnGroupComp.prototype, \"eColumnGroupIcons\", void 0);\n    __decorate$4([\n        agGridCommunity.PostConstruct\n    ], ToolPanelColumnGroupComp.prototype, \"init\", null);\n    return ToolPanelColumnGroupComp;\n}(agGridCommunity.Component));\n\nvar __extends$5 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelColumnComp = /** @class */ (function (_super) {\n    __extends$5(ToolPanelColumnComp, _super);\n    function ToolPanelColumnComp(column, columnDept, allowDragging, groupsExist, focusWrapper) {\n        var _this = _super.call(this) || this;\n        _this.column = column;\n        _this.columnDept = columnDept;\n        _this.allowDragging = allowDragging;\n        _this.groupsExist = groupsExist;\n        _this.focusWrapper = focusWrapper;\n        _this.processingColumnStateChange = false;\n        return _this;\n    }\n    ToolPanelColumnComp.prototype.init = function () {\n        this.setTemplate(ToolPanelColumnComp.TEMPLATE);\n        this.eDragHandle = agGridCommunity._.createIconNoSpan('columnDrag', this.gridOptionsWrapper);\n        agGridCommunity._.addCssClass(this.eDragHandle, 'ag-drag-handle');\n        agGridCommunity._.addCssClass(this.eDragHandle, 'ag-column-select-column-drag-handle');\n        this.cbSelect.getGui().insertAdjacentElement('afterend', this.eDragHandle);\n        this.displayName = this.columnController.getDisplayNameForColumn(this.column, 'columnToolPanel');\n        var displayNameSanitised = agGridCommunity._.escapeString(this.displayName);\n        this.eLabel.innerHTML = displayNameSanitised;\n        // if grouping, we add an extra level of indent, to cater for expand/contract icons we need to indent for\n        var indent = this.columnDept;\n        if (this.groupsExist) {\n            this.addCssClass('ag-column-select-add-group-indent');\n        }\n        this.addCssClass(\"ag-column-select-indent-\" + indent);\n        this.setupDragging();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.column, agGridCommunity.Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.column, agGridCommunity.Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.column, agGridCommunity.Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.column, agGridCommunity.Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.focusWrapper, 'keydown', this.handleKeyDown.bind(this));\n        this.addManagedListener(this.gridOptionsWrapper, 'functionsReadOnly', this.onColumnStateChanged.bind(this));\n        this.addManagedListener(this.cbSelect, agGridCommunity.AgCheckbox.EVENT_CHANGED, this.onCheckboxChanged.bind(this));\n        this.addManagedListener(this.eLabel, 'click', this.onLabelClicked.bind(this));\n        this.onColumnStateChanged();\n        this.refreshAriaLabel();\n        this.setupTooltip();\n        agGridCommunity.CssClassApplier.addToolPanelClassesFromColDef(this.column.getColDef(), this.getGui(), this.gridOptionsWrapper, this.column, null);\n    };\n    ToolPanelColumnComp.prototype.setupTooltip = function () {\n        var _this = this;\n        var refresh = function () {\n            var newTooltipText = _this.column.getColDef().headerTooltip;\n            _this.setTooltip(newTooltipText);\n        };\n        refresh();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, refresh);\n    };\n    ToolPanelColumnComp.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'columnToolPanelColumn';\n        res.colDef = this.column.getColDef();\n        return res;\n    };\n    ToolPanelColumnComp.prototype.handleKeyDown = function (e) {\n        if (e.keyCode === agGridCommunity.KeyCode.SPACE) {\n            e.preventDefault();\n            if (this.isSelectable()) {\n                this.onSelectAllChanged(!this.isSelected());\n            }\n        }\n    };\n    ToolPanelColumnComp.prototype.onLabelClicked = function () {\n        if (this.gridOptionsWrapper.isFunctionsReadOnly()) {\n            return;\n        }\n        var nextState = !this.cbSelect.getValue();\n        this.onChangeCommon(nextState);\n    };\n    ToolPanelColumnComp.prototype.onCheckboxChanged = function (event) {\n        this.onChangeCommon(event.selected);\n    };\n    ToolPanelColumnComp.prototype.onChangeCommon = function (nextState) {\n        // ignore lock visible columns\n        if (this.cbSelect.isReadOnly()) {\n            return;\n        }\n        this.refreshAriaLabel();\n        // only want to action if the user clicked the checkbox, not if we are setting the checkbox because\n        // of a change in the model\n        if (this.processingColumnStateChange) {\n            return;\n        }\n        this.modelItemUtils.setColumn(this.column, nextState, 'toolPanelUi');\n    };\n    ToolPanelColumnComp.prototype.refreshAriaLabel = function () {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        var state = this.cbSelect.getValue() ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden');\n        var label = translate('ariaColumnToggleVisibility', 'column toggle visibility');\n        agGridCommunity._.setAriaLabel(this.focusWrapper, this.displayName + \" \" + label + \" (\" + state + \")\");\n    };\n    ToolPanelColumnComp.prototype.setupDragging = function () {\n        var _this = this;\n        if (!this.allowDragging) {\n            agGridCommunity._.setDisplayed(this.eDragHandle, false);\n            return;\n        }\n        var dragSource = {\n            type: agGridCommunity.DragSourceType.ToolPanel,\n            eElement: this.eDragHandle,\n            dragItemName: this.displayName,\n            getDragItem: function () { return _this.createDragItem(); }\n        };\n        this.dragAndDropService.addDragSource(dragSource, true);\n        this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource); });\n    };\n    ToolPanelColumnComp.prototype.createDragItem = function () {\n        var visibleState = {};\n        visibleState[this.column.getId()] = this.column.isVisible();\n        return {\n            columns: [this.column],\n            visibleState: visibleState\n        };\n    };\n    ToolPanelColumnComp.prototype.onColumnStateChanged = function () {\n        this.processingColumnStateChange = true;\n        var isPivotMode = this.columnController.isPivotMode();\n        if (isPivotMode) {\n            // if reducing, checkbox means column is one of pivot, value or group\n            var anyFunctionActive = this.column.isAnyFunctionActive();\n            this.cbSelect.setValue(anyFunctionActive);\n        }\n        else {\n            // if not reducing, the checkbox tells us if column is visible or not\n            this.cbSelect.setValue(this.column.isVisible());\n        }\n        var checkboxReadOnly;\n        if (isPivotMode) {\n            // when in pivot mode, the item should be read only if:\n            //  a) gui is not allowed make any changes\n            var functionsReadOnly = this.gridOptionsWrapper.isFunctionsReadOnly();\n            //  b) column is not allow any functions on it\n            var noFunctionsAllowed = !this.column.isAnyFunctionAllowed();\n            checkboxReadOnly = functionsReadOnly || noFunctionsAllowed;\n        }\n        else {\n            // when in normal mode, the checkbox is read only if visibility is locked\n            checkboxReadOnly = !!this.column.getColDef().lockVisible;\n        }\n        this.cbSelect.setReadOnly(checkboxReadOnly);\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-column-select-column-readonly', checkboxReadOnly);\n        var checkboxPassive = isPivotMode && this.gridOptionsWrapper.isFunctionsPassive();\n        this.cbSelect.setPassive(checkboxPassive);\n        this.processingColumnStateChange = false;\n    };\n    ToolPanelColumnComp.prototype.getDisplayName = function () {\n        return this.displayName;\n    };\n    ToolPanelColumnComp.prototype.onSelectAllChanged = function (value) {\n        if (value !== this.cbSelect.getValue()) {\n            if (!this.cbSelect.isReadOnly()) {\n                this.cbSelect.toggle();\n            }\n        }\n    };\n    ToolPanelColumnComp.prototype.isSelected = function () {\n        return this.cbSelect.getValue();\n    };\n    ToolPanelColumnComp.prototype.isSelectable = function () {\n        return !this.cbSelect.isReadOnly();\n    };\n    ToolPanelColumnComp.prototype.isExpandable = function () {\n        return false;\n    };\n    ToolPanelColumnComp.prototype.setExpanded = function (value) {\n        console.warn('ag-grid: can not expand a column item that does not represent a column group header');\n    };\n    ToolPanelColumnComp.TEMPLATE = \"<div class=\\\"ag-column-select-column\\\" aria-hidden=\\\"true\\\">\\n            <ag-checkbox ref=\\\"cbSelect\\\" class=\\\"ag-column-select-checkbox\\\"></ag-checkbox>\\n            <span class=\\\"ag-column-select-column-label\\\" ref=\\\"eLabel\\\"></span>\\n        </div>\";\n    __decorate$5([\n        agGridCommunity.Autowired('columnController')\n    ], ToolPanelColumnComp.prototype, \"columnController\", void 0);\n    __decorate$5([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], ToolPanelColumnComp.prototype, \"dragAndDropService\", void 0);\n    __decorate$5([\n        agGridCommunity.Autowired('modelItemUtils')\n    ], ToolPanelColumnComp.prototype, \"modelItemUtils\", void 0);\n    __decorate$5([\n        agGridCommunity.RefSelector('eLabel')\n    ], ToolPanelColumnComp.prototype, \"eLabel\", void 0);\n    __decorate$5([\n        agGridCommunity.RefSelector('cbSelect')\n    ], ToolPanelColumnComp.prototype, \"cbSelect\", void 0);\n    __decorate$5([\n        agGridCommunity.PostConstruct\n    ], ToolPanelColumnComp.prototype, \"init\", null);\n    return ToolPanelColumnComp;\n}(agGridCommunity.Component));\n\nvar __extends$6 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ColumnModel = /** @class */ (function () {\n    function ColumnModel(items) {\n        this.items = items;\n    }\n    ColumnModel.prototype.getRowCount = function () {\n        return this.items.length;\n    };\n    ColumnModel.prototype.getRow = function (index) {\n        return this.items[index];\n    };\n    return ColumnModel;\n}());\nvar PrimaryColsListPanel = /** @class */ (function (_super) {\n    __extends$6(PrimaryColsListPanel, _super);\n    function PrimaryColsListPanel() {\n        var _this = _super.call(this, PrimaryColsListPanel.TEMPLATE) || this;\n        _this.destroyColumnItemFuncs = [];\n        return _this;\n    }\n    PrimaryColsListPanel.prototype.destroyColumnTree = function () {\n        this.allColsTree = [];\n        this.destroyColumnItemFuncs.forEach(function (f) { return f(); });\n        this.destroyColumnItemFuncs = [];\n    };\n    PrimaryColsListPanel.prototype.init = function (params, allowDragging, eventType) {\n        var _this = this;\n        this.params = params;\n        this.allowDragging = allowDragging;\n        this.eventType = eventType;\n        if (!this.params.suppressSyncLayoutWithGrid) {\n            this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_MOVED, this.onColumnsChanged.bind(this));\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnsChanged.bind(this));\n        var eventsImpactingCheckedState = [\n            agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGED,\n            agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            agGridCommunity.Events.EVENT_COLUMN_VALUE_CHANGED,\n            agGridCommunity.Events.EVENT_COLUMN_VISIBLE,\n            agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED\n        ];\n        eventsImpactingCheckedState.forEach(function (event) {\n            // update header select all checkbox with current selection state\n            _this.addManagedListener(_this.eventService, event, _this.fireSelectionChangedEvent.bind(_this));\n        });\n        this.expandGroupsByDefault = !this.params.contractColumnSelection;\n        this.virtualList = this.createManagedBean(new agGridCommunity.VirtualList('column-select', 'tree'));\n        this.appendChild(this.virtualList.getGui());\n        this.virtualList.setComponentCreator(function (item, listItemElement) { return _this.createComponentFromItem(item, listItemElement); });\n        if (this.columnController.isReady()) {\n            this.onColumnsChanged();\n        }\n    };\n    PrimaryColsListPanel.prototype.createComponentFromItem = function (item, listItemElement) {\n        if (item.isGroup()) {\n            var renderedGroup = new ToolPanelColumnGroupComp(item, this.allowDragging, this.eventType, listItemElement);\n            this.getContext().createBean(renderedGroup);\n            return renderedGroup;\n        }\n        var columnComp = new ToolPanelColumnComp(item.getColumn(), item.getDept(), this.allowDragging, this.groupsExist, listItemElement);\n        this.getContext().createBean(columnComp);\n        return columnComp;\n    };\n    PrimaryColsListPanel.prototype.onColumnsChanged = function () {\n        var expandedStates = this.getExpandedStates();\n        var pivotModeActive = this.columnController.isPivotMode();\n        var shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;\n        if (shouldSyncColumnLayoutWithGrid) {\n            this.buildTreeFromWhatGridIsDisplaying();\n        }\n        else {\n            this.buildTreeFromProvidedColumnDefs();\n        }\n        this.setExpandedStates(expandedStates);\n        this.markFilteredColumns();\n        this.flattenAndFilterModel();\n    };\n    PrimaryColsListPanel.prototype.getExpandedStates = function () {\n        if (!this.allColsTree) {\n            return {};\n        }\n        var res = {};\n        this.forEachItem(function (item) {\n            if (!item.isGroup()) {\n                return;\n            }\n            var colGroup = item.getColumnGroup();\n            if (colGroup) { // group should always exist, this is defensive\n                res[colGroup.getId()] = item.isExpanded();\n            }\n        });\n        return res;\n    };\n    PrimaryColsListPanel.prototype.setExpandedStates = function (states) {\n        if (!this.allColsTree) {\n            return;\n        }\n        this.forEachItem(function (item) {\n            if (!item.isGroup()) {\n                return;\n            }\n            var colGroup = item.getColumnGroup();\n            if (colGroup) { // group should always exist, this is defensive\n                var expanded = states[colGroup.getId()];\n                var groupExistedLastTime = expanded != null;\n                if (groupExistedLastTime) {\n                    item.setExpanded(expanded);\n                }\n            }\n        });\n    };\n    PrimaryColsListPanel.prototype.buildTreeFromWhatGridIsDisplaying = function () {\n        this.colDefService.syncLayoutWithGrid(this.setColumnLayout.bind(this));\n    };\n    PrimaryColsListPanel.prototype.setColumnLayout = function (colDefs) {\n        var columnTree = this.colDefService.createColumnTree(colDefs);\n        this.buildListModel(columnTree);\n        // using col defs to check if groups exist as it could be a custom layout\n        this.groupsExist = colDefs.some(function (colDef) {\n            return colDef && typeof colDef.children !== 'undefined';\n        });\n        this.markFilteredColumns();\n        this.flattenAndFilterModel();\n    };\n    PrimaryColsListPanel.prototype.buildTreeFromProvidedColumnDefs = function () {\n        // add column / group comps to tool panel\n        this.buildListModel(this.columnController.getPrimaryColumnTree());\n        this.groupsExist = this.columnController.isPrimaryColumnGroupsPresent();\n    };\n    PrimaryColsListPanel.prototype.buildListModel = function (columnTree) {\n        var _this = this;\n        var columnExpandedListener = this.onColumnExpanded.bind(this);\n        var addListeners = function (item) {\n            item.addEventListener(ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);\n            var removeFunc = item.removeEventListener.bind(item, ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);\n            _this.destroyColumnItemFuncs.push(removeFunc);\n        };\n        var recursivelyBuild = function (tree, dept, parentList) {\n            tree.forEach(function (child) {\n                if (child instanceof agGridCommunity.OriginalColumnGroup) {\n                    createGroupItem(child, dept, parentList);\n                }\n                else {\n                    createColumnItem(child, dept, parentList);\n                }\n            });\n        };\n        var createGroupItem = function (columnGroup, dept, parentList) {\n            var columnGroupDef = columnGroup.getColGroupDef();\n            var skipThisGroup = columnGroupDef && columnGroupDef.suppressColumnsToolPanel;\n            if (skipThisGroup) {\n                return;\n            }\n            if (columnGroup.isPadding()) {\n                recursivelyBuild(columnGroup.getChildren(), dept, parentList);\n                return;\n            }\n            var displayName = _this.columnController.getDisplayNameForOriginalColumnGroup(null, columnGroup, _this.eventType);\n            var item = new ColumnModelItem(displayName, columnGroup, dept, true, _this.expandGroupsByDefault);\n            parentList.push(item);\n            addListeners(item);\n            recursivelyBuild(columnGroup.getChildren(), dept + 1, item.getChildren());\n        };\n        var createColumnItem = function (column, dept, parentList) {\n            var skipThisColumn = column.getColDef() && column.getColDef().suppressColumnsToolPanel;\n            if (skipThisColumn) {\n                return;\n            }\n            var displayName = _this.columnController.getDisplayNameForColumn(column, 'columnToolPanel');\n            parentList.push(new ColumnModelItem(displayName, column, dept));\n        };\n        this.destroyColumnTree();\n        recursivelyBuild(columnTree, 0, this.allColsTree);\n    };\n    PrimaryColsListPanel.prototype.onColumnExpanded = function () {\n        this.flattenAndFilterModel();\n    };\n    PrimaryColsListPanel.prototype.flattenAndFilterModel = function () {\n        var _this = this;\n        this.displayedColsList = [];\n        var recursiveFunc = function (item) {\n            if (!item.isPassesFilter()) {\n                return;\n            }\n            _this.displayedColsList.push(item);\n            if (item.isGroup() && item.isExpanded()) {\n                item.getChildren().forEach(recursiveFunc);\n            }\n        };\n        this.allColsTree.forEach(recursiveFunc);\n        this.virtualList.setModel(new ColumnModel(this.displayedColsList));\n        var focusedRow = this.virtualList.getLastFocusedRow();\n        this.virtualList.refresh();\n        if (focusedRow != null) {\n            this.focusRowIfAlive(focusedRow);\n        }\n        this.notifyListeners();\n    };\n    PrimaryColsListPanel.prototype.focusRowIfAlive = function (rowIndex) {\n        var _this = this;\n        window.setTimeout(function () {\n            if (_this.isAlive()) {\n                _this.virtualList.focusRow(rowIndex);\n            }\n        }, 0);\n    };\n    PrimaryColsListPanel.prototype.forEachItem = function (callback) {\n        var recursiveFunc = function (items) {\n            items.forEach(function (item) {\n                callback(item);\n                if (item.isGroup()) {\n                    recursiveFunc(item.getChildren());\n                }\n            });\n        };\n        recursiveFunc(this.allColsTree);\n    };\n    PrimaryColsListPanel.prototype.doSetExpandedAll = function (value) {\n        this.forEachItem(function (item) {\n            if (item.isGroup()) {\n                item.setExpanded(value);\n            }\n        });\n    };\n    PrimaryColsListPanel.prototype.setGroupsExpanded = function (expand, groupIds) {\n        if (!groupIds) {\n            this.doSetExpandedAll(expand);\n            return;\n        }\n        var expandedGroupIds = [];\n        this.forEachItem(function (item) {\n            if (!item.isGroup()) {\n                return;\n            }\n            var groupId = item.getColumnGroup().getId();\n            if (groupIds.indexOf(groupId) >= 0) {\n                item.setExpanded(expand);\n                expandedGroupIds.push(groupId);\n            }\n        });\n        var unrecognisedGroupIds = groupIds.filter(function (groupId) { return !agGridCommunity._.includes(expandedGroupIds, groupId); });\n        if (unrecognisedGroupIds.length > 0) {\n            console.warn('AG Grid: unable to find group(s) for supplied groupIds:', unrecognisedGroupIds);\n        }\n    };\n    PrimaryColsListPanel.prototype.getExpandState = function () {\n        var expandedCount = 0;\n        var notExpandedCount = 0;\n        this.forEachItem(function (item) {\n            if (!item.isGroup()) {\n                return;\n            }\n            if (item.isExpanded()) {\n                expandedCount++;\n            }\n            else {\n                notExpandedCount++;\n            }\n        });\n        if (expandedCount > 0 && notExpandedCount > 0) {\n            return ExpandState.INDETERMINATE;\n        }\n        if (notExpandedCount > 0) {\n            return ExpandState.COLLAPSED;\n        }\n        return ExpandState.EXPANDED;\n    };\n    PrimaryColsListPanel.prototype.doSetSelectedAll = function (selectAllChecked) {\n        this.modelItemUtils.selectAllChildren(this.allColsTree, selectAllChecked, this.eventType);\n    };\n    PrimaryColsListPanel.prototype.getSelectionState = function () {\n        var checkedCount = 0;\n        var uncheckedCount = 0;\n        var pivotMode = this.columnController.isPivotMode();\n        this.forEachItem(function (item) {\n            if (item.isGroup()) {\n                return;\n            }\n            if (!item.isPassesFilter()) {\n                return;\n            }\n            var column = item.getColumn();\n            var colDef = column.getColDef();\n            var checked;\n            if (pivotMode) {\n                var noPivotModeOptionsAllowed = !column.isAllowPivot() && !column.isAllowRowGroup() && !column.isAllowValue();\n                if (noPivotModeOptionsAllowed) {\n                    return;\n                }\n                checked = column.isValueActive() || column.isPivotActive() || column.isRowGroupActive();\n            }\n            else {\n                if (colDef.lockVisible) {\n                    return;\n                }\n                checked = column.isVisible();\n            }\n            checked ? checkedCount++ : uncheckedCount++;\n        });\n        if (checkedCount > 0 && uncheckedCount > 0) {\n            return undefined;\n        }\n        return !(checkedCount === 0 || uncheckedCount > 0);\n    };\n    PrimaryColsListPanel.prototype.setFilterText = function (filterText) {\n        this.filterText = agGridCommunity._.exists(filterText) ? filterText.toLowerCase() : null;\n        this.markFilteredColumns();\n        this.flattenAndFilterModel();\n    };\n    PrimaryColsListPanel.prototype.markFilteredColumns = function () {\n        var _this = this;\n        var passesFilter = function (item) {\n            if (!agGridCommunity._.exists(_this.filterText)) {\n                return true;\n            }\n            var displayName = item.getDisplayName();\n            return displayName == null || displayName.toLowerCase().indexOf(_this.filterText) !== -1;\n        };\n        var recursivelyCheckFilter = function (item, parentPasses) {\n            var atLeastOneChildPassed = false;\n            if (item.isGroup()) {\n                var groupPasses_1 = passesFilter(item);\n                item.getChildren().forEach(function (child) {\n                    var childPasses = recursivelyCheckFilter(child, groupPasses_1 || parentPasses);\n                    if (childPasses) {\n                        atLeastOneChildPassed = childPasses;\n                    }\n                });\n            }\n            var filterPasses = (parentPasses || atLeastOneChildPassed) ? true : passesFilter(item);\n            item.setPassesFilter(filterPasses);\n            return filterPasses;\n        };\n        this.allColsTree.forEach(function (item) { return recursivelyCheckFilter(item, false); });\n    };\n    PrimaryColsListPanel.prototype.notifyListeners = function () {\n        this.fireGroupExpandedEvent();\n        this.fireSelectionChangedEvent();\n    };\n    PrimaryColsListPanel.prototype.fireGroupExpandedEvent = function () {\n        var expandState = this.getExpandState();\n        this.dispatchEvent({ type: 'groupExpanded', state: expandState });\n    };\n    PrimaryColsListPanel.prototype.fireSelectionChangedEvent = function () {\n        var selectionState = this.getSelectionState();\n        this.dispatchEvent({ type: 'selectionChanged', state: selectionState });\n    };\n    PrimaryColsListPanel.TEMPLATE = \"<div class=\\\"ag-column-select-list\\\" role=\\\"tree\\\"></div>\";\n    __decorate$6([\n        agGridCommunity.Autowired('columnController')\n    ], PrimaryColsListPanel.prototype, \"columnController\", void 0);\n    __decorate$6([\n        agGridCommunity.Autowired('toolPanelColDefService')\n    ], PrimaryColsListPanel.prototype, \"colDefService\", void 0);\n    __decorate$6([\n        agGridCommunity.Autowired('columnApi')\n    ], PrimaryColsListPanel.prototype, \"columnApi\", void 0);\n    __decorate$6([\n        agGridCommunity.Autowired('modelItemUtils')\n    ], PrimaryColsListPanel.prototype, \"modelItemUtils\", void 0);\n    __decorate$6([\n        agGridCommunity.PreDestroy\n    ], PrimaryColsListPanel.prototype, \"destroyColumnTree\", null);\n    return PrimaryColsListPanel;\n}(agGridCommunity.Component));\n\nvar __extends$7 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PivotModePanel = /** @class */ (function (_super) {\n    __extends$7(PivotModePanel, _super);\n    function PivotModePanel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PivotModePanel.prototype.createTemplate = function () {\n        return /* html */ \"<div class=\\\"ag-pivot-mode-panel\\\">\\n                <ag-toggle-button ref=\\\"cbPivotMode\\\" class=\\\"ag-pivot-mode-select\\\"></ag-toggle-button>\\n            </div>\";\n    };\n    PivotModePanel.prototype.init = function () {\n        this.setTemplate(this.createTemplate());\n        this.cbPivotMode.setValue(this.columnController.isPivotMode());\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.cbPivotMode.setLabel(localeTextFunc('pivotMode', 'Pivot Mode'));\n        this.addManagedListener(this.cbPivotMode, agGridCommunity.AgCheckbox.EVENT_CHANGED, this.onBtPivotMode.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.onPivotModeChanged.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));\n    };\n    PivotModePanel.prototype.onBtPivotMode = function () {\n        var newValue = !!this.cbPivotMode.getValue();\n        if (newValue !== this.columnController.isPivotMode()) {\n            this.columnController.setPivotMode(newValue, \"toolPanelUi\");\n            var api = this.gridOptionsWrapper.getApi();\n            if (api) {\n                api.refreshHeader();\n            }\n        }\n    };\n    PivotModePanel.prototype.onPivotModeChanged = function () {\n        var pivotModeActive = this.columnController.isPivotMode();\n        this.cbPivotMode.setValue(pivotModeActive);\n    };\n    __decorate$7([\n        agGridCommunity.Autowired('columnController')\n    ], PivotModePanel.prototype, \"columnController\", void 0);\n    __decorate$7([\n        agGridCommunity.RefSelector('cbPivotMode')\n    ], PivotModePanel.prototype, \"cbPivotMode\", void 0);\n    __decorate$7([\n        agGridCommunity.PreConstruct\n    ], PivotModePanel.prototype, \"init\", null);\n    return PivotModePanel;\n}(agGridCommunity.Component));\n\nvar __extends$8 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AggregationStage = /** @class */ (function (_super) {\n    __extends$8(AggregationStage, _super);\n    function AggregationStage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    AggregationStage.prototype.execute = function (params) {\n        // if changed path is active, it means we came from a) change detection or b) transaction update.\n        // for both of these, if no value columns are present, it means there is nothing to aggregate now\n        // and there is no cleanup to be done (as value columns don't change between transactions or change\n        // detections). if no value columns and no changed path, means we have to go through all nodes in\n        // case we need to clean up agg data from before.\n        var noValueColumns = agGridCommunity._.missingOrEmpty(this.columnController.getValueColumns());\n        var noUserAgg = !this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n        var changedPathActive = params.changedPath && params.changedPath.isActive();\n        if (noValueColumns && noUserAgg && changedPathActive) {\n            return;\n        }\n        var aggDetails = this.createAggDetails(params);\n        this.recursivelyCreateAggData(aggDetails);\n    };\n    AggregationStage.prototype.createAggDetails = function (params) {\n        var pivotActive = this.columnController.isPivotActive();\n        var measureColumns = this.columnController.getValueColumns();\n        var pivotColumns = pivotActive ? this.columnController.getPivotColumns() : [];\n        var aggDetails = {\n            changedPath: params.changedPath,\n            valueColumns: measureColumns,\n            pivotColumns: pivotColumns\n        };\n        return aggDetails;\n    };\n    AggregationStage.prototype.recursivelyCreateAggData = function (aggDetails) {\n        var _this = this;\n        // update prop, in case changed since last time\n        this.filteredOnly = !this.gridOptionsWrapper.isSuppressAggFilteredOnly();\n        var callback = function (rowNode) {\n            var hasNoChildren = !rowNode.hasChildren();\n            if (hasNoChildren) {\n                // this check is needed for TreeData, in case the node is no longer a child,\n                // but it was a child previously.\n                if (rowNode.aggData) {\n                    rowNode.setAggData(null);\n                }\n                // never agg data for leaf nodes\n                return;\n            }\n            //Optionally prevent the aggregation at the root Node\n            //https://ag-grid.atlassian.net/browse/AG-388\n            var isRootNode = rowNode.level === -1;\n            if (isRootNode) {\n                var notPivoting = !_this.columnController.isPivotMode();\n                var suppressAggAtRootLevel = _this.gridOptionsWrapper.isSuppressAggAtRootLevel();\n                if (suppressAggAtRootLevel && notPivoting) {\n                    return;\n                }\n            }\n            _this.aggregateRowNode(rowNode, aggDetails);\n        };\n        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);\n    };\n    AggregationStage.prototype.aggregateRowNode = function (rowNode, aggDetails) {\n        var measureColumnsMissing = aggDetails.valueColumns.length === 0;\n        var pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n        var userFunc = this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n        var aggResult;\n        if (userFunc) {\n            aggResult = userFunc(rowNode.childrenAfterFilter);\n        }\n        else if (measureColumnsMissing) {\n            aggResult = null;\n        }\n        else if (pivotColumnsMissing) {\n            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n        }\n        else {\n            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n        }\n        rowNode.setAggData(aggResult);\n        // if we are grouping, then it's possible there is a sibling footer\n        // to the group, so update the data here also if there is one\n        if (rowNode.sibling) {\n            rowNode.sibling.setAggData(aggResult);\n        }\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesAndPivot = function (rowNode) {\n        var _this = this;\n        var result = {};\n        var pivotColumnDefs = this.pivotStage.getPivotColumnDefs();\n        // Step 1: process value columns\n        pivotColumnDefs\n            .filter(function (v) { return !agGridCommunity._.exists(v.pivotTotalColumnIds); }) // only process pivot value columns\n            .forEach(function (valueColDef) {\n            var keys = valueColDef.pivotKeys || [];\n            var values;\n            var valueColumn = valueColDef.pivotValueColumn;\n            var colId = valueColDef.colId;\n            if (rowNode.leafGroup) {\n                // lowest level group, get the values from the mapped set\n                values = _this.getValuesFromMappedSet(rowNode.childrenMapped, keys, valueColumn);\n            }\n            else {\n                // value columns and pivot columns, non-leaf group\n                values = _this.getValuesPivotNonLeaf(rowNode, colId);\n            }\n            result[colId] = _this.aggregateValues(values, valueColumn.getAggFunc(), valueColumn, rowNode);\n        });\n        // Step 2: process total columns\n        pivotColumnDefs\n            .filter(function (v) { return agGridCommunity._.exists(v.pivotTotalColumnIds); }) // only process pivot total columns\n            .forEach(function (totalColDef) {\n            var aggResults = [];\n            var pivotValueColumn = totalColDef.pivotValueColumn, pivotTotalColumnIds = totalColDef.pivotTotalColumnIds, colId = totalColDef.colId;\n            //retrieve results for colIds associated with this pivot total column\n            if (!pivotTotalColumnIds || !pivotTotalColumnIds.length) {\n                return;\n            }\n            pivotTotalColumnIds.forEach(function (currentColId) {\n                aggResults.push(result[currentColId]);\n            });\n            result[colId] = _this.aggregateValues(aggResults, pivotValueColumn.getAggFunc(), pivotValueColumn, rowNode);\n        });\n        return result;\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesOnly = function (rowNode, aggDetails) {\n        var _this = this;\n        var result = {};\n        var changedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : aggDetails.valueColumns;\n        var notChangedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : null;\n        var values2d = this.getValuesNormal(rowNode, changedValueColumns);\n        var oldValues = rowNode.aggData;\n        changedValueColumns.forEach(function (valueColumn, index) {\n            result[valueColumn.getId()] = _this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);\n        });\n        if (notChangedValueColumns && oldValues) {\n            notChangedValueColumns.forEach(function (valueColumn) {\n                result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n            });\n        }\n        return result;\n    };\n    AggregationStage.prototype.getValuesPivotNonLeaf = function (rowNode, colId) {\n        var values = [];\n        rowNode.childrenAfterFilter.forEach(function (node) {\n            var value = node.aggData[colId];\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesFromMappedSet = function (mappedSet, keys, valueColumn) {\n        var _this = this;\n        var mapPointer = mappedSet;\n        keys.forEach(function (key) { return (mapPointer = mapPointer ? mapPointer[key] : null); });\n        if (!mapPointer) {\n            return [];\n        }\n        var values = [];\n        mapPointer.forEach(function (rowNode) {\n            var value = _this.valueService.getValue(valueColumn, rowNode);\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesNormal = function (rowNode, valueColumns) {\n        // create 2d array, of all values for all valueColumns\n        var values = [];\n        valueColumns.forEach(function () { return values.push([]); });\n        var valueColumnCount = valueColumns.length;\n        var nodeList = this.filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;\n        var rowCount = nodeList.length;\n        for (var i = 0; i < rowCount; i++) {\n            var childNode = nodeList[i];\n            for (var j = 0; j < valueColumnCount; j++) {\n                var valueColumn = valueColumns[j];\n                // if the row is a group, then it will only have an agg result value,\n                // which means valueGetter is never used.\n                var value = this.valueService.getValue(valueColumn, childNode);\n                values[j].push(value);\n            }\n        }\n        return values;\n    };\n    AggregationStage.prototype.aggregateValues = function (values, aggFuncOrString, column, rowNode) {\n        var aggFunc = typeof aggFuncOrString === 'string' ?\n            this.aggFuncService.getAggFunc(aggFuncOrString) :\n            aggFuncOrString;\n        if (typeof aggFunc !== 'function') {\n            console.error(\"AG Grid: unrecognised aggregation function \" + aggFuncOrString);\n            return null;\n        }\n        var deprecationWarning = function () {\n            agGridCommunity._.doOnce(function () {\n                console.warn('AG Grid: since v24.0, custom aggregation functions take a params object. Please alter your aggregation function to use params.values');\n            }, 'aggregationStage.aggregateValues Deprecation');\n        };\n        var aggFuncAny = aggFunc;\n        var params = {\n            values: values,\n            column: column,\n            colDef: column ? column.getColDef() : undefined,\n            rowNode: rowNode,\n            data: rowNode ? rowNode.data : undefined,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            context: this.gridOptionsWrapper.getContext(),\n            // the three things below are for logging warning messages in case anyone is treating\n            // the params object as an array. in previous grid versions, we didn't pass params object,\n            // but passed values array instead.\n            forEach: function (callback, thisArg) {\n                deprecationWarning();\n                return values.forEach(callback, thisArg);\n            },\n            get length() {\n                deprecationWarning();\n                return values.length;\n            },\n            set length(val) {\n                deprecationWarning();\n                values.length = val;\n            }\n        }; // the \"as any\" is needed to allow the deprecation warning messages\n        return aggFuncAny(params);\n    };\n    __decorate$8([\n        agGridCommunity.Autowired('columnController')\n    ], AggregationStage.prototype, \"columnController\", void 0);\n    __decorate$8([\n        agGridCommunity.Autowired('valueService')\n    ], AggregationStage.prototype, \"valueService\", void 0);\n    __decorate$8([\n        agGridCommunity.Autowired('pivotStage')\n    ], AggregationStage.prototype, \"pivotStage\", void 0);\n    __decorate$8([\n        agGridCommunity.Autowired('aggFuncService')\n    ], AggregationStage.prototype, \"aggFuncService\", void 0);\n    __decorate$8([\n        agGridCommunity.Autowired('gridApi')\n    ], AggregationStage.prototype, \"gridApi\", void 0);\n    __decorate$8([\n        agGridCommunity.Autowired('columnApi')\n    ], AggregationStage.prototype, \"columnApi\", void 0);\n    AggregationStage = __decorate$8([\n        agGridCommunity.Bean('aggregationStage')\n    ], AggregationStage);\n    return AggregationStage;\n}(agGridCommunity.BeanStub));\n\nvar BatchRemover = /** @class */ (function () {\n    function BatchRemover() {\n        this.allSets = {};\n        this.allParents = [];\n    }\n    BatchRemover.prototype.removeFromChildrenAfterGroup = function (parent, child) {\n        var set = this.getSet(parent);\n        set.removeFromChildrenAfterGroup[child.id] = true;\n    };\n    BatchRemover.prototype.removeFromAllLeafChildren = function (parent, child) {\n        var set = this.getSet(parent);\n        set.removeFromAllLeafChildren[child.id] = true;\n    };\n    BatchRemover.prototype.getSet = function (parent) {\n        if (!this.allSets[parent.id]) {\n            this.allSets[parent.id] = {\n                removeFromAllLeafChildren: {},\n                removeFromChildrenAfterGroup: {}\n            };\n            this.allParents.push(parent);\n        }\n        return this.allSets[parent.id];\n    };\n    BatchRemover.prototype.getAllParents = function () {\n        return this.allParents;\n    };\n    BatchRemover.prototype.flush = function () {\n        var _this = this;\n        this.allParents.forEach(function (parent) {\n            var nodeDetails = _this.allSets[parent.id];\n            parent.childrenAfterGroup = parent.childrenAfterGroup.filter(function (child) { return !nodeDetails.removeFromChildrenAfterGroup[child.id]; });\n            parent.allLeafChildren = parent.allLeafChildren.filter(function (child) { return !nodeDetails.removeFromAllLeafChildren[child.id]; });\n            parent.updateHasChildren();\n        });\n        this.allSets = {};\n        this.allParents.length = 0;\n    };\n    return BatchRemover;\n}());\n\nvar __extends$9 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar GroupStage = /** @class */ (function (_super) {\n    __extends$9(GroupStage, _super);\n    function GroupStage() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // we use a sequence variable so that each time we do a grouping, we don't\n        // reuse the ids - otherwise the rowRenderer will confuse rowNodes between redraws\n        // when it tries to animate between rows.\n        _this.groupIdSequence = new agGridCommunity.NumberSequence();\n        return _this;\n    }\n    GroupStage.prototype.postConstruct = function () {\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.usingTreeData) {\n            this.getDataPath = this.gridOptionsWrapper.getDataPathFunc();\n        }\n    };\n    GroupStage.prototype.execute = function (params) {\n        var details = this.createGroupingDetails(params);\n        if (details.transactions) {\n            this.handleTransaction(details);\n        }\n        else {\n            var afterColsChanged = params.afterColumnsChanged === true;\n            this.shotgunResetEverything(details, afterColsChanged);\n        }\n        this.sortGroupsWithComparator(details.rootNode);\n        this.selectableService.updateSelectableAfterGrouping(details.rootNode);\n    };\n    GroupStage.prototype.createGroupingDetails = function (params) {\n        var rowNode = params.rowNode, changedPath = params.changedPath, rowNodeTransactions = params.rowNodeTransactions, rowNodeOrder = params.rowNodeOrder;\n        var groupedCols = this.usingTreeData ? null : this.columnController.getRowGroupColumns();\n        var details = {\n            // someone complained that the parent attribute was causing some change detection\n            // to break is some angular add-on - which i never used. taking the parent out breaks\n            // a cyclic dependency, hence this flag got introduced.\n            includeParents: !this.gridOptionsWrapper.isSuppressParentsInRowNodes(),\n            expandByDefault: this.gridOptionsWrapper.getGroupDefaultExpanded(),\n            groupedCols: groupedCols,\n            rootNode: rowNode,\n            pivotMode: this.columnController.isPivotMode(),\n            groupedColCount: this.usingTreeData || !groupedCols ? 0 : groupedCols.length,\n            rowNodeOrder: rowNodeOrder,\n            transactions: rowNodeTransactions,\n            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n            changedPath: changedPath\n        };\n        return details;\n    };\n    GroupStage.prototype.handleTransaction = function (details) {\n        var _this = this;\n        details.transactions.forEach(function (tran) {\n            // we don't allow batch remover for tree data as tree data uses Filler Nodes,\n            // and creating/deleting filler nodes needs to be done alongside the node deleting\n            // and moving. if we want to Batch Remover working with tree data then would need\n            // to consider how Filler Nodes would be impacted (it's possible that it can be easily\n            // modified to work, however for now I don't have the brain energy to work it all out).\n            var batchRemover = !_this.usingTreeData ? new BatchRemover() : undefined;\n            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,\n            // as the order is important when a record with the same id is added and removed in the same\n            // transaction.\n            if (agGridCommunity._.existsAndNotEmpty(tran.remove)) {\n                _this.removeNodes(tran.remove, details, batchRemover);\n            }\n            if (agGridCommunity._.existsAndNotEmpty(tran.update)) {\n                _this.moveNodesInWrongPath(tran.update, details, batchRemover);\n            }\n            if (agGridCommunity._.existsAndNotEmpty(tran.add)) {\n                _this.insertNodes(tran.add, details, false);\n            }\n            // must flush here, and not allow another transaction to be applied,\n            // as each transaction must finish leaving the data in a consistent state.\n            if (batchRemover) {\n                var parentsWithChildrenRemoved = batchRemover.getAllParents().slice();\n                batchRemover.flush();\n                _this.removeEmptyGroups(parentsWithChildrenRemoved, details);\n            }\n        });\n        if (details.rowNodeOrder) {\n            this.sortChildren(details);\n        }\n    };\n    // this is used when doing delta updates, eg Redux, keeps nodes in right order\n    GroupStage.prototype.sortChildren = function (details) {\n        details.changedPath.forEachChangedNodeDepthFirst(function (rowNode) {\n            agGridCommunity._.sortRowNodesByOrder(rowNode.childrenAfterGroup, details.rowNodeOrder);\n        });\n    };\n    GroupStage.prototype.sortGroupsWithComparator = function (rootNode) {\n        // we don't do group sorting for tree data\n        if (this.usingTreeData) {\n            return;\n        }\n        var comparator = this.gridOptionsWrapper.getDefaultGroupSortComparator();\n        if (agGridCommunity._.exists(comparator)) {\n            recursiveSort(rootNode);\n        }\n        function recursiveSort(rowNode) {\n            var doSort = agGridCommunity._.exists(rowNode.childrenAfterGroup) &&\n                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n                !rowNode.leafGroup;\n            if (doSort) {\n                rowNode.childrenAfterGroup.sort(comparator);\n                rowNode.childrenAfterGroup.forEach(function (childNode) { return recursiveSort(childNode); });\n            }\n        }\n    };\n    GroupStage.prototype.getExistingPathForNode = function (node, details) {\n        var res = [];\n        // when doing tree data, the node is part of the path,\n        // but when doing grid grouping, the node is not part of the path so we start with the parent.\n        var pointer = this.usingTreeData ? node : node.parent;\n        while (pointer && pointer !== details.rootNode) {\n            res.push({\n                key: pointer.key,\n                rowGroupColumn: pointer.rowGroupColumn,\n                field: pointer.field\n            });\n            pointer = pointer.parent;\n        }\n        res.reverse();\n        return res;\n    };\n    GroupStage.prototype.moveNodesInWrongPath = function (childNodes, details, batchRemover) {\n        var _this = this;\n        childNodes.forEach(function (childNode) {\n            // we add node, even if parent has not changed, as the data could have\n            // changed, hence aggregations will be wrong\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(childNode.parent);\n            }\n            var infoToKeyMapper = function (item) { return item.key; };\n            var oldPath = _this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n            var newPath = _this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n            var nodeInCorrectPath = agGridCommunity._.areEqual(oldPath, newPath);\n            if (!nodeInCorrectPath) {\n                _this.moveNode(childNode, details, batchRemover);\n            }\n        });\n    };\n    GroupStage.prototype.moveNode = function (childNode, details, batchRemover) {\n        this.removeNodesInStages([childNode], details, batchRemover);\n        this.insertOneNode(childNode, details, true);\n        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n        // refreshed into the gui.\n        // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n        // then will get each cell in the row to refresh - which is what we need as we don't know which\n        // columns will be displaying the rowNode.key info.\n        childNode.setData(childNode.data);\n        // we add both old and new parents to changed path, as both will need to be refreshed.\n        // we already added the old parent (in calling method), so just add the new parent here\n        if (details.changedPath.isActive()) {\n            var newParent = childNode.parent;\n            details.changedPath.addParentNode(newParent);\n        }\n    };\n    GroupStage.prototype.removeNodes = function (leafRowNodes, details, batchRemover) {\n        this.removeNodesInStages(leafRowNodes, details, batchRemover);\n        if (details.changedPath.isActive()) {\n            leafRowNodes.forEach(function (rowNode) { return details.changedPath.addParentNode(rowNode.parent); });\n        }\n    };\n    GroupStage.prototype.removeNodesInStages = function (leafRowNodes, details, batchRemover) {\n        this.removeNodesFromParents(leafRowNodes, details, batchRemover);\n        if (this.usingTreeData) {\n            this.postRemoveCreateFillerNodes(leafRowNodes, details);\n            // When not TreeData, then removeEmptyGroups is called just before the BatchRemover is flushed.\n            // However for TreeData, there is no BatchRemover, so we have to call removeEmptyGroups here.\n            var nodeParents = leafRowNodes.map(function (n) { return n.parent; });\n            this.removeEmptyGroups(nodeParents, details);\n        }\n    };\n    GroupStage.prototype.forEachParentGroup = function (details, group, callback) {\n        var pointer = group;\n        while (pointer && pointer !== details.rootNode) {\n            callback(pointer);\n            pointer = pointer.parent;\n        }\n    };\n    GroupStage.prototype.removeNodesFromParents = function (nodesToRemove, details, provided) {\n        var _this = this;\n        // this method can be called with BatchRemover as optional. if it is missed, we created a local version\n        // and flush it at the end. if one is provided, we add to the provided one and it gets flushed elsewhere.\n        var batchRemoverIsLocal = provided == null;\n        var batchRemoverToUse = provided ? provided : new BatchRemover();\n        nodesToRemove.forEach(function (nodeToRemove) {\n            _this.removeFromParent(nodeToRemove, batchRemoverToUse);\n            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as\n            // the ClientSideNodeManager is responsible for the Root Node.\n            _this.forEachParentGroup(details, nodeToRemove.parent, function (parentNode) {\n                batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);\n            });\n        });\n        if (batchRemoverIsLocal) {\n            batchRemoverToUse.flush();\n        }\n    };\n    GroupStage.prototype.postRemoveCreateFillerNodes = function (nodesToRemove, details) {\n        var _this = this;\n        nodesToRemove.forEach(function (nodeToRemove) {\n            // if not group, and children are present, need to move children to a group.\n            // otherwise if no children, we can just remove without replacing.\n            var replaceWithGroup = nodeToRemove.hasChildren();\n            if (replaceWithGroup) {\n                var oldPath = _this.getExistingPathForNode(nodeToRemove, details);\n                // because we just removed the userGroup, this will always return new support group\n                var newGroupNode_1 = _this.findParentForNode(nodeToRemove, oldPath, details);\n                // these properties are the ones that will be incorrect in the newly created group,\n                // so copy them from the old childNode\n                newGroupNode_1.expanded = nodeToRemove.expanded;\n                newGroupNode_1.allLeafChildren = nodeToRemove.allLeafChildren;\n                newGroupNode_1.childrenAfterGroup = nodeToRemove.childrenAfterGroup;\n                newGroupNode_1.childrenMapped = nodeToRemove.childrenMapped;\n                newGroupNode_1.updateHasChildren();\n                newGroupNode_1.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = newGroupNode_1; });\n            }\n        });\n    };\n    GroupStage.prototype.removeEmptyGroups = function (possibleEmptyGroups, details) {\n        var _this = this;\n        // we do this multiple times, as when we remove groups, that means the parent of just removed\n        // group can then be empty. to get around this, if we remove, then we check everything again for\n        // newly emptied groups. the max number of times this will execute is the depth of the group tree.\n        var checkAgain = true;\n        var groupShouldBeRemoved = function (rowNode) {\n            // because of the while loop below, it's possible we already moved the node,\n            // so double check before trying to remove again.\n            var mapKey = _this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);\n            var parentRowNode = rowNode.parent;\n            var groupAlreadyRemoved = (parentRowNode && parentRowNode.childrenMapped) ?\n                !parentRowNode.childrenMapped[mapKey] : true;\n            if (groupAlreadyRemoved) {\n                // if not linked, then group was already removed\n                return false;\n            }\n            // if still not removed, then we remove if this group is empty\n            return !!rowNode.isEmptyRowGroupNode();\n        };\n        var _loop_1 = function () {\n            checkAgain = false;\n            var batchRemover = new BatchRemover();\n            possibleEmptyGroups.forEach(function (possibleEmptyGroup) {\n                // remove empty groups\n                _this.forEachParentGroup(details, possibleEmptyGroup, function (rowNode) {\n                    if (groupShouldBeRemoved(rowNode)) {\n                        checkAgain = true;\n                        _this.removeFromParent(rowNode, batchRemover);\n                        // we remove selection on filler nodes here, as the selection would not be removed\n                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager\n                        rowNode.setSelected(false);\n                    }\n                });\n            });\n            batchRemover.flush();\n        };\n        while (checkAgain) {\n            _loop_1();\n        }\n    };\n    // removes the node from the parent by:\n    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)\n    // b) removing from childrenMapped (immediately)\n    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed\n    // d) setRowIndex(null) - as the rowNode will no longer be displayed.\n    GroupStage.prototype.removeFromParent = function (child, batchRemover) {\n        if (child.parent) {\n            if (batchRemover) {\n                batchRemover.removeFromChildrenAfterGroup(child.parent, child);\n            }\n            else {\n                agGridCommunity._.removeFromArray(child.parent.childrenAfterGroup, child);\n                child.parent.updateHasChildren();\n            }\n        }\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        if (child.parent && child.parent.childrenMapped) {\n            child.parent.childrenMapped[mapKey] = undefined;\n        }\n        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n        // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n        child.setRowTop(null);\n        child.setRowIndex(null);\n    };\n    GroupStage.prototype.addToParent = function (child, parent) {\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        if (parent) {\n            if (parent.childrenMapped) {\n                parent.childrenMapped[mapKey] = child;\n            }\n            parent.childrenAfterGroup.push(child);\n            parent.updateHasChildren();\n        }\n    };\n    GroupStage.prototype.areGroupColsEqual = function (d1, d2) {\n        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {\n            return false;\n        }\n        return agGridCommunity._.areEqual(d1.groupedCols, d2.groupedCols);\n    };\n    GroupStage.prototype.shotgunResetEverything = function (details, afterColumnsChanged) {\n        var skipStage = afterColumnsChanged ?\n            this.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails)\n            : false;\n        this.oldGroupingDetails = details;\n        if (skipStage) {\n            return;\n        }\n        // because we are not creating the root node each time, we have the logic\n        // here to change leafGroup once.\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        details.rootNode.leafGroup = this.usingTreeData ? false : details.groupedCols.length === 0;\n        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n        details.rootNode.childrenAfterGroup = [];\n        details.rootNode.childrenMapped = {};\n        details.rootNode.updateHasChildren();\n        this.insertNodes(details.rootNode.allLeafChildren, details, false);\n    };\n    GroupStage.prototype.insertNodes = function (newRowNodes, details, isMove) {\n        var _this = this;\n        newRowNodes.forEach(function (rowNode) {\n            _this.insertOneNode(rowNode, details, isMove);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(rowNode.parent);\n            }\n        });\n    };\n    GroupStage.prototype.insertOneNode = function (childNode, details, isMove) {\n        var path = this.getGroupInfo(childNode, details);\n        var parentGroup = this.findParentForNode(childNode, path, details);\n        if (!parentGroup.group) {\n            console.warn(\"AG Grid: duplicate group keys for row data, keys should be unique\", [parentGroup.data, childNode.data]);\n        }\n        if (this.usingTreeData) {\n            this.swapGroupWithUserNode(parentGroup, childNode, isMove);\n        }\n        else {\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            parentGroup.childrenAfterGroup.push(childNode);\n            parentGroup.updateHasChildren();\n        }\n    };\n    GroupStage.prototype.findParentForNode = function (childNode, path, details) {\n        var _this = this;\n        var nextNode = details.rootNode;\n        path.forEach(function (groupInfo, level) {\n            nextNode = _this.getOrCreateNextNode(nextNode, groupInfo, level, details);\n            // node gets added to all group nodes.\n            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n            nextNode.allLeafChildren.push(childNode);\n        });\n        return nextNode;\n    };\n    GroupStage.prototype.swapGroupWithUserNode = function (fillerGroup, userGroup, isMove) {\n        userGroup.parent = fillerGroup.parent;\n        userGroup.key = fillerGroup.key;\n        userGroup.field = fillerGroup.field;\n        userGroup.groupData = fillerGroup.groupData;\n        userGroup.level = fillerGroup.level;\n        // AG-3441 - preserve the existing expanded status of the node if we're moving it, so that\n        // you can drag a sub tree from one parent to another without changing its expansion\n        if (!isMove) {\n            userGroup.expanded = fillerGroup.expanded;\n        }\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        userGroup.leafGroup = fillerGroup.leafGroup;\n        // always null for userGroups, as row grouping is not allowed when doing tree data\n        userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;\n        userGroup.allLeafChildren = fillerGroup.allLeafChildren;\n        userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;\n        userGroup.childrenMapped = fillerGroup.childrenMapped;\n        userGroup.updateHasChildren();\n        this.removeFromParent(fillerGroup);\n        userGroup.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = userGroup; });\n        this.addToParent(userGroup, fillerGroup.parent);\n    };\n    GroupStage.prototype.getOrCreateNextNode = function (parentGroup, groupInfo, level, details) {\n        var key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n        var map = parentGroup.childrenMapped;\n        // we use hasOwnProperty as otherwise things like 'constructor' would fail as a key,\n        // as javascript map already has an inherited property 'constructor\n        var nodeExists = map && map.hasOwnProperty(key);\n        var nextNode = nodeExists ? map[key] : undefined;\n        if (!nextNode) {\n            nextNode = this.createGroup(groupInfo, parentGroup, level, details);\n            // attach the new group to the parent\n            this.addToParent(nextNode, parentGroup);\n        }\n        return nextNode;\n    };\n    GroupStage.prototype.createGroup = function (groupInfo, parent, level, details) {\n        var _this = this;\n        var groupNode = new agGridCommunity.RowNode();\n        this.context.createBean(groupNode);\n        groupNode.group = true;\n        groupNode.field = groupInfo.field;\n        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n        groupNode.groupData = {};\n        var groupDisplayCols = this.columnController.getGroupDisplayColumns();\n        groupDisplayCols.forEach(function (col) {\n            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n            var displayGroupForCol = _this.usingTreeData || (groupNode.rowGroupColumn ? col.isRowGroupDisplayed(groupNode.rowGroupColumn.getId()) : false);\n            if (displayGroupForCol) {\n                groupNode.groupData[col.getColId()] = groupInfo.key;\n            }\n        });\n        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'\n        // for top pinned and bottom pinned rows.\n        groupNode.id = agGridCommunity.RowNode.ID_PREFIX_ROW_GROUP + this.groupIdSequence.next();\n        groupNode.key = groupInfo.key;\n        groupNode.level = level;\n        groupNode.leafGroup = this.usingTreeData ? false : level === (details.groupedColCount - 1);\n        // if doing pivoting, then the leaf group is never expanded,\n        // as we do not show leaf rows\n        if (details.pivotMode && groupNode.leafGroup) {\n            groupNode.expanded = false;\n        }\n        else {\n            groupNode.expanded = this.isExpanded(details.expandByDefault, level);\n        }\n        groupNode.allLeafChildren = [];\n        // why is this done here? we are not updating the children count as we go,\n        // i suspect this is updated in the filter stage\n        groupNode.setAllChildrenCount(0);\n        groupNode.rowGroupIndex = this.usingTreeData ? null : level;\n        groupNode.childrenAfterGroup = [];\n        groupNode.childrenMapped = {};\n        groupNode.updateHasChildren();\n        groupNode.parent = details.includeParents ? parent : null;\n        return groupNode;\n    };\n    GroupStage.prototype.getChildrenMappedKey = function (key, rowGroupColumn) {\n        if (rowGroupColumn) {\n            // grouping by columns\n            return rowGroupColumn.getId() + '-' + key;\n        }\n        else {\n            // tree data - we don't have rowGroupColumns\n            return key;\n        }\n    };\n    GroupStage.prototype.isExpanded = function (expandByDefault, level) {\n        if (expandByDefault === -1) {\n            return true;\n        }\n        else {\n            return level < expandByDefault;\n        }\n    };\n    GroupStage.prototype.getGroupInfo = function (rowNode, details) {\n        if (this.usingTreeData) {\n            return this.getGroupInfoFromCallback(rowNode);\n        }\n        else {\n            return this.getGroupInfoFromGroupColumns(rowNode, details);\n        }\n    };\n    GroupStage.prototype.getGroupInfoFromCallback = function (rowNode) {\n        var keys = this.getDataPath ? this.getDataPath(rowNode.data) : null;\n        if (keys === null || keys === undefined || keys.length === 0) {\n            agGridCommunity._.doOnce(function () { return console.warn(\"getDataPath() should not return an empty path for data\", rowNode.data); }, 'groupStage.getGroupInfoFromCallback');\n        }\n        var groupInfoMapper = function (key) { return ({ key: key, field: null, rowGroupColumn: null }); };\n        return keys ? keys.map(groupInfoMapper) : [];\n    };\n    GroupStage.prototype.getGroupInfoFromGroupColumns = function (rowNode, details) {\n        var _this = this;\n        var res = [];\n        details.groupedCols.forEach(function (groupCol) {\n            var key = _this.valueService.getKeyForNode(groupCol, rowNode);\n            var keyExists = key !== null && key !== undefined;\n            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n            // this keeps the tree balanced and hence can be represented as a group.\n            if (details.pivotMode && !keyExists) {\n                key = ' ';\n                keyExists = true;\n            }\n            if (keyExists) {\n                var item = {\n                    key: key,\n                    field: groupCol.getColDef().field,\n                    rowGroupColumn: groupCol\n                };\n                res.push(item);\n            }\n        });\n        return res;\n    };\n    __decorate$9([\n        agGridCommunity.Autowired('columnController')\n    ], GroupStage.prototype, \"columnController\", void 0);\n    __decorate$9([\n        agGridCommunity.Autowired('selectableService')\n    ], GroupStage.prototype, \"selectableService\", void 0);\n    __decorate$9([\n        agGridCommunity.Autowired('valueService')\n    ], GroupStage.prototype, \"valueService\", void 0);\n    __decorate$9([\n        agGridCommunity.PostConstruct\n    ], GroupStage.prototype, \"postConstruct\", null);\n    GroupStage = __decorate$9([\n        agGridCommunity.Bean('groupStage')\n    ], GroupStage);\n    return GroupStage;\n}(agGridCommunity.BeanStub));\n\nvar __extends$a = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar PivotColDefService = /** @class */ (function (_super) {\n    __extends$a(PivotColDefService, _super);\n    function PivotColDefService() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PivotColDefService_1 = PivotColDefService;\n    PivotColDefService.prototype.createPivotColumnDefs = function (uniqueValues) {\n        // this is passed to the columnController, to configure the columns and groups we show\n        var pivotColumnGroupDefs = [];\n        // this is used by the aggregation stage, to do the aggregation based on the pivot columns\n        var pivotColumnDefs = [];\n        var pivotColumns = this.columnController.getPivotColumns();\n        var valueColumns = this.columnController.getValueColumns();\n        var levelsDeep = pivotColumns.length;\n        var columnIdSequence = new agGridCommunity.NumberSequence();\n        this.recursivelyAddGroup(pivotColumnGroupDefs, pivotColumnDefs, 1, uniqueValues, [], columnIdSequence, levelsDeep, pivotColumns);\n        // additional columns that contain the aggregated total for each value column per row\n        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs, valueColumns, columnIdSequence);\n        // additional group columns that contain child totals for each collapsed child column / group\n        this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence);\n        // additional group columns that contain an aggregated total across all child columns\n        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence);\n        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that\n        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,\n        // as these use the col defs also\n        var pivotColumnDefsClone = pivotColumnDefs.map(function (colDef) { return agGridCommunity._.cloneObject(colDef); });\n        return {\n            pivotColumnGroupDefs: pivotColumnGroupDefs,\n            pivotColumnDefs: pivotColumnDefsClone\n        };\n    };\n    // parentChildren - the list of colDefs we are adding to\n    // @index - how far the column is from the top (also same as pivotKeys.length)\n    // @uniqueValues - the values for which we should create a col for\n    // @pivotKeys - the keys for the pivot, eg if pivoting on {Language,Country} then could be {English,Ireland}\n    PivotColDefService.prototype.recursivelyAddGroup = function (parentChildren, pivotColumnDefs, index, uniqueValues, pivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns) {\n        var _this = this;\n        agGridCommunity._.iterateObject(uniqueValues, function (key, value) {\n            var newPivotKeys = __spreadArrays(pivotKeys, [key]);\n            var createGroup = index !== levelsDeep;\n            if (createGroup) {\n                var groupDef = {\n                    children: [],\n                    headerName: key,\n                    pivotKeys: newPivotKeys,\n                    columnGroupShow: 'open',\n                    groupId: 'pivot' + columnIdSequence.next()\n                };\n                parentChildren.push(groupDef);\n                _this.recursivelyAddGroup(groupDef.children, pivotColumnDefs, index + 1, value, newPivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns);\n            }\n            else {\n                var measureColumns = _this.columnController.getValueColumns();\n                var valueGroup_1 = {\n                    children: [],\n                    headerName: key,\n                    pivotKeys: newPivotKeys,\n                    columnGroupShow: 'open',\n                    groupId: 'pivot' + columnIdSequence.next()\n                };\n                // if no value columns selected, then we insert one blank column, so the user at least sees columns\n                // rendered. otherwise the grid would render with no columns (just empty groups) which would give the\n                // impression that the grid is broken\n                if (measureColumns.length === 0) {\n                    // this is the blank column, for when no value columns enabled.\n                    var colDef = _this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n                    valueGroup_1.children.push(colDef);\n                    pivotColumnDefs.push(colDef);\n                }\n                else {\n                    measureColumns.forEach(function (measureColumn) {\n                        var columnName = _this.columnController.getDisplayNameForColumn(measureColumn, 'header');\n                        var colDef = _this.createColDef(measureColumn, columnName, newPivotKeys, columnIdSequence);\n                        colDef.columnGroupShow = 'open';\n                        valueGroup_1.children.push(colDef);\n                        pivotColumnDefs.push(colDef);\n                    });\n                }\n                parentChildren.push(valueGroup_1);\n            }\n        });\n        // sort by either user provided comparator, or our own one\n        var primaryPivotColumnDefs = primaryPivotColumns[index - 1].getColDef();\n        var userComparator = primaryPivotColumnDefs.pivotComparator;\n        var comparator = this.headerNameComparator.bind(this, userComparator);\n        parentChildren.sort(comparator);\n    };\n    PivotColDefService.prototype.addExpandablePivotGroups = function (pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence) {\n        var _this = this;\n        if (this.gridOptionsWrapper.isSuppressExpandablePivotGroups() ||\n            this.gridOptionsWrapper.getPivotColumnGroupTotals()) {\n            return;\n        }\n        var recursivelyAddSubTotals = function (groupDef, currentPivotColumnDefs, currentColumnIdSequence, acc) {\n            var group = groupDef;\n            if (group.children) {\n                var childAcc_1 = new Map();\n                group.children.forEach(function (grp) {\n                    recursivelyAddSubTotals(grp, currentPivotColumnDefs, currentColumnIdSequence, childAcc_1);\n                });\n                var firstGroup_1 = !group.children.some(function (child) { return child.children; });\n                _this.columnController.getValueColumns().forEach(function (valueColumn) {\n                    var columnName = _this.columnController.getDisplayNameForColumn(valueColumn, 'header');\n                    var totalColDef = _this.createColDef(valueColumn, columnName, groupDef.pivotKeys, currentColumnIdSequence);\n                    totalColDef.pivotTotalColumnIds = childAcc_1.get(valueColumn.getColId());\n                    totalColDef.columnGroupShow = 'closed';\n                    totalColDef.aggFunc = valueColumn.getAggFunc();\n                    if (!firstGroup_1) {\n                        // add total colDef to group and pivot colDefs array\n                        var children = groupDef.children;\n                        children.push(totalColDef);\n                        currentPivotColumnDefs.push(totalColDef);\n                    }\n                });\n                _this.merge(acc, childAcc_1);\n            }\n            else {\n                var def = groupDef;\n                // check that value column exists, i.e. aggFunc is supplied\n                if (!def.pivotValueColumn) {\n                    return;\n                }\n                var pivotValueColId = def.pivotValueColumn.getColId();\n                var arr = acc.has(pivotValueColId) ? acc.get(pivotValueColId) : [];\n                arr.push(def.colId);\n                acc.set(pivotValueColId, arr);\n            }\n        };\n        pivotColumnGroupDefs.forEach(function (groupDef) {\n            recursivelyAddSubTotals(groupDef, pivotColumnDefs, columnIdSequence, new Map());\n        });\n    };\n    PivotColDefService.prototype.addPivotTotalsToGroups = function (pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.getPivotColumnGroupTotals()) {\n            return;\n        }\n        var insertAfter = this.gridOptionsWrapper.getPivotColumnGroupTotals() === 'after';\n        var valueCols = this.columnController.getValueColumns();\n        var aggFuncs = valueCols.map(function (valueCol) { return valueCol.getAggFunc(); });\n        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same\n        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {\n            // console.warn('AG Grid: aborting adding pivot total columns - value columns require same aggFunc');\n            return;\n        }\n        // arbitrarily select a value column to use as a template for pivot columns\n        var valueColumn = valueCols[0];\n        pivotColumnGroupDefs.forEach(function (groupDef) {\n            _this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n        });\n    };\n    PivotColDefService.prototype.recursivelyAddPivotTotal = function (groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter) {\n        var _this = this;\n        var group = groupDef;\n        if (!group.children) {\n            var def = groupDef;\n            return def.colId ? [def.colId] : null;\n        }\n        var colIds = [];\n        // need to recurse children first to obtain colIds used in the aggregation stage\n        group.children\n            .forEach(function (grp) {\n            var childColIds = _this.recursivelyAddPivotTotal(grp, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n            if (childColIds) {\n                colIds = colIds.concat(childColIds);\n            }\n        });\n        // only add total colDef if there is more than 1 child node\n        if (group.children.length > 1) {\n            //create total colDef using an arbitrary value column as a template\n            var totalColDef = this.createColDef(valueColumn, 'Total', groupDef.pivotKeys, columnIdSequence);\n            totalColDef.pivotTotalColumnIds = colIds;\n            totalColDef.aggFunc = valueColumn.getAggFunc();\n            // add total colDef to group and pivot colDefs array\n            var children = groupDef.children;\n            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);\n            pivotColumnDefs.push(totalColDef);\n        }\n        return colIds;\n    };\n    PivotColDefService.prototype.addRowGroupTotals = function (pivotColumnGroupDefs, pivotColumnDefs, valueColumns, columnIdSequence) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.getPivotRowTotals()) {\n            return;\n        }\n        var insertAfter = this.gridOptionsWrapper.getPivotRowTotals() === 'after';\n        // order of row group totals depends on position\n        var valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();\n        var _loop_1 = function (i) {\n            var valueCol = valueCols[i];\n            var colIds = [];\n            pivotColumnGroupDefs.forEach(function (groupDef) {\n                colIds = colIds.concat(_this.extractColIdsForValueColumn(groupDef, valueCol));\n            });\n            this_1.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, [], columnIdSequence, valueCol, colIds, insertAfter);\n        };\n        var this_1 = this;\n        for (var i = 0; i < valueCols.length; i++) {\n            _loop_1(i);\n        }\n    };\n    PivotColDefService.prototype.extractColIdsForValueColumn = function (groupDef, valueColumn) {\n        var _this = this;\n        var group = groupDef;\n        if (!group.children) {\n            var colDef = group;\n            return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];\n        }\n        var colIds = [];\n        group.children\n            .forEach(function (grp) {\n            _this.extractColIdsForValueColumn(grp, valueColumn);\n            var childColIds = _this.extractColIdsForValueColumn(grp, valueColumn);\n            colIds = colIds.concat(childColIds);\n        });\n        return colIds;\n    };\n    PivotColDefService.prototype.createRowGroupTotal = function (parentChildren, pivotColumnDefs, pivotKeys, columnIdSequence, valueColumn, colIds, insertAfter) {\n        var newPivotKeys = pivotKeys.slice(0);\n        var measureColumns = this.columnController.getValueColumns();\n        var valueGroup = {\n            children: [],\n            pivotKeys: newPivotKeys,\n            groupId: PivotColDefService_1.PIVOT_ROW_TOTAL_PREFIX + columnIdSequence.next(),\n        };\n        if (measureColumns.length === 0) {\n            var colDef = this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n            valueGroup.children.push(colDef);\n            pivotColumnDefs.push(colDef);\n        }\n        else {\n            var columnName = this.columnController.getDisplayNameForColumn(valueColumn, 'header');\n            var colDef = this.createColDef(valueColumn, columnName, newPivotKeys, columnIdSequence);\n            colDef.pivotTotalColumnIds = colIds;\n            valueGroup.children.push(colDef);\n            pivotColumnDefs.push(colDef);\n        }\n        insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);\n    };\n    PivotColDefService.prototype.createColDef = function (valueColumn, headerName, pivotKeys, columnIdSequence) {\n        var colDef = {};\n        if (valueColumn) {\n            var colDefToCopy = valueColumn.getColDef();\n            agGridCommunity._.assign(colDef, colDefToCopy);\n            // even if original column was hidden, we always show the pivot value column, otherwise it would be\n            // very confusing for people thinking the pivot is broken\n            colDef.hide = false;\n        }\n        colDef.headerName = headerName;\n        colDef.colId = 'pivot_' + columnIdSequence.next();\n        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to\n        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.\n        colDef.field = colDef.colId;\n        colDef.pivotKeys = pivotKeys;\n        colDef.pivotValueColumn = valueColumn;\n        colDef.filter = false;\n        return colDef;\n    };\n    PivotColDefService.prototype.sameAggFuncs = function (aggFuncs) {\n        if (aggFuncs.length == 1) {\n            return true;\n        }\n        //check if all aggFunc's match\n        for (var i = 1; i < aggFuncs.length; i++) {\n            if (aggFuncs[i] !== aggFuncs[0]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    PivotColDefService.prototype.headerNameComparator = function (userComparator, a, b) {\n        if (userComparator) {\n            return userComparator(a.headerName, b.headerName);\n        }\n        else {\n            if (a.headerName && !b.headerName) {\n                return 1;\n            }\n            else if (!a.headerName && b.headerName) {\n                return -1;\n            }\n            // slightly naff here - just to satify typescript\n            // really should be &&, but if so ts complains\n            // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are\n            // ..still naff though\n            if (!a.headerName || !b.headerName) {\n                return 0;\n            }\n            if (a.headerName < b.headerName) {\n                return -1;\n            }\n            if (a.headerName > b.headerName) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n    PivotColDefService.prototype.merge = function (m1, m2) {\n        m2.forEach(function (value, key, map) {\n            var existingList = m1.has(key) ? m1.get(key) : [];\n            var updatedList = __spreadArrays(existingList, value);\n            m1.set(key, updatedList);\n        });\n    };\n    var PivotColDefService_1;\n    PivotColDefService.PIVOT_ROW_TOTAL_PREFIX = 'PivotRowTotal_';\n    __decorate$a([\n        agGridCommunity.Autowired('columnController')\n    ], PivotColDefService.prototype, \"columnController\", void 0);\n    PivotColDefService = PivotColDefService_1 = __decorate$a([\n        agGridCommunity.Bean('pivotColDefService')\n    ], PivotColDefService);\n    return PivotColDefService;\n}(agGridCommunity.BeanStub));\n\nvar __extends$b = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PivotStage = /** @class */ (function (_super) {\n    __extends$b(PivotStage, _super);\n    function PivotStage() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.uniqueValues = {};\n        return _this;\n    }\n    PivotStage.prototype.execute = function (params) {\n        var rootNode = params.rowNode;\n        var changedPath = params.changedPath;\n        if (this.columnController.isPivotActive()) {\n            this.executePivotOn(rootNode, changedPath);\n        }\n        else {\n            this.executePivotOff(changedPath);\n        }\n    };\n    PivotStage.prototype.executePivotOff = function (changedPath) {\n        this.aggregationColumnsHashLastTime = null;\n        this.uniqueValues = {};\n        if (this.columnController.isSecondaryColumnsPresent()) {\n            this.columnController.setSecondaryColumns(null, \"rowModelUpdated\");\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n    };\n    PivotStage.prototype.executePivotOn = function (rootNode, changedPath) {\n        var uniqueValues = this.bucketUpRowNodes(rootNode);\n        var uniqueValuesChanged = this.setUniqueValues(uniqueValues);\n        var aggregationColumns = this.columnController.getValueColumns();\n        var aggregationColumnsHash = aggregationColumns.map(function (column) { return column.getId(); }).join('#');\n        var aggregationFuncsHash = aggregationColumns.map(function (column) { return column.getAggFunc().toString(); }).join('#');\n        var aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;\n        var aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;\n        this.aggregationColumnsHashLastTime = aggregationColumnsHash;\n        this.aggregationFuncsHashLastTime = aggregationFuncsHash;\n        if (uniqueValuesChanged || aggregationColumnsChanged || aggregationFuncsChanged) {\n            var _a = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues), pivotColumnGroupDefs = _a.pivotColumnGroupDefs, pivotColumnDefs = _a.pivotColumnDefs;\n            this.pivotColumnDefs = pivotColumnDefs;\n            this.columnController.setSecondaryColumns(pivotColumnGroupDefs, \"rowModelUpdated\");\n            // because the secondary columns have changed, then the aggregation needs to visit the whole\n            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n    };\n    PivotStage.prototype.setUniqueValues = function (newValues) {\n        var json1 = JSON.stringify(newValues);\n        var json2 = JSON.stringify(this.uniqueValues);\n        var uniqueValuesChanged = json1 !== json2;\n        // we only continue the below if the unique values are different, as otherwise\n        // the result will be the same as the last time we did it\n        if (uniqueValuesChanged) {\n            this.uniqueValues = newValues;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // returns true if values were different\n    PivotStage.prototype.bucketUpRowNodes = function (rootNode) {\n        var _this = this;\n        // accessed from inside inner function\n        var uniqueValues = {};\n        // finds all leaf groups and calls mapRowNode with it\n        var recursivelySearchForLeafNodes = function (rowNode) {\n            if (rowNode.leafGroup) {\n                _this.bucketRowNode(rowNode, uniqueValues);\n            }\n            else {\n                rowNode.childrenAfterFilter.forEach(function (child) {\n                    recursivelySearchForLeafNodes(child);\n                });\n            }\n        };\n        recursivelySearchForLeafNodes(rootNode);\n        return uniqueValues;\n    };\n    PivotStage.prototype.bucketRowNode = function (rowNode, uniqueValues) {\n        var pivotColumns = this.columnController.getPivotColumns();\n        if (pivotColumns.length === 0) {\n            rowNode.childrenMapped = null;\n            return;\n        }\n        rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);\n    };\n    PivotStage.prototype.bucketChildren = function (children, pivotColumns, pivotIndex, uniqueValues) {\n        var _this = this;\n        var mappedChildren = {};\n        var pivotColumn = pivotColumns[pivotIndex];\n        // map the children out based on the pivot column\n        children.forEach(function (child) {\n            var key = _this.valueService.getKeyForNode(pivotColumn, child);\n            if (agGridCommunity._.missing(key)) {\n                key = '';\n            }\n            if (!uniqueValues[key]) {\n                uniqueValues[key] = {};\n            }\n            if (!mappedChildren[key]) {\n                mappedChildren[key] = [];\n            }\n            mappedChildren[key].push(child);\n        });\n        // if it's the last pivot column, return as is, otherwise go one level further in the map\n        if (pivotIndex === pivotColumns.length - 1) {\n            return mappedChildren;\n        }\n        else {\n            var result_1 = {};\n            agGridCommunity._.iterateObject(mappedChildren, function (key, value) {\n                result_1[key] = _this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);\n            });\n            return result_1;\n        }\n    };\n    PivotStage.prototype.getPivotColumnDefs = function () {\n        return this.pivotColumnDefs;\n    };\n    __decorate$b([\n        agGridCommunity.Autowired('valueService')\n    ], PivotStage.prototype, \"valueService\", void 0);\n    __decorate$b([\n        agGridCommunity.Autowired('columnController')\n    ], PivotStage.prototype, \"columnController\", void 0);\n    __decorate$b([\n        agGridCommunity.Autowired('pivotColDefService')\n    ], PivotStage.prototype, \"pivotColDefService\", void 0);\n    PivotStage = __decorate$b([\n        agGridCommunity.Bean('pivotStage')\n    ], PivotStage);\n    return PivotStage;\n}(agGridCommunity.BeanStub));\n\nvar __extends$c = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AggFuncService = /** @class */ (function (_super) {\n    __extends$c(AggFuncService, _super);\n    function AggFuncService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.aggFuncsMap = {};\n        _this.initialised = false;\n        return _this;\n    }\n    AggFuncService_1 = AggFuncService;\n    AggFuncService.prototype.init = function () {\n        if (this.initialised) {\n            return;\n        }\n        this.initialiseWithDefaultAggregations();\n        this.addAggFuncs(this.gridOptionsWrapper.getAggFuncs());\n    };\n    AggFuncService.prototype.initialiseWithDefaultAggregations = function () {\n        this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;\n        this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;\n        this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;\n        this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;\n        this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;\n        this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;\n        this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;\n        this.initialised = true;\n    };\n    AggFuncService.prototype.getDefaultAggFunc = function (column) {\n        var allKeys = this.getFuncNames(column);\n        // use 'sum' if it's a) allowed for the column and b) still registered\n        // (ie not removed by user)\n        var sumInKeysList = agGridCommunity._.includes(allKeys, AggFuncService_1.AGG_SUM);\n        var sumInFuncs = agGridCommunity._.exists(this.aggFuncsMap[AggFuncService_1.AGG_SUM]);\n        if (sumInKeysList && sumInFuncs) {\n            return AggFuncService_1.AGG_SUM;\n        }\n        return agGridCommunity._.existsAndNotEmpty(allKeys) ? allKeys[0] : null;\n    };\n    AggFuncService.prototype.addAggFuncs = function (aggFuncs) {\n        agGridCommunity._.iterateObject(aggFuncs, this.addAggFunc.bind(this));\n    };\n    AggFuncService.prototype.addAggFunc = function (key, aggFunc) {\n        this.init();\n        this.aggFuncsMap[key] = aggFunc;\n    };\n    AggFuncService.prototype.getAggFunc = function (name) {\n        this.init();\n        return this.aggFuncsMap[name];\n    };\n    AggFuncService.prototype.getFuncNames = function (column) {\n        var userAllowedFuncs = column.getColDef().allowedAggFuncs;\n        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;\n    };\n    AggFuncService.prototype.clear = function () {\n        this.aggFuncsMap = {};\n    };\n    var AggFuncService_1;\n    AggFuncService.AGG_SUM = 'sum';\n    AggFuncService.AGG_FIRST = 'first';\n    AggFuncService.AGG_LAST = 'last';\n    AggFuncService.AGG_MIN = 'min';\n    AggFuncService.AGG_MAX = 'max';\n    AggFuncService.AGG_COUNT = 'count';\n    AggFuncService.AGG_AVG = 'avg';\n    __decorate$c([\n        agGridCommunity.PostConstruct\n    ], AggFuncService.prototype, \"init\", null);\n    AggFuncService = AggFuncService_1 = __decorate$c([\n        agGridCommunity.Bean('aggFuncService')\n    ], AggFuncService);\n    return AggFuncService;\n}(agGridCommunity.BeanStub));\nfunction aggSum(params) {\n    var values = params.values;\n    var result = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if (typeof value === 'number') {\n            if (result === null) {\n                result = value;\n            }\n            else {\n                result += typeof result === 'number' ? value : BigInt(value);\n            }\n        }\n        else if (typeof value === 'bigint') {\n            if (result === null) {\n                result = value;\n            }\n            else {\n                result = (typeof result === 'bigint' ? result : BigInt(result)) + value;\n            }\n        }\n    }\n    return result;\n}\nfunction aggFirst(params) {\n    return params.values.length > 0 ? params.values[0] : null;\n}\nfunction aggLast(params) {\n    return params.values.length > 0 ? agGridCommunity._.last(params.values) : null;\n}\nfunction aggMin(params) {\n    var values = params.values;\n    var result = null;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {\n            result = value;\n        }\n    }\n    return result;\n}\nfunction aggMax(params) {\n    var values = params.values;\n    var result = null;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {\n            result = value;\n        }\n    }\n    return result;\n}\nfunction aggCount(params) {\n    var values = params.values;\n    var result = 0;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        // check if the value is from a group, in which case use the group's count\n        result += value != null && typeof value.value === 'number' ? value.value : 1;\n    }\n    return {\n        value: result,\n        toString: function () {\n            return this.value.toString();\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        }\n    };\n}\n// the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\nfunction aggAvg(params) {\n    var values = params.values;\n    var sum = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    var count = 0;\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (var i = 0; i < values.length; i++) {\n        var currentValue = values[i];\n        var valueToAdd = null;\n        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {\n            valueToAdd = currentValue;\n            count++;\n        }\n        else if (currentValue != null && (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') && typeof currentValue.count === 'number') {\n            // we are aggregating groups, so we take the aggregated values to calculated a weighted average\n            valueToAdd = currentValue.value * (typeof currentValue.value === 'number' ? currentValue.count : BigInt(currentValue.count));\n            count += currentValue.count;\n        }\n        if (typeof valueToAdd === 'number') {\n            sum += typeof sum === 'number' ? valueToAdd : BigInt(valueToAdd);\n        }\n        else if (typeof valueToAdd === 'bigint') {\n            sum = (typeof sum === 'bigint' ? sum : BigInt(sum)) + valueToAdd;\n        }\n    }\n    var value = null;\n    // avoid divide by zero error\n    if (count > 0) {\n        value = sum / (typeof sum === 'number' ? count : BigInt(count));\n    }\n    // the result will be an object. when this cell is rendered, only the avg is shown.\n    // however when this cell is part of another aggregation, the count is also needed\n    // to create a weighted average for the next level.\n    return {\n        count: count,\n        value: value,\n        // the grid by default uses toString to render values for an object, so this\n        // is a trick to get the default cellRenderer to display the avg value\n        toString: function () {\n            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';\n        },\n        // used for sorting\n        toNumber: function () {\n            return this.value;\n        }\n    };\n}\n\nvar __extends$d = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DropZoneColumnComp = /** @class */ (function (_super) {\n    __extends$d(DropZoneColumnComp, _super);\n    function DropZoneColumnComp(column, dragSourceDropTarget, ghost, valueColumn, horizontal) {\n        var _this = _super.call(this) || this;\n        _this.column = column;\n        _this.dragSourceDropTarget = dragSourceDropTarget;\n        _this.ghost = ghost;\n        _this.valueColumn = valueColumn;\n        _this.horizontal = horizontal;\n        _this.popupShowing = false;\n        return _this;\n    }\n    DropZoneColumnComp.prototype.init = function () {\n        this.setTemplate(DropZoneColumnComp.TEMPLATE);\n        this.addElementClasses(this.getGui());\n        this.addElementClasses(this.eDragHandle, 'drag-handle');\n        this.addElementClasses(this.eText, 'text');\n        this.addElementClasses(this.eButton, 'button');\n        this.eDragHandle.appendChild(agGridCommunity._.createIconNoSpan('columnDrag', this.gridOptionsWrapper));\n        this.eButton.appendChild(agGridCommunity._.createIconNoSpan('cancel', this.gridOptionsWrapper));\n        this.displayName = this.columnController.getDisplayNameForColumn(this.column, 'columnDrop');\n        this.setupComponents();\n        if (!this.ghost && !this.gridOptionsWrapper.isFunctionsReadOnly()) {\n            this.addDragSource();\n        }\n        this.setupTooltip();\n    };\n    DropZoneColumnComp.prototype.setupTooltip = function () {\n        var _this = this;\n        var refresh = function () {\n            var newTooltipText = _this.column.getColDef().headerTooltip;\n            _this.setTooltip(newTooltipText);\n        };\n        refresh();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, refresh);\n    };\n    DropZoneColumnComp.prototype.addDragSource = function () {\n        var _this = this;\n        var dragSource = {\n            type: agGridCommunity.DragSourceType.ToolPanel,\n            eElement: this.eDragHandle,\n            defaultIconName: agGridCommunity.DragAndDropService.ICON_HIDE,\n            getDragItem: function () { return _this.createDragItem(); },\n            dragItemName: this.displayName,\n            dragSourceDropTarget: this.dragSourceDropTarget\n        };\n        this.dragAndDropService.addDragSource(dragSource, true);\n        this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource); });\n    };\n    DropZoneColumnComp.prototype.createDragItem = function () {\n        var visibleState = {};\n        visibleState[this.column.getId()] = this.column.isVisible();\n        return {\n            columns: [this.column],\n            visibleState: visibleState\n        };\n    };\n    DropZoneColumnComp.prototype.setupComponents = function () {\n        this.setTextValue();\n        this.setupRemove();\n        if (this.ghost) {\n            agGridCommunity._.addCssClass(this.getGui(), 'ag-column-drop-cell-ghost');\n        }\n        if (this.valueColumn && !this.gridOptionsWrapper.isFunctionsReadOnly()) {\n            this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));\n        }\n    };\n    DropZoneColumnComp.prototype.setupRemove = function () {\n        var _this = this;\n        agGridCommunity._.setDisplayed(this.eButton, !this.gridOptionsWrapper.isFunctionsReadOnly());\n        this.addManagedListener(this.eButton, 'click', function (mouseEvent) {\n            var agEvent = { type: DropZoneColumnComp.EVENT_COLUMN_REMOVE };\n            _this.dispatchEvent(agEvent);\n            mouseEvent.stopPropagation();\n        });\n        var touchListener = new agGridCommunity.TouchListener(this.eButton);\n        this.addManagedListener(touchListener, agGridCommunity.TouchListener.EVENT_TAP, function (event) {\n            var agEvent = { type: DropZoneColumnComp.EVENT_COLUMN_REMOVE };\n            _this.dispatchEvent(agEvent);\n        });\n        this.addDestroyFunc(touchListener.destroy.bind(touchListener));\n    };\n    DropZoneColumnComp.prototype.setTextValue = function () {\n        var displayValue;\n        if (this.valueColumn) {\n            var aggFunc = this.column.getAggFunc();\n            // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'\n            var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';\n            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            displayValue = aggFuncStringTranslated + \"(\" + this.displayName + \")\";\n        }\n        else {\n            displayValue = this.displayName;\n        }\n        var displayValueSanitised = agGridCommunity._.escapeString(displayValue);\n        this.eText.innerHTML = displayValueSanitised;\n    };\n    DropZoneColumnComp.prototype.onShowAggFuncSelection = function () {\n        var _this = this;\n        if (this.popupShowing) {\n            return;\n        }\n        this.popupShowing = true;\n        var virtualList = new agGridCommunity.VirtualList('select-agg-func');\n        var rows = this.aggFuncService.getFuncNames(this.column);\n        virtualList.setModel({\n            getRow: function (index) { return rows[index]; },\n            getRowCount: function () { return rows.length; }\n        });\n        this.getContext().createBean(virtualList);\n        var ePopup = agGridCommunity._.loadTemplate('<div class=\"ag-select-agg-func-popup\"></div>');\n        ePopup.style.top = '0px';\n        ePopup.style.left = '0px';\n        ePopup.appendChild(virtualList.getGui());\n        // ePopup.style.height = this.gridOptionsWrapper.getAggFuncPopupHeight() + 'px';\n        ePopup.style.width = this.getGui().clientWidth + 'px';\n        var popupHiddenFunc = function () {\n            _this.destroyBean(virtualList);\n            _this.popupShowing = false;\n        };\n        var addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: ePopup,\n            closeOnEsc: true,\n            closedCallback: popupHiddenFunc\n        });\n        if (addPopupRes) {\n            virtualList.setComponentCreator(this.createAggSelect.bind(this, addPopupRes.hideFunc));\n        }\n        this.popupService.positionPopupUnderComponent({\n            type: 'aggFuncSelect',\n            eventSource: this.getGui(),\n            ePopup: ePopup,\n            keepWithinBounds: true,\n            column: this.column\n        });\n        virtualList.refresh();\n    };\n    DropZoneColumnComp.prototype.createAggSelect = function (hidePopup, value) {\n        var _this = this;\n        var itemSelected = function () {\n            hidePopup();\n            if (_this.gridOptionsWrapper.isFunctionsPassive()) {\n                var event_1 = {\n                    type: agGridCommunity.Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST,\n                    columns: [_this.column],\n                    aggFunc: value,\n                    api: _this.gridApi,\n                    columnApi: _this.columnApi\n                };\n                _this.eventService.dispatchEvent(event_1);\n            }\n            else {\n                _this.columnController.setColumnAggFunc(_this.column, value, \"toolPanelDragAndDrop\");\n            }\n        };\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var aggFuncString = value.toString();\n        var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n        var comp = new AggItemComp(itemSelected, aggFuncStringTranslated);\n        return comp;\n    };\n    DropZoneColumnComp.prototype.addElementClasses = function (el, suffix) {\n        suffix = suffix ? \"-\" + suffix : '';\n        agGridCommunity._.addCssClass(el, \"ag-column-drop-cell\" + suffix);\n        var direction = this.horizontal ? 'horizontal' : 'vertical';\n        agGridCommunity._.addCssClass(el, \"ag-column-drop-\" + direction + \"-cell\" + suffix);\n    };\n    DropZoneColumnComp.EVENT_COLUMN_REMOVE = 'columnRemove';\n    DropZoneColumnComp.TEMPLATE = \"<span>\\n          <span ref=\\\"eDragHandle\\\" class=\\\"ag-drag-handle ag-column-drop-cell-drag-handle\\\"></span>\\n          <span ref=\\\"eText\\\" class=\\\"ag-column-drop-cell-text\\\"></span>\\n          <span ref=\\\"eButton\\\" class=\\\"ag-column-drop-cell-button\\\"></span>\\n        </span>\";\n    __decorate$d([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], DropZoneColumnComp.prototype, \"dragAndDropService\", void 0);\n    __decorate$d([\n        agGridCommunity.Autowired('columnController')\n    ], DropZoneColumnComp.prototype, \"columnController\", void 0);\n    __decorate$d([\n        agGridCommunity.Autowired('popupService')\n    ], DropZoneColumnComp.prototype, \"popupService\", void 0);\n    __decorate$d([\n        agGridCommunity.Optional('aggFuncService')\n    ], DropZoneColumnComp.prototype, \"aggFuncService\", void 0);\n    __decorate$d([\n        agGridCommunity.Autowired('columnApi')\n    ], DropZoneColumnComp.prototype, \"columnApi\", void 0);\n    __decorate$d([\n        agGridCommunity.Autowired('gridApi')\n    ], DropZoneColumnComp.prototype, \"gridApi\", void 0);\n    __decorate$d([\n        agGridCommunity.RefSelector('eText')\n    ], DropZoneColumnComp.prototype, \"eText\", void 0);\n    __decorate$d([\n        agGridCommunity.RefSelector('eDragHandle')\n    ], DropZoneColumnComp.prototype, \"eDragHandle\", void 0);\n    __decorate$d([\n        agGridCommunity.RefSelector('eButton')\n    ], DropZoneColumnComp.prototype, \"eButton\", void 0);\n    __decorate$d([\n        agGridCommunity.PostConstruct\n    ], DropZoneColumnComp.prototype, \"init\", null);\n    return DropZoneColumnComp;\n}(agGridCommunity.Component));\nvar AggItemComp = /** @class */ (function (_super) {\n    __extends$d(AggItemComp, _super);\n    function AggItemComp(itemSelected, value) {\n        var _this = _super.call(this, '<div class=\"ag-select-agg-func-item\"/>') || this;\n        _this.getGui().innerText = value;\n        _this.value = value;\n        _this.addGuiEventListener('click', itemSelected);\n        return _this;\n    }\n    return AggItemComp;\n}(agGridCommunity.Component));\n\nvar __extends$e = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar BaseDropZonePanel = /** @class */ (function (_super) {\n    __extends$e(BaseDropZonePanel, _super);\n    function BaseDropZonePanel(horizontal, valueColumn) {\n        var _this = _super.call(this, \"<div class=\\\"ag-unselectable\\\"></div>\") || this;\n        _this.horizontal = horizontal;\n        _this.valueColumn = valueColumn;\n        _this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;\n        _this.guiDestroyFunctions = [];\n        _this.childColumnComponents = [];\n        _this.addElementClasses(_this.getGui());\n        _this.eColumnDropList = document.createElement('div');\n        _this.addElementClasses(_this.eColumnDropList, 'list');\n        return _this;\n    }\n    BaseDropZonePanel.prototype.isHorizontal = function () {\n        return this.horizontal;\n    };\n    BaseDropZonePanel.prototype.setBeans = function (beans) {\n        this.beans = beans;\n    };\n    BaseDropZonePanel.prototype.destroy = function () {\n        this.destroyGui();\n        _super.prototype.destroy.call(this);\n    };\n    BaseDropZonePanel.prototype.destroyGui = function () {\n        this.guiDestroyFunctions.forEach(function (func) { return func(); });\n        this.guiDestroyFunctions.length = 0;\n        this.childColumnComponents.length = 0;\n        agGridCommunity._.clearElement(this.getGui());\n        agGridCommunity._.clearElement(this.eColumnDropList);\n    };\n    BaseDropZonePanel.prototype.init = function (params) {\n        this.params = params;\n        this.addManagedListener(this.beans.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.refreshGui.bind(this));\n        this.addManagedListener(this.beans.gridOptionsWrapper, 'functionsReadOnly', this.refreshGui.bind(this));\n        this.setupDropTarget();\n        // we don't know if this bean will be initialised before columnController.\n        // if columnController first, then below will work\n        // if columnController second, then below will put blank in, and then above event gets first when columnController is set up\n        this.refreshGui();\n    };\n    BaseDropZonePanel.prototype.addElementClasses = function (el, suffix) {\n        suffix = suffix ? \"-\" + suffix : '';\n        agGridCommunity._.addCssClass(el, \"ag-column-drop\" + suffix);\n        var direction = this.horizontal ? 'horizontal' : 'vertical';\n        agGridCommunity._.addCssClass(el, \"ag-column-drop-\" + direction + suffix);\n    };\n    BaseDropZonePanel.prototype.setupDropTarget = function () {\n        this.dropTarget = {\n            getContainer: this.getGui.bind(this),\n            getIconName: this.getIconName.bind(this),\n            onDragging: this.onDragging.bind(this),\n            onDragEnter: this.onDragEnter.bind(this),\n            onDragLeave: this.onDragLeave.bind(this),\n            onDragStop: this.onDragStop.bind(this),\n            isInterestedIn: this.isInterestedIn.bind(this)\n        };\n        this.beans.dragAndDropService.addDropTarget(this.dropTarget);\n    };\n    BaseDropZonePanel.prototype.isInterestedIn = function (type) {\n        // not interested in row drags\n        return type === agGridCommunity.DragSourceType.HeaderCell || type === agGridCommunity.DragSourceType.ToolPanel;\n    };\n    BaseDropZonePanel.prototype.checkInsertIndex = function (draggingEvent) {\n        var newIndex = this.horizontal ? this.getNewHorizontalInsertIndex(draggingEvent) : this.getNewVerticalInsertIndex(draggingEvent);\n        // <0 happens when drag is no a direction we are interested in, eg drag is up/down but in horizontal panel\n        if (newIndex < 0) {\n            return false;\n        }\n        var changed = newIndex !== this.insertIndex;\n        if (changed) {\n            this.insertIndex = newIndex;\n        }\n        return changed;\n    };\n    BaseDropZonePanel.prototype.getNewHorizontalInsertIndex = function (draggingEvent) {\n        if (agGridCommunity._.missing(draggingEvent.hDirection)) {\n            return -1;\n        }\n        var newIndex = 0;\n        var mouseEvent = draggingEvent.event;\n        var enableRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n        var goingLeft = draggingEvent.hDirection === agGridCommunity.HorizontalDirection.Left;\n        var mouseX = mouseEvent.clientX;\n        this.childColumnComponents.forEach(function (childColumn) {\n            var rect = childColumn.getGui().getBoundingClientRect();\n            var rectX = goingLeft ? rect.right : rect.left;\n            var horizontalFit = enableRtl ? mouseX <= rectX : mouseX >= rectX;\n            if (horizontalFit) {\n                newIndex++;\n            }\n        });\n        return newIndex;\n    };\n    BaseDropZonePanel.prototype.getNewVerticalInsertIndex = function (draggingEvent) {\n        if (agGridCommunity._.missing(draggingEvent.vDirection)) {\n            return -1;\n        }\n        var newIndex = 0;\n        var mouseEvent = draggingEvent.event;\n        this.childColumnComponents.forEach(function (childColumn) {\n            var rect = childColumn.getGui().getBoundingClientRect();\n            var verticalFit = mouseEvent.clientY >= (draggingEvent.vDirection === agGridCommunity.VerticalDirection.Down ? rect.top : rect.bottom);\n            if (verticalFit) {\n                newIndex++;\n            }\n        });\n        return newIndex;\n    };\n    BaseDropZonePanel.prototype.checkDragStartedBySelf = function (draggingEvent) {\n        if (this.state !== BaseDropZonePanel.STATE_NOT_DRAGGING) {\n            return;\n        }\n        this.state = BaseDropZonePanel.STATE_REARRANGE_COLUMNS;\n        this.potentialDndColumns = draggingEvent.dragSource.getDragItem().columns || [];\n        this.refreshGui();\n        this.checkInsertIndex(draggingEvent);\n        this.refreshGui();\n    };\n    BaseDropZonePanel.prototype.onDragging = function (draggingEvent) {\n        this.checkDragStartedBySelf(draggingEvent);\n        if (this.checkInsertIndex(draggingEvent)) {\n            this.refreshGui();\n        }\n    };\n    BaseDropZonePanel.prototype.onDragEnter = function (draggingEvent) {\n        // this will contain all columns that are potential drops\n        var dragColumns = draggingEvent.dragSource.getDragItem().columns || [];\n        this.state = BaseDropZonePanel.STATE_NEW_COLUMNS_IN;\n        // take out columns that are not droppable\n        var goodDragColumns = dragColumns.filter(this.isColumnDroppable.bind(this));\n        if (goodDragColumns.length > 0) {\n            this.potentialDndColumns = goodDragColumns;\n            this.checkInsertIndex(draggingEvent);\n            this.refreshGui();\n        }\n    };\n    BaseDropZonePanel.prototype.isPotentialDndColumns = function () {\n        return agGridCommunity._.existsAndNotEmpty(this.potentialDndColumns);\n    };\n    BaseDropZonePanel.prototype.onDragLeave = function (draggingEvent) {\n        // if the dragging started from us, we remove the group, however if it started\n        // someplace else, then we don't, as it was only 'asking'\n        if (this.state === BaseDropZonePanel.STATE_REARRANGE_COLUMNS) {\n            var columns = draggingEvent.dragSource.getDragItem().columns || [];\n            this.removeColumns(columns);\n        }\n        if (this.isPotentialDndColumns()) {\n            this.potentialDndColumns = [];\n            this.refreshGui();\n        }\n        this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;\n    };\n    BaseDropZonePanel.prototype.onDragStop = function () {\n        if (this.isPotentialDndColumns()) {\n            var success = false;\n            if (this.state === BaseDropZonePanel.STATE_NEW_COLUMNS_IN) {\n                this.addColumns(this.potentialDndColumns);\n                success = true;\n            }\n            else {\n                success = this.rearrangeColumns(this.potentialDndColumns);\n            }\n            this.potentialDndColumns = [];\n            // If the function is passive, then we don't refresh, as we assume the client application\n            // is going to call setRowGroups / setPivots / setValues at a later point which will then\n            // cause a refresh. This gives a nice GUI where the ghost stays until the app has caught\n            // up with the changes. However, if there was no change in the order, then we do need to\n            // refresh to reset the columns\n            if (!this.beans.gridOptionsWrapper.isFunctionsPassive() || !success) {\n                this.refreshGui();\n            }\n        }\n        this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;\n    };\n    BaseDropZonePanel.prototype.removeColumns = function (columnsToRemove) {\n        var newColumnList = this.getExistingColumns().filter(function (col) { return !agGridCommunity._.includes(columnsToRemove, col); });\n        this.updateColumns(newColumnList);\n    };\n    BaseDropZonePanel.prototype.addColumns = function (columnsToAdd) {\n        if (!columnsToAdd) {\n            return;\n        }\n        var newColumnList = this.getExistingColumns().slice();\n        var colsToAddNoDuplicates = columnsToAdd.filter(function (col) { return newColumnList.indexOf(col) < 0; });\n        agGridCommunity._.insertArrayIntoArray(newColumnList, colsToAddNoDuplicates, this.insertIndex);\n        this.updateColumns(newColumnList);\n    };\n    BaseDropZonePanel.prototype.rearrangeColumns = function (columnsToAdd) {\n        var newColumnList = this.getNonGhostColumns().slice();\n        agGridCommunity._.insertArrayIntoArray(newColumnList, columnsToAdd, this.insertIndex);\n        if (agGridCommunity._.areEqual(newColumnList, this.getExistingColumns())) {\n            return false;\n        }\n        else {\n            this.updateColumns(newColumnList);\n            return true;\n        }\n    };\n    BaseDropZonePanel.prototype.refreshGui = function () {\n        // we reset the scroll position after the refresh.\n        // if we don't do this, then the list will always scroll to the top\n        // each time we refresh it. this is because part of the refresh empties\n        // out the list which sets scroll to zero. so the user could be just\n        // reordering the list - we want to prevent the resetting of the scroll.\n        // this is relevant for vertical display only (as horizontal has no scroll)\n        var scrollTop = this.eColumnDropList.scrollTop;\n        this.destroyGui();\n        this.addIconAndTitleToGui();\n        this.addEmptyMessageToGui();\n        this.addColumnsToGui();\n        if (!this.isHorizontal()) {\n            this.eColumnDropList.scrollTop = scrollTop;\n        }\n    };\n    BaseDropZonePanel.prototype.getNonGhostColumns = function () {\n        var _this = this;\n        var existingColumns = this.getExistingColumns();\n        if (this.isPotentialDndColumns()) {\n            return existingColumns.filter(function (column) { return !agGridCommunity._.includes(_this.potentialDndColumns, column); });\n        }\n        else {\n            return existingColumns;\n        }\n    };\n    BaseDropZonePanel.prototype.addColumnsToGui = function () {\n        var _this = this;\n        var nonGhostColumns = this.getNonGhostColumns();\n        var addingGhosts = this.isPotentialDndColumns();\n        var itemsToAddToGui = [];\n        nonGhostColumns.forEach(function (column, index) {\n            if (addingGhosts && index >= _this.insertIndex) {\n                return;\n            }\n            var columnComponent = _this.createColumnComponent(column, false);\n            itemsToAddToGui.push(columnComponent);\n        });\n        if (this.isPotentialDndColumns()) {\n            this.potentialDndColumns.forEach(function (column) {\n                var columnComponent = _this.createColumnComponent(column, true);\n                itemsToAddToGui.push(columnComponent);\n            });\n            nonGhostColumns.forEach(function (column, index) {\n                if (index < _this.insertIndex) {\n                    return;\n                }\n                var columnComponent = _this.createColumnComponent(column, false);\n                itemsToAddToGui.push(columnComponent);\n            });\n        }\n        this.getGui().appendChild(this.eColumnDropList);\n        itemsToAddToGui.forEach(function (columnComponent, index) {\n            if (index > 0) {\n                _this.addArrow(_this.eColumnDropList);\n            }\n            _this.eColumnDropList.appendChild(columnComponent.getGui());\n        });\n    };\n    BaseDropZonePanel.prototype.createColumnComponent = function (column, ghost) {\n        var _this = this;\n        var columnComponent = new DropZoneColumnComp(column, this.dropTarget, ghost, this.valueColumn, this.horizontal);\n        columnComponent.addEventListener(DropZoneColumnComp.EVENT_COLUMN_REMOVE, this.removeColumns.bind(this, [column]));\n        this.beans.context.createBean(columnComponent);\n        this.guiDestroyFunctions.push(function () { return _this.destroyBean(columnComponent); });\n        if (!ghost) {\n            this.childColumnComponents.push(columnComponent);\n        }\n        return columnComponent;\n    };\n    BaseDropZonePanel.prototype.addIconAndTitleToGui = function () {\n        var eGroupIcon = this.params.icon;\n        var eTitleBar = document.createElement('div');\n        this.addElementClasses(eTitleBar, 'title-bar');\n        this.addElementClasses(eGroupIcon, 'icon');\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-column-drop-empty', this.isExistingColumnsEmpty());\n        eTitleBar.appendChild(eGroupIcon);\n        if (!this.horizontal) {\n            var eTitle = document.createElement('span');\n            this.addElementClasses(eTitle, 'title');\n            eTitle.innerHTML = this.params.title;\n            eTitleBar.appendChild(eTitle);\n        }\n        this.getGui().appendChild(eTitleBar);\n    };\n    BaseDropZonePanel.prototype.isExistingColumnsEmpty = function () {\n        return this.getExistingColumns().length === 0;\n    };\n    BaseDropZonePanel.prototype.addEmptyMessageToGui = function () {\n        if (!this.isExistingColumnsEmpty() || this.isPotentialDndColumns()) {\n            return;\n        }\n        var eMessage = document.createElement('span');\n        eMessage.innerHTML = this.params.emptyMessage;\n        this.addElementClasses(eMessage, 'empty-message');\n        this.eColumnDropList.appendChild(eMessage);\n    };\n    BaseDropZonePanel.prototype.addArrow = function (eParent) {\n        // only add the arrows if the layout is horizontal\n        if (this.horizontal) {\n            // for RTL it's a left arrow, otherwise it's a right arrow\n            var enableRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n            var icon = agGridCommunity._.createIconNoSpan(enableRtl ? 'smallLeft' : 'smallRight', this.beans.gridOptionsWrapper);\n            this.addElementClasses(icon, 'cell-separator');\n            eParent.appendChild(icon);\n        }\n    };\n    BaseDropZonePanel.STATE_NOT_DRAGGING = 'notDragging';\n    BaseDropZonePanel.STATE_NEW_COLUMNS_IN = 'newColumnsIn';\n    BaseDropZonePanel.STATE_REARRANGE_COLUMNS = 'rearrangeColumns';\n    return BaseDropZonePanel;\n}(agGridCommunity.Component));\n\nvar __extends$f = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RowGroupDropZonePanel = /** @class */ (function (_super) {\n    __extends$f(RowGroupDropZonePanel, _super);\n    function RowGroupDropZonePanel(horizontal) {\n        return _super.call(this, horizontal, false) || this;\n    }\n    RowGroupDropZonePanel.prototype.passBeansUp = function () {\n        _super.prototype.setBeans.call(this, {\n            gridOptionsWrapper: this.gridOptionsWrapper,\n            eventService: this.eventService,\n            context: this.getContext(),\n            loggerFactory: this.loggerFactory,\n            dragAndDropService: this.dragAndDropService\n        });\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to set row groups');\n        var title = localeTextFunc('groups', 'Row Groups');\n        _super.prototype.init.call(this, {\n            dragAndDropIcon: agGridCommunity.DragAndDropService.ICON_GROUP,\n            icon: agGridCommunity._.createIconNoSpan('rowGroupPanel', this.gridOptionsWrapper, null),\n            emptyMessage: emptyMessage,\n            title: title\n        });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));\n    };\n    RowGroupDropZonePanel.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'rowGroupColumnsList';\n        return res;\n    };\n    RowGroupDropZonePanel.prototype.isColumnDroppable = function (column) {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsWrapper.isFunctionsReadOnly() || !column.isPrimary()) {\n            return false;\n        }\n        return column.isAllowRowGroup() && !column.isRowGroupActive();\n    };\n    RowGroupDropZonePanel.prototype.updateColumns = function (columns) {\n        if (this.gridOptionsWrapper.isFunctionsPassive()) {\n            var event_1 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,\n                columns: columns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        else {\n            this.columnController.setRowGroupColumns(columns, \"toolPanelUi\");\n        }\n    };\n    RowGroupDropZonePanel.prototype.getIconName = function () {\n        return this.isPotentialDndColumns() ? agGridCommunity.DragAndDropService.ICON_GROUP : agGridCommunity.DragAndDropService.ICON_NOT_ALLOWED;\n    };\n    RowGroupDropZonePanel.prototype.getExistingColumns = function () {\n        return this.columnController.getRowGroupColumns();\n    };\n    __decorate$e([\n        agGridCommunity.Autowired('columnController')\n    ], RowGroupDropZonePanel.prototype, \"columnController\", void 0);\n    __decorate$e([\n        agGridCommunity.Autowired('loggerFactory')\n    ], RowGroupDropZonePanel.prototype, \"loggerFactory\", void 0);\n    __decorate$e([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], RowGroupDropZonePanel.prototype, \"dragAndDropService\", void 0);\n    __decorate$e([\n        agGridCommunity.Autowired('columnApi')\n    ], RowGroupDropZonePanel.prototype, \"columnApi\", void 0);\n    __decorate$e([\n        agGridCommunity.Autowired('gridApi')\n    ], RowGroupDropZonePanel.prototype, \"gridApi\", void 0);\n    __decorate$e([\n        agGridCommunity.PostConstruct\n    ], RowGroupDropZonePanel.prototype, \"passBeansUp\", null);\n    return RowGroupDropZonePanel;\n}(BaseDropZonePanel));\n\nvar __extends$g = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PivotDropZonePanel = /** @class */ (function (_super) {\n    __extends$g(PivotDropZonePanel, _super);\n    function PivotDropZonePanel(horizontal) {\n        return _super.call(this, horizontal, false) || this;\n    }\n    PivotDropZonePanel.prototype.passBeansUp = function () {\n        _super.prototype.setBeans.call(this, {\n            gridOptionsWrapper: this.gridOptionsWrapper,\n            eventService: this.eventService,\n            context: this.getContext(),\n            loggerFactory: this.loggerFactory,\n            dragAndDropService: this.dragAndDropService\n        });\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to set column labels');\n        var title = localeTextFunc('pivots', 'Column Labels');\n        _super.prototype.init.call(this, {\n            dragAndDropIcon: agGridCommunity.DragAndDropService.ICON_GROUP,\n            icon: agGridCommunity._.createIconNoSpan('pivotPanel', this.gridOptionsWrapper, null),\n            emptyMessage: emptyMessage,\n            title: title\n        });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.refresh.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this));\n        this.refresh();\n    };\n    PivotDropZonePanel.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'pivotColumnsList';\n        return res;\n    };\n    PivotDropZonePanel.prototype.refresh = function () {\n        this.checkVisibility();\n        this.refreshGui();\n    };\n    PivotDropZonePanel.prototype.checkVisibility = function () {\n        var pivotMode = this.columnController.isPivotMode();\n        if (this.isHorizontal()) {\n            // what we do for horizontal (ie the pivot panel at the top) depends\n            // on the user property as well as pivotMode.\n            switch (this.gridOptionsWrapper.getPivotPanelShow()) {\n                case 'always':\n                    this.setDisplayed(pivotMode);\n                    break;\n                case 'onlyWhenPivoting':\n                    var pivotActive = this.columnController.isPivotActive();\n                    this.setDisplayed(pivotMode && pivotActive);\n                    break;\n                default:\n                    // never show it\n                    this.setDisplayed(false);\n                    break;\n            }\n        }\n        else {\n            // in toolPanel, the pivot panel is always shown when pivot mode is on\n            this.setDisplayed(pivotMode);\n        }\n    };\n    PivotDropZonePanel.prototype.isColumnDroppable = function (column) {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsWrapper.isFunctionsReadOnly() || !column.isPrimary()) {\n            return false;\n        }\n        return column.isAllowPivot() && !column.isPivotActive();\n    };\n    PivotDropZonePanel.prototype.updateColumns = function (columns) {\n        if (this.gridOptionsWrapper.isFunctionsPassive()) {\n            var event_1 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,\n                columns: columns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        else {\n            this.columnController.setPivotColumns(columns, \"toolPanelUi\");\n        }\n    };\n    PivotDropZonePanel.prototype.getIconName = function () {\n        return this.isPotentialDndColumns() ? agGridCommunity.DragAndDropService.ICON_PIVOT : agGridCommunity.DragAndDropService.ICON_NOT_ALLOWED;\n    };\n    PivotDropZonePanel.prototype.getExistingColumns = function () {\n        return this.columnController.getPivotColumns();\n    };\n    __decorate$f([\n        agGridCommunity.Autowired('columnController')\n    ], PivotDropZonePanel.prototype, \"columnController\", void 0);\n    __decorate$f([\n        agGridCommunity.Autowired('loggerFactory')\n    ], PivotDropZonePanel.prototype, \"loggerFactory\", void 0);\n    __decorate$f([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], PivotDropZonePanel.prototype, \"dragAndDropService\", void 0);\n    __decorate$f([\n        agGridCommunity.Autowired('columnApi')\n    ], PivotDropZonePanel.prototype, \"columnApi\", void 0);\n    __decorate$f([\n        agGridCommunity.Autowired('gridApi')\n    ], PivotDropZonePanel.prototype, \"gridApi\", void 0);\n    __decorate$f([\n        agGridCommunity.PostConstruct\n    ], PivotDropZonePanel.prototype, \"passBeansUp\", null);\n    return PivotDropZonePanel;\n}(BaseDropZonePanel));\n\nvar __extends$h = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar GridHeaderDropZones = /** @class */ (function (_super) {\n    __extends$h(GridHeaderDropZones, _super);\n    function GridHeaderDropZones() {\n        return _super.call(this) || this;\n    }\n    GridHeaderDropZones.prototype.postConstruct = function () {\n        this.setGui(this.createNorthPanel());\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.onRowGroupChanged.bind(this));\n        this.onRowGroupChanged();\n    };\n    GridHeaderDropZones.prototype.createNorthPanel = function () {\n        var topPanelGui = document.createElement('div');\n        var dropPanelVisibleListener = this.onDropPanelVisible.bind(this);\n        agGridCommunity._.addCssClass(topPanelGui, 'ag-column-drop-wrapper');\n        this.rowGroupComp = new RowGroupDropZonePanel(true);\n        this.createManagedBean(this.rowGroupComp);\n        this.pivotComp = new PivotDropZonePanel(true);\n        this.createManagedBean(this.pivotComp);\n        topPanelGui.appendChild(this.rowGroupComp.getGui());\n        topPanelGui.appendChild(this.pivotComp.getGui());\n        this.addManagedListener(this.rowGroupComp, agGridCommunity.Component.EVENT_DISPLAYED_CHANGED, dropPanelVisibleListener);\n        this.addManagedListener(this.pivotComp, agGridCommunity.Component.EVENT_DISPLAYED_CHANGED, dropPanelVisibleListener);\n        this.onDropPanelVisible();\n        return topPanelGui;\n    };\n    GridHeaderDropZones.prototype.onDropPanelVisible = function () {\n        var bothDisplayed = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();\n        this.rowGroupComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);\n        this.pivotComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);\n    };\n    GridHeaderDropZones.prototype.onRowGroupChanged = function () {\n        if (!this.rowGroupComp) {\n            return;\n        }\n        var rowGroupPanelShow = this.gridOptionsWrapper.getRowGroupPanelShow();\n        if (rowGroupPanelShow === agGridCommunity.Constants.ALWAYS) {\n            this.rowGroupComp.setDisplayed(true);\n        }\n        else if (rowGroupPanelShow === agGridCommunity.Constants.ONLY_WHEN_GROUPING) {\n            var grouping = !this.columnController.isRowGroupEmpty();\n            this.rowGroupComp.setDisplayed(grouping);\n        }\n        else {\n            this.rowGroupComp.setDisplayed(false);\n        }\n    };\n    __decorate$g([\n        agGridCommunity.Autowired('columnController')\n    ], GridHeaderDropZones.prototype, \"columnController\", void 0);\n    __decorate$g([\n        agGridCommunity.PostConstruct\n    ], GridHeaderDropZones.prototype, \"postConstruct\", null);\n    return GridHeaderDropZones;\n}(agGridCommunity.Component));\n\nvar RowGroupingModule = {\n    moduleName: agGridCommunity.ModuleNames.RowGroupingModule,\n    beans: [AggregationStage, GroupStage, PivotColDefService, PivotStage, AggFuncService],\n    agStackComponents: [\n        { componentName: 'AgGridHeaderDropZones', componentClass: GridHeaderDropZones }\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$i = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ValuesDropZonePanel = /** @class */ (function (_super) {\n    __extends$i(ValuesDropZonePanel, _super);\n    function ValuesDropZonePanel(horizontal) {\n        return _super.call(this, horizontal, true) || this;\n    }\n    ValuesDropZonePanel.prototype.passBeansUp = function () {\n        _super.prototype.setBeans.call(this, {\n            gridOptionsWrapper: this.gridOptionsWrapper,\n            eventService: this.eventService,\n            context: this.getContext(),\n            loggerFactory: this.loggerFactory,\n            dragAndDropService: this.dragAndDropService\n        });\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var emptyMessage = localeTextFunc('valueColumnsEmptyMessage', 'Drag here to aggregate');\n        var title = localeTextFunc('values', 'Values');\n        _super.prototype.init.call(this, {\n            dragAndDropIcon: agGridCommunity.DragAndDropService.ICON_AGGREGATE,\n            icon: agGridCommunity._.createIconNoSpan('valuePanel', this.gridOptionsWrapper, null),\n            emptyMessage: emptyMessage,\n            title: title\n        });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));\n    };\n    ValuesDropZonePanel.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'valueColumnsList';\n        return res;\n    };\n    ValuesDropZonePanel.prototype.getIconName = function () {\n        return this.isPotentialDndColumns() ? agGridCommunity.DragAndDropService.ICON_AGGREGATE : agGridCommunity.DragAndDropService.ICON_NOT_ALLOWED;\n    };\n    ValuesDropZonePanel.prototype.isColumnDroppable = function (column) {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsWrapper.isFunctionsReadOnly() || !column.isPrimary()) {\n            return false;\n        }\n        return column.isAllowValue() && !column.isValueActive();\n    };\n    ValuesDropZonePanel.prototype.updateColumns = function (columns) {\n        if (this.gridOptionsWrapper.isFunctionsPassive()) {\n            var event_1 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,\n                columns: columns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        else {\n            this.columnController.setValueColumns(columns, \"toolPanelUi\");\n        }\n    };\n    ValuesDropZonePanel.prototype.getExistingColumns = function () {\n        return this.columnController.getValueColumns();\n    };\n    __decorate$h([\n        agGridCommunity.Autowired('columnController')\n    ], ValuesDropZonePanel.prototype, \"columnController\", void 0);\n    __decorate$h([\n        agGridCommunity.Autowired('loggerFactory')\n    ], ValuesDropZonePanel.prototype, \"loggerFactory\", void 0);\n    __decorate$h([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], ValuesDropZonePanel.prototype, \"dragAndDropService\", void 0);\n    __decorate$h([\n        agGridCommunity.Autowired('columnApi')\n    ], ValuesDropZonePanel.prototype, \"columnApi\", void 0);\n    __decorate$h([\n        agGridCommunity.Autowired('gridApi')\n    ], ValuesDropZonePanel.prototype, \"gridApi\", void 0);\n    __decorate$h([\n        agGridCommunity.PostConstruct\n    ], ValuesDropZonePanel.prototype, \"passBeansUp\", null);\n    return ValuesDropZonePanel;\n}(BaseDropZonePanel));\n\nvar __extends$j = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PrimaryColsPanel = /** @class */ (function (_super) {\n    __extends$j(PrimaryColsPanel, _super);\n    function PrimaryColsPanel() {\n        return _super.call(this, PrimaryColsPanel.TEMPLATE, true) || this;\n    }\n    // we allow dragging in the toolPanel, but not when this component appears in the column menu\n    PrimaryColsPanel.prototype.init = function (allowDragging, params, eventType) {\n        this.allowDragging = allowDragging;\n        this.params = params;\n        this.eventType = eventType;\n        this.primaryColsHeaderPanel.init(this.params);\n        var hideFilter = this.params.suppressColumnFilter;\n        var hideSelect = this.params.suppressColumnSelectAll;\n        var hideExpand = this.params.suppressColumnExpandAll;\n        if (hideExpand && hideFilter && hideSelect) {\n            this.primaryColsHeaderPanel.setDisplayed(false);\n        }\n        this.addManagedListener(this.primaryColsListPanel, 'groupExpanded', this.onGroupExpanded.bind(this));\n        this.addManagedListener(this.primaryColsListPanel, 'selectionChanged', this.onSelectionChange.bind(this));\n        this.primaryColsListPanel.init(this.params, this.allowDragging, this.eventType);\n        this.addManagedListener(this.primaryColsHeaderPanel, 'expandAll', this.onExpandAll.bind(this));\n        this.addManagedListener(this.primaryColsHeaderPanel, 'collapseAll', this.onCollapseAll.bind(this));\n        this.addManagedListener(this.primaryColsHeaderPanel, 'selectAll', this.onSelectAll.bind(this));\n        this.addManagedListener(this.primaryColsHeaderPanel, 'unselectAll', this.onUnselectAll.bind(this));\n        this.addManagedListener(this.primaryColsHeaderPanel, 'filterChanged', this.onFilterChanged.bind(this));\n    };\n    PrimaryColsPanel.prototype.onExpandAll = function () {\n        this.primaryColsListPanel.doSetExpandedAll(true);\n    };\n    PrimaryColsPanel.prototype.onCollapseAll = function () {\n        this.primaryColsListPanel.doSetExpandedAll(false);\n    };\n    PrimaryColsPanel.prototype.expandGroups = function (groupIds) {\n        this.primaryColsListPanel.setGroupsExpanded(true, groupIds);\n    };\n    PrimaryColsPanel.prototype.collapseGroups = function (groupIds) {\n        this.primaryColsListPanel.setGroupsExpanded(false, groupIds);\n    };\n    PrimaryColsPanel.prototype.setColumnLayout = function (colDefs) {\n        this.primaryColsListPanel.setColumnLayout(colDefs);\n    };\n    PrimaryColsPanel.prototype.onFilterChanged = function (event) {\n        this.primaryColsListPanel.setFilterText(event.filterText);\n    };\n    PrimaryColsPanel.prototype.syncLayoutWithGrid = function () {\n        this.primaryColsListPanel.onColumnsChanged();\n    };\n    PrimaryColsPanel.prototype.onSelectAll = function () {\n        this.primaryColsListPanel.doSetSelectedAll(true);\n    };\n    PrimaryColsPanel.prototype.onUnselectAll = function () {\n        this.primaryColsListPanel.doSetSelectedAll(false);\n    };\n    PrimaryColsPanel.prototype.onGroupExpanded = function (event) {\n        this.primaryColsHeaderPanel.setExpandState(event.state);\n    };\n    PrimaryColsPanel.prototype.onSelectionChange = function (event) {\n        this.primaryColsHeaderPanel.setSelectionState(event.state);\n    };\n    PrimaryColsPanel.TEMPLATE = \"<div class=\\\"ag-column-select\\\">\\n            <ag-primary-cols-header ref=\\\"primaryColsHeaderPanel\\\"></ag-primary-cols-header>\\n            <ag-primary-cols-list ref=\\\"primaryColsListPanel\\\"></ag-primary-cols-list>\\n        </div>\";\n    __decorate$i([\n        agGridCommunity.RefSelector('primaryColsHeaderPanel')\n    ], PrimaryColsPanel.prototype, \"primaryColsHeaderPanel\", void 0);\n    __decorate$i([\n        agGridCommunity.RefSelector('primaryColsListPanel')\n    ], PrimaryColsPanel.prototype, \"primaryColsListPanel\", void 0);\n    return PrimaryColsPanel;\n}(agGridCommunity.ManagedFocusComponent));\n\nvar __extends$k = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ColumnToolPanel = /** @class */ (function (_super) {\n    __extends$k(ColumnToolPanel, _super);\n    function ColumnToolPanel() {\n        var _this = _super.call(this, ColumnToolPanel.TEMPLATE) || this;\n        _this.initialised = false;\n        _this.childDestroyFuncs = [];\n        return _this;\n    }\n    // lazy initialise the panel\n    ColumnToolPanel.prototype.setVisible = function (visible) {\n        _super.prototype.setDisplayed.call(this, visible);\n        if (visible && !this.initialised) {\n            this.init(this.params);\n        }\n    };\n    ColumnToolPanel.prototype.init = function (params) {\n        var _this = this;\n        var defaultParams = {\n            suppressSideButtons: false,\n            suppressColumnSelectAll: false,\n            suppressColumnFilter: false,\n            suppressColumnExpandAll: false,\n            contractColumnSelection: false,\n            suppressPivotMode: false,\n            suppressRowGroups: false,\n            suppressValues: false,\n            suppressPivots: false,\n            suppressSyncLayoutWithGrid: false,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        agGridCommunity._.mergeDeep(defaultParams, params);\n        this.params = defaultParams;\n        if (this.isRowGroupingModuleLoaded() && !this.params.suppressPivotMode) {\n            this.pivotModePanel = this.createBean(new PivotModePanel()); // DO NOT CHANGE TO createManagedBean\n            this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.pivotModePanel); });\n            this.appendChild(this.pivotModePanel);\n        }\n        this.primaryColsPanel = this.createBean(new PrimaryColsPanel()); // DO NOT CHANGE TO createManagedBean\n        this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.primaryColsPanel); });\n        this.primaryColsPanel.init(true, this.params, \"toolPanelUi\");\n        agGridCommunity._.addCssClass(this.primaryColsPanel.getGui(), 'ag-column-panel-column-select');\n        this.appendChild(this.primaryColsPanel);\n        if (this.isRowGroupingModuleLoaded()) {\n            if (!this.params.suppressRowGroups) {\n                this.rowGroupDropZonePanel = this.createBean(new RowGroupDropZonePanel(false)); // DO NOT CHANGE TO createManagedBean\n                this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.rowGroupDropZonePanel); });\n                this.appendChild(this.rowGroupDropZonePanel);\n            }\n            if (!this.params.suppressValues) {\n                this.valuesDropZonePanel = this.createBean(new ValuesDropZonePanel(false)); // DO NOT CHANGE TO createManagedBean\n                this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.valuesDropZonePanel); });\n                this.appendChild(this.valuesDropZonePanel);\n            }\n            if (!this.params.suppressPivots) {\n                this.pivotDropZonePanel = this.createBean(new PivotDropZonePanel(false)); // DO NOT CHANGE TO createManagedBean\n                this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.pivotDropZonePanel); });\n                this.appendChild(this.pivotDropZonePanel);\n            }\n            this.setLastVisible();\n            var pivotModeListener_1 = this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.setLastVisible.bind(this));\n            this.childDestroyFuncs.push(function () { return pivotModeListener_1(); });\n        }\n        this.initialised = true;\n    };\n    ColumnToolPanel.prototype.setPivotModeSectionVisible = function (visible) {\n        var _this = this;\n        if (!this.isRowGroupingModuleLoaded()) {\n            return;\n        }\n        if (this.pivotModePanel) {\n            this.pivotModePanel.setDisplayed(visible);\n        }\n        else if (visible) {\n            this.pivotModePanel = this.createBean(new PivotModePanel());\n            // ensure pivot mode panel is positioned at the top of the columns tool panel\n            this.getGui().insertBefore(this.pivotModePanel.getGui(), this.getGui().firstChild);\n            this.childDestroyFuncs.push(function () { return _this.destroyBean(_this.pivotModePanel); });\n        }\n        this.setLastVisible();\n    };\n    ColumnToolPanel.prototype.setRowGroupsSectionVisible = function (visible) {\n        if (!this.isRowGroupingModuleLoaded()) {\n            return;\n        }\n        if (this.rowGroupDropZonePanel) {\n            this.rowGroupDropZonePanel.setDisplayed(visible);\n        }\n        else if (visible) {\n            this.rowGroupDropZonePanel = this.createManagedBean(new RowGroupDropZonePanel(false));\n            this.appendChild(this.rowGroupDropZonePanel);\n        }\n        this.setLastVisible();\n    };\n    ColumnToolPanel.prototype.setValuesSectionVisible = function (visible) {\n        if (!this.isRowGroupingModuleLoaded()) {\n            return;\n        }\n        if (this.valuesDropZonePanel) {\n            this.valuesDropZonePanel.setDisplayed(visible);\n        }\n        else if (visible) {\n            this.valuesDropZonePanel = this.createManagedBean(new ValuesDropZonePanel(false));\n            this.appendChild(this.valuesDropZonePanel);\n        }\n        this.setLastVisible();\n    };\n    ColumnToolPanel.prototype.setPivotSectionVisible = function (visible) {\n        if (!this.isRowGroupingModuleLoaded()) {\n            return;\n        }\n        if (this.pivotDropZonePanel) {\n            this.pivotDropZonePanel.setDisplayed(visible);\n        }\n        else if (visible) {\n            this.pivotDropZonePanel = this.createManagedBean(new PivotDropZonePanel(false));\n            this.appendChild(this.pivotDropZonePanel);\n            this.pivotDropZonePanel.setDisplayed(visible);\n        }\n        this.setLastVisible();\n    };\n    ColumnToolPanel.prototype.setLastVisible = function () {\n        var eGui = this.getGui();\n        var columnDrops = Array.prototype.slice.call(eGui.querySelectorAll('.ag-column-drop'));\n        columnDrops.forEach(function (columnDrop) { return agGridCommunity._.removeCssClass(columnDrop, 'ag-last-column-drop'); });\n        var columnDropEls = eGui.querySelectorAll('.ag-column-drop:not(.ag-hidden)');\n        var lastVisible = agGridCommunity._.last(columnDropEls);\n        if (lastVisible) {\n            agGridCommunity._.addCssClass(lastVisible, 'ag-last-column-drop');\n        }\n    };\n    ColumnToolPanel.prototype.isRowGroupingModuleLoaded = function () {\n        return agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.RowGroupingModule, 'Row Grouping');\n    };\n    ColumnToolPanel.prototype.expandColumnGroups = function (groupIds) {\n        this.primaryColsPanel.expandGroups(groupIds);\n    };\n    ColumnToolPanel.prototype.collapseColumnGroups = function (groupIds) {\n        this.primaryColsPanel.collapseGroups(groupIds);\n    };\n    ColumnToolPanel.prototype.setColumnLayout = function (colDefs) {\n        this.primaryColsPanel.setColumnLayout(colDefs);\n    };\n    ColumnToolPanel.prototype.syncLayoutWithGrid = function () {\n        this.primaryColsPanel.syncLayoutWithGrid();\n    };\n    ColumnToolPanel.prototype.destroyChildren = function () {\n        this.childDestroyFuncs.forEach(function (func) { return func(); });\n        this.childDestroyFuncs.length = 0;\n        agGridCommunity._.clearElement(this.getGui());\n    };\n    ColumnToolPanel.prototype.refresh = function () {\n        this.destroyChildren();\n        this.init(this.params);\n    };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so this must be public.\n    ColumnToolPanel.prototype.destroy = function () {\n        this.destroyChildren();\n        _super.prototype.destroy.call(this);\n    };\n    ColumnToolPanel.TEMPLATE = \"<div class=\\\"ag-column-panel\\\"></div>\";\n    __decorate$j([\n        agGridCommunity.Autowired(\"gridApi\")\n    ], ColumnToolPanel.prototype, \"gridApi\", void 0);\n    __decorate$j([\n        agGridCommunity.Autowired(\"columnApi\")\n    ], ColumnToolPanel.prototype, \"columnApi\", void 0);\n    return ColumnToolPanel;\n}(agGridCommunity.Component));\n\nvar __extends$l = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar HorizontalResizeComp = /** @class */ (function (_super) {\n    __extends$l(HorizontalResizeComp, _super);\n    function HorizontalResizeComp() {\n        return _super.call(this, /* html */ \"<div class=\\\"ag-tool-panel-horizontal-resize\\\"></div>\") || this;\n    }\n    HorizontalResizeComp.prototype.setElementToResize = function (elementToResize) {\n        this.elementToResize = elementToResize;\n    };\n    HorizontalResizeComp.prototype.postConstruct = function () {\n        var finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({\n            eResizeBar: this.getGui(),\n            dragStartPixels: 1,\n            onResizeStart: this.onResizeStart.bind(this),\n            onResizing: this.onResizing.bind(this),\n            onResizeEnd: this.onResizing.bind(this)\n        });\n        this.addDestroyFunc(finishedWithResizeFunc);\n        this.setInverted(this.gridOptionsWrapper.isEnableRtl());\n    };\n    HorizontalResizeComp.prototype.onResizeStart = function () {\n        this.startingWidth = this.elementToResize.offsetWidth;\n    };\n    HorizontalResizeComp.prototype.onResizing = function (delta) {\n        var direction = this.inverted ? -1 : 1;\n        var newWidth = Math.max(100, Math.floor(this.startingWidth - (delta * direction)));\n        this.elementToResize.style.width = newWidth + \"px\";\n    };\n    HorizontalResizeComp.prototype.setInverted = function (inverted) {\n        this.inverted = inverted;\n    };\n    __decorate$k([\n        agGridCommunity.Autowired('horizontalResizeService')\n    ], HorizontalResizeComp.prototype, \"horizontalResizeService\", void 0);\n    __decorate$k([\n        agGridCommunity.PostConstruct\n    ], HorizontalResizeComp.prototype, \"postConstruct\", null);\n    return HorizontalResizeComp;\n}(agGridCommunity.Component));\n\nvar __extends$m = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SideBarButtonsComp = /** @class */ (function (_super) {\n    __extends$m(SideBarButtonsComp, _super);\n    function SideBarButtonsComp() {\n        var _this = _super.call(this, SideBarButtonsComp.TEMPLATE) || this;\n        _this.buttonComps = [];\n        return _this;\n    }\n    SideBarButtonsComp.prototype.postConstruct = function () {\n        this.addManagedListener(this.getFocusableElement(), 'keydown', this.handleKeyDown.bind(this));\n    };\n    SideBarButtonsComp.prototype.handleKeyDown = function (e) {\n        if (e.keyCode !== agGridCommunity.KeyCode.TAB || !e.shiftKey) {\n            return;\n        }\n        var prevEl = this.focusController.findNextFocusableElement(this.getFocusableElement(), null, true);\n        if (!prevEl) {\n            var headerPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(0, 'start');\n            if (!headerPosition) {\n                return;\n            }\n            e.preventDefault();\n            this.focusController.focusHeaderPosition(headerPosition);\n        }\n    };\n    SideBarButtonsComp.prototype.setToolPanelDefs = function (toolPanelDefs) {\n        toolPanelDefs.forEach(this.addButtonComp.bind(this));\n    };\n    SideBarButtonsComp.prototype.setActiveButton = function (id) {\n        this.buttonComps.forEach(function (comp) {\n            comp.setSelected(id === comp.getToolPanelId());\n        });\n    };\n    SideBarButtonsComp.prototype.addButtonComp = function (def) {\n        var _this = this;\n        var buttonComp = this.createBean(new SideBarButtonComp(def));\n        this.buttonComps.push(buttonComp);\n        this.appendChild(buttonComp);\n        buttonComp.addEventListener(SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED, function () {\n            _this.dispatchEvent({\n                type: SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED,\n                toolPanelId: def.id\n            });\n        });\n    };\n    SideBarButtonsComp.prototype.clearButtons = function () {\n        this.buttonComps = this.destroyBeans(this.buttonComps);\n        agGridCommunity._.clearElement(this.getGui());\n    };\n    SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED = 'sideBarButtonClicked';\n    SideBarButtonsComp.TEMPLATE = \"<div class=\\\"ag-side-buttons\\\"></div>\";\n    __decorate$l([\n        agGridCommunity.Autowired('focusController')\n    ], SideBarButtonsComp.prototype, \"focusController\", void 0);\n    __decorate$l([\n        agGridCommunity.Autowired('headerPositionUtils')\n    ], SideBarButtonsComp.prototype, \"headerPositionUtils\", void 0);\n    __decorate$l([\n        agGridCommunity.PostConstruct\n    ], SideBarButtonsComp.prototype, \"postConstruct\", null);\n    __decorate$l([\n        agGridCommunity.PreDestroy\n    ], SideBarButtonsComp.prototype, \"clearButtons\", null);\n    return SideBarButtonsComp;\n}(agGridCommunity.Component));\nvar SideBarButtonComp = /** @class */ (function (_super) {\n    __extends$m(SideBarButtonComp, _super);\n    function SideBarButtonComp(toolPanelDef) {\n        var _this = _super.call(this) || this;\n        _this.toolPanelDef = toolPanelDef;\n        return _this;\n    }\n    SideBarButtonComp.prototype.getToolPanelId = function () {\n        return this.toolPanelDef.id;\n    };\n    SideBarButtonComp.prototype.postConstruct = function () {\n        var template = this.createTemplate();\n        this.setTemplate(template);\n        this.eIconWrapper.insertAdjacentElement('afterbegin', agGridCommunity._.createIconNoSpan(this.toolPanelDef.iconKey, this.gridOptionsWrapper));\n        this.addManagedListener(this.eToggleButton, 'click', this.onButtonPressed.bind(this));\n    };\n    SideBarButtonComp.prototype.createTemplate = function () {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        var def = this.toolPanelDef;\n        var label = translate(def.labelKey, def.labelDefault);\n        var res = \"<div class=\\\"ag-side-button\\\">\\n                <button type=\\\"button\\\" ref=\\\"eToggleButton\\\" class=\\\"ag-side-button-button\\\">\\n                    <div ref=\\\"eIconWrapper\\\" class=\\\"ag-side-button-icon-wrapper\\\"></div>\\n                    <span class=\\\"ag-side-button-label\\\">\" + label + \"</span>\\n                </button>\\n            </div>\";\n        return res;\n    };\n    SideBarButtonComp.prototype.onButtonPressed = function () {\n        this.dispatchEvent({ type: SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED });\n    };\n    SideBarButtonComp.prototype.setSelected = function (selected) {\n        this.addOrRemoveCssClass('ag-selected', selected);\n    };\n    SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED = 'toggleButtonClicked';\n    __decorate$l([\n        agGridCommunity.RefSelector('eToggleButton')\n    ], SideBarButtonComp.prototype, \"eToggleButton\", void 0);\n    __decorate$l([\n        agGridCommunity.RefSelector('eIconWrapper')\n    ], SideBarButtonComp.prototype, \"eIconWrapper\", void 0);\n    __decorate$l([\n        agGridCommunity.PostConstruct\n    ], SideBarButtonComp.prototype, \"postConstruct\", null);\n    return SideBarButtonComp;\n}(agGridCommunity.Component));\n\nvar __extends$n = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelWrapper = /** @class */ (function (_super) {\n    __extends$n(ToolPanelWrapper, _super);\n    function ToolPanelWrapper() {\n        return _super.call(this, ToolPanelWrapper.TEMPLATE) || this;\n    }\n    ToolPanelWrapper.prototype.getToolPanelId = function () {\n        return this.toolPanelId;\n    };\n    ToolPanelWrapper.prototype.setToolPanelDef = function (toolPanelDef) {\n        this.toolPanelId = toolPanelDef.id;\n        var params = {\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        var componentPromise = this.userComponentFactory.newToolPanelComponent(toolPanelDef, params);\n        if (componentPromise == null) {\n            console.warn(\"ag-grid: error processing tool panel component \" + toolPanelDef.id + \". You need to specify either 'toolPanel' or 'toolPanelFramework'\");\n            return;\n        }\n        componentPromise.then(this.setToolPanelComponent.bind(this));\n    };\n    ToolPanelWrapper.prototype.setupResize = function () {\n        var resizeBar = this.resizeBar = new HorizontalResizeComp();\n        this.getContext().createBean(resizeBar);\n        resizeBar.setElementToResize(this.getGui());\n        this.appendChild(resizeBar);\n    };\n    ToolPanelWrapper.prototype.setToolPanelComponent = function (compInstance) {\n        var _this = this;\n        this.toolPanelCompInstance = compInstance;\n        this.appendChild(compInstance.getGui());\n        this.addDestroyFunc(function () {\n            _this.destroyBean(compInstance);\n        });\n    };\n    ToolPanelWrapper.prototype.getToolPanelInstance = function () {\n        return this.toolPanelCompInstance;\n    };\n    ToolPanelWrapper.prototype.setResizerSizerSide = function (side) {\n        var isRtl = this.gridOptionsWrapper.isEnableRtl();\n        var isLeft = side === 'left';\n        var inverted = isRtl ? isLeft : !isLeft;\n        this.resizeBar.setInverted(inverted);\n    };\n    ToolPanelWrapper.prototype.refresh = function () {\n        this.toolPanelCompInstance.refresh();\n    };\n    ToolPanelWrapper.TEMPLATE = \"<div class=\\\"ag-tool-panel-wrapper\\\"/>\";\n    __decorate$m([\n        agGridCommunity.Autowired(\"userComponentFactory\")\n    ], ToolPanelWrapper.prototype, \"userComponentFactory\", void 0);\n    __decorate$m([\n        agGridCommunity.PostConstruct\n    ], ToolPanelWrapper.prototype, \"setupResize\", null);\n    return ToolPanelWrapper;\n}(agGridCommunity.Component));\n\nvar __extends$o = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SideBarComp = /** @class */ (function (_super) {\n    __extends$o(SideBarComp, _super);\n    function SideBarComp() {\n        var _this = _super.call(this, SideBarComp.TEMPLATE) || this;\n        _this.toolPanelWrappers = [];\n        return _this;\n    }\n    SideBarComp.prototype.postConstruct = function () {\n        this.sideBarButtonsComp.addEventListener(SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED, this.onToolPanelButtonClicked.bind(this));\n        this.setSideBarDef();\n    };\n    SideBarComp.prototype.onToolPanelButtonClicked = function (event) {\n        var id = event.toolPanelId;\n        var openedItem = this.openedItem();\n        // if item was already open, we close it\n        if (openedItem === id) {\n            this.openToolPanel(undefined); // passing undefined closes\n        }\n        else {\n            this.openToolPanel(id);\n        }\n    };\n    SideBarComp.prototype.clearDownUi = function () {\n        this.sideBarButtonsComp.clearButtons();\n        this.destroyToolPanelWrappers();\n    };\n    SideBarComp.prototype.setSideBarDef = function () {\n        // initially hide side bar\n        this.setDisplayed(false);\n        var sideBar = this.gridOptionsWrapper.getSideBar();\n        var sideBarExists = !!sideBar && !!sideBar.toolPanels;\n        if (!sideBarExists) {\n            return;\n        }\n        var shouldDisplaySideBar = sideBarExists && !sideBar.hiddenByDefault;\n        this.setDisplayed(shouldDisplaySideBar);\n        var toolPanelDefs = sideBar.toolPanels;\n        this.sideBarButtonsComp.setToolPanelDefs(toolPanelDefs);\n        this.setupToolPanels(toolPanelDefs);\n        this.setSideBarPosition(sideBar.position);\n        if (!sideBar.hiddenByDefault) {\n            this.openToolPanel(sideBar.defaultToolPanel);\n        }\n    };\n    SideBarComp.prototype.setSideBarPosition = function (position) {\n        if (!position) {\n            position = 'right';\n        }\n        var isLeft = position === 'left';\n        var resizerSide = isLeft ? 'right' : 'left';\n        var eGui = this.getGui();\n        agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-side-bar-left', isLeft);\n        agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-side-bar-right', !isLeft);\n        this.toolPanelWrappers.forEach(function (wrapper) {\n            wrapper.setResizerSizerSide(resizerSide);\n        });\n        return this;\n    };\n    SideBarComp.prototype.setupToolPanels = function (defs) {\n        var _this = this;\n        defs.forEach(function (def) {\n            if (def.id == null) {\n                console.warn(\"ag-grid: please review all your toolPanel components, it seems like at least one of them doesn't have an id\");\n                return;\n            }\n            // helpers, in case user doesn't have the right module loaded\n            if (def.toolPanel === 'agColumnsToolPanel') {\n                var moduleMissing = !agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.ColumnToolPanelModule, 'Column Tool Panel');\n                if (moduleMissing) {\n                    return;\n                }\n            }\n            if (def.toolPanel === 'agFiltersToolPanel') {\n                var moduleMissing = !agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.FiltersToolPanelModule, 'Filters Tool Panel');\n                if (moduleMissing) {\n                    return;\n                }\n            }\n            var wrapper = new ToolPanelWrapper();\n            _this.getContext().createBean(wrapper);\n            wrapper.setToolPanelDef(def);\n            wrapper.setDisplayed(false);\n            _this.getGui().appendChild(wrapper.getGui());\n            _this.toolPanelWrappers.push(wrapper);\n        });\n    };\n    SideBarComp.prototype.refresh = function () {\n        this.toolPanelWrappers.forEach(function (wrapper) { return wrapper.refresh(); });\n    };\n    SideBarComp.prototype.openToolPanel = function (key) {\n        var currentlyOpenedKey = this.openedItem();\n        if (currentlyOpenedKey === key) {\n            return;\n        }\n        this.toolPanelWrappers.forEach(function (wrapper) {\n            var show = key === wrapper.getToolPanelId();\n            wrapper.setDisplayed(show);\n        });\n        var newlyOpenedKey = this.openedItem();\n        var openToolPanelChanged = currentlyOpenedKey !== newlyOpenedKey;\n        if (openToolPanelChanged) {\n            this.sideBarButtonsComp.setActiveButton(key);\n            this.raiseToolPanelVisibleEvent(key);\n        }\n    };\n    SideBarComp.prototype.getToolPanelInstance = function (key) {\n        var toolPanelWrapper = this.toolPanelWrappers.filter(function (toolPanel) { return toolPanel.getToolPanelId() === key; })[0];\n        if (!toolPanelWrapper) {\n            console.warn(\"ag-grid: unable to lookup Tool Panel as invalid key supplied: \" + key);\n            return;\n        }\n        return toolPanelWrapper.getToolPanelInstance();\n    };\n    SideBarComp.prototype.raiseToolPanelVisibleEvent = function (key) {\n        var event = {\n            type: agGridCommunity.Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED,\n            source: key,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi()\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    SideBarComp.prototype.close = function () {\n        this.openToolPanel(undefined);\n    };\n    SideBarComp.prototype.isToolPanelShowing = function () {\n        return !!this.openedItem();\n    };\n    SideBarComp.prototype.openedItem = function () {\n        var activeToolPanel = null;\n        this.toolPanelWrappers.forEach(function (wrapper) {\n            if (wrapper.isDisplayed()) {\n                activeToolPanel = wrapper.getToolPanelId();\n            }\n        });\n        return activeToolPanel;\n    };\n    // get called after user sets new sideBarDef via the API\n    SideBarComp.prototype.reset = function () {\n        this.clearDownUi();\n        this.setSideBarDef();\n    };\n    SideBarComp.prototype.destroyToolPanelWrappers = function () {\n        var _this = this;\n        this.toolPanelWrappers.forEach(function (wrapper) {\n            agGridCommunity._.removeFromParent(wrapper.getGui());\n            _this.destroyBean(wrapper);\n        });\n        this.toolPanelWrappers.length = 0;\n    };\n    SideBarComp.prototype.destroy = function () {\n        this.destroyToolPanelWrappers();\n        _super.prototype.destroy.call(this);\n    };\n    SideBarComp.TEMPLATE = \"<div class=\\\"ag-side-bar ag-unselectable\\\">\\n            <ag-side-bar-buttons ref=\\\"sideBarButtons\\\"></ag-side-bar-buttons>\\n        </div>\";\n    __decorate$n([\n        agGridCommunity.RefSelector('sideBarButtons')\n    ], SideBarComp.prototype, \"sideBarButtonsComp\", void 0);\n    __decorate$n([\n        agGridCommunity.PostConstruct\n    ], SideBarComp.prototype, \"postConstruct\", null);\n    return SideBarComp;\n}(agGridCommunity.Component));\n\nvar __extends$p = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelColDefService = /** @class */ (function (_super) {\n    __extends$p(ToolPanelColDefService, _super);\n    function ToolPanelColDefService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isColGroupDef = function (colDef) { return colDef && typeof colDef.children !== 'undefined'; };\n        _this.getId = function (colDef) {\n            return _this.isColGroupDef(colDef) ? colDef.groupId : colDef.colId;\n        };\n        return _this;\n    }\n    ToolPanelColDefService.prototype.createColumnTree = function (colDefs) {\n        var _this = this;\n        var invalidColIds = [];\n        var createDummyColGroup = function (abstractColDef, depth) {\n            if (_this.isColGroupDef(abstractColDef)) {\n                // creating 'dummy' group which is not associated with grid column group\n                var groupDef = abstractColDef;\n                var groupId = (typeof groupDef.groupId !== 'undefined') ? groupDef.groupId : groupDef.headerName;\n                var group = new agGridCommunity.OriginalColumnGroup(groupDef, groupId, false, depth);\n                var children_1 = [];\n                groupDef.children.forEach(function (def) {\n                    var child = createDummyColGroup(def, depth + 1);\n                    // check column exists in case invalid colDef is supplied for primary column\n                    if (child) {\n                        children_1.push(child);\n                    }\n                });\n                group.setChildren(children_1);\n                return group;\n            }\n            else {\n                var colDef = abstractColDef;\n                var key = colDef.colId ? colDef.colId : colDef.field;\n                var column = _this.columnController.getPrimaryColumn(key);\n                if (!column) {\n                    invalidColIds.push(colDef);\n                }\n                return column;\n            }\n        };\n        var mappedResults = [];\n        colDefs.forEach(function (colDef) {\n            var result = createDummyColGroup(colDef, 0);\n            if (result) {\n                // only return correctly mapped colDef results\n                mappedResults.push(result);\n            }\n        });\n        if (invalidColIds.length > 0) {\n            console.warn('AG Grid: unable to find grid columns for the supplied colDef(s):', invalidColIds);\n        }\n        return mappedResults;\n    };\n    ToolPanelColDefService.prototype.syncLayoutWithGrid = function (syncLayoutCallback) {\n        // extract ordered list of leaf path trees (column group hierarchy for each individual leaf column)\n        var leafPathTrees = this.getLeafPathTrees();\n        // merge leaf path tree taking split column groups into account\n        var mergedColumnTrees = this.mergeLeafPathTrees(leafPathTrees);\n        // sync layout with merged column trees\n        syncLayoutCallback(mergedColumnTrees);\n    };\n    ToolPanelColDefService.prototype.getLeafPathTrees = function () {\n        // leaf tree paths are obtained by walking up the tree starting at a column until we reach the top level group.\n        var getLeafPathTree = function (node, childDef) {\n            var leafPathTree;\n            // build up tree in reverse order\n            if (node instanceof agGridCommunity.OriginalColumnGroup) {\n                if (node.isPadding()) {\n                    // skip over padding groups\n                    leafPathTree = childDef;\n                }\n                else {\n                    var groupDef = agGridCommunity._.assign({}, node.getColGroupDef());\n                    // ensure group contains groupId\n                    groupDef.groupId = node.getGroupId();\n                    groupDef.children = [childDef];\n                    leafPathTree = groupDef;\n                }\n            }\n            else {\n                var colDef = agGridCommunity._.assign({}, node.getColDef());\n                // ensure col contains colId\n                colDef.colId = node.getColId();\n                leafPathTree = colDef;\n            }\n            // walk tree\n            var parent = node.getOriginalParent();\n            if (parent) {\n                // keep walking up the tree until we reach the root\n                return getLeafPathTree(parent, leafPathTree);\n            }\n            else {\n                // we have reached the root - exit with resulting leaf path tree\n                return leafPathTree;\n            }\n        };\n        // obtain a sorted list of all grid columns\n        var allGridColumns = this.columnController.getAllGridColumns();\n        // only primary columns and non row group columns should appear in the tool panel\n        var allPrimaryGridColumns = allGridColumns.filter(function (column) {\n            var colDef = column.getColDef();\n            return column.isPrimary() && !colDef.showRowGroup;\n        });\n        // construct a leaf path tree for each column\n        return allPrimaryGridColumns.map(function (col) { return getLeafPathTree(col, col.getColDef()); });\n    };\n    ToolPanelColDefService.prototype.mergeLeafPathTrees = function (leafPathTrees) {\n        var _this = this;\n        var matchingRootGroupIds = function (pathA, pathB) {\n            var bothPathsAreGroups = _this.isColGroupDef(pathA) && _this.isColGroupDef(pathB);\n            return bothPathsAreGroups && _this.getId(pathA) === _this.getId(pathB);\n        };\n        var mergeTrees = function (treeA, treeB) {\n            if (!_this.isColGroupDef(treeB)) {\n                return treeA;\n            }\n            var mergeResult = treeA;\n            var groupToMerge = treeB;\n            if (groupToMerge.children && groupToMerge.groupId) {\n                var added = _this.addChildrenToGroup(mergeResult, groupToMerge.groupId, groupToMerge.children[0]);\n                if (added) {\n                    return mergeResult;\n                }\n            }\n            groupToMerge.children.forEach(function (child) { return mergeTrees(mergeResult, child); });\n            return mergeResult;\n        };\n        // we can't just merge the leaf path trees as groups can be split apart - instead only merge if leaf\n        // path groups with the same root group id are contiguous.\n        var mergeColDefs = [];\n        for (var i = 1; i <= leafPathTrees.length; i++) {\n            var first = leafPathTrees[i - 1];\n            var second = leafPathTrees[i];\n            if (matchingRootGroupIds(first, second)) {\n                leafPathTrees[i] = mergeTrees(first, second);\n            }\n            else {\n                mergeColDefs.push(first);\n            }\n        }\n        return mergeColDefs;\n    };\n    ToolPanelColDefService.prototype.addChildrenToGroup = function (tree, groupId, colDef) {\n        var _this = this;\n        var subGroupIsSplit = function (currentSubGroup, currentSubGroupToAdd) {\n            var existingChildIds = currentSubGroup.children.map(_this.getId);\n            var childGroupAlreadyExists = agGridCommunity._.includes(existingChildIds, _this.getId(currentSubGroupToAdd));\n            var lastChild = agGridCommunity._.last(currentSubGroup.children);\n            var lastChildIsDifferent = lastChild && _this.getId(lastChild) !== _this.getId(currentSubGroupToAdd);\n            return childGroupAlreadyExists && lastChildIsDifferent;\n        };\n        if (!this.isColGroupDef(tree)) {\n            return true;\n        }\n        var currentGroup = tree;\n        var groupToAdd = colDef;\n        if (subGroupIsSplit(currentGroup, groupToAdd)) {\n            currentGroup.children.push(groupToAdd);\n            return true;\n        }\n        if (currentGroup.groupId === groupId) {\n            // add children that don't already exist to group\n            var existingChildIds = currentGroup.children.map(this.getId);\n            var colDefAlreadyPresent = agGridCommunity._.includes(existingChildIds, this.getId(groupToAdd));\n            if (!colDefAlreadyPresent) {\n                currentGroup.children.push(groupToAdd);\n                return true;\n            }\n        }\n        // recurse until correct group is found to add children\n        currentGroup.children.forEach(function (subGroup) { return _this.addChildrenToGroup(subGroup, groupId, colDef); });\n        return false;\n    };\n    __decorate$o([\n        agGridCommunity.Autowired('columnController')\n    ], ToolPanelColDefService.prototype, \"columnController\", void 0);\n    ToolPanelColDefService = __decorate$o([\n        agGridCommunity.Bean('toolPanelColDefService')\n    ], ToolPanelColDefService);\n    return ToolPanelColDefService;\n}(agGridCommunity.BeanStub));\n\nvar SideBarModule = {\n    moduleName: agGridCommunity.ModuleNames.SideBarModule,\n    beans: [ToolPanelColDefService],\n    agStackComponents: [\n        { componentName: 'AgHorizontalResize', componentClass: HorizontalResizeComp },\n        { componentName: 'AgSideBar', componentClass: SideBarComp },\n        { componentName: 'AgSideBarButtons', componentClass: SideBarButtonsComp },\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ModelItemUtils = /** @class */ (function () {\n    function ModelItemUtils() {\n    }\n    ModelItemUtils.prototype.selectAllChildren = function (colTree, selectAllChecked, eventType) {\n        var cols = this.extractAllLeafColumns(colTree);\n        this.setAllColumns(cols, selectAllChecked, eventType);\n    };\n    ModelItemUtils.prototype.setColumn = function (col, selectAllChecked, eventType) {\n        this.setAllColumns([col], selectAllChecked, eventType);\n    };\n    ModelItemUtils.prototype.setAllColumns = function (cols, selectAllChecked, eventType) {\n        if (this.columnController.isPivotMode()) {\n            this.setAllPivot(cols, selectAllChecked, eventType);\n        }\n        else {\n            this.setAllVisible(cols, selectAllChecked, eventType);\n        }\n    };\n    ModelItemUtils.prototype.extractAllLeafColumns = function (allItems) {\n        var res = [];\n        var recursiveFunc = function (items) {\n            items.forEach(function (item) {\n                if (!item.isPassesFilter()) {\n                    return;\n                }\n                if (item.isGroup()) {\n                    recursiveFunc(item.getChildren());\n                }\n                else {\n                    res.push(item.getColumn());\n                }\n            });\n        };\n        recursiveFunc(allItems);\n        return res;\n    };\n    ModelItemUtils.prototype.setAllVisible = function (columns, visible, eventType) {\n        var colStateItems = [];\n        columns.forEach(function (col) {\n            if (col.getColDef().lockVisible) {\n                return;\n            }\n            if (col.isVisible() != visible) {\n                colStateItems.push({\n                    colId: col.getId(),\n                    hide: !visible\n                });\n            }\n        });\n        if (colStateItems.length > 0) {\n            this.columnController.applyColumnState({ state: colStateItems }, eventType);\n        }\n    };\n    ModelItemUtils.prototype.setAllPivot = function (columns, value, eventType) {\n        if (this.gridOptionsWrapper.isFunctionsPassive()) {\n            this.setAllPivotPassive(columns, value);\n        }\n        else {\n            this.setAllPivotActive(columns, value, eventType);\n        }\n    };\n    ModelItemUtils.prototype.setAllPivotPassive = function (columns, value) {\n        var copyOfPivotColumns = this.columnController.getPivotColumns().slice();\n        var copyOfValueColumns = this.columnController.getValueColumns().slice();\n        var copyOfRowGroupColumns = this.columnController.getRowGroupColumns().slice();\n        var pivotChanged = false;\n        var valueChanged = false;\n        var rowGroupChanged = false;\n        var turnOnAction = function (col) {\n            // don't change any column that's already got a function active\n            if (col.isAnyFunctionActive()) {\n                return;\n            }\n            if (col.isAllowValue()) {\n                copyOfValueColumns.push(col);\n                valueChanged = true;\n            }\n            else if (col.isAllowRowGroup()) {\n                copyOfRowGroupColumns.push(col);\n                pivotChanged = true;\n            }\n            else if (col.isAllowPivot()) {\n                copyOfPivotColumns.push(col);\n                rowGroupChanged = true;\n            }\n        };\n        var turnOffAction = function (col) {\n            if (!col.isAnyFunctionActive()) {\n                return;\n            }\n            if (copyOfPivotColumns.indexOf(col) >= 0) {\n                agGridCommunity._.removeFromArray(copyOfPivotColumns, col);\n                pivotChanged = true;\n            }\n            if (copyOfValueColumns.indexOf(col) >= 0) {\n                agGridCommunity._.removeFromArray(copyOfValueColumns, col);\n                valueChanged = true;\n            }\n            if (copyOfRowGroupColumns.indexOf(col) >= 0) {\n                agGridCommunity._.removeFromArray(copyOfRowGroupColumns, col);\n                rowGroupChanged = true;\n            }\n        };\n        var action = value ? turnOnAction : turnOffAction;\n        columns.forEach(action);\n        if (pivotChanged) {\n            var event_1 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,\n                columns: copyOfPivotColumns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        if (rowGroupChanged) {\n            var event_2 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,\n                columns: copyOfRowGroupColumns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_2);\n        }\n        if (valueChanged) {\n            var event_3 = {\n                type: agGridCommunity.Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,\n                columns: copyOfRowGroupColumns,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_3);\n        }\n    };\n    ModelItemUtils.prototype.setAllPivotActive = function (columns, value, eventType) {\n        var _this = this;\n        var colStateItems = [];\n        var turnOnAction = function (col) {\n            // don't change any column that's already got a function active\n            if (col.isAnyFunctionActive()) {\n                return;\n            }\n            if (col.isAllowValue()) {\n                var aggFunc = typeof col.getAggFunc() === 'string'\n                    ? col.getAggFunc()\n                    : _this.aggFuncService.getDefaultAggFunc(col);\n                colStateItems.push({\n                    colId: col.getId(),\n                    aggFunc: aggFunc\n                });\n            }\n            else if (col.isAllowRowGroup()) {\n                colStateItems.push({\n                    colId: col.getId(),\n                    rowGroup: true\n                });\n            }\n            else if (col.isAllowPivot()) {\n                colStateItems.push({\n                    colId: col.getId(),\n                    pivot: true\n                });\n            }\n        };\n        var turnOffAction = function (col) {\n            var isActive = col.isPivotActive() || col.isRowGroupActive() || col.isValueActive();\n            if (isActive) {\n                colStateItems.push({\n                    colId: col.getId(),\n                    pivot: false,\n                    rowGroup: false,\n                    aggFunc: null\n                });\n            }\n        };\n        var action = value ? turnOnAction : turnOffAction;\n        columns.forEach(action);\n        if (colStateItems.length > 0) {\n            this.columnController.applyColumnState({ state: colStateItems }, eventType);\n        }\n    };\n    __decorate$p([\n        agGridCommunity.Autowired('aggFuncService')\n    ], ModelItemUtils.prototype, \"aggFuncService\", void 0);\n    __decorate$p([\n        agGridCommunity.Autowired('columnController')\n    ], ModelItemUtils.prototype, \"columnController\", void 0);\n    __decorate$p([\n        agGridCommunity.Autowired('gridOptionsWrapper')\n    ], ModelItemUtils.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate$p([\n        agGridCommunity.Autowired('columnApi')\n    ], ModelItemUtils.prototype, \"columnApi\", void 0);\n    __decorate$p([\n        agGridCommunity.Autowired('gridApi')\n    ], ModelItemUtils.prototype, \"gridApi\", void 0);\n    __decorate$p([\n        agGridCommunity.Autowired('eventService')\n    ], ModelItemUtils.prototype, \"eventService\", void 0);\n    ModelItemUtils = __decorate$p([\n        agGridCommunity.Bean('modelItemUtils')\n    ], ModelItemUtils);\n    return ModelItemUtils;\n}());\n\nvar ColumnsToolPanelModule = {\n    moduleName: agGridCommunity.ModuleNames.ColumnToolPanelModule,\n    beans: [ModelItemUtils],\n    agStackComponents: [\n        { componentName: 'AgPrimaryColsHeader', componentClass: PrimaryColsHeaderPanel },\n        { componentName: 'AgPrimaryColsList', componentClass: PrimaryColsListPanel },\n        { componentName: 'AgPrimaryCols', componentClass: PrimaryColsPanel }\n    ],\n    userComponents: [\n        { componentName: 'agColumnsToolPanel', componentClass: ColumnToolPanel },\n    ],\n    dependantModules: [\n        EnterpriseCoreModule,\n        RowGroupingModule,\n        SideBarModule\n    ]\n};\n\nvar coreFactory = {\n    getTemplate: function () {\n        var dt = new Date();\n        var jsonDate = dt.toJSON();\n        return {\n            name: 'cp:coreProperties',\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"xmlns:\",\n                        map: {\n                            cp: \"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\",\n                            dc: 'http://purl.org/dc/elements/1.1/',\n                            dcterms: 'http://purl.org/dc/terms/',\n                            dcmitype: 'http://purl.org/dc/dcmitype/',\n                            xsi: 'http://www.w3.org/2001/XMLSchema-instance'\n                        }\n                    }]\n            },\n            children: [{\n                    name: 'dc:creator',\n                    textNode: 'AG Grid'\n                }, {\n                    name: 'dc:title',\n                    textNode: 'Workbook'\n                }, {\n                    name: 'dcterms:created',\n                    properties: {\n                        rawMap: {\n                            'xsi:type': 'dcterms:W3CDTF'\n                        }\n                    },\n                    textNode: jsonDate\n                }, {\n                    name: 'dcterms:modified',\n                    properties: {\n                        rawMap: {\n                            'xsi:type': 'dcterms:W3CDTF'\n                        }\n                    },\n                    textNode: jsonDate\n                }]\n        };\n    }\n};\n\nvar contentTypeFactory = {\n    getTemplate: function (config) {\n        var name = config.name, ContentType = config.ContentType, Extension = config.Extension, PartName = config.PartName;\n        return {\n            name: name,\n            properties: {\n                rawMap: {\n                    Extension: Extension,\n                    PartName: PartName,\n                    ContentType: ContentType\n                }\n            }\n        };\n    }\n};\n\nvar contentTypesFactory = {\n    getTemplate: function () {\n        var children = [{\n                name: 'Default',\n                Extension: 'rels',\n                ContentType: 'application/vnd.openxmlformats-package.relationships+xml'\n            }, {\n                name: 'Default',\n                ContentType: 'application/xml',\n                Extension: 'xml'\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',\n                PartName: \"/xl/workbook.xml\"\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',\n                PartName: '/xl/worksheets/sheet1.xml'\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',\n                PartName: '/xl/theme/theme1.xml'\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',\n                PartName: '/xl/styles.xml'\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',\n                PartName: '/xl/sharedStrings.xml'\n            }, {\n                name: 'Override',\n                ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',\n                PartName: '/docProps/core.xml'\n            }].map(contentTypeFactory.getTemplate);\n        return {\n            name: \"Types\",\n            properties: {\n                rawMap: {\n                    xmlns: \"http://schemas.openxmlformats.org/package/2006/content-types\"\n                }\n            },\n            children: children\n        };\n    }\n};\n\nvar getColorChildren = function (props) {\n    var type = props[0], innerType = props[1], val = props[2], lastClr = props[3];\n    return {\n        name: \"a:\" + type,\n        children: [{\n                name: \"a:\" + innerType,\n                properties: {\n                    rawMap: {\n                        val: val,\n                        lastClr: lastClr\n                    }\n                }\n            }]\n    };\n};\nvar colorScheme = {\n    getTemplate: function () {\n        return {\n            name: \"a:clrScheme\",\n            properties: {\n                rawMap: {\n                    name: \"Office\"\n                }\n            },\n            children: [\n                getColorChildren(['dk1', 'sysClr', 'windowText', '000000']),\n                getColorChildren(['lt1', 'sysClr', 'window', 'FFFFFF']),\n                getColorChildren(['dk2', 'srgbClr', '44546A']),\n                getColorChildren(['lt2', 'srgbClr', 'E7E6E6']),\n                getColorChildren(['accent1', 'srgbClr', '4472C4']),\n                getColorChildren(['accent2', 'srgbClr', 'ED7D31']),\n                getColorChildren(['accent3', 'srgbClr', 'A5A5A5']),\n                getColorChildren(['accent4', 'srgbClr', 'FFC000']),\n                getColorChildren(['accent5', 'srgbClr', '5B9BD5']),\n                getColorChildren(['accent6', 'srgbClr', '70AD47']),\n                getColorChildren(['hlink', 'srgbClr', '0563C1']),\n                getColorChildren(['folHlink', 'srgbClr', '954F72'])\n            ]\n        };\n    }\n};\n\nvar getFont = function (props) {\n    var type = props[0], typeface = props[1], script = props[2], panose = props[3];\n    return {\n        name: \"a:\" + type,\n        properties: {\n            rawMap: {\n                script: script,\n                typeface: typeface,\n                panose: panose\n            }\n        }\n    };\n};\nvar fontScheme = {\n    getTemplate: function () {\n        var utf8_encode = agGridCommunity._.utf8_encode;\n        return {\n            name: \"a:fontScheme\",\n            properties: {\n                rawMap: {\n                    name: \"Office\"\n                }\n            },\n            children: [{\n                    name: 'a:majorFont',\n                    children: [\n                        getFont(['latin', 'Calibri Light', undefined, '020F0302020204030204']),\n                        getFont(['ea', '']),\n                        getFont(['cs', '']),\n                        getFont(['font', utf8_encode(' Light'), 'Jpan']),\n                        getFont(['font', utf8_encode(' '), 'Hang']),\n                        getFont(['font', utf8_encode(' Light'), 'Hans']),\n                        getFont(['font', utf8_encode(''), 'Hant']),\n                        getFont(['font', 'Times New Roman', 'Arab']),\n                        getFont(['font', 'Times New Roman', 'Hebr']),\n                        getFont(['font', 'Tahoma', 'Thai']),\n                        getFont(['font', 'Nyala', 'Ethi']),\n                        getFont(['font', 'Vrinda', 'Beng']),\n                        getFont(['font', 'Shruti', 'Gujr']),\n                        getFont(['font', 'MoolBoran', 'Khmr']),\n                        getFont(['font', 'Tunga', 'Knda']),\n                        getFont(['font', 'Raavi', 'Guru']),\n                        getFont(['font', 'Euphemia', 'Cans']),\n                        getFont(['font', 'Plantagenet Cherokee', 'Cher']),\n                        getFont(['font', 'Microsoft Yi Baiti', 'Yiii']),\n                        getFont(['font', 'Microsoft Himalaya', 'Tibt']),\n                        getFont(['font', 'MV Boli', 'Thaa']),\n                        getFont(['font', 'Mangal', 'Deva']),\n                        getFont(['font', 'Gautami', 'Telu']),\n                        getFont(['font', 'Latha', 'Taml']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrc']),\n                        getFont(['font', 'Kalinga', 'Orya']),\n                        getFont(['font', 'Kartika', 'Mlym']),\n                        getFont(['font', 'DokChampa', 'Laoo']),\n                        getFont(['font', 'Iskoola Pota', 'Sinh']),\n                        getFont(['font', 'Mongolian Baiti', 'Mong']),\n                        getFont(['font', 'Times New Roman', 'Viet']),\n                        getFont(['font', 'Microsoft Uighur', 'Uigh']),\n                        getFont(['font', 'Sylfaen', 'Geor']),\n                        getFont(['font', 'Arial', 'Armn']),\n                        getFont(['font', 'Leelawadee UI', 'Bugi']),\n                        getFont(['font', 'Microsoft JhengHei', 'Bopo']),\n                        getFont(['font', 'Javanese Text', 'Java']),\n                        getFont(['font', 'Segoe UI', 'Lisu']),\n                        getFont(['font', 'Myanmar Text', 'Mymr']),\n                        getFont(['font', 'Ebrima', 'Nkoo']),\n                        getFont(['font', 'Nirmala UI', 'Olck']),\n                        getFont(['font', 'Ebrima', 'Osma']),\n                        getFont(['font', 'Phagspa', 'Phag']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrn']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrj']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syre']),\n                        getFont(['font', 'Nirmala UI', 'Sora']),\n                        getFont(['font', 'Microsoft Tai Le', 'Tale']),\n                        getFont(['font', 'Microsoft New Tai Lue', 'Talu']),\n                        getFont(['font', 'Ebrima', 'Tfng'])\n                    ]\n                }, {\n                    name: 'a:minorFont',\n                    children: [\n                        getFont(['latin', 'Calibri', undefined, '020F0502020204030204']),\n                        getFont(['ea', '']),\n                        getFont(['cs', '']),\n                        getFont(['font', utf8_encode(''), 'Jpan']),\n                        getFont(['font', utf8_encode(' '), 'Hang']),\n                        getFont(['font', utf8_encode(''), 'Hans']),\n                        getFont(['font', utf8_encode(''), 'Hant']),\n                        getFont(['font', 'Arial', 'Arab']),\n                        getFont(['font', 'Arial', 'Hebr']),\n                        getFont(['font', 'Tahoma', 'Thai']),\n                        getFont(['font', 'Nyala', 'Ethi']),\n                        getFont(['font', 'Vrinda', 'Beng']),\n                        getFont(['font', 'Shruti', 'Gujr']),\n                        getFont(['font', 'DaunPenh', 'Khmr']),\n                        getFont(['font', 'Tunga', 'Knda']),\n                        getFont(['font', 'Raavi', 'Guru']),\n                        getFont(['font', 'Euphemia', 'Cans']),\n                        getFont(['font', 'Plantagenet Cherokee', 'Cher']),\n                        getFont(['font', 'Microsoft Yi Baiti', 'Yiii']),\n                        getFont(['font', 'Microsoft Himalaya', 'Tibt']),\n                        getFont(['font', 'MV Boli', 'Thaa']),\n                        getFont(['font', 'Mangal', 'Deva']),\n                        getFont(['font', 'Gautami', 'Telu']),\n                        getFont(['font', 'Latha', 'Taml']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrc']),\n                        getFont(['font', 'Kalinga', 'Orya']),\n                        getFont(['font', 'Kartika', 'Mlym']),\n                        getFont(['font', 'DokChampa', 'Laoo']),\n                        getFont(['font', 'Iskoola Pota', 'Sinh']),\n                        getFont(['font', 'Mongolian Baiti', 'Mong']),\n                        getFont(['font', 'Arial', 'Viet']),\n                        getFont(['font', 'Microsoft Uighur', 'Uigh']),\n                        getFont(['font', 'Sylfaen', 'Geor']),\n                        getFont(['font', 'Arial', 'Armn']),\n                        getFont(['font', 'Leelawadee UI', 'Bugi']),\n                        getFont(['font', 'Microsoft JhengHei', 'Bopo']),\n                        getFont(['font', 'Javanese Text', 'Java']),\n                        getFont(['font', 'Segoe UI', 'Lisu']),\n                        getFont(['font', 'Myanmar Text', 'Mymr']),\n                        getFont(['font', 'Ebrima', 'Nkoo']),\n                        getFont(['font', 'Nirmala UI', 'Olck']),\n                        getFont(['font', 'Ebrima', 'Osma']),\n                        getFont(['font', 'Phagspa', 'Phag']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrn']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syrj']),\n                        getFont(['font', 'Estrangelo Edessa', 'Syre']),\n                        getFont(['font', 'Nirmala UI', 'Sora']),\n                        getFont(['font', 'Microsoft Tai Le', 'Tale']),\n                        getFont(['font', 'Microsoft New Tai Lue', 'Talu']),\n                        getFont(['font', 'Ebrima', 'Tfng'])\n                    ]\n                }]\n        };\n    }\n};\n\nvar getPropertyVal = function (name, val, children) { return ({\n    name: \"a:\" + name,\n    properties: {\n        rawMap: {\n            val: val\n        }\n    },\n    children: children\n}); };\nvar getGs = function (props) {\n    var pos = props[0], schemeColor = props[1], satMod = props[2], lumMod = props[3], tint = props[4], shade = props[5];\n    var children = [];\n    children.push(getPropertyVal('satMod', satMod));\n    if (lumMod) {\n        children.push(getPropertyVal('lumMod', lumMod));\n    }\n    if (tint) {\n        children.push(getPropertyVal('tint', tint));\n    }\n    if (shade) {\n        children.push(getPropertyVal('shade', shade));\n    }\n    return {\n        name: 'a:gs',\n        properties: {\n            rawMap: {\n                pos: pos\n            }\n        },\n        children: [{\n                name: 'a:schemeClr',\n                properties: {\n                    rawMap: {\n                        val: schemeColor\n                    }\n                },\n                children: children\n            }]\n    };\n};\nvar getSolidFill = function (val, children) { return ({\n    name: 'a:solidFill',\n    children: [getPropertyVal('schemeClr', val, children)]\n}); };\nvar getGradFill = function (props) {\n    var rotWithShape = props[0], gs1 = props[1], gs2 = props[2], gs3 = props[3], lin = props[4];\n    var ang = lin[0], scaled = lin[1];\n    return {\n        name: 'a:gradFill',\n        properties: {\n            rawMap: {\n                rotWithShape: rotWithShape\n            }\n        },\n        children: [{\n                name: 'a:gsLst',\n                children: [\n                    getGs(gs1),\n                    getGs(gs2),\n                    getGs(gs3)\n                ]\n            }, {\n                name: 'a:lin',\n                properties: {\n                    rawMap: {\n                        ang: ang,\n                        scaled: scaled\n                    }\n                }\n            }]\n    };\n};\nvar getLine = function (props) {\n    var w = props[0], cap = props[1], cmpd = props[2], algn = props[3];\n    return {\n        name: 'a:ln',\n        properties: {\n            rawMap: { w: w, cap: cap, cmpd: cmpd, algn: algn }\n        },\n        children: [\n            getSolidFill('phClr'),\n            getPropertyVal('prstDash', 'solid'),\n            {\n                name: 'a:miter',\n                properties: {\n                    rawMap: {\n                        lim: '800000'\n                    }\n                }\n            }\n        ]\n    };\n};\nvar getEffectStyle = function (shadow) {\n    var children = [];\n    if (shadow) {\n        var blurRad = shadow[0], dist = shadow[1], dir = shadow[2], algn = shadow[3], rotWithShape = shadow[4];\n        children.push({\n            name: 'a:outerShdw',\n            properties: {\n                rawMap: { blurRad: blurRad, dist: dist, dir: dir, algn: algn, rotWithShape: rotWithShape }\n            },\n            children: [\n                getPropertyVal('srgbClr', '000000', [getPropertyVal('alpha', '63000')])\n            ]\n        });\n    }\n    return {\n        name: 'a:effectStyle',\n        children: [agGridCommunity._.assign({}, {\n                name: 'a:effectLst'\n            }, children.length ? { children: children } : {})]\n    };\n};\nvar getFillStyleList = function () { return ({\n    name: 'a:fillStyleLst',\n    children: [\n        getSolidFill('phClr'),\n        getGradFill([\n            '1',\n            ['0', 'phClr', '105000', '110000', '67000'],\n            ['50000', 'phClr', '103000', '105000', '73000'],\n            ['100000', 'phClr', '109000', '105000', '81000'],\n            ['5400000', '0']\n        ]),\n        getGradFill([\n            '1',\n            ['0', 'phClr', '103000', '102000', '94000'],\n            ['50000', 'phClr', '110000', '100000', undefined, '100000'],\n            ['100000', 'phClr', '120000', '99000', undefined, '78000'],\n            ['5400000', '0']\n        ])\n    ]\n}); };\nvar getLineStyleList = function () { return ({\n    name: 'a:lnStyleLst',\n    children: [\n        getLine(['6350', 'flat', 'sng', 'ctr']),\n        getLine(['12700', 'flat', 'sng', 'ctr']),\n        getLine(['19050', 'flat', 'sng', 'ctr'])\n    ]\n}); };\nvar getEffectStyleList = function () { return ({\n    name: 'a:effectStyleLst',\n    children: [\n        getEffectStyle(),\n        getEffectStyle(),\n        getEffectStyle(['57150', '19050', '5400000', 'ctr', '0'])\n    ]\n}); };\nvar getBgFillStyleList = function () { return ({\n    name: 'a:bgFillStyleLst',\n    children: [\n        getSolidFill('phClr'),\n        getSolidFill('phClr', [\n            getPropertyVal('tint', '95000'),\n            getPropertyVal('satMod', '170000'),\n        ]),\n        getGradFill([\n            '1',\n            ['0', 'phClr', '150000', '102000', '93000', '98000'],\n            ['50000', 'phClr', '130000', '103000', '98000', '90000'],\n            ['100000', 'phClr', '120000', undefined, undefined, '63000'],\n            ['5400000', '0']\n        ])\n    ]\n}); };\nvar formatScheme = {\n    getTemplate: function () {\n        return {\n            name: \"a:fmtScheme\",\n            properties: {\n                rawMap: {\n                    name: \"Office\"\n                }\n            },\n            children: [\n                getFillStyleList(),\n                getLineStyleList(),\n                getEffectStyleList(),\n                getBgFillStyleList()\n            ]\n        };\n    }\n};\n\nvar themeElements = {\n    getTemplate: function () {\n        return {\n            name: \"a:themeElements\",\n            children: [\n                colorScheme.getTemplate(),\n                fontScheme.getTemplate(),\n                formatScheme.getTemplate()\n            ]\n        };\n    }\n};\n\nvar officeTheme = {\n    getTemplate: function () {\n        return {\n            name: \"a:theme\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"xmlns:\",\n                        map: {\n                            a: \"http://schemas.openxmlformats.org/drawingml/2006/main\"\n                        },\n                    }],\n                rawMap: {\n                    name: \"Office Theme\"\n                }\n            },\n            children: [\n                themeElements.getTemplate(),\n                {\n                    name: 'a:objectDefaults'\n                },\n                {\n                    name: 'a:extraClrSchemeLst'\n                }\n            ]\n        };\n    }\n};\n\nvar buildSharedString = function (textNode) {\n    textNode = textNode.toString();\n    var child = {\n        name: 't',\n        textNode: agGridCommunity._.utf8_encode(agGridCommunity._.escapeString(textNode))\n    };\n    // if we have leading or trailing spaces, instruct Excel not to trim them\n    var preserveSpaces = textNode.replace(/^\\s*|\\s*$/g, '').length !== textNode.length;\n    if (preserveSpaces) {\n        child.properties = {\n            rawMap: {\n                \"xml:space\": \"preserve\"\n            }\n        };\n    }\n    return {\n        name: 'si',\n        children: [child]\n    };\n};\nvar sharedStrings = {\n    getTemplate: function (strings) {\n        return {\n            name: \"sst\",\n            properties: {\n                rawMap: {\n                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n                    count: strings.length,\n                    uniqueCount: strings.length\n                }\n            },\n            children: strings.map(buildSharedString)\n        };\n    }\n};\n\nvar numberFormatFactory = {\n    getTemplate: function (numberFormat) {\n        var formatCode = numberFormat.formatCode, numFmtId = numberFormat.numFmtId;\n        return {\n            name: \"numFmt\",\n            properties: {\n                rawMap: {\n                    formatCode: formatCode,\n                    numFmtId: numFmtId\n                }\n            }\n        };\n    }\n};\nvar numberFormatMap = {\n    '0': 1,\n    '0.00': 2,\n    '#,##0': 3,\n    '#,##0.00': 4,\n    '0%': 9,\n    '0.00%': 10,\n    '0.00E+00': 11,\n    '# ?/?': 12,\n    '# ??/??': 13,\n    'mm-dd-yy': 14,\n    'd-mmm-yy': 15,\n    'd-mmm': 16,\n    'mmm-yy': 17,\n    'h:mm AM/PM': 18,\n    'h:mm:ss AM/PM': 19,\n    'h:mm': 20,\n    'h:mm:ss': 21,\n    'm/d/yy h:mm': 22,\n    '#,##0 ;(#,##0)': 37,\n    '#,##0 ;[Red](#,##0)': 38,\n    '#,##0.00;(#,##0.00)': 39,\n    '#,##0.00;[Red](#,##0.00)': 40,\n    'mm:ss': 45,\n    '[h]:mm:ss': 46,\n    'mmss.0': 47,\n    '##0.0E+0': 48,\n    '@': 49\n};\n\nvar numberFormatsFactory = {\n    getTemplate: function (numberFormats) {\n        return {\n            name: \"numFmts\",\n            properties: {\n                rawMap: {\n                    count: numberFormats.length\n                }\n            },\n            children: numberFormats.map(numberFormatFactory.getTemplate)\n        };\n    }\n};\n\nvar fontFactory = {\n    getTemplate: function (font) {\n        var _a = font.size, size = _a === void 0 ? 14 : _a, colorTheme = font.colorTheme, _b = font.color, color = _b === void 0 ? '00000000' : _b, _c = font.name, name = _c === void 0 ? 'Calibri' : _c, family = font.family, scheme = font.scheme, italic = font.italic, bold = font.bold, strike = font.strike, outline = font.outline, shadow = font.shadow, underline = font.underline;\n        var children = [\n            { name: 'sz', properties: { rawMap: { val: size } } },\n            { name: 'color', properties: { rawMap: { theme: colorTheme, rgb: color } } },\n            { name: 'name', properties: { rawMap: { val: name } } }\n        ];\n        if (family) {\n            children.push({ name: 'family', properties: { rawMap: { val: family } } });\n        }\n        if (scheme) {\n            children.push({ name: 'scheme', properties: { rawMap: { val: scheme } } });\n        }\n        if (italic) {\n            children.push({ name: 'i' });\n        }\n        if (bold) {\n            children.push({ name: 'b' });\n        }\n        if (strike) {\n            children.push({ name: 'strike' });\n        }\n        if (outline) {\n            children.push({ name: 'outline' });\n        }\n        if (shadow) {\n            children.push({ name: 'shadow' });\n        }\n        if (underline) {\n            var lUnder = underline.toLocaleLowerCase();\n            children.push({ name: 'u', properties: { rawMap: { val: lUnder === 'double' ? 'double' : 'single' } } });\n        }\n        return {\n            name: \"font\",\n            children: children\n        };\n    }\n};\nvar getFamilyId = function (name) {\n    var families = ['Automatic', 'Roman', 'Swiss', 'Modern', 'Script', 'Decorative'];\n    var pos = families.indexOf(name || 'Automatic');\n    return Math.max(pos, 0);\n};\n\nvar fontsFactory = {\n    getTemplate: function (fonts) {\n        return {\n            name: \"fonts\",\n            properties: {\n                rawMap: {\n                    count: fonts.length\n                }\n            },\n            children: fonts.map(fontFactory.getTemplate)\n        };\n    }\n};\n\nvar fillFactory = {\n    getTemplate: function (fill) {\n        var patternType = fill.patternType, fgTheme = fill.fgTheme, fgTint = fill.fgTint, fgRgb = fill.fgRgb, bgRgb = fill.bgRgb, bgIndexed = fill.bgIndexed;\n        var pf = {\n            name: 'patternFill',\n            properties: {\n                rawMap: {\n                    patternType: patternType\n                }\n            }\n        };\n        if (fgTheme || fgTint || fgRgb) {\n            pf.children = [{\n                    name: 'fgColor',\n                    properties: {\n                        rawMap: {\n                            theme: fgTheme,\n                            tint: fgTint,\n                            rgb: fgRgb\n                        }\n                    }\n                }];\n        }\n        if (bgIndexed) {\n            if (!pf.children) {\n                pf.children = [];\n            }\n            pf.children.push({\n                name: 'bgColor',\n                properties: {\n                    rawMap: {\n                        indexed: bgIndexed,\n                        rgb: bgRgb\n                    }\n                }\n            });\n        }\n        return {\n            name: \"fill\",\n            children: [pf]\n        };\n    }\n};\n\nvar fillsFactory = {\n    getTemplate: function (fills) {\n        return {\n            name: \"fills\",\n            properties: {\n                rawMap: {\n                    count: fills.length\n                }\n            },\n            children: fills.map(fillFactory.getTemplate)\n        };\n    }\n};\n\nvar getBorderColor = function (color) {\n    return {\n        name: 'color',\n        properties: {\n            rawMap: {\n                rgb: convertLegacyColor(color || '#000000')\n            }\n        }\n    };\n};\nvar borderFactory = {\n    getTemplate: function (border) {\n        var left = border.left, right = border.right, top = border.top, bottom = border.bottom, diagonal = border.diagonal;\n        var leftChildren = left ? [getBorderColor(left.color)] : undefined;\n        var rightChildren = right ? [getBorderColor(right.color)] : undefined;\n        var topChildren = top ? [getBorderColor(top.color)] : undefined;\n        var bottomChildren = bottom ? [getBorderColor(bottom.color)] : undefined;\n        var diagonalChildren = diagonal ? [getBorderColor(diagonal.color)] : undefined;\n        return {\n            name: 'border',\n            children: [{\n                    name: 'left',\n                    properties: { rawMap: { style: left && left.style } },\n                    children: leftChildren\n                }, {\n                    name: 'right',\n                    properties: { rawMap: { style: right && right.style } },\n                    children: rightChildren\n                }, {\n                    name: 'top',\n                    properties: { rawMap: { style: top && top.style } },\n                    children: topChildren\n                }, {\n                    name: 'bottom',\n                    properties: { rawMap: { style: bottom && bottom.style } },\n                    children: bottomChildren\n                }, {\n                    name: 'diagonal',\n                    properties: { rawMap: { style: diagonal && diagonal.style } },\n                    children: diagonalChildren\n                }]\n        };\n    }\n};\nvar getWeightName = function (value) {\n    if (value === 1) {\n        return 'thin';\n    }\n    if (value === 2) {\n        return 'medium';\n    }\n    if (value === 3) {\n        return 'thick';\n    }\n    return 'hair';\n};\nvar mappedNames = {\n    None: 'None',\n    Dot: 'Dotted',\n    Dash: 'Dashed',\n    Double: 'Double',\n    DashDot: 'DashDot',\n    DashDotDot: 'DashDotDot',\n    SlantDashDot: 'SlantDashDot'\n};\nvar mediumBorders = ['Dashed', 'DashDot', 'DashDotDot'];\nvar convertLegacyBorder = function (type, weight) {\n    // Legacy Types are: None, Continuous, Dash, Dot, DashDot, DashDotDot, SlantDashDot, and Double\n    // Weight represents: 0Hairline, 1Thin , 2Medium, 3Thick\n    // New types: none, thin, medium, dashed, dotted, thick, double, hair, mediumDashed, dashDot, mediumDashDot,\n    // dashDotDot, mediumDashDotDot, slantDashDot\n    var namedWeight = getWeightName(weight);\n    var mappedName = mappedNames[type];\n    if (!type) {\n        return 'thin';\n    }\n    if (type === 'Continuous') {\n        return namedWeight;\n    }\n    if (namedWeight === 'medium' && mediumBorders.indexOf(mappedName) !== -1) {\n        return \"medium\" + mappedName;\n    }\n    return mappedName.charAt(0).toLowerCase() + mappedName.substr(1);\n};\n\nvar bordersFactory = {\n    getTemplate: function (borders) {\n        return {\n            name: \"borders\",\n            properties: {\n                rawMap: {\n                    count: borders.length\n                }\n            },\n            children: borders.map(borderFactory.getTemplate)\n        };\n    }\n};\n\nvar convertLegacyHorizontalAlignment = function (alignment) {\n    var map = {\n        Automatic: 'general',\n        Left: 'left',\n        Center: 'center',\n        Right: 'right',\n        Fill: 'fill',\n        Justify: 'justify',\n        CenterAcrossSelection: 'centerContinuous',\n        Distributed: 'distributed',\n        JustifyDistributed: 'justify'\n    };\n    return map[alignment] || 'general';\n};\nvar convertLegacyVerticalAlignment = function (alignment) {\n    var map = {\n        Automatic: undefined,\n        Top: 'top',\n        Bottom: 'bottom',\n        Center: 'center',\n        Justify: 'justify',\n        Distributed: 'distributed',\n        JustifyDistributed: 'justify'\n    };\n    return map[alignment] || undefined;\n};\nvar getReadingOrderId = function (readingOrder) {\n    var order = ['Context', 'LeftToRight', 'RightToLeft'];\n    var pos = order.indexOf(readingOrder);\n    return Math.max(pos, 0);\n};\nvar alignmentFactory = {\n    getTemplate: function (alignment) {\n        var horizontal = alignment.horizontal, indent = alignment.indent, readingOrder = alignment.readingOrder, rotate = alignment.rotate, shrinkToFit = alignment.shrinkToFit, vertical = alignment.vertical, wrapText = alignment.wrapText;\n        return {\n            name: 'alignment',\n            properties: {\n                rawMap: {\n                    horizontal: horizontal && convertLegacyHorizontalAlignment(horizontal),\n                    indent: indent,\n                    readingOrder: readingOrder && getReadingOrderId(readingOrder),\n                    textRotation: rotate,\n                    shrinkToFit: shrinkToFit,\n                    vertical: vertical && convertLegacyVerticalAlignment(vertical),\n                    wrapText: wrapText\n                }\n            }\n        };\n    }\n};\n\nvar protectionFactory = {\n    getTemplate: function (protection) {\n        var locked = protection.protected === false ? 0 : 1;\n        var hidden = protection.hideFormula === true ? 1 : 0;\n        return {\n            name: 'protection',\n            properties: {\n                rawMap: {\n                    hidden: hidden,\n                    locked: locked\n                }\n            }\n        };\n    }\n};\n\nvar xfFactory = {\n    getTemplate: function (xf) {\n        var alignment = xf.alignment, borderId = xf.borderId, fillId = xf.fillId, fontId = xf.fontId, numFmtId = xf.numFmtId, protection = xf.protection, xfId = xf.xfId;\n        var children = [];\n        if (alignment) {\n            children.push(alignmentFactory.getTemplate(alignment));\n        }\n        if (protection) {\n            children.push(protectionFactory.getTemplate(protection));\n        }\n        return {\n            name: \"xf\",\n            properties: {\n                rawMap: {\n                    applyAlignment: alignment ? 1 : undefined,\n                    applyProtection: protection ? 1 : undefined,\n                    applyBorder: borderId ? 1 : undefined,\n                    borderId: borderId,\n                    fillId: fillId,\n                    applyFont: fontId ? 1 : undefined,\n                    fontId: fontId,\n                    applyNumberFormat: numFmtId ? 1 : undefined,\n                    numFmtId: numFmtId,\n                    xfId: xfId\n                }\n            },\n            children: children.length ? children : undefined\n        };\n    }\n};\n\nvar cellStylesXfsFactory = {\n    getTemplate: function (xf) {\n        return {\n            name: \"cellStyleXfs\",\n            properties: {\n                rawMap: {\n                    count: xf.length\n                }\n            },\n            children: xf.map(xfFactory.getTemplate)\n        };\n    }\n};\n\nvar cellXfsFactory = {\n    getTemplate: function (xf) {\n        return {\n            name: \"cellXfs\",\n            properties: {\n                rawMap: {\n                    count: xf.length\n                }\n            },\n            children: xf.map(xfFactory.getTemplate)\n        };\n    }\n};\n\nvar borderFactory$1 = {\n    getTemplate: function (cellStyle) {\n        var builtinId = cellStyle.builtinId, name = cellStyle.name, xfId = cellStyle.xfId;\n        return {\n            name: \"cellStyle\",\n            properties: {\n                rawMap: {\n                    builtinId: builtinId,\n                    name: name,\n                    xfId: xfId\n                }\n            }\n        };\n    }\n};\n\nvar cellStylesFactory = {\n    getTemplate: function (cellStyles) {\n        return {\n            name: \"cellStyles\",\n            properties: {\n                rawMap: {\n                    count: cellStyles.length\n                }\n            },\n            children: cellStyles.map(borderFactory$1.getTemplate)\n        };\n    }\n};\n\nvar stylesMap;\nvar registeredNumberFmts;\nvar registeredFonts;\nvar registeredFills;\nvar registeredBorders;\nvar registeredCellStyleXfs;\nvar registeredCellXfs;\nvar registeredCellStyles;\nvar resetStylesheetValues = function () {\n    stylesMap = { base: 0 };\n    registeredNumberFmts = [];\n    registeredFonts = [{ name: 'Calibri', size: 14, colorTheme: '1', family: 2, scheme: 'minor' }];\n    registeredFills = [{ patternType: 'none', }, { patternType: 'gray125' }];\n    registeredBorders = [{ left: undefined, right: undefined, top: undefined, bottom: undefined, diagonal: undefined }];\n    registeredCellStyleXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0 }];\n    registeredCellXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0, xfId: 0 }];\n    registeredCellStyles = [{ builtinId: 0, name: 'normal', xfId: 0 }];\n};\nvar convertLegacyPattern = function (name) {\n    var colorMap = {\n        None: 'none',\n        Solid: 'solid',\n        Gray50: 'mediumGray',\n        Gray75: 'darkGray',\n        Gray25: 'lightGray',\n        HorzStripe: 'darkHorizontal',\n        VertStripe: 'darkVertical',\n        ReverseDiagStripe: 'darkDown',\n        DiagStripe: 'darkUp',\n        DiagCross: 'darkGrid',\n        ThickDiagCross: 'darkTrellis',\n        ThinHorzStripe: 'lightHorizontal',\n        ThinVertStripe: 'lightVertical',\n        ThinReverseDiagStripe: 'lightDown',\n        ThinDiagStripe: 'lightUp',\n        ThinHorzCross: 'lightGrid',\n        ThinDiagCross: 'lightTrellis',\n        Gray125: 'gray125',\n        Gray0625: 'gray0625'\n    };\n    if (!name) {\n        return 'none';\n    }\n    return colorMap[name] || name;\n};\nvar convertLegacyColor = function (color) {\n    if (color == undefined) {\n        return color;\n    }\n    if (color.charAt(0) === '#') {\n        color = color.substr(1);\n    }\n    return color.length === 6 ? '00' + color : color;\n};\nvar registerFill = function (fill) {\n    var convertedPattern = convertLegacyPattern(fill.pattern);\n    var convertedFillColor = convertLegacyColor(fill.color);\n    var convertedPatternColor = convertLegacyColor(fill.patternColor);\n    var pos = agGridCommunity._.findIndex(registeredFills, function (currentFill) {\n        var patternType = currentFill.patternType, fgRgb = currentFill.fgRgb, bgRgb = currentFill.bgRgb;\n        if (patternType != convertedPattern ||\n            fgRgb != convertedFillColor ||\n            bgRgb != convertedPatternColor) {\n            return false;\n        }\n        return true;\n    });\n    if (pos === -1) {\n        pos = registeredFills.length;\n        registeredFills.push({ patternType: convertedPattern, fgRgb: convertedFillColor, bgRgb: convertedPatternColor });\n    }\n    return pos;\n};\nvar registerNumberFmt = function (format) {\n    format = agGridCommunity._.utf8_encode(format);\n    if (numberFormatMap[format]) {\n        return numberFormatMap[format];\n    }\n    var pos = agGridCommunity._.findIndex(registeredNumberFmts, function (currentFormat) { return currentFormat.formatCode === format; });\n    if (pos === -1) {\n        pos = registeredNumberFmts.length + 164;\n        registeredNumberFmts.push({ formatCode: format, numFmtId: pos });\n    }\n    else {\n        pos = registeredNumberFmts[pos].numFmtId;\n    }\n    return pos;\n};\nvar registerBorders = function (borders) {\n    var borderBottom = borders.borderBottom, borderTop = borders.borderTop, borderLeft = borders.borderLeft, borderRight = borders.borderRight;\n    var bottomStyle;\n    var topStyle;\n    var leftStyle;\n    var rightStyle;\n    var bottomColor;\n    var topColor;\n    var leftColor;\n    var rightColor;\n    if (borderLeft) {\n        leftStyle = convertLegacyBorder(borderLeft.lineStyle, borderLeft.weight);\n        leftColor = convertLegacyColor(borderLeft.color);\n    }\n    if (borderRight) {\n        rightStyle = convertLegacyBorder(borderRight.lineStyle, borderRight.weight);\n        rightColor = convertLegacyColor(borderRight.color);\n    }\n    if (borderBottom) {\n        bottomStyle = convertLegacyBorder(borderBottom.lineStyle, borderBottom.weight);\n        bottomColor = convertLegacyColor(borderBottom.color);\n    }\n    if (borderTop) {\n        topStyle = convertLegacyBorder(borderTop.lineStyle, borderTop.weight);\n        topColor = convertLegacyColor(borderTop.color);\n    }\n    var pos = agGridCommunity._.findIndex(registeredBorders, function (currentBorder) {\n        var left = currentBorder.left, right = currentBorder.right, top = currentBorder.top, bottom = currentBorder.bottom;\n        if (!left && (leftStyle || leftColor)) {\n            return false;\n        }\n        if (!right && (rightStyle || rightColor)) {\n            return false;\n        }\n        if (!top && (topStyle || topColor)) {\n            return false;\n        }\n        if (!bottom && (bottomStyle || bottomColor)) {\n            return false;\n        }\n        var _a = left || {}, clS = _a.style, clC = _a.color;\n        var _b = right || {}, crS = _b.style, crC = _b.color;\n        var _c = top || {}, ctS = _c.style, ctC = _c.color;\n        var _d = bottom || {}, cbS = _d.style, cbC = _d.color;\n        if (clS != leftStyle || clC != leftColor) {\n            return false;\n        }\n        if (crS != rightStyle || crC != rightColor) {\n            return false;\n        }\n        if (ctS != topStyle || ctC != topColor) {\n            return false;\n        }\n        if (cbS != bottomStyle || cbC != bottomColor) {\n            return false;\n        }\n        return true;\n    });\n    if (pos === -1) {\n        pos = registeredBorders.length;\n        registeredBorders.push({\n            left: {\n                style: leftStyle, color: leftColor\n            },\n            right: {\n                style: rightStyle, color: rightColor\n            },\n            top: {\n                style: topStyle, color: topColor\n            },\n            bottom: {\n                style: bottomStyle, color: bottomColor\n            },\n            diagonal: {\n                style: undefined,\n                color: undefined\n            }\n        });\n    }\n    return pos;\n};\nvar registerFont = function (font) {\n    var name = font.fontName, color = font.color, size = font.size, bold = font.bold, italic = font.italic, outline = font.outline, shadow = font.shadow, strikeThrough = font.strikeThrough, underline = font.underline, family = font.family;\n    var utf8Name = name ? agGridCommunity._.utf8_encode(name) : name;\n    var convertedColor = convertLegacyColor(color);\n    var familyId = getFamilyId(family);\n    var pos = agGridCommunity._.findIndex(registeredFonts, function (currentFont) {\n        if (currentFont.name != utf8Name ||\n            currentFont.color != convertedColor ||\n            currentFont.size != size ||\n            currentFont.bold != bold ||\n            currentFont.italic != italic ||\n            currentFont.outline != outline ||\n            currentFont.shadow != shadow ||\n            currentFont.strike != strikeThrough ||\n            currentFont.underline != underline ||\n            currentFont.family != familyId) {\n            return false;\n        }\n        return true;\n    });\n    if (pos === -1) {\n        pos = registeredFonts.length;\n        registeredFonts.push({\n            name: utf8Name,\n            color: convertedColor,\n            size: size,\n            bold: bold,\n            italic: italic,\n            outline: outline,\n            shadow: shadow,\n            strike: strikeThrough,\n            underline: underline,\n            family: familyId\n        });\n    }\n    return pos;\n};\nvar registerStyle = function (config) {\n    var id = config.id, alignment = config.alignment, borders = config.borders, font = config.font, interior = config.interior, numberFormat = config.numberFormat, protection = config.protection;\n    var currentFill = 0;\n    var currentBorder = 0;\n    var currentFont = 0;\n    var currentNumberFmt = 0;\n    if (!id || stylesMap[id] != undefined) {\n        return;\n    }\n    if (interior) {\n        currentFill = registerFill(interior);\n    }\n    if (borders) {\n        currentBorder = registerBorders(borders);\n    }\n    if (font) {\n        currentFont = registerFont(font);\n    }\n    if (numberFormat) {\n        currentNumberFmt = registerNumberFmt(numberFormat.format);\n    }\n    stylesMap[id] = registeredCellXfs.length;\n    registeredCellXfs.push({\n        alignment: alignment,\n        borderId: currentBorder || 0,\n        fillId: currentFill || 0,\n        fontId: currentFont || 0,\n        numFmtId: currentNumberFmt || 0,\n        protection: protection,\n        xfId: 0\n    });\n};\nvar stylesheetFactory = {\n    getTemplate: function () {\n        var numberFormats = numberFormatsFactory.getTemplate(registeredNumberFmts);\n        var fonts = fontsFactory.getTemplate(registeredFonts);\n        var fills = fillsFactory.getTemplate(registeredFills);\n        var borders = bordersFactory.getTemplate(registeredBorders);\n        var cellStylesXfs = cellStylesXfsFactory.getTemplate(registeredCellStyleXfs);\n        var cellXfs = cellXfsFactory.getTemplate(registeredCellXfs);\n        var cellStyles = cellStylesFactory.getTemplate(registeredCellStyles);\n        resetStylesheetValues();\n        return {\n            name: 'styleSheet',\n            properties: {\n                rawMap: {\n                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'\n                }\n            },\n            children: [\n                numberFormats,\n                fonts,\n                fills,\n                borders,\n                cellStylesXfs,\n                cellXfs,\n                cellStyles,\n                {\n                    name: 'tableStyles',\n                    properties: {\n                        rawMap: {\n                            count: 0,\n                            defaultPivotStyle: 'PivotStyleLight16',\n                            defaultTableStyle: 'TableStyleMedium2'\n                        }\n                    }\n                }\n            ]\n        };\n    }\n};\nvar getStyleId = function (name) {\n    return stylesMap[name] || 0;\n};\nvar registerStyles = function (styles) {\n    resetStylesheetValues();\n    styles.forEach(registerStyle);\n};\n\nvar sheetFactory = {\n    getTemplate: function (name, idx) {\n        var sheetId = (idx + 1).toString();\n        return {\n            name: \"sheet\",\n            properties: {\n                rawMap: {\n                    \"name\": name,\n                    \"sheetId\": sheetId,\n                    \"r:id\": \"rId\" + sheetId\n                }\n            }\n        };\n    }\n};\n\nvar sheetsFactory = {\n    getTemplate: function (names) {\n        return {\n            name: \"sheets\",\n            children: names.map(sheetFactory.getTemplate)\n        };\n    }\n};\n\nvar workbookFactory = {\n    getTemplate: function (names) {\n        return {\n            name: \"workbook\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"xmlns:\",\n                        map: {\n                            r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n                        },\n                    }],\n                rawMap: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n                }\n            },\n            children: [sheetsFactory.getTemplate(names)]\n        };\n    }\n};\n\n// https://docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths\nvar getExcelCellWidth = function (width) { return Math.ceil((width - 12) / 7 + 1); };\nvar columnFactory = {\n    getTemplate: function (config) {\n        var min = config.min, max = config.max, s = config.s, width = config.width, hidden = config.hidden, bestFit = config.bestFit;\n        var excelWidth = 1;\n        var customWidth = '0';\n        if (width > 1) {\n            excelWidth = getExcelCellWidth(width);\n            customWidth = '1';\n        }\n        return {\n            name: 'col',\n            properties: {\n                rawMap: {\n                    min: min,\n                    max: max,\n                    width: excelWidth,\n                    style: s,\n                    hidden: hidden ? '1' : '0',\n                    bestFit: bestFit ? '1' : '0',\n                    customWidth: customWidth\n                }\n            }\n        };\n    }\n};\n\nvar convertLegacyType = function (type) {\n    var t = type.charAt(0).toLowerCase();\n    return t === 's' ? 'inlineStr' : t;\n};\nvar cellFactory = {\n    getTemplate: function (config) {\n        var ref = config.ref, data = config.data, styleId = config.styleId;\n        var type = data.type, value = data.value;\n        var convertedType = type;\n        if (type.charAt(0) === type.charAt(0).toUpperCase()) {\n            convertedType = convertLegacyType(type);\n        }\n        var obj = {\n            name: 'c',\n            properties: {\n                rawMap: {\n                    r: ref,\n                    t: convertedType === 'empty' ? undefined : convertedType,\n                    s: styleId ? getStyleId(styleId) : undefined\n                }\n            }\n        };\n        var children;\n        if (convertedType === 'inlineStr') {\n            children = [{\n                    name: 'is',\n                    children: [{\n                            name: 't',\n                            textNode: agGridCommunity._.escapeString(agGridCommunity._.utf8_encode(value))\n                        }]\n                }];\n        }\n        else {\n            children = [{\n                    name: 'v',\n                    textNode: value\n                }];\n        }\n        return agGridCommunity._.assign({}, obj, { children: children });\n    }\n};\n\nvar __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar addEmptyCells = function (cells, rowIdx) {\n    var mergeMap = [];\n    var posCounter = 0;\n    for (var i = 0; i < cells.length; i++) {\n        var cell = cells[i];\n        if (cell.mergeAcross) {\n            mergeMap.push({\n                pos: i,\n                excelPos: posCounter\n            });\n            posCounter += cell.mergeAcross;\n        }\n        posCounter++;\n    }\n    if (mergeMap.length) {\n        for (var i = mergeMap.length - 1; i >= 0; i--) {\n            var mergedCells = [];\n            var cell = cells[mergeMap[i].pos];\n            for (var j = 1; j <= cell.mergeAcross; j++) {\n                mergedCells.push({\n                    ref: \"\" + getExcelColumnName(mergeMap[i].excelPos + 1 + j) + (rowIdx + 1),\n                    styleId: cell.styleId,\n                    data: { type: 'empty', value: null }\n                });\n            }\n            if (mergedCells.length) {\n                cells.splice.apply(cells, __spreadArrays$1([mergeMap[i].pos + 1, 0], mergedCells));\n            }\n        }\n    }\n};\nvar rowFactory = {\n    getTemplate: function (config, idx) {\n        var index = config.index, collapsed = config.collapsed, hidden = config.hidden, height = config.height, s = config.s, _a = config.cells, cells = _a === void 0 ? [] : _a;\n        addEmptyCells(cells, idx);\n        var children = cells.map(cellFactory.getTemplate);\n        return {\n            name: \"row\",\n            properties: {\n                rawMap: {\n                    r: index,\n                    collapsed: collapsed,\n                    hidden: hidden ? '1' : '0',\n                    ht: height,\n                    customHeight: height != null ? '1' : '0',\n                    s: s,\n                    customFormat: s != null ? '1' : '0'\n                }\n            },\n            children: children\n        };\n    }\n};\n\nvar mergeCell = {\n    getTemplate: function (ref) {\n        return {\n            name: 'mergeCell',\n            properties: {\n                rawMap: {\n                    ref: ref\n                }\n            }\n        };\n    }\n};\n\nvar updateColMinMax = function (col, min, range, prevCol) {\n    if (!col.min) {\n        col.min = min;\n        col.max = min + range;\n        return;\n    }\n    var currentMin = min;\n    if (prevCol) {\n        currentMin = Math.max(currentMin, prevCol.min);\n    }\n    col.min = Math.max(col.min, currentMin);\n    col.max = Math.max(col.max, currentMin + range);\n};\nvar getMergedCells = function (rows, cols) {\n    var mergedCells = [];\n    rows.forEach(function (currentRow, rowIdx) {\n        var cells = currentRow.cells;\n        var merges = 0;\n        currentRow.index = rowIdx + 1;\n        var lastCol;\n        cells.forEach(function (currentCell, cellIdx) {\n            var min = cellIdx + merges + 1;\n            var start = getExcelColumnName(min);\n            var outputRow = rowIdx + 1;\n            if (currentCell.mergeAcross) {\n                merges += currentCell.mergeAcross;\n                var end = getExcelColumnName(cellIdx + merges + 1);\n                mergedCells.push(\"\" + start + outputRow + \":\" + end + outputRow);\n            }\n            if (!cols[min - 1]) {\n                cols[min - 1] = {};\n            }\n            updateColMinMax(cols[min - 1], min, merges, lastCol);\n            lastCol = cols[min - 1];\n            currentCell.ref = \"\" + start + outputRow;\n        });\n    });\n    return mergedCells;\n};\nvar getExcelColumnName = function (colIdx) {\n    var startCode = 65;\n    var tableWidth = 26;\n    var fromCharCode = String.fromCharCode;\n    var pos = Math.floor(colIdx / tableWidth);\n    var tableIdx = colIdx % tableWidth;\n    if (!pos || colIdx === tableWidth) {\n        return fromCharCode(startCode + colIdx - 1);\n    }\n    if (!tableIdx) {\n        return getExcelColumnName(pos - 1) + 'Z';\n    }\n    if (pos < tableWidth) {\n        return fromCharCode(startCode + pos - 1) + fromCharCode(startCode + tableIdx - 1);\n    }\n    return getExcelColumnName(pos) + fromCharCode(startCode + tableIdx - 1);\n};\nvar worksheetFactory = {\n    getTemplate: function (config) {\n        var table = config.table;\n        var rows = table.rows, columns = table.columns;\n        var mergedCells = (columns && columns.length) ? getMergedCells(rows, columns) : [];\n        var children = [];\n        if (columns.length) {\n            children.push({\n                name: 'cols',\n                children: columns.map(columnFactory.getTemplate)\n            });\n        }\n        if (rows.length) {\n            children.push({\n                name: 'sheetData',\n                children: rows.map(rowFactory.getTemplate)\n            });\n        }\n        if (mergedCells.length) {\n            children.push({\n                name: 'mergeCells',\n                properties: {\n                    rawMap: {\n                        count: mergedCells.length\n                    }\n                },\n                children: mergedCells.map(mergeCell.getTemplate)\n            });\n        }\n        return {\n            name: \"worksheet\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"xmlns:\",\n                        map: {\n                            r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n                        }\n                    }],\n                rawMap: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n                }\n            },\n            children: children\n        };\n    }\n};\n\nvar relationshipFactory = {\n    getTemplate: function (config) {\n        var Id = config.Id, Type = config.Type, Target = config.Target;\n        return {\n            name: \"Relationship\",\n            properties: {\n                rawMap: {\n                    Id: Id,\n                    Type: Type,\n                    Target: Target\n                }\n            }\n        };\n    }\n};\n\nvar relationshipsFactory = {\n    getTemplate: function (c) {\n        var children = c.map(relationshipFactory.getTemplate);\n        return {\n            name: \"Relationships\",\n            properties: {\n                rawMap: {\n                    xmlns: \"http://schemas.openxmlformats.org/package/2006/relationships\"\n                }\n            },\n            children: children\n        };\n    }\n};\n\nvar __extends$q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * See https://www.ecma-international.org/news/TC45_current_work/OpenXML%20White%20Paper.pdf\n */\nvar ExcelXlsxFactory = /** @class */ (function (_super) {\n    __extends$q(ExcelXlsxFactory, _super);\n    function ExcelXlsxFactory() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sharedStrings = [];\n        return _this;\n    }\n    ExcelXlsxFactory.prototype.createSharedStrings = function () {\n        return this.createXmlPart(sharedStrings.getTemplate(this.sharedStrings));\n    };\n    ExcelXlsxFactory.prototype.createXmlPart = function (body) {\n        var header = this.xmlFactory.createHeader({\n            encoding: 'UTF-8',\n            standalone: 'yes'\n        });\n        var xmlBody = this.xmlFactory.createXml(body);\n        return \"\" + header + xmlBody;\n    };\n    ExcelXlsxFactory.prototype.createExcel = function (styles, worksheets, sharedStrings) {\n        if (sharedStrings === void 0) { sharedStrings = []; }\n        this.sharedStrings = sharedStrings;\n        this.sheetNames = worksheets.map(function (worksheet) { return worksheet.name; });\n        registerStyles(styles);\n        return this.createWorksheet(worksheets);\n    };\n    ExcelXlsxFactory.prototype.createCore = function () {\n        return this.createXmlPart(coreFactory.getTemplate());\n    };\n    ExcelXlsxFactory.prototype.createContentTypes = function () {\n        return this.createXmlPart(contentTypesFactory.getTemplate());\n    };\n    ExcelXlsxFactory.prototype.createRels = function () {\n        var rs = relationshipsFactory.getTemplate([{\n                Id: 'rId1',\n                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',\n                Target: 'xl/workbook.xml'\n            }, {\n                Id: 'rId2',\n                Type: 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',\n                Target: 'docProps/core.xml'\n            }]);\n        return this.createXmlPart(rs);\n    };\n    ExcelXlsxFactory.prototype.createStylesheet = function () {\n        return this.createXmlPart(stylesheetFactory.getTemplate());\n    };\n    ExcelXlsxFactory.prototype.createTheme = function () {\n        return this.createXmlPart(officeTheme.getTemplate());\n    };\n    ExcelXlsxFactory.prototype.createWorkbook = function () {\n        return this.createXmlPart(workbookFactory.getTemplate(this.sheetNames));\n    };\n    ExcelXlsxFactory.prototype.createWorkbookRels = function () {\n        var rs = relationshipsFactory.getTemplate([{\n                Id: 'rId1',\n                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',\n                Target: 'worksheets/sheet1.xml'\n            }, {\n                Id: 'rId2',\n                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',\n                Target: 'theme/theme1.xml'\n            }, {\n                Id: 'rId3',\n                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',\n                Target: 'styles.xml'\n            }, {\n                Id: 'rId4',\n                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',\n                Target: 'sharedStrings.xml'\n            }]);\n        return this.createXmlPart(rs);\n    };\n    ExcelXlsxFactory.prototype.createWorksheet = function (worksheets) {\n        return this.createXmlPart(worksheetFactory.getTemplate(worksheets[0]));\n    };\n    __decorate$q([\n        agGridCommunity.Autowired('xmlFactory')\n    ], ExcelXlsxFactory.prototype, \"xmlFactory\", void 0);\n    ExcelXlsxFactory = __decorate$q([\n        agGridCommunity.Bean('excelXlsxFactory')\n    ], ExcelXlsxFactory);\n    return ExcelXlsxFactory;\n}(agGridCommunity.BeanStub));\n\nvar workbook = {\n    getTemplate: function () {\n        return {\n            name: \"Workbook\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"xmlns:\",\n                        map: {\n                            o: \"urn:schemas-microsoft-com:office:office\",\n                            x: \"urn:schemas-microsoft-com:office:excel\",\n                            ss: \"urn:schemas-microsoft-com:office:spreadsheet\",\n                            html: \"http://www.w3.org/TR/REC-html40\"\n                        },\n                    }],\n                rawMap: {\n                    xmlns: \"urn:schemas-microsoft-com:office:spreadsheet\"\n                }\n            }\n        };\n    }\n};\n\nvar excelWorkbook = {\n    getTemplate: function () {\n        return {\n            name: \"ExcelWorkbook\",\n            properties: {\n                rawMap: {\n                    xmlns: \"urn:schemas-microsoft-com:office:excel\"\n                }\n            },\n            children: [{\n                    name: \"WindowHeight\",\n                    textNode: \"8130\"\n                }, {\n                    name: \"WindowWidth\",\n                    textNode: \"15135\"\n                }, {\n                    name: \"WindowHeight\",\n                    textNode: \"8130\"\n                }, {\n                    name: \"WindowTopX\",\n                    textNode: \"120\"\n                }, {\n                    name: \"WindowTopY\",\n                    textNode: \"45\"\n                }, {\n                    name: \"ProtectStructure\",\n                    textNode: \"False\"\n                }, {\n                    name: \"ProtectWindow\",\n                    textNode: \"False\"\n                }]\n        };\n    }\n};\n\nvar column = {\n    getTemplate: function (c) {\n        var width = c.width;\n        return {\n            name: \"Column\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Width: width\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar cell = {\n    getTemplate: function (c) {\n        var mergeAcross = c.mergeAcross, styleId = c.styleId, data = c.data;\n        var properties = {};\n        if (mergeAcross) {\n            properties.MergeAcross = mergeAcross;\n        }\n        if (styleId) {\n            properties.StyleID = styleId;\n        }\n        return {\n            name: \"Cell\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: properties\n                    }]\n            },\n            children: [{\n                    name: \"Data\",\n                    properties: {\n                        prefixedAttributes: [{\n                                prefix: \"ss:\",\n                                map: {\n                                    Type: data.type\n                                }\n                            }]\n                    },\n                    textNode: data.value\n                }]\n        };\n    }\n};\n\nvar row = {\n    getTemplate: function (r) {\n        var cells = r.cells;\n        return {\n            name: \"Row\",\n            children: cells.map(function (it) { return cell.getTemplate(it); })\n        };\n    }\n};\n\nvar worksheet = {\n    getTemplate: function (ws) {\n        var table = ws.table, name = ws.name;\n        var columns = table.columns, rows = table.rows;\n        var c = columns.map(function (it) { return column.getTemplate(it); });\n        var r = rows.map(function (it) { return row.getTemplate(it); });\n        return {\n            name: \"Worksheet\",\n            children: [{\n                    name: \"Table\",\n                    children: c.concat(r)\n                }],\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Name: name\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar documentProperties = {\n    getTemplate: function () {\n        return {\n            name: \"DocumentProperties\",\n            properties: {\n                rawMap: {\n                    xmlns: \"urn:schemas-microsoft-com:office:office\"\n                }\n            },\n            children: [{\n                    name: \"Version\",\n                    textNode: \"12.00\"\n                }]\n        };\n    }\n};\n\nvar alignment = {\n    getTemplate: function (styleProperties) {\n        var _a = styleProperties.alignment, vertical = _a.vertical, horizontal = _a.horizontal, indent = _a.indent, readingOrder = _a.readingOrder, rotate = _a.rotate, shrinkToFit = _a.shrinkToFit, verticalText = _a.verticalText, wrapText = _a.wrapText;\n        return {\n            name: 'Alignment',\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Vertical: vertical,\n                            Horizontal: horizontal,\n                            Indent: indent,\n                            ReadingOrder: readingOrder,\n                            Rotate: rotate,\n                            ShrinkToFit: shrinkToFit,\n                            VerticalText: verticalText,\n                            WrapText: wrapText\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar borders = {\n    getTemplate: function (styleProperties) {\n        var _a = styleProperties.borders, borderBottom = _a.borderBottom, borderLeft = _a.borderLeft, borderRight = _a.borderRight, borderTop = _a.borderTop;\n        return {\n            name: 'Borders',\n            children: [borderBottom, borderLeft, borderRight, borderTop].map(function (it, index) {\n                var current = index == 0 ? \"Bottom\" : index == 1 ? \"Left\" : index == 2 ? \"Right\" : \"Top\";\n                return {\n                    name: 'Border',\n                    properties: {\n                        prefixedAttributes: [{\n                                prefix: 'ss:',\n                                map: {\n                                    Position: current,\n                                    LineStyle: it.lineStyle,\n                                    Weight: it.weight,\n                                    Color: it.color\n                                }\n                            }]\n                    }\n                };\n            })\n        };\n    }\n};\n\nvar font = {\n    getTemplate: function (styleProperties) {\n        var _a = styleProperties.font, bold = _a.bold, fontName = _a.fontName, italic = _a.italic, color = _a.color, outline = _a.outline, shadow = _a.shadow, size = _a.size, strikeThrough = _a.strikeThrough, underline = _a.underline, verticalAlign = _a.verticalAlign, charSet = _a.charSet, family = _a.family;\n        return {\n            name: \"Font\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Bold: bold,\n                            FontName: fontName,\n                            Italic: italic,\n                            Color: color,\n                            Outline: outline,\n                            Shadow: shadow,\n                            Size: size,\n                            StrikeThrough: strikeThrough,\n                            Underline: underline,\n                            VerticalAlign: verticalAlign\n                        }\n                    }, {\n                        prefix: \"x:\",\n                        map: {\n                            CharSet: charSet,\n                            Family: family\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar interior = {\n    getTemplate: function (styleProperties) {\n        var _a = styleProperties.interior, color = _a.color, pattern = _a.pattern, patternColor = _a.patternColor;\n        return {\n            name: \"Interior\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Color: color,\n                            Pattern: pattern,\n                            PatternColor: patternColor\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar protection = {\n    getTemplate: function (styleProperties) {\n        return {\n            name: \"Protection\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Protected: styleProperties.protection.protected,\n                            HideFormula: styleProperties.protection.hideFormula\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar numberFormat = {\n    getTemplate: function (styleProperties) {\n        var format = styleProperties.numberFormat.format;\n        return {\n            name: \"NumberFormat\",\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            Format: format\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar style = {\n    getTemplate: function (styleProperties) {\n        var id = styleProperties.id, name = styleProperties.name;\n        return {\n            name: 'Style',\n            properties: {\n                prefixedAttributes: [{\n                        prefix: \"ss:\",\n                        map: {\n                            ID: id,\n                            Name: name ? name : id\n                        }\n                    }]\n            }\n        };\n    }\n};\n\nvar __extends$r = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * See https://msdn.microsoft.com/en-us/library/aa140066(v=office.10).aspx\n */\nvar ExcelXmlFactory = /** @class */ (function (_super) {\n    __extends$r(ExcelXmlFactory, _super);\n    function ExcelXmlFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ExcelXmlFactory.prototype.createExcel = function (styles, worksheets, sharedStrings) {\n        var header = this.excelXmlHeader();\n        var docProps = documentProperties.getTemplate();\n        var eWorkbook = excelWorkbook.getTemplate();\n        var wb = this.workbook(docProps, eWorkbook, styles, worksheets);\n        return \"\" + header + this.xmlFactory.createXml(wb, function (boolean) { return boolean ? '1' : '0'; });\n    };\n    ExcelXmlFactory.prototype.workbook = function (docProperties, eWorkbook, styles, worksheets) {\n        var children = [\n            docProperties,\n            eWorkbook,\n            this.stylesXmlElement(styles)\n        ].concat(worksheets.map(function (it) { return worksheet.getTemplate(it); }));\n        return agGridCommunity._.assign({}, workbook.getTemplate(), { children: children });\n    };\n    ExcelXmlFactory.prototype.excelXmlHeader = function () {\n        return \"<?xml version=\\\"1.0\\\" ?>\\n        <?mso-application progid=\\\"Excel.Sheet\\\" ?>\\n        \";\n    };\n    ExcelXmlFactory.prototype.stylesXmlElement = function (styles) {\n        var _this = this;\n        return {\n            name: 'Styles',\n            children: styles ? styles.map(function (it) { return _this.styleXmlElement(it); }) : []\n        };\n    };\n    ExcelXmlFactory.prototype.styleXmlElement = function (styleProperties) {\n        var children = agGridCommunity._.compose(this.addProperty('alignment', styleProperties), this.addProperty('borders', styleProperties), this.addProperty('font', styleProperties), this.addProperty('interior', styleProperties), this.addProperty('protection', styleProperties), this.addProperty('numberFormat', styleProperties))([]);\n        return agGridCommunity._.assign({}, style.getTemplate(styleProperties), { children: children });\n    };\n    ExcelXmlFactory.prototype.addProperty = function (property, styleProperties) {\n        return function (children) {\n            if (!styleProperties[property]) {\n                return children;\n            }\n            var options = {\n                alignment: alignment,\n                borders: borders,\n                font: font,\n                interior: interior,\n                numberFormat: numberFormat,\n                protection: protection\n            };\n            return children.concat(options[property].getTemplate(styleProperties));\n        };\n    };\n    __decorate$r([\n        agGridCommunity.Autowired('xmlFactory')\n    ], ExcelXmlFactory.prototype, \"xmlFactory\", void 0);\n    ExcelXmlFactory = __decorate$r([\n        agGridCommunity.Bean('excelXmlFactory')\n    ], ExcelXmlFactory);\n    return ExcelXmlFactory;\n}(agGridCommunity.BeanStub));\n\nvar BaseCreator = /** @class */ (function () {\n    function BaseCreator() {\n    }\n    BaseCreator.prototype.setBeans = function (beans) {\n        this.beans = beans;\n    };\n    BaseCreator.prototype.export = function (userParams) {\n        if (this.isExportSuppressed()) {\n            console.warn(\"ag-grid: Export cancelled. Export is not allowed as per your configuration.\");\n            return '';\n        }\n        var _a = this.getMergedParamsAndData(userParams), mergedParams = _a.mergedParams, data = _a.data;\n        var fileNamePresent = mergedParams && mergedParams.fileName && mergedParams.fileName.length !== 0;\n        var fileName = fileNamePresent ? mergedParams.fileName : this.getDefaultFileName();\n        if (fileName.indexOf(\".\") === -1) {\n            fileName = fileName + \".\" + this.getDefaultFileExtension();\n        }\n        this.beans.downloader.download(fileName, this.packageFile(data));\n        return data;\n    };\n    BaseCreator.prototype.getData = function (params) {\n        return this.getMergedParamsAndData(params).data;\n    };\n    BaseCreator.prototype.getMergedParamsAndData = function (userParams) {\n        var mergedParams = this.mergeDefaultParams(userParams);\n        var data = this.beans.gridSerializer.serialize(this.createSerializingSession(mergedParams), mergedParams);\n        return { mergedParams: mergedParams, data: data };\n    };\n    BaseCreator.prototype.mergeDefaultParams = function (userParams) {\n        var baseParams = this.beans.gridOptionsWrapper.getDefaultExportParams();\n        var params = {};\n        agGridCommunity._.assign(params, baseParams);\n        agGridCommunity._.assign(params, userParams);\n        return params;\n    };\n    BaseCreator.prototype.packageFile = function (data) {\n        return new Blob([\"\\ufeff\", data], {\n            // @ts-ignore\n            type: window.navigator.msSaveOrOpenBlob ? this.getMimeType() : 'octet/stream'\n        });\n    };\n    return BaseCreator;\n}());\n\nvar BaseGridSerializingSession = /** @class */ (function () {\n    function BaseGridSerializingSession(config) {\n        this.groupColumns = [];\n        var columnController = config.columnController, valueService = config.valueService, gridOptionsWrapper = config.gridOptionsWrapper, processCellCallback = config.processCellCallback, processHeaderCallback = config.processHeaderCallback, processGroupHeaderCallback = config.processGroupHeaderCallback, processRowGroupCallback = config.processRowGroupCallback;\n        this.columnController = columnController;\n        this.valueService = valueService;\n        this.gridOptionsWrapper = gridOptionsWrapper;\n        this.processCellCallback = processCellCallback;\n        this.processHeaderCallback = processHeaderCallback;\n        this.processGroupHeaderCallback = processGroupHeaderCallback;\n        this.processRowGroupCallback = processRowGroupCallback;\n    }\n    BaseGridSerializingSession.prototype.prepare = function (columnsToExport) {\n        this.groupColumns = agGridCommunity._.filter(columnsToExport, function (col) { return !!col.getColDef().showRowGroup; });\n    };\n    BaseGridSerializingSession.prototype.extractHeaderValue = function (column) {\n        var value = this.getHeaderName(this.processHeaderCallback, column);\n        return value != null ? value : '';\n    };\n    BaseGridSerializingSession.prototype.extractRowCellValue = function (column, index, type, node) {\n        // we render the group summary text e.g. \"-> Parent -> Child\"...\n        var groupIndex = this.gridOptionsWrapper.isGroupMultiAutoColumn() ? node.rowGroupIndex : 0;\n        var renderGroupSummaryCell = \n        // on group rows\n        node && node.group\n            && (\n            // in the group column if groups appear in regular grid cells\n            index === groupIndex && this.groupColumns.indexOf(column) !== -1\n                // or the first cell in the row, if we're doing full width rows\n                || (index === 0 && this.gridOptionsWrapper.isGroupUseEntireRow(this.columnController.isPivotMode())));\n        var valueForCell;\n        if (renderGroupSummaryCell) {\n            valueForCell = this.createValueForGroupNode(node);\n        }\n        else {\n            valueForCell = this.valueService.getValue(column, node);\n        }\n        var value = this.processCell(node, column, valueForCell, this.processCellCallback, type);\n        return value != null ? value : '';\n    };\n    BaseGridSerializingSession.prototype.getHeaderName = function (callback, column) {\n        if (callback) {\n            return callback({\n                column: column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            });\n        }\n        return this.columnController.getDisplayNameForColumn(column, 'csv', true);\n    };\n    BaseGridSerializingSession.prototype.createValueForGroupNode = function (node) {\n        if (this.processRowGroupCallback) {\n            return this.processRowGroupCallback({\n                node: node,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n            });\n        }\n        var keys = [node.key];\n        if (!this.gridOptionsWrapper.isGroupMultiAutoColumn()) {\n            while (node.parent) {\n                node = node.parent;\n                keys.push(node.key);\n            }\n        }\n        return keys.reverse().join(' -> ');\n    };\n    BaseGridSerializingSession.prototype.processCell = function (rowNode, column, value, processCellCallback, type) {\n        if (processCellCallback) {\n            return processCellCallback({\n                column: column,\n                node: rowNode,\n                value: value,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n                type: type\n            });\n        }\n        return value;\n    };\n    return BaseGridSerializingSession;\n}());\n\nvar __extends$s = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar LINE_SEPARATOR = '\\r\\n';\nvar CsvSerializingSession = /** @class */ (function (_super) {\n    __extends$s(CsvSerializingSession, _super);\n    function CsvSerializingSession(config) {\n        var _this = _super.call(this, config) || this;\n        _this.isFirstLine = true;\n        _this.result = '';\n        var suppressQuotes = config.suppressQuotes, columnSeparator = config.columnSeparator;\n        _this.suppressQuotes = suppressQuotes;\n        _this.columnSeparator = columnSeparator;\n        return _this;\n    }\n    CsvSerializingSession.prototype.addCustomContent = function (content) {\n        var _this = this;\n        if (!content) {\n            return;\n        }\n        if (typeof content === 'string') {\n            // we used to require the customFooter to be prefixed with a newline but no longer do,\n            // so only add the newline if the user has not supplied one\n            if (!/^\\s*\\n/.test(content)) {\n                this.beginNewLine();\n            }\n            // replace whatever newlines are supplied with the style we're using\n            content = content.replace(/\\r?\\n/g, LINE_SEPARATOR);\n            this.result += content;\n        }\n        else {\n            content.forEach(function (row) {\n                _this.beginNewLine();\n                row.forEach(function (cell, index) {\n                    if (index !== 0) {\n                        _this.result += _this.columnSeparator;\n                    }\n                    _this.result += _this.putInQuotes(cell.data.value || '');\n                    if (cell.mergeAcross) {\n                        _this.appendEmptyCells(cell.mergeAcross);\n                    }\n                });\n            });\n        }\n    };\n    CsvSerializingSession.prototype.onNewHeaderGroupingRow = function () {\n        this.beginNewLine();\n        return {\n            onColumn: this.onNewHeaderGroupingRowColumn.bind(this)\n        };\n    };\n    CsvSerializingSession.prototype.onNewHeaderGroupingRowColumn = function (header, index, span) {\n        if (index != 0) {\n            this.result += this.columnSeparator;\n        }\n        this.result += this.putInQuotes(header);\n        this.appendEmptyCells(span);\n    };\n    CsvSerializingSession.prototype.appendEmptyCells = function (count) {\n        for (var i = 1; i <= count; i++) {\n            this.result += this.columnSeparator + this.putInQuotes(\"\");\n        }\n    };\n    CsvSerializingSession.prototype.onNewHeaderRow = function () {\n        this.beginNewLine();\n        return {\n            onColumn: this.onNewHeaderRowColumn.bind(this)\n        };\n    };\n    CsvSerializingSession.prototype.onNewHeaderRowColumn = function (column, index) {\n        if (index != 0) {\n            this.result += this.columnSeparator;\n        }\n        this.result += this.putInQuotes(this.extractHeaderValue(column));\n    };\n    CsvSerializingSession.prototype.onNewBodyRow = function () {\n        this.beginNewLine();\n        return {\n            onColumn: this.onNewBodyRowColumn.bind(this)\n        };\n    };\n    CsvSerializingSession.prototype.onNewBodyRowColumn = function (column, index, node) {\n        if (index != 0) {\n            this.result += this.columnSeparator;\n        }\n        this.result += this.putInQuotes(this.extractRowCellValue(column, index, agGridCommunity.Constants.EXPORT_TYPE_CSV, node));\n    };\n    CsvSerializingSession.prototype.putInQuotes = function (value) {\n        if (this.suppressQuotes) {\n            return value;\n        }\n        if (value === null || value === undefined) {\n            return '\"\"';\n        }\n        var stringValue;\n        if (typeof value === 'string') {\n            stringValue = value;\n        }\n        else if (typeof value.toString === 'function') {\n            stringValue = value.toString();\n        }\n        else {\n            console.warn('unknown value type during csv conversion');\n            stringValue = '';\n        }\n        // replace each \" with \"\" (ie two sets of double quotes is how to do double quotes in csv)\n        var valueEscaped = stringValue.replace(/\"/g, \"\\\"\\\"\");\n        return '\"' + valueEscaped + '\"';\n    };\n    CsvSerializingSession.prototype.parse = function () {\n        return this.result;\n    };\n    CsvSerializingSession.prototype.beginNewLine = function () {\n        if (!this.isFirstLine) {\n            this.result += LINE_SEPARATOR;\n        }\n        this.isFirstLine = false;\n    };\n    return CsvSerializingSession;\n}(BaseGridSerializingSession));\n\nvar __extends$t = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar CsvCreator = /** @class */ (function (_super) {\n    __extends$t(CsvCreator, _super);\n    function CsvCreator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CsvCreator.prototype.postConstruct = function () {\n        this.setBeans({\n            downloader: this.downloader,\n            gridSerializer: this.gridSerializer,\n            gridOptionsWrapper: this.gridOptionsWrapper\n        });\n    };\n    CsvCreator.prototype.exportDataAsCsv = function (params) {\n        return this.export(params);\n    };\n    CsvCreator.prototype.getDataAsCsv = function (params) {\n        return this.getData(params);\n    };\n    CsvCreator.prototype.getMimeType = function () {\n        return 'text/csv;charset=utf-8;';\n    };\n    CsvCreator.prototype.getDefaultFileName = function () {\n        return 'export.csv';\n    };\n    CsvCreator.prototype.getDefaultFileExtension = function () {\n        return 'csv';\n    };\n    CsvCreator.prototype.createSerializingSession = function (params) {\n        var _a = this, columnController = _a.columnController, valueService = _a.valueService, gridOptionsWrapper = _a.gridOptionsWrapper;\n        var _b = params, processCellCallback = _b.processCellCallback, processHeaderCallback = _b.processHeaderCallback, processGroupHeaderCallback = _b.processGroupHeaderCallback, processRowGroupCallback = _b.processRowGroupCallback, suppressQuotes = _b.suppressQuotes, columnSeparator = _b.columnSeparator;\n        return new CsvSerializingSession({\n            columnController: columnController,\n            valueService: valueService,\n            gridOptionsWrapper: gridOptionsWrapper,\n            processCellCallback: processCellCallback || undefined,\n            processHeaderCallback: processHeaderCallback || undefined,\n            processGroupHeaderCallback: processGroupHeaderCallback || undefined,\n            processRowGroupCallback: processRowGroupCallback || undefined,\n            suppressQuotes: suppressQuotes || false,\n            columnSeparator: columnSeparator || ','\n        });\n    };\n    CsvCreator.prototype.isExportSuppressed = function () {\n        return this.gridOptionsWrapper.isSuppressCsvExport();\n    };\n    __decorate$s([\n        agGridCommunity.Autowired('columnController')\n    ], CsvCreator.prototype, \"columnController\", void 0);\n    __decorate$s([\n        agGridCommunity.Autowired('valueService')\n    ], CsvCreator.prototype, \"valueService\", void 0);\n    __decorate$s([\n        agGridCommunity.Autowired('downloader')\n    ], CsvCreator.prototype, \"downloader\", void 0);\n    __decorate$s([\n        agGridCommunity.Autowired('gridSerializer')\n    ], CsvCreator.prototype, \"gridSerializer\", void 0);\n    __decorate$s([\n        agGridCommunity.Autowired('gridOptionsWrapper')\n    ], CsvCreator.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate$s([\n        agGridCommunity.PostConstruct\n    ], CsvCreator.prototype, \"postConstruct\", null);\n    CsvCreator = __decorate$s([\n        agGridCommunity.Bean('csvCreator')\n    ], CsvCreator);\n    return CsvCreator;\n}(BaseCreator));\n\nvar __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Downloader = /** @class */ (function () {\n    function Downloader() {\n    }\n    Downloader.prototype.download = function (fileName, content) {\n        // Internet Explorer\n        if (window.navigator.msSaveOrOpenBlob) {\n            window.navigator.msSaveOrOpenBlob(content, fileName);\n        }\n        else {\n            // Other Browsers\n            var element = document.createElement(\"a\");\n            var url_1 = window.URL.createObjectURL(content);\n            element.setAttribute(\"href\", url_1);\n            element.setAttribute(\"download\", fileName);\n            element.style.display = \"none\";\n            document.body.appendChild(element);\n            element.dispatchEvent(new MouseEvent('click', {\n                bubbles: false,\n                cancelable: true,\n                view: window\n            }));\n            document.body.removeChild(element);\n            window.setTimeout(function () {\n                window.URL.revokeObjectURL(url_1);\n            }, 0);\n        }\n    };\n    Downloader = __decorate$t([\n        agGridCommunity.Bean(\"downloader\")\n    ], Downloader);\n    return Downloader;\n}());\n\nvar __extends$u = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LINE_SEPARATOR$1 = '\\r\\n';\nvar XmlFactory = /** @class */ (function (_super) {\n    __extends$u(XmlFactory, _super);\n    function XmlFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    XmlFactory.prototype.createHeader = function (headerElement) {\n        if (headerElement === void 0) { headerElement = {}; }\n        var headerStart = '<?';\n        var headerEnd = '?>';\n        var keys = ['version'];\n        if (!headerElement.version) {\n            headerElement.version = \"1.0\";\n        }\n        if (headerElement.encoding) {\n            keys.push('encoding');\n        }\n        if (headerElement.standalone) {\n            keys.push('standalone');\n        }\n        var att = keys.map(function (key) { return key + \"=\\\"\" + headerElement[key] + \"\\\"\"; }).join(' ');\n        return headerStart + \"xml \" + att + \" \" + headerEnd;\n    };\n    XmlFactory.prototype.createXml = function (xmlElement, booleanTransformer) {\n        var _this = this;\n        var props = '';\n        if (xmlElement.properties) {\n            if (xmlElement.properties.prefixedAttributes) {\n                xmlElement.properties.prefixedAttributes.forEach(function (prefixedSet) {\n                    Object.keys(prefixedSet.map).forEach(function (key) {\n                        props += _this.returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);\n                    });\n                });\n            }\n            if (xmlElement.properties.rawMap) {\n                Object.keys(xmlElement.properties.rawMap).forEach(function (key) {\n                    props += _this.returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);\n                });\n            }\n        }\n        var result = '<' + xmlElement.name + props;\n        if (!xmlElement.children && xmlElement.textNode == null) {\n            return result + '/>' + LINE_SEPARATOR$1;\n        }\n        if (xmlElement.textNode != null) {\n            return result + '>' + xmlElement.textNode + '</' + xmlElement.name + '>' + LINE_SEPARATOR$1;\n        }\n        result += '>' + LINE_SEPARATOR$1;\n        if (xmlElement.children) {\n            xmlElement.children.forEach(function (it) {\n                result += _this.createXml(it, booleanTransformer);\n            });\n        }\n        return result + '</' + xmlElement.name + '>' + LINE_SEPARATOR$1;\n    };\n    XmlFactory.prototype.returnAttributeIfPopulated = function (key, value, booleanTransformer) {\n        if (!value && value !== '' && value !== 0) {\n            return '';\n        }\n        var xmlValue = value;\n        if ((typeof (value) === 'boolean')) {\n            if (booleanTransformer) {\n                xmlValue = booleanTransformer(value);\n            }\n        }\n        return \" \" + key + \"=\\\"\" + xmlValue + \"\\\"\";\n    };\n    XmlFactory = __decorate$u([\n        agGridCommunity.Bean('xmlFactory')\n    ], XmlFactory);\n    return XmlFactory;\n}(agGridCommunity.BeanStub));\n\nvar __extends$v = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar GridSerializer = /** @class */ (function (_super) {\n    __extends$v(GridSerializer, _super);\n    function GridSerializer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GridSerializer.prototype.serialize = function (gridSerializingSession, params) {\n        if (params === void 0) { params = {}; }\n        var rowSkipper = params.shouldRowBeSkipped || (function () { return false; });\n        var gridOptionsWrapper = this.gridOptionsWrapper;\n        var api = gridOptionsWrapper.getApi();\n        var columnApi = gridOptionsWrapper.getColumnApi();\n        var skipSingleChildrenGroup = gridOptionsWrapper.isGroupRemoveSingleChildren();\n        var skipLowestSingleChildrenGroup = gridOptionsWrapper.isGroupRemoveLowestSingleChildren();\n        var hideOpenParents = gridOptionsWrapper.isGroupHideOpenParents();\n        var context = gridOptionsWrapper.getContext();\n        // when in pivot mode, we always render cols on screen, never 'all columns'\n        var isPivotMode = this.columnController.isPivotMode();\n        var rowModelNormal = this.rowModel.getType() === agGridCommunity.Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n        var onlySelectedNonStandardModel = !rowModelNormal && params.onlySelected;\n        var columnsToExport = [];\n        if (agGridCommunity._.existsAndNotEmpty(params.columnKeys)) {\n            columnsToExport = this.columnController.getGridColumns(params.columnKeys);\n        }\n        else if (params.allColumns && !isPivotMode) {\n            // add auto group column for tree data\n            columnsToExport = gridOptionsWrapper.isTreeData() ?\n                this.columnController.getGridColumns([agGridCommunity.Constants.GROUP_AUTO_COLUMN_ID]) : [];\n            columnsToExport = columnsToExport.concat(this.columnController.getAllPrimaryColumns() || []);\n        }\n        else {\n            columnsToExport = this.columnController.getAllDisplayedColumns();\n        }\n        if (params.customHeader) {\n            gridSerializingSession.addCustomContent(params.customHeader);\n        }\n        gridSerializingSession.prepare(columnsToExport);\n        // first pass, put in the header names of the cols\n        if (params.columnGroups) {\n            var groupInstanceIdCreator = new agGridCommunity.GroupInstanceIdCreator();\n            var displayedGroups = this.displayedGroupCreator.createDisplayedGroups(columnsToExport, this.columnController.getGridBalancedTree(), groupInstanceIdCreator, null);\n            this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);\n        }\n        if (!params.skipHeader) {\n            var gridRowIterator_1 = gridSerializingSession.onNewHeaderRow();\n            columnsToExport.forEach(function (column, index) {\n                gridRowIterator_1.onColumn(column, index, undefined);\n            });\n        }\n        this.pinnedRowModel.forEachPinnedTopRow(processRow);\n        var rowModel = this.rowModel;\n        var clientSideRowModel = this.rowModel;\n        if (isPivotMode) {\n            // @ts-ignore - ignore tautology below as we are using it to check if it's clientSideRowModel\n            if (clientSideRowModel.forEachPivotNode) {\n                clientSideRowModel.forEachPivotNode(processRow);\n            }\n            else {\n                // n=must be enterprise, so we can just loop through all the nodes\n                rowModel.forEachNode(processRow);\n            }\n        }\n        else {\n            // onlySelectedAllPages: user doing pagination and wants selected items from\n            // other pages, so cannot use the standard row model as it won't have rows from\n            // other pages.\n            // onlySelectedNonStandardModel: if user wants selected in non standard row model\n            // (eg viewport) then again RowModel cannot be used, so need to use selected instead.\n            if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {\n                var selectedNodes = this.selectionController.getSelectedNodes();\n                selectedNodes.forEach(function (node) {\n                    processRow(node);\n                });\n            }\n            else {\n                // here is everything else - including standard row model and selected. we don't use\n                // the selection model even when just using selected, so that the result is the order\n                // of the rows appearing on the screen.\n                if (rowModelNormal) {\n                    clientSideRowModel.forEachNodeAfterFilterAndSort(processRow);\n                }\n                else {\n                    rowModel.forEachNode(processRow);\n                }\n            }\n        }\n        this.pinnedRowModel.forEachPinnedBottomRow(processRow);\n        if (params.customFooter) {\n            gridSerializingSession.addCustomContent(params.customFooter);\n        }\n        function processRow(node) {\n            var shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;\n            var shouldSkipCurrentGroup = node.allChildrenCount === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);\n            if (node.group && (params.skipGroups || shouldSkipCurrentGroup || hideOpenParents)) {\n                return;\n            }\n            if (params.skipFooters && node.footer) {\n                return;\n            }\n            if (params.onlySelected && !node.isSelected()) {\n                return;\n            }\n            if (params.skipPinnedTop && node.rowPinned === 'top') {\n                return;\n            }\n            if (params.skipPinnedBottom && node.rowPinned === 'bottom') {\n                return;\n            }\n            // if we are in pivotMode, then the grid will show the root node only\n            // if it's not a leaf group\n            var nodeIsRootNode = node.level === -1;\n            if (nodeIsRootNode && !node.leafGroup) {\n                return;\n            }\n            var shouldRowBeSkipped = rowSkipper({ node: node, api: api, context: context });\n            if (shouldRowBeSkipped) {\n                return;\n            }\n            var rowAccumulator = gridSerializingSession.onNewBodyRow();\n            columnsToExport.forEach(function (column, index) {\n                rowAccumulator.onColumn(column, index, node);\n            });\n            if (params.getCustomContentBelowRow) {\n                var content = params.getCustomContentBelowRow({ node: node, api: api, columnApi: columnApi, context: context });\n                if (content) {\n                    gridSerializingSession.addCustomContent(content);\n                }\n            }\n        }\n        return gridSerializingSession.parse();\n    };\n    GridSerializer.prototype.recursivelyAddHeaderGroups = function (displayedGroups, gridSerializingSession, processGroupHeaderCallback) {\n        var directChildrenHeaderGroups = [];\n        displayedGroups.forEach(function (columnGroupChild) {\n            var columnGroup = columnGroupChild;\n            if (!columnGroup.getChildren) {\n                return;\n            }\n            columnGroup.getChildren().forEach(function (it) { return directChildrenHeaderGroups.push(it); });\n        });\n        if (displayedGroups.length > 0 && displayedGroups[0] instanceof agGridCommunity.ColumnGroup) {\n            this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);\n        }\n        if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {\n            this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);\n        }\n    };\n    GridSerializer.prototype.doAddHeaderHeader = function (gridSerializingSession, displayedGroups, processGroupHeaderCallback) {\n        var _this = this;\n        var gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();\n        var columnIndex = 0;\n        displayedGroups.forEach(function (columnGroupChild) {\n            var columnGroup = columnGroupChild;\n            var name;\n            if (processGroupHeaderCallback) {\n                name = processGroupHeaderCallback({\n                    columnGroup: columnGroup,\n                    api: _this.gridOptionsWrapper.getApi(),\n                    columnApi: _this.gridOptionsWrapper.getColumnApi(),\n                    context: _this.gridOptionsWrapper.getContext()\n                });\n            }\n            else {\n                name = _this.columnController.getDisplayNameForColumnGroup(columnGroup, 'header');\n            }\n            gridRowIterator.onColumn(name || '', columnIndex++, columnGroup.getLeafColumns().length - 1);\n        });\n    };\n    __decorate$v([\n        agGridCommunity.Autowired('displayedGroupCreator')\n    ], GridSerializer.prototype, \"displayedGroupCreator\", void 0);\n    __decorate$v([\n        agGridCommunity.Autowired('columnController')\n    ], GridSerializer.prototype, \"columnController\", void 0);\n    __decorate$v([\n        agGridCommunity.Autowired('rowModel')\n    ], GridSerializer.prototype, \"rowModel\", void 0);\n    __decorate$v([\n        agGridCommunity.Autowired('pinnedRowModel')\n    ], GridSerializer.prototype, \"pinnedRowModel\", void 0);\n    __decorate$v([\n        agGridCommunity.Autowired('selectionController')\n    ], GridSerializer.prototype, \"selectionController\", void 0);\n    GridSerializer = __decorate$v([\n        agGridCommunity.Bean(\"gridSerializer\")\n    ], GridSerializer);\n    return GridSerializer;\n}(agGridCommunity.BeanStub));\nvar RowType;\n(function (RowType) {\n    RowType[RowType[\"HEADER_GROUPING\"] = 0] = \"HEADER_GROUPING\";\n    RowType[RowType[\"HEADER\"] = 1] = \"HEADER\";\n    RowType[RowType[\"BODY\"] = 2] = \"BODY\";\n})(RowType || (RowType = {}));\n\nvar __extends$w = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n// table for crc calculation\n// from: https://referencesource.microsoft.com/#System/sys/System/IO/compression/Crc32Helper.cs,3b31978c7d7f7246,references\nvar crcTable = [\n    0, 1996959894, -301047508, -1727442502, 124634137, 1886057615, -379345611, -1637575261, 249268274,\n    2044508324, -522852066, -1747789432, 162941995, 2125561021, -407360249, -1866523247, 498536548,\n    1789927666, -205950648, -2067906082, 450548861, 1843258603, -187386543, -2083289657, 325883990,\n    1684777152, -43845254, -1973040660, 335633487, 1661365465, -99664541, -1928851979, 997073096,\n    1281953886, -715111964, -1570279054, 1006888145, 1258607687, -770865667, -1526024853, 901097722,\n    1119000684, -608450090, -1396901568, 853044451, 1172266101, -589951537, -1412350631, 651767980,\n    1373503546, -925412992, -1076862698, 565507253, 1454621731, -809855591, -1195530993, 671266974,\n    1594198024, -972236366, -1324619484, 795835527, 1483230225, -1050600021, -1234817731, 1994146192,\n    31158534, -1731059524, -271249366, 1907459465, 112637215, -1614814043, -390540237, 2013776290,\n    251722036, -1777751922, -519137256, 2137656763, 141376813, -1855689577, -429695999, 1802195444,\n    476864866, -2056965928, -228458418, 1812370925, 453092731, -2113342271, -183516073, 1706088902,\n    314042704, -1950435094, -54949764, 1658658271, 366619977, -1932296973, -69972891, 1303535960,\n    984961486, -1547960204, -725929758, 1256170817, 1037604311, -1529756563, -740887301, 1131014506,\n    879679996, -1385723834, -631195440, 1141124467, 855842277, -1442165665, -586318647, 1342533948,\n    654459306, -1106571248, -921952122, 1466479909, 544179635, -1184443383, -832445281, 1591671054,\n    702138776, -1328506846, -942167884, 1504918807, 783551873, -1212326853, -1061524307, -306674912,\n    -1698712650, 62317068, 1957810842, -355121351, -1647151185, 81470997, 1943803523, -480048366,\n    -1805370492, 225274430, 2053790376, -468791541, -1828061283, 167816743, 2097651377, -267414716,\n    -2029476910, 503444072, 1762050814, -144550051, -2140837941, 426522225, 1852507879, -19653770,\n    -1982649376, 282753626, 1742555852, -105259153, -1900089351, 397917763, 1622183637, -690576408,\n    -1580100738, 953729732, 1340076626, -776247311, -1497606297, 1068828381, 1219638859, -670225446,\n    -1358292148, 906185462, 1090812512, -547295293, -1469587627, 829329135, 1181335161, -882789492,\n    -1134132454, 628085408, 1382605366, -871598187, -1156888829, 570562233, 1426400815, -977650754,\n    -1296233688, 733239954, 1555261956, -1026031705, -1244606671, 752459403, 1541320221, -1687895376,\n    -328994266, 1969922972, 40735498, -1677130071, -351390145, 1913087877, 83908371, -1782625662,\n    -491226604, 2075208622, 213261112, -1831694693, -438977011, 2094854071, 198958881, -2032938284,\n    -237706686, 1759359992, 534414190, -2118248755, -155638181, 1873836001, 414664567, -2012718362,\n    -15766928, 1711684554, 285281116, -1889165569, -127750551, 1634467795, 376229701, -1609899400,\n    -686959890, 1308918612, 956543938, -1486412191, -799009033, 1231636301, 1047427035, -1362007478,\n    -640263460, 1088359270, 936918000, -1447252397, -558129467, 1202900863, 817233897, -1111625188,\n    -893730166, 1404277552, 615818150, -1160759803, -841546093, 1423857449, 601450431, -1285129682,\n    -1000256840, 1567103746, 711928724, -1274298825, -1022587231, 1510334235, 755167117\n];\nvar ZipContainer = /** @class */ (function (_super) {\n    __extends$w(ZipContainer, _super);\n    function ZipContainer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.folders = [];\n        _this.files = [];\n        _this.addFolder = function (path) {\n            _this.folders.push({\n                path: path,\n                created: new Date()\n            });\n        };\n        return _this;\n    }\n    ZipContainer.prototype.addFolders = function (paths) {\n        paths.forEach(this.addFolder);\n    };\n    ZipContainer.prototype.addFile = function (path, content) {\n        this.files.push({\n            path: path,\n            created: new Date(),\n            content: content\n        });\n    };\n    ZipContainer.prototype.clearStream = function () {\n        this.folders = [];\n        this.files = [];\n    };\n    ZipContainer.prototype.getContent = function (mimeType) {\n        if (mimeType === void 0) { mimeType = 'application/zip'; }\n        var textOutput = this.buildFileStream();\n        var uInt8Output = this.buildUint8Array(textOutput);\n        this.clearStream();\n        return new Blob([uInt8Output], { type: mimeType });\n    };\n    ZipContainer.prototype.buildFileStream = function (fData) {\n        if (fData === void 0) { fData = ''; }\n        var totalFiles = this.folders.concat(this.files);\n        var len = totalFiles.length;\n        var foData = '';\n        var lL = 0;\n        var cL = 0;\n        for (var _i = 0, totalFiles_1 = totalFiles; _i < totalFiles_1.length; _i++) {\n            var currentFile = totalFiles_1[_i];\n            var _a = this.getHeader(currentFile, lL), fileHeader = _a.fileHeader, folderHeader = _a.folderHeader, content = _a.content;\n            lL += fileHeader.length + content.length;\n            cL += folderHeader.length;\n            fData += fileHeader + content;\n            foData += folderHeader;\n        }\n        var foEnd = this.buildFolderEnd(len, cL, lL);\n        return fData + foData + foEnd;\n    };\n    ZipContainer.prototype.getHeader = function (currentFile, offset) {\n        var content = currentFile.content, path = currentFile.path, created = currentFile.created;\n        var utf8_encode = agGridCommunity._.utf8_encode, decToHex = agGridCommunity._.decToHex;\n        var utfPath = utf8_encode(path);\n        var isUTF8 = utfPath !== path;\n        var time = this.convertTime(created);\n        var dt = this.convertDate(created);\n        var extraFields = '';\n        if (isUTF8) {\n            var uExtraFieldPath = decToHex(1, 1) + decToHex(this.getFromCrc32Table(utfPath), 4) + utfPath;\n            extraFields = \"\\x75\\x70\" + decToHex(uExtraFieldPath.length, 2) + uExtraFieldPath;\n        }\n        var header = '\\x0A\\x00' +\n            (isUTF8 ? '\\x00\\x08' : '\\x00\\x00') +\n            '\\x00\\x00' +\n            decToHex(time, 2) + // last modified time\n            decToHex(dt, 2) + // last modified date\n            decToHex(content ? this.getFromCrc32Table(content) : 0, 4) +\n            decToHex(content ? content.length : 0, 4) + // compressed size\n            decToHex(content ? content.length : 0, 4) + // uncompressed size\n            decToHex(utfPath.length, 2) + // file name length\n            decToHex(extraFields.length, 2); // extra field length\n        var fileHeader = 'PK\\x03\\x04' + header + utfPath + extraFields;\n        var folderHeader = 'PK\\x01\\x02' + // central header\n            '\\x14\\x00' +\n            header + // file header\n            '\\x00\\x00' +\n            '\\x00\\x00' +\n            '\\x00\\x00' +\n            (content ? '\\x00\\x00\\x00\\x00' : '\\x10\\x00\\x00\\x00') + // external file attributes\n            decToHex(offset, 4) + // relative offset of local header\n            utfPath + // file name\n            extraFields; // extra field\n        return { fileHeader: fileHeader, folderHeader: folderHeader, content: content || '' };\n    };\n    ZipContainer.prototype.buildFolderEnd = function (tLen, cLen, lLen) {\n        var decToHex = agGridCommunity._.decToHex;\n        return 'PK\\x05\\x06' + // central folder end\n            '\\x00\\x00' +\n            '\\x00\\x00' +\n            decToHex(tLen, 2) + // total number of entries in the central folder\n            decToHex(tLen, 2) + // total number of entries in the central folder\n            decToHex(cLen, 4) + // size of the central folder\n            decToHex(lLen, 4) + // central folder start offset\n            '\\x00\\x00';\n    };\n    ZipContainer.prototype.buildUint8Array = function (content) {\n        var uint8 = new Uint8Array(content.length);\n        for (var i = 0; i < uint8.length; i++) {\n            uint8[i] = content.charCodeAt(i);\n        }\n        return uint8;\n    };\n    ZipContainer.prototype.getFromCrc32Table = function (content, crc) {\n        if (crc === void 0) { crc = 0; }\n        if (!content.length) {\n            return 0;\n        }\n        crc ^= (-1);\n        var j = 0;\n        var k = 0;\n        var l = 0;\n        for (var i = 0; i < content.length; i++) {\n            j = content.charCodeAt(i);\n            k = (crc ^ j) & 0xFF;\n            l = crcTable[k];\n            crc = (crc >>> 8) ^ l;\n        }\n        return crc ^ (-1);\n    };\n    ZipContainer.prototype.convertTime = function (date) {\n        var time = date.getHours();\n        time <<= 6;\n        time = time | date.getMinutes();\n        time <<= 5;\n        time = time | date.getSeconds() / 2;\n        return time;\n    };\n    ZipContainer.prototype.convertDate = function (date) {\n        var dt = date.getFullYear() - 1980;\n        dt <<= 4;\n        dt = dt | (date.getMonth() + 1);\n        dt <<= 5;\n        dt = dt | date.getDate();\n        return dt;\n    };\n    ZipContainer = __decorate$w([\n        agGridCommunity.Bean('zipContainer')\n    ], ZipContainer);\n    return ZipContainer;\n}(agGridCommunity.BeanStub));\n\nvar CsvExportModule = {\n    moduleName: agGridCommunity.ModuleNames.CsvExportModule,\n    beans: [CsvCreator, Downloader, XmlFactory, GridSerializer, ZipContainer]\n};\n\nvar __extends$x = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays$2 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar ExcelXmlSerializingSession = /** @class */ (function (_super) {\n    __extends$x(ExcelXmlSerializingSession, _super);\n    function ExcelXmlSerializingSession(config) {\n        var _this = _super.call(this, config) || this;\n        _this.mixedStyles = {};\n        _this.mixedStyleCounter = 0;\n        _this.rows = [];\n        _this.config = agGridCommunity._.assign({}, config);\n        _this.stylesByIds = {};\n        _this.config.baseExcelStyles.forEach(function (style) {\n            _this.stylesByIds[style.id] = style;\n        });\n        _this.excelStyles = __spreadArrays$2(_this.config.baseExcelStyles);\n        return _this;\n    }\n    ExcelXmlSerializingSession.prototype.addCustomContent = function (customContent) {\n        var _this = this;\n        customContent.forEach(function (cells) { return _this.rows.push({ cells: cells }); });\n    };\n    ExcelXmlSerializingSession.prototype.prepare = function (columnsToExport) {\n        var _this = this;\n        _super.prototype.prepare.call(this, columnsToExport);\n        this.cols = columnsToExport.map(function (col, i) { return _this.convertColumnToExcel(col, i); });\n    };\n    ExcelXmlSerializingSession.prototype.onNewHeaderGroupingRow = function () {\n        var _this = this;\n        var currentCells = [];\n        this.rows.push({\n            cells: currentCells,\n            height: this.config.headerRowHeight\n        });\n        return {\n            onColumn: function (header, index, span) {\n                var styleIds = _this.config.styleLinker(RowType.HEADER_GROUPING, 1, index, \"grouping-\" + header, undefined, undefined);\n                currentCells.push(_this.createMergedCell((styleIds && styleIds.length > 0) ? styleIds[0] : undefined, \"String\", header, span));\n            }\n        };\n    };\n    ExcelXmlSerializingSession.prototype.onNewHeaderRow = function () {\n        return this.onNewRow(this.onNewHeaderColumn, this.config.headerRowHeight);\n    };\n    ExcelXmlSerializingSession.prototype.onNewBodyRow = function () {\n        return this.onNewRow(this.onNewBodyColumn, this.config.rowHeight);\n    };\n    ExcelXmlSerializingSession.prototype.onNewRow = function (onNewColumnAccumulator, height) {\n        var currentCells = [];\n        this.rows.push({\n            cells: currentCells,\n            height: height\n        });\n        return {\n            onColumn: onNewColumnAccumulator.bind(this, this.rows.length, currentCells)()\n        };\n    };\n    ExcelXmlSerializingSession.prototype.onNewHeaderColumn = function (rowIndex, currentCells) {\n        var _this = this;\n        return function (column, index) {\n            var nameForCol = _this.extractHeaderValue(column);\n            var styleIds = _this.config.styleLinker(RowType.HEADER, rowIndex, index, nameForCol, column, undefined);\n            currentCells.push(_this.createCell((styleIds && styleIds.length > 0) ? styleIds[0] : undefined, 'String', nameForCol));\n        };\n    };\n    ExcelXmlSerializingSession.prototype.parse = function () {\n        // adding custom content might have made some rows wider than the grid, so add new columns\n        var longestRow = this.rows.reduce(function (a, b) { return Math.max(a, b.cells.length); }, 0);\n        while (this.cols.length < longestRow) {\n            this.cols.push(this.convertColumnToExcel(null, this.cols.length + 1));\n        }\n        var data = [{\n                name: this.config.sheetName,\n                table: {\n                    columns: this.cols,\n                    rows: this.rows\n                }\n            }];\n        return this.createExcel(data);\n    };\n    ExcelXmlSerializingSession.prototype.createExcel = function (data) {\n        return this.config.excelFactory.createExcel(this.excelStyles, data, []);\n    };\n    ExcelXmlSerializingSession.prototype.onNewBodyColumn = function (rowIndex, currentCells) {\n        var _this = this;\n        return function (column, index, node) {\n            var valueForCell = _this.extractRowCellValue(column, index, agGridCommunity.Constants.EXPORT_TYPE_EXCEL, node);\n            var styleIds = _this.config.styleLinker(RowType.BODY, rowIndex, index, valueForCell, column, node);\n            var excelStyleId;\n            if (styleIds && styleIds.length == 1) {\n                excelStyleId = styleIds[0];\n            }\n            else if (styleIds && styleIds.length > 1) {\n                var key = styleIds.join(\"-\");\n                if (!_this.mixedStyles[key]) {\n                    _this.addNewMixedStyle(styleIds);\n                }\n                excelStyleId = _this.mixedStyles[key].excelID;\n            }\n            currentCells.push(_this.createCell(excelStyleId, _this.getDataTypeForValue(valueForCell), valueForCell));\n        };\n    };\n    ExcelXmlSerializingSession.prototype.getDataTypeForValue = function (valueForCell) {\n        return agGridCommunity._.isNumeric(valueForCell) ? 'Number' : 'String';\n    };\n    ExcelXmlSerializingSession.prototype.addNewMixedStyle = function (styleIds) {\n        var _this = this;\n        this.mixedStyleCounter += 1;\n        var excelId = 'mixedStyle' + this.mixedStyleCounter;\n        var resultantStyle = {};\n        styleIds.forEach(function (styleId) {\n            _this.excelStyles.forEach(function (excelStyle) {\n                if (excelStyle.id === styleId) {\n                    agGridCommunity._.mergeDeep(resultantStyle, agGridCommunity._.deepCloneObject(excelStyle));\n                }\n            });\n        });\n        resultantStyle.id = excelId;\n        resultantStyle.name = excelId;\n        var key = styleIds.join(\"-\");\n        this.mixedStyles[key] = {\n            excelID: excelId,\n            key: key,\n            result: resultantStyle\n        };\n        this.excelStyles.push(resultantStyle);\n        this.stylesByIds[excelId] = resultantStyle;\n    };\n    ExcelXmlSerializingSession.prototype.styleExists = function (styleId) {\n        if (styleId == null) {\n            return false;\n        }\n        return this.stylesByIds[styleId];\n    };\n    ExcelXmlSerializingSession.prototype.createCell = function (styleId, type, value) {\n        var _this = this;\n        var actualStyle = styleId && this.stylesByIds[styleId];\n        var styleExists = actualStyle !== undefined;\n        function getType() {\n            if (styleExists &&\n                actualStyle.dataType) {\n                switch (actualStyle.dataType) {\n                    case 'string':\n                        return 'String';\n                    case 'number':\n                        return 'Number';\n                    case 'dateTime':\n                        return 'DateTime';\n                    case 'error':\n                        return 'Error';\n                    case 'boolean':\n                        return 'Boolean';\n                    default:\n                        console.warn(\"ag-grid: Unrecognized data type for excel export [\" + actualStyle.id + \".dataType=\" + actualStyle.dataType + \"]\");\n                }\n            }\n            return type;\n        }\n        var typeTransformed = getType();\n        var massageText = function (val) {\n            if (_this.config.suppressTextAsCDATA) {\n                return agGridCommunity._.escapeString(val);\n            }\n            var cdataStart = '<![CDATA[';\n            var cdataEnd = ']]>';\n            var cdataEndRegex = new RegExp(cdataEnd, \"g\");\n            return cdataStart\n                // CDATA sections are closed by the character sequence ']]>' and there is no\n                // way of escaping this, so if the text contains the offending sequence, emit\n                // multiple CDATA sections and split the characters between them.\n                + String(val).replace(cdataEndRegex, ']]' + cdataEnd + cdataStart + '>')\n                + cdataEnd;\n        };\n        var convertBoolean = function (val) {\n            if (!val || val === '0' || val === 'false') {\n                return '0';\n            }\n            return '1';\n        };\n        return {\n            styleId: styleExists ? styleId : undefined,\n            data: {\n                type: typeTransformed,\n                value: typeTransformed === 'String' ? massageText(value) :\n                    typeTransformed === 'Number' ? Number(value).valueOf() + '' :\n                        typeTransformed === 'Boolean' ? convertBoolean(value) :\n                            value\n            }\n        };\n    };\n    ExcelXmlSerializingSession.prototype.createMergedCell = function (styleId, type, value, numOfCells) {\n        return {\n            styleId: this.styleExists(styleId) ? styleId : undefined,\n            data: {\n                type: type,\n                value: value\n            },\n            mergeAcross: numOfCells\n        };\n    };\n    ExcelXmlSerializingSession.prototype.convertColumnToExcel = function (column, index) {\n        var columnWidth = this.config.columnWidth;\n        if (columnWidth) {\n            if (typeof columnWidth === 'number') {\n                return { width: columnWidth };\n            }\n            else {\n                return { width: columnWidth({ column: column, index: index }) };\n            }\n        }\n        if (column) {\n            var smallestUsefulWidth = 75;\n            return { width: Math.max(column.getActualWidth(), smallestUsefulWidth) };\n        }\n        return {};\n    };\n    return ExcelXmlSerializingSession;\n}(BaseGridSerializingSession));\n\nvar __extends$y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ExcelXlsxSerializingSession = /** @class */ (function (_super) {\n    __extends$y(ExcelXlsxSerializingSession, _super);\n    function ExcelXlsxSerializingSession() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.stringList = [];\n        _this.stringMap = {};\n        return _this;\n    }\n    ExcelXlsxSerializingSession.prototype.onNewHeaderGroupingRow = function () {\n        var _this = this;\n        var currentCells = [];\n        this.rows.push({\n            cells: currentCells,\n            height: this.config.headerRowHeight\n        });\n        return {\n            onColumn: function (header, index, span) {\n                var styleIds = _this.config.styleLinker(RowType.HEADER_GROUPING, 1, index, \"grouping-\" + header, undefined, undefined);\n                currentCells.push(_this.createMergedCell((styleIds && styleIds.length > 0) ? styleIds[0] : undefined, 's', header, span));\n            }\n        };\n    };\n    ExcelXlsxSerializingSession.prototype.onNewHeaderColumn = function (rowIndex, currentCells) {\n        var _this = this;\n        return function (column, index, node) {\n            var nameForCol = _this.extractHeaderValue(column);\n            var styleIds = _this.config.styleLinker(RowType.HEADER, rowIndex, index, nameForCol, column, undefined);\n            currentCells.push(_this.createCell((styleIds && styleIds.length > 0) ? styleIds[0] : undefined, 's', nameForCol));\n        };\n    };\n    ExcelXlsxSerializingSession.prototype.createExcel = function (data) {\n        return this.config.excelFactory.createExcel(this.excelStyles, data, this.stringList);\n    };\n    ExcelXlsxSerializingSession.prototype.getDataTypeForValue = function (valueForCell) {\n        return agGridCommunity._.isNumeric(valueForCell) ? 'n' : 's';\n    };\n    ExcelXlsxSerializingSession.prototype.getStringPosition = function (val) {\n        var pos = this.stringMap[val];\n        if (pos === undefined) {\n            pos = this.stringMap[val] = this.stringList.length;\n            this.stringList.push(val);\n        }\n        return pos;\n    };\n    ExcelXlsxSerializingSession.prototype.createCell = function (styleId, type, value) {\n        var actualStyle = styleId && this.stylesByIds[styleId];\n        var styleExists = actualStyle !== undefined;\n        function getType() {\n            if (styleExists &&\n                actualStyle.dataType) {\n                switch (actualStyle.dataType) {\n                    case 'string':\n                        return 's';\n                    case 'number':\n                        return 'n';\n                    case 'dateTime':\n                        return 'd';\n                    case 'error':\n                        return 'e';\n                    case 'boolean':\n                        return 'b';\n                    default:\n                        console.warn(\"ag-grid: Unrecognized data type for excel export [\" + actualStyle.id + \".dataType=\" + actualStyle.dataType + \"]\");\n                }\n            }\n            return type;\n        }\n        var typeTransformed = getType();\n        return {\n            styleId: styleExists ? styleId : undefined,\n            data: {\n                type: typeTransformed,\n                value: typeTransformed === 's'\n                    ? this.getStringPosition(value == null ? '' : value).toString()\n                    : typeTransformed === 'n'\n                        ? Number(value).toString()\n                        : value\n            }\n        };\n    };\n    ExcelXlsxSerializingSession.prototype.createMergedCell = function (styleId, type, value, numOfCells) {\n        return {\n            styleId: this.styleExists(styleId) ? styleId : undefined,\n            data: {\n                type: type,\n                value: type === 's' ? this.getStringPosition(value == null ? '' : value).toString() : value\n            },\n            mergeAcross: numOfCells\n        };\n    };\n    return ExcelXlsxSerializingSession;\n}(ExcelXmlSerializingSession));\n\nvar __extends$z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __decorate$x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ExcelCreator = /** @class */ (function (_super) {\n    __extends$z(ExcelCreator, _super);\n    function ExcelCreator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ExcelCreator.prototype.postConstruct = function () {\n        this.setBeans({\n            downloader: this.downloader,\n            gridSerializer: this.gridSerializer,\n            gridOptionsWrapper: this.gridOptionsWrapper\n        });\n    };\n    ExcelCreator.prototype.exportDataAsExcel = function (params) {\n        this.setExportMode(params ? params.exportMode : undefined);\n        return this.export(params);\n    };\n    ExcelCreator.prototype.getDataAsExcel = function (params) {\n        var data = this.getData(params || {});\n        if (params && params.exportMode === 'xml') {\n            return data;\n        }\n        return this.packageFile(data);\n    };\n    ExcelCreator.prototype.getMimeType = function () {\n        return this.getExportMode() === 'xml' ? 'application/vnd.ms-excel' : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n    };\n    ExcelCreator.prototype.getDefaultFileName = function () {\n        return \"export.\" + this.getExportMode();\n    };\n    ExcelCreator.prototype.getDefaultFileExtension = function () {\n        return this.getExportMode();\n    };\n    ExcelCreator.prototype.createSerializingSession = function (params) {\n        var _a = this, columnController = _a.columnController, valueService = _a.valueService, gridOptionsWrapper = _a.gridOptionsWrapper;\n        var isXlsx = this.getExportMode() === 'xlsx';\n        var excelFactory = isXlsx ? this.xlsxFactory : this.excelXmlFactory;\n        var sheetName = 'ag-grid';\n        if (agGridCommunity._.exists(params.sheetName)) {\n            sheetName = agGridCommunity._.utf8_encode(params.sheetName.toString().substr(0, 31));\n        }\n        var config = __assign(__assign({}, params), { columnController: columnController,\n            valueService: valueService,\n            gridOptionsWrapper: gridOptionsWrapper, headerRowHeight: params.headerRowHeight || params.rowHeight, sheetName: sheetName,\n            excelFactory: excelFactory, baseExcelStyles: this.gridOptions.excelStyles || [], styleLinker: this.styleLinker.bind(this) });\n        return new (isXlsx ? ExcelXlsxSerializingSession : ExcelXmlSerializingSession)((config));\n    };\n    ExcelCreator.prototype.styleLinker = function (rowType, rowIndex, colIndex, value, column, node) {\n        if ((rowType === RowType.HEADER) || (rowType === RowType.HEADER_GROUPING)) {\n            return [\"header\"];\n        }\n        var styles = this.gridOptions.excelStyles;\n        if (!styles || !styles.length) {\n            return null;\n        }\n        var styleIds = styles.map(function (it) {\n            return it.id;\n        });\n        var applicableStyles = [];\n        this.stylingService.processAllCellClasses(column.getColDef(), {\n            value: value,\n            data: node.data,\n            node: node,\n            colDef: column.getColDef(),\n            rowIndex: rowIndex,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi(),\n            $scope: null,\n            context: this.gridOptionsWrapper.getContext()\n        }, function (className) {\n            if (styleIds.indexOf(className) > -1) {\n                applicableStyles.push(className);\n            }\n        });\n        return applicableStyles.sort(function (left, right) {\n            return (styleIds.indexOf(left) < styleIds.indexOf(right)) ? -1 : 1;\n        });\n    };\n    ExcelCreator.prototype.isExportSuppressed = function () {\n        return this.gridOptionsWrapper.isSuppressExcelExport();\n    };\n    ExcelCreator.prototype.setExportMode = function (exportMode) {\n        this.exportMode = exportMode;\n    };\n    ExcelCreator.prototype.getExportMode = function () {\n        return this.exportMode || 'xlsx';\n    };\n    ExcelCreator.prototype.packageFile = function (data) {\n        if (this.getExportMode() === 'xml') {\n            return _super.prototype.packageFile.call(this, data);\n        }\n        var _a = this, zipContainer = _a.zipContainer, xlsxFactory = _a.xlsxFactory;\n        zipContainer.addFolders([\n            'xl/worksheets/',\n            'xl/',\n            'xl/theme/',\n            'xl/_rels/',\n            'docProps/',\n            '_rels/'\n        ]);\n        zipContainer.addFile('xl/worksheets/sheet1.xml', data);\n        zipContainer.addFile('xl/workbook.xml', xlsxFactory.createWorkbook());\n        zipContainer.addFile('xl/styles.xml', xlsxFactory.createStylesheet());\n        zipContainer.addFile('xl/sharedStrings.xml', xlsxFactory.createSharedStrings());\n        zipContainer.addFile('xl/theme/theme1.xml', xlsxFactory.createTheme());\n        zipContainer.addFile('xl/_rels/workbook.xml.rels', xlsxFactory.createWorkbookRels());\n        zipContainer.addFile('docProps/core.xml', xlsxFactory.createCore());\n        zipContainer.addFile('[Content_Types].xml', xlsxFactory.createContentTypes());\n        zipContainer.addFile('_rels/.rels', xlsxFactory.createRels());\n        return zipContainer.getContent('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n    };\n    __decorate$x([\n        agGridCommunity.Autowired('excelXmlFactory')\n    ], ExcelCreator.prototype, \"excelXmlFactory\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('excelXlsxFactory')\n    ], ExcelCreator.prototype, \"xlsxFactory\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('columnController')\n    ], ExcelCreator.prototype, \"columnController\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('valueService')\n    ], ExcelCreator.prototype, \"valueService\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('gridOptions')\n    ], ExcelCreator.prototype, \"gridOptions\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('stylingService')\n    ], ExcelCreator.prototype, \"stylingService\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('downloader')\n    ], ExcelCreator.prototype, \"downloader\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('gridSerializer')\n    ], ExcelCreator.prototype, \"gridSerializer\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('gridOptionsWrapper')\n    ], ExcelCreator.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate$x([\n        agGridCommunity.Autowired('zipContainer')\n    ], ExcelCreator.prototype, \"zipContainer\", void 0);\n    __decorate$x([\n        agGridCommunity.PostConstruct\n    ], ExcelCreator.prototype, \"postConstruct\", null);\n    ExcelCreator = __decorate$x([\n        agGridCommunity.Bean('excelCreator')\n    ], ExcelCreator);\n    return ExcelCreator;\n}(BaseCreator));\n\nvar ExcelExportModule = {\n    moduleName: agGridCommunity.ModuleNames.ExcelExportModule,\n    beans: [\n        // beans in this module\n        ExcelCreator, ExcelXmlFactory, ExcelXlsxFactory,\n        // these beans are part of CSV Export module\n        GridSerializer, ZipContainer, XmlFactory, Downloader, CsvCreator\n    ],\n    dependantModules: [\n        CsvExportModule,\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$A = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar EXPAND_STATE;\n(function (EXPAND_STATE) {\n    EXPAND_STATE[EXPAND_STATE[\"EXPANDED\"] = 0] = \"EXPANDED\";\n    EXPAND_STATE[EXPAND_STATE[\"COLLAPSED\"] = 1] = \"COLLAPSED\";\n    EXPAND_STATE[EXPAND_STATE[\"INDETERMINATE\"] = 2] = \"INDETERMINATE\";\n})(EXPAND_STATE || (EXPAND_STATE = {}));\nvar FiltersToolPanelHeaderPanel = /** @class */ (function (_super) {\n    __extends$A(FiltersToolPanelHeaderPanel, _super);\n    function FiltersToolPanelHeaderPanel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FiltersToolPanelHeaderPanel.prototype.preConstruct = function () {\n        this.setTemplate(/* html */ \"<div class=\\\"ag-filter-toolpanel-search\\\" role=\\\"presentation\\\">\\n                <div ref=\\\"eExpand\\\" class=\\\"ag-filter-toolpanel-expand\\\"></div>\\n                <ag-input-text-field ref=\\\"eFilterTextField\\\" class=\\\"ag-filter-toolpanel-search-input\\\"></ag-input-text-field>\\n            </div>\");\n    };\n    FiltersToolPanelHeaderPanel.prototype.postConstruct = function () {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eFilterTextField.onValueChange(this.onSearchTextChanged.bind(this));\n        this.eFilterTextField.setInputAriaLabel(translate('ariaSearch', 'Search'));\n        this.createExpandIcons();\n        this.setExpandState(EXPAND_STATE.EXPANDED);\n        this.addManagedListener(this.eExpand, 'click', this.onExpandClicked.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));\n    };\n    FiltersToolPanelHeaderPanel.prototype.init = function (params) {\n        this.params = params;\n        if (this.columnController.isReady()) {\n            this.showOrHideOptions();\n        }\n    };\n    FiltersToolPanelHeaderPanel.prototype.createExpandIcons = function () {\n        this.eExpand.appendChild(this.eExpandChecked = agGridCommunity._.createIconNoSpan('columnSelectOpen', this.gridOptionsWrapper));\n        this.eExpand.appendChild(this.eExpandUnchecked = agGridCommunity._.createIconNoSpan('columnSelectClosed', this.gridOptionsWrapper));\n        this.eExpand.appendChild(this.eExpandIndeterminate = agGridCommunity._.createIconNoSpan('columnSelectIndeterminate', this.gridOptionsWrapper));\n    };\n    // we only show expand / collapse if we are showing filters\n    FiltersToolPanelHeaderPanel.prototype.showOrHideOptions = function () {\n        var showFilterSearch = !this.params.suppressFilterSearch;\n        var showExpand = !this.params.suppressExpandAll;\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));\n        var isFilterGroupPresent = function (col) { return col.getOriginalParent() && col.isFilterAllowed(); };\n        var filterGroupsPresent = this.columnController.getAllGridColumns().some(isFilterGroupPresent);\n        agGridCommunity._.setDisplayed(this.eFilterTextField.getGui(), showFilterSearch);\n        agGridCommunity._.setDisplayed(this.eExpand, showExpand && filterGroupsPresent);\n    };\n    FiltersToolPanelHeaderPanel.prototype.onSearchTextChanged = function () {\n        var _this = this;\n        if (!this.onSearchTextChangedDebounced) {\n            this.onSearchTextChangedDebounced = agGridCommunity._.debounce(function () {\n                _this.dispatchEvent({ type: 'searchChanged', searchText: _this.eFilterTextField.getValue() });\n            }, 300);\n        }\n        this.onSearchTextChangedDebounced();\n    };\n    FiltersToolPanelHeaderPanel.prototype.onExpandClicked = function () {\n        var event = this.currentExpandState === EXPAND_STATE.EXPANDED ? { type: 'collapseAll' } : { type: 'expandAll' };\n        this.dispatchEvent(event);\n    };\n    FiltersToolPanelHeaderPanel.prototype.setExpandState = function (state) {\n        this.currentExpandState = state;\n        agGridCommunity._.setDisplayed(this.eExpandChecked, this.currentExpandState === EXPAND_STATE.EXPANDED);\n        agGridCommunity._.setDisplayed(this.eExpandUnchecked, this.currentExpandState === EXPAND_STATE.COLLAPSED);\n        agGridCommunity._.setDisplayed(this.eExpandIndeterminate, this.currentExpandState === EXPAND_STATE.INDETERMINATE);\n    };\n    __decorate$y([\n        agGridCommunity.Autowired('columnController')\n    ], FiltersToolPanelHeaderPanel.prototype, \"columnController\", void 0);\n    __decorate$y([\n        agGridCommunity.RefSelector('eExpand')\n    ], FiltersToolPanelHeaderPanel.prototype, \"eExpand\", void 0);\n    __decorate$y([\n        agGridCommunity.RefSelector('eFilterTextField')\n    ], FiltersToolPanelHeaderPanel.prototype, \"eFilterTextField\", void 0);\n    __decorate$y([\n        agGridCommunity.PreConstruct\n    ], FiltersToolPanelHeaderPanel.prototype, \"preConstruct\", null);\n    __decorate$y([\n        agGridCommunity.PostConstruct\n    ], FiltersToolPanelHeaderPanel.prototype, \"postConstruct\", null);\n    return FiltersToolPanelHeaderPanel;\n}(agGridCommunity.Component));\n\nvar __extends$B = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelFilterComp = /** @class */ (function (_super) {\n    __extends$B(ToolPanelFilterComp, _super);\n    function ToolPanelFilterComp(hideHeader) {\n        if (hideHeader === void 0) { hideHeader = false; }\n        var _this = _super.call(this, ToolPanelFilterComp.TEMPLATE) || this;\n        _this.expanded = false;\n        _this.hideHeader = hideHeader;\n        return _this;\n    }\n    ToolPanelFilterComp.prototype.postConstruct = function () {\n        this.eExpandChecked = agGridCommunity._.createIconNoSpan('columnSelectOpen', this.gridOptionsWrapper);\n        this.eExpandUnchecked = agGridCommunity._.createIconNoSpan('columnSelectClosed', this.gridOptionsWrapper);\n        this.eExpand.appendChild(this.eExpandChecked);\n        this.eExpand.appendChild(this.eExpandUnchecked);\n    };\n    ToolPanelFilterComp.prototype.setColumn = function (column) {\n        var _this = this;\n        this.column = column;\n        this.eFilterName.innerText = this.columnController.getDisplayNameForColumn(this.column, 'filterToolPanel', false) || '';\n        this.addManagedListener(this.eFilterToolPanelHeader, 'click', this.toggleExpanded.bind(this));\n        this.addManagedListener(this.eFilterToolPanelHeader, 'keydown', function (e) {\n            if (e.keyCode === agGridCommunity.KeyCode.ENTER) {\n                _this.toggleExpanded();\n            }\n        });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this));\n        this.addInIcon('filter', this.eFilterIcon, this.column);\n        agGridCommunity._.addOrRemoveCssClass(this.eFilterIcon, 'ag-hidden', !this.isFilterActive());\n        agGridCommunity._.addCssClass(this.eExpandChecked, 'ag-hidden');\n        if (this.hideHeader) {\n            agGridCommunity._.addOrRemoveCssClass(this.eFilterToolPanelHeader, 'ag-hidden', true);\n            this.eFilterToolPanelHeader.removeAttribute('tabindex');\n        }\n        else {\n            this.eFilterToolPanelHeader.setAttribute('tabindex', '0');\n        }\n        this.addManagedListener(this.column, agGridCommunity.Column.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    };\n    ToolPanelFilterComp.prototype.getColumn = function () {\n        return this.column;\n    };\n    ToolPanelFilterComp.prototype.getColumnFilterName = function () {\n        return this.columnController.getDisplayNameForColumn(this.column, 'filterToolPanel', false);\n    };\n    ToolPanelFilterComp.prototype.addCssClassToTitleBar = function (cssClass) {\n        agGridCommunity._.addCssClass(this.eFilterToolPanelHeader, cssClass);\n    };\n    ToolPanelFilterComp.prototype.addInIcon = function (iconName, eParent, column) {\n        if (eParent == null) {\n            return;\n        }\n        var eIcon = agGridCommunity._.createIconNoSpan(iconName, this.gridOptionsWrapper, column);\n        eParent.appendChild(eIcon);\n    };\n    ToolPanelFilterComp.prototype.isFilterActive = function () {\n        return this.filterManager.isFilterActive(this.column);\n    };\n    ToolPanelFilterComp.prototype.onFilterChanged = function () {\n        agGridCommunity._.addOrRemoveCssClass(this.eFilterIcon, 'ag-hidden', !this.isFilterActive());\n        this.dispatchEvent({ type: agGridCommunity.Column.EVENT_FILTER_CHANGED });\n    };\n    ToolPanelFilterComp.prototype.toggleExpanded = function () {\n        this.expanded ? this.collapse() : this.expand();\n    };\n    ToolPanelFilterComp.prototype.expand = function () {\n        var _this = this;\n        if (this.expanded) {\n            return;\n        }\n        this.expanded = true;\n        var container = agGridCommunity._.loadTemplate(/* html */ \"<div class=\\\"ag-filter-toolpanel-instance-filter\\\"></div>\");\n        var filterPromise = this.filterManager.getOrCreateFilterWrapper(this.column, 'TOOLBAR').filterPromise;\n        if (filterPromise) {\n            filterPromise.then(function (filter) {\n                _this.underlyingFilter = filter;\n                if (!filter) {\n                    return;\n                }\n                container.appendChild(filter.getGui());\n                _this.agFilterToolPanelBody.appendChild(container);\n                if (filter.afterGuiAttached) {\n                    filter.afterGuiAttached({ container: 'toolPanel' });\n                }\n            });\n        }\n        agGridCommunity._.setDisplayed(this.eExpandChecked, true);\n        agGridCommunity._.setDisplayed(this.eExpandUnchecked, false);\n    };\n    ToolPanelFilterComp.prototype.collapse = function () {\n        if (!this.expanded) {\n            return;\n        }\n        this.expanded = false;\n        this.agFilterToolPanelBody.removeChild(this.agFilterToolPanelBody.children[0]);\n        agGridCommunity._.setDisplayed(this.eExpandChecked, false);\n        agGridCommunity._.setDisplayed(this.eExpandUnchecked, true);\n    };\n    ToolPanelFilterComp.prototype.refreshFilter = function () {\n        if (!this.expanded) {\n            return;\n        }\n        var filter = this.underlyingFilter;\n        if (!filter) {\n            return;\n        }\n        // set filters should be updated when the filter has been changed elsewhere, i.e. via api. Note that we can't\n        // use 'afterGuiAttached' to refresh the virtual list as it also focuses on the mini filter which changes the\n        // scroll position in the filter list panel\n        if (typeof filter.refreshVirtualList === 'function') {\n            filter.refreshVirtualList();\n        }\n    };\n    ToolPanelFilterComp.prototype.onFilterOpened = function (event) {\n        if (event.source !== 'COLUMN_MENU') {\n            return;\n        }\n        if (event.column !== this.column) {\n            return;\n        }\n        if (!this.expanded) {\n            return;\n        }\n        this.collapse();\n    };\n    ToolPanelFilterComp.TEMPLATE = \"\\n        <div class=\\\"ag-filter-toolpanel-instance\\\">\\n            <div class=\\\"ag-filter-toolpanel-header ag-filter-toolpanel-instance-header\\\" ref=\\\"eFilterToolPanelHeader\\\">\\n                <div ref=\\\"eExpand\\\" class=\\\"ag-filter-toolpanel-expand\\\"></div>\\n                <span ref=\\\"eFilterName\\\" class=\\\"ag-header-cell-text\\\"></span>\\n                <span ref=\\\"eFilterIcon\\\" class=\\\"ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon\\\" aria-hidden=\\\"true\\\"></span>\\n            </div>\\n            <div class=\\\"ag-filter-toolpanel-instance-body ag-filter\\\" ref=\\\"agFilterToolPanelBody\\\"></div>\\n        </div>\";\n    __decorate$z([\n        agGridCommunity.RefSelector('eFilterToolPanelHeader')\n    ], ToolPanelFilterComp.prototype, \"eFilterToolPanelHeader\", void 0);\n    __decorate$z([\n        agGridCommunity.RefSelector('eFilterName')\n    ], ToolPanelFilterComp.prototype, \"eFilterName\", void 0);\n    __decorate$z([\n        agGridCommunity.RefSelector('agFilterToolPanelBody')\n    ], ToolPanelFilterComp.prototype, \"agFilterToolPanelBody\", void 0);\n    __decorate$z([\n        agGridCommunity.RefSelector('eFilterIcon')\n    ], ToolPanelFilterComp.prototype, \"eFilterIcon\", void 0);\n    __decorate$z([\n        agGridCommunity.RefSelector('eExpand')\n    ], ToolPanelFilterComp.prototype, \"eExpand\", void 0);\n    __decorate$z([\n        agGridCommunity.Autowired('filterManager')\n    ], ToolPanelFilterComp.prototype, \"filterManager\", void 0);\n    __decorate$z([\n        agGridCommunity.Autowired('columnController')\n    ], ToolPanelFilterComp.prototype, \"columnController\", void 0);\n    __decorate$z([\n        agGridCommunity.PostConstruct\n    ], ToolPanelFilterComp.prototype, \"postConstruct\", null);\n    return ToolPanelFilterComp;\n}(agGridCommunity.Component));\n\nvar __extends$C = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ToolPanelFilterGroupComp = /** @class */ (function (_super) {\n    __extends$C(ToolPanelFilterGroupComp, _super);\n    function ToolPanelFilterGroupComp(columnGroup, childFilterComps, expandedCallback, depth, showingColumn) {\n        var _this = _super.call(this) || this;\n        _this.columnGroup = columnGroup;\n        _this.childFilterComps = childFilterComps;\n        _this.depth = depth;\n        _this.expandedCallback = expandedCallback;\n        _this.showingColumn = showingColumn;\n        return _this;\n    }\n    ToolPanelFilterGroupComp.prototype.preConstruct = function () {\n        var groupParams = {\n            cssIdentifier: 'filter-toolpanel',\n            direction: 'vertical'\n        };\n        this.setTemplate(ToolPanelFilterGroupComp.TEMPLATE, { filterGroupComp: groupParams });\n    };\n    ToolPanelFilterGroupComp.prototype.init = function () {\n        var _this = this;\n        this.setGroupTitle();\n        this.filterGroupComp.setAlignItems('stretch');\n        agGridCommunity._.addCssClass(this.filterGroupComp.getGui(), \"ag-filter-toolpanel-group-level-\" + this.depth);\n        this.filterGroupComp.addCssClassToTitleBar(\"ag-filter-toolpanel-group-level-\" + this.depth + \"-header\");\n        this.childFilterComps.forEach(function (filterComp) {\n            _this.filterGroupComp.addItem(filterComp);\n            filterComp.addCssClassToTitleBar(\"ag-filter-toolpanel-group-level-\" + (_this.depth + 1) + \"-header\");\n        });\n        this.addExpandCollapseListeners();\n        this.addFilterChangedListeners();\n        this.setupTooltip();\n    };\n    ToolPanelFilterGroupComp.prototype.setupTooltip = function () {\n        var _this = this;\n        // we don't show tooltips for groups, as when the group expands, it's div contains the columns which also\n        // have tooltips, so the tooltips would clash. Eg mouse over group, tooltip shows, mouse over column, another\n        // tooltip shows but cos we didn't leave the group the group tooltip remains. this should be fixed in the future,\n        // maye the group shouldn't contain the children form a DOM perspective.\n        if (!this.showingColumn) {\n            return;\n        }\n        var refresh = function () {\n            var newTooltipText = _this.columnGroup.getColDef().headerTooltip;\n            _this.setTooltip(newTooltipText);\n        };\n        refresh();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, refresh);\n    };\n    ToolPanelFilterGroupComp.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'filterToolPanelColumnGroup';\n        return res;\n    };\n    ToolPanelFilterGroupComp.prototype.addCssClassToTitleBar = function (cssClass) {\n        this.filterGroupComp.addCssClassToTitleBar(cssClass);\n    };\n    ToolPanelFilterGroupComp.prototype.refreshFilters = function () {\n        this.childFilterComps.forEach(function (filterComp) {\n            if (filterComp instanceof ToolPanelFilterGroupComp) {\n                filterComp.refreshFilters();\n            }\n            else {\n                filterComp.refreshFilter();\n            }\n        });\n    };\n    ToolPanelFilterGroupComp.prototype.isColumnGroup = function () {\n        return this.columnGroup instanceof agGridCommunity.OriginalColumnGroup;\n    };\n    ToolPanelFilterGroupComp.prototype.isExpanded = function () {\n        return this.filterGroupComp.isExpanded();\n    };\n    ToolPanelFilterGroupComp.prototype.getChildren = function () {\n        return this.childFilterComps;\n    };\n    ToolPanelFilterGroupComp.prototype.getFilterGroupName = function () {\n        return this.filterGroupName ? this.filterGroupName : '';\n    };\n    ToolPanelFilterGroupComp.prototype.getFilterGroupId = function () {\n        return this.columnGroup.getId();\n    };\n    ToolPanelFilterGroupComp.prototype.hideGroupItem = function (hide, index) {\n        this.filterGroupComp.hideItem(hide, index);\n    };\n    ToolPanelFilterGroupComp.prototype.hideGroup = function (hide) {\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-hidden', hide);\n    };\n    ToolPanelFilterGroupComp.prototype.forEachToolPanelFilterChild = function (action) {\n        agGridCommunity._.forEach(this.childFilterComps, function (filterComp) {\n            if (filterComp instanceof ToolPanelFilterComp) {\n                action(filterComp);\n            }\n        });\n    };\n    ToolPanelFilterGroupComp.prototype.addExpandCollapseListeners = function () {\n        var _this = this;\n        var expandListener = this.isColumnGroup() ?\n            function () { return _this.expandedCallback(); } :\n            function () { return _this.forEachToolPanelFilterChild(function (filterComp) { return filterComp.expand(); }); };\n        var collapseListener = this.isColumnGroup() ?\n            function () { return _this.expandedCallback(); } :\n            function () { return _this.forEachToolPanelFilterChild(function (filterComp) { return filterComp.collapse(); }); };\n        this.addManagedListener(this.filterGroupComp, agGridCommunity.AgGroupComponent.EVENT_EXPANDED, expandListener);\n        this.addManagedListener(this.filterGroupComp, agGridCommunity.AgGroupComponent.EVENT_COLLAPSED, collapseListener);\n    };\n    ToolPanelFilterGroupComp.prototype.addFilterChangedListeners = function () {\n        var _this = this;\n        if (this.columnGroup instanceof agGridCommunity.OriginalColumnGroup) {\n            var group_1 = this.columnGroup;\n            var anyChildFiltersActive_1 = function () { return group_1.getLeafColumns().some(function (col) { return col.isFilterActive(); }); };\n            group_1.getLeafColumns().forEach(function (column) {\n                _this.addManagedListener(column, agGridCommunity.Column.EVENT_FILTER_CHANGED, function () {\n                    agGridCommunity._.addOrRemoveCssClass(_this.filterGroupComp.getGui(), 'ag-has-filter', anyChildFiltersActive_1());\n                });\n            });\n        }\n        else {\n            var column_1 = this.columnGroup;\n            this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this));\n            this.addManagedListener(column_1, agGridCommunity.Column.EVENT_FILTER_CHANGED, function () {\n                agGridCommunity._.addOrRemoveCssClass(_this.filterGroupComp.getGui(), 'ag-has-filter', column_1.isFilterActive());\n            });\n        }\n    };\n    ToolPanelFilterGroupComp.prototype.onFilterOpened = function (event) {\n        // when a filter is opened elsewhere, i.e. column menu we close the filter comp so we also need to collapse\n        // the column group. This approach means we don't need to try and sync filter models on the same column.\n        if (event.source !== 'COLUMN_MENU') {\n            return;\n        }\n        if (event.column !== this.columnGroup) {\n            return;\n        }\n        if (!this.isExpanded()) {\n            return;\n        }\n        this.collapse();\n    };\n    ToolPanelFilterGroupComp.prototype.expand = function () {\n        this.filterGroupComp.toggleGroupExpand(true);\n    };\n    ToolPanelFilterGroupComp.prototype.collapse = function () {\n        this.filterGroupComp.toggleGroupExpand(false);\n    };\n    ToolPanelFilterGroupComp.prototype.setGroupTitle = function () {\n        this.filterGroupName = (this.columnGroup instanceof agGridCommunity.OriginalColumnGroup) ?\n            this.getColumnGroupName(this.columnGroup) : this.getColumnName(this.columnGroup);\n        this.filterGroupComp.setTitle(this.filterGroupName || '');\n    };\n    ToolPanelFilterGroupComp.prototype.getColumnGroupName = function (columnGroup) {\n        return this.columnController.getDisplayNameForOriginalColumnGroup(null, columnGroup, 'filterToolPanel');\n    };\n    ToolPanelFilterGroupComp.prototype.getColumnName = function (column) {\n        return this.columnController.getDisplayNameForColumn(column, 'filterToolPanel', false);\n    };\n    ToolPanelFilterGroupComp.prototype.destroyFilters = function () {\n        this.childFilterComps = this.destroyBeans(this.childFilterComps);\n        agGridCommunity._.clearElement(this.getGui());\n    };\n    ToolPanelFilterGroupComp.prototype.destroy = function () {\n        this.destroyFilters();\n        _super.prototype.destroy.call(this);\n    };\n    ToolPanelFilterGroupComp.TEMPLATE = \"<div class=\\\"ag-filter-toolpanel-group-wrapper\\\">\\n            <ag-group-component ref=\\\"filterGroupComp\\\"></ag-group-component>\\n        </div>\";\n    __decorate$A([\n        agGridCommunity.RefSelector('filterGroupComp')\n    ], ToolPanelFilterGroupComp.prototype, \"filterGroupComp\", void 0);\n    __decorate$A([\n        agGridCommunity.Autowired('columnController')\n    ], ToolPanelFilterGroupComp.prototype, \"columnController\", void 0);\n    __decorate$A([\n        agGridCommunity.PreConstruct\n    ], ToolPanelFilterGroupComp.prototype, \"preConstruct\", null);\n    __decorate$A([\n        agGridCommunity.PostConstruct\n    ], ToolPanelFilterGroupComp.prototype, \"init\", null);\n    return ToolPanelFilterGroupComp;\n}(agGridCommunity.Component));\n\nvar __extends$D = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FiltersToolPanelListPanel = /** @class */ (function (_super) {\n    __extends$D(FiltersToolPanelListPanel, _super);\n    function FiltersToolPanelListPanel() {\n        var _this = _super.call(this, FiltersToolPanelListPanel.TEMPLATE) || this;\n        _this.initialised = false;\n        _this.filterGroupComps = [];\n        return _this;\n    }\n    FiltersToolPanelListPanel.prototype.init = function (params) {\n        var _this = this;\n        this.initialised = true;\n        var defaultParams = {\n            suppressExpandAll: false,\n            suppressFilterSearch: false,\n            suppressSyncLayoutWithGrid: false,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        agGridCommunity._.mergeDeep(defaultParams, params);\n        this.params = defaultParams;\n        if (!this.params.suppressSyncLayoutWithGrid) {\n            this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_MOVED, function () { return _this.onColumnsChanged(); });\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, function () { return _this.onColumnsChanged(); });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED, function (event) {\n            // when re-entering the filters tool panel we need to refresh the virtual lists in the set filters in case\n            // filters have been changed elsewhere, i.e. via an api call.\n            if (event.source === 'filters') {\n                _this.refreshFilters();\n            }\n        });\n        if (this.columnController.isReady()) {\n            this.onColumnsChanged();\n        }\n    };\n    FiltersToolPanelListPanel.prototype.onColumnsChanged = function () {\n        var pivotModeActive = this.columnController.isPivotMode();\n        var shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;\n        shouldSyncColumnLayoutWithGrid ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs();\n    };\n    FiltersToolPanelListPanel.prototype.syncFilterLayout = function () {\n        this.toolPanelColDefService.syncLayoutWithGrid(this.setFiltersLayout.bind(this));\n    };\n    FiltersToolPanelListPanel.prototype.buildTreeFromProvidedColumnDefs = function () {\n        var _this = this;\n        this.destroyFilters();\n        var columnTree = this.columnController.getPrimaryColumnTree();\n        this.filterGroupComps = this.recursivelyAddComps(columnTree, 0);\n        var len = this.filterGroupComps.length;\n        if (len) {\n            this.filterGroupComps.forEach(function (comp) { return _this.appendChild(comp); });\n            this.setFirstAndLastVisible(0, len - 1);\n        }\n        // perform search if searchFilterText exists\n        if (agGridCommunity._.exists(this.searchFilterText)) {\n            this.searchFilters(this.searchFilterText);\n        }\n        // notify header of expand\n        this.fireExpandedEvent();\n    };\n    FiltersToolPanelListPanel.prototype.setFiltersLayout = function (colDefs) {\n        var _this = this;\n        this.destroyFilters();\n        var columnTree = this.toolPanelColDefService.createColumnTree(colDefs);\n        this.filterGroupComps = this.recursivelyAddComps(columnTree, 0);\n        var len = this.filterGroupComps.length;\n        if (len) {\n            this.filterGroupComps.forEach(function (comp) { return _this.appendChild(comp); });\n            this.setFirstAndLastVisible(0, len - 1);\n        }\n        // perform search if searchFilterText exists\n        if (agGridCommunity._.exists(this.searchFilterText)) {\n            this.searchFilters(this.searchFilterText);\n        }\n        // notify header of expand\n        this.fireExpandedEvent();\n    };\n    FiltersToolPanelListPanel.prototype.recursivelyAddComps = function (tree, depth) {\n        var _this = this;\n        return agGridCommunity._.flatten(tree.map(function (child) {\n            if (child instanceof agGridCommunity.OriginalColumnGroup) {\n                return agGridCommunity._.flatten(_this.recursivelyAddFilterGroupComps(child, depth));\n            }\n            var column = child;\n            if (!_this.shouldDisplayFilter(column)) {\n                return [];\n            }\n            var hideFilterCompHeader = depth === 0;\n            var filterComp = new ToolPanelFilterComp(hideFilterCompHeader);\n            _this.getContext().createBean(filterComp);\n            filterComp.setColumn(column);\n            if (depth > 0) {\n                return filterComp;\n            }\n            var filterGroupComp = _this.createBean(new ToolPanelFilterGroupComp(column, [filterComp], _this.onGroupExpanded.bind(_this), depth, true));\n            filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');\n            filterGroupComp.collapse();\n            return filterGroupComp;\n        }));\n    };\n    FiltersToolPanelListPanel.prototype.recursivelyAddFilterGroupComps = function (columnGroup, depth) {\n        if (!this.filtersExistInChildren(columnGroup.getChildren())) {\n            return;\n        }\n        var colGroupDef = columnGroup.getColGroupDef();\n        if (colGroupDef && colGroupDef.suppressFiltersToolPanel) {\n            return [];\n        }\n        var newDepth = columnGroup.isPadding() ? depth : depth + 1;\n        var childFilterComps = agGridCommunity._.flatten(this.recursivelyAddComps(columnGroup.getChildren(), newDepth));\n        if (columnGroup.isPadding()) {\n            return childFilterComps;\n        }\n        var filterGroupComp = new ToolPanelFilterGroupComp(columnGroup, childFilterComps, this.onGroupExpanded.bind(this), depth, false);\n        this.getContext().createBean(filterGroupComp);\n        filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');\n        return [filterGroupComp];\n    };\n    FiltersToolPanelListPanel.prototype.filtersExistInChildren = function (tree) {\n        var _this = this;\n        return tree.some(function (child) {\n            if (child instanceof agGridCommunity.OriginalColumnGroup) {\n                return _this.filtersExistInChildren(child.getChildren());\n            }\n            return _this.shouldDisplayFilter(child);\n        });\n    };\n    FiltersToolPanelListPanel.prototype.shouldDisplayFilter = function (column) {\n        var suppressFiltersToolPanel = column.getColDef() && column.getColDef().suppressFiltersToolPanel;\n        return column.isFilterAllowed() && !suppressFiltersToolPanel;\n    };\n    // we don't support refreshing, but must implement because it's on the tool panel interface\n    FiltersToolPanelListPanel.prototype.refresh = function () { };\n    // lazy initialise the panel\n    FiltersToolPanelListPanel.prototype.setVisible = function (visible) {\n        _super.prototype.setDisplayed.call(this, visible);\n        if (visible && !this.initialised) {\n            this.init(this.params);\n        }\n    };\n    FiltersToolPanelListPanel.prototype.expandFilterGroups = function (expand, groupIds) {\n        var updatedGroupIds = [];\n        var updateGroupExpandState = function (filterGroup) {\n            var groupId = filterGroup.getFilterGroupId();\n            var shouldExpandOrCollapse = !groupIds || agGridCommunity._.includes(groupIds, groupId);\n            if (shouldExpandOrCollapse) {\n                // don't expand 'column groups', i.e. top level columns wrapped in a group\n                if (expand && filterGroup.isColumnGroup()) {\n                    filterGroup.expand();\n                }\n                else {\n                    filterGroup.collapse();\n                }\n                updatedGroupIds.push(groupId);\n            }\n            // recursively look for more groups to expand / collapse\n            filterGroup.getChildren().forEach(function (child) {\n                if (child instanceof ToolPanelFilterGroupComp) {\n                    updateGroupExpandState(child);\n                }\n            });\n        };\n        this.filterGroupComps.forEach(updateGroupExpandState);\n        // update header expand / collapse icon\n        this.onGroupExpanded();\n        if (groupIds) {\n            var unrecognisedGroupIds = groupIds.filter(function (groupId) { return updatedGroupIds.indexOf(groupId) < 0; });\n            if (unrecognisedGroupIds.length > 0) {\n                console.warn('AG Grid: unable to find groups for these supplied groupIds:', unrecognisedGroupIds);\n            }\n        }\n    };\n    FiltersToolPanelListPanel.prototype.expandFilters = function (expand, colIds) {\n        var updatedColIds = [];\n        var updateGroupExpandState = function (filterComp) {\n            if (filterComp instanceof ToolPanelFilterGroupComp) {\n                var anyChildrenChanged_1 = false;\n                filterComp.getChildren().forEach(function (child) {\n                    var childUpdated = updateGroupExpandState(child);\n                    if (childUpdated) {\n                        if (expand) {\n                            filterComp.expand();\n                            anyChildrenChanged_1 = true;\n                        }\n                        else if (!filterComp.isColumnGroup()) {\n                            // we only collapse columns wrapped in groups\n                            filterComp.collapse();\n                        }\n                    }\n                });\n                return anyChildrenChanged_1;\n            }\n            var colId = filterComp.getColumn().getColId();\n            var updateFilterExpandState = !colIds || agGridCommunity._.includes(colIds, colId);\n            if (updateFilterExpandState) {\n                expand ? filterComp.expand() : filterComp.collapse();\n                updatedColIds.push(colId);\n            }\n            return updateFilterExpandState;\n        };\n        this.filterGroupComps.forEach(updateGroupExpandState);\n        // update header expand / collapse icon\n        this.onGroupExpanded();\n        if (colIds) {\n            var unrecognisedColIds = colIds.filter(function (colId) { return updatedColIds.indexOf(colId) < 0; });\n            if (unrecognisedColIds.length > 0) {\n                console.warn('AG Grid: unable to find columns for these supplied colIds:', unrecognisedColIds);\n            }\n        }\n    };\n    FiltersToolPanelListPanel.prototype.onGroupExpanded = function () {\n        this.fireExpandedEvent();\n    };\n    FiltersToolPanelListPanel.prototype.fireExpandedEvent = function () {\n        var expandedCount = 0;\n        var notExpandedCount = 0;\n        var updateExpandCounts = function (filterGroup) {\n            if (!filterGroup.isColumnGroup()) {\n                return;\n            }\n            filterGroup.isExpanded() ? expandedCount++ : notExpandedCount++;\n            filterGroup.getChildren().forEach(function (child) {\n                if (child instanceof ToolPanelFilterGroupComp) {\n                    updateExpandCounts(child);\n                }\n            });\n        };\n        this.filterGroupComps.forEach(updateExpandCounts);\n        var state;\n        if (expandedCount > 0 && notExpandedCount > 0) {\n            state = EXPAND_STATE.INDETERMINATE;\n        }\n        else if (notExpandedCount > 0) {\n            state = EXPAND_STATE.COLLAPSED;\n        }\n        else {\n            state = EXPAND_STATE.EXPANDED;\n        }\n        this.dispatchEvent({ type: 'groupExpanded', state: state });\n    };\n    FiltersToolPanelListPanel.prototype.performFilterSearch = function (searchText) {\n        this.searchFilterText = agGridCommunity._.exists(searchText) ? searchText.toLowerCase() : null;\n        this.searchFilters(this.searchFilterText);\n    };\n    FiltersToolPanelListPanel.prototype.searchFilters = function (searchFilter) {\n        var passesFilter = function (groupName) {\n            return !agGridCommunity._.exists(searchFilter) || groupName.toLowerCase().indexOf(searchFilter) !== -1;\n        };\n        var recursivelySearch = function (filterItem, parentPasses) {\n            if (!(filterItem instanceof ToolPanelFilterGroupComp)) {\n                return passesFilter(filterItem.getColumnFilterName() || '');\n            }\n            var children = filterItem.getChildren();\n            var groupNamePasses = passesFilter(filterItem.getFilterGroupName());\n            // if group or parent already passed - ensure this group and all children are visible\n            var alreadyPassed = parentPasses || groupNamePasses;\n            if (alreadyPassed) {\n                // ensure group visible\n                filterItem.hideGroup(false);\n                // ensure all children are visible\n                for (var i = 0; i < children.length; i++) {\n                    recursivelySearch(children[i], alreadyPassed);\n                    filterItem.hideGroupItem(false, i);\n                }\n                return true;\n            }\n            // hide group item filters\n            var anyChildPasses = false;\n            children.forEach(function (child, index) {\n                var childPasses = recursivelySearch(child, parentPasses);\n                filterItem.hideGroupItem(!childPasses, index);\n                if (childPasses) {\n                    anyChildPasses = true;\n                }\n            });\n            // hide group if no children pass\n            filterItem.hideGroup(!anyChildPasses);\n            return anyChildPasses;\n        };\n        var firstVisible;\n        var lastVisible;\n        this.filterGroupComps.forEach(function (filterGroup, idx) {\n            recursivelySearch(filterGroup, false);\n            if (firstVisible === undefined) {\n                if (!agGridCommunity._.containsClass(filterGroup.getGui(), 'ag-hidden')) {\n                    firstVisible = idx;\n                    lastVisible = idx;\n                }\n            }\n            else if (!agGridCommunity._.containsClass(filterGroup.getGui(), 'ag-hidden') && lastVisible !== idx) {\n                lastVisible = idx;\n            }\n        });\n        this.setFirstAndLastVisible(firstVisible, lastVisible);\n    };\n    FiltersToolPanelListPanel.prototype.setFirstAndLastVisible = function (firstIdx, lastIdx) {\n        this.filterGroupComps.forEach(function (filterGroup, idx) {\n            agGridCommunity._.removeCssClass(filterGroup.getGui(), 'ag-first-group-visible');\n            agGridCommunity._.removeCssClass(filterGroup.getGui(), 'ag-last-group-visible');\n            if (idx === firstIdx) {\n                agGridCommunity._.addCssClass(filterGroup.getGui(), 'ag-first-group-visible');\n            }\n            if (idx === lastIdx) {\n                agGridCommunity._.addCssClass(filterGroup.getGui(), 'ag-last-group-visible');\n            }\n        });\n    };\n    FiltersToolPanelListPanel.prototype.refreshFilters = function () {\n        this.filterGroupComps.forEach(function (filterGroupComp) { return filterGroupComp.refreshFilters(); });\n    };\n    FiltersToolPanelListPanel.prototype.destroyFilters = function () {\n        this.filterGroupComps = this.destroyBeans(this.filterGroupComps);\n        agGridCommunity._.clearElement(this.getGui());\n    };\n    FiltersToolPanelListPanel.prototype.destroy = function () {\n        this.destroyFilters();\n        _super.prototype.destroy.call(this);\n    };\n    FiltersToolPanelListPanel.TEMPLATE = \"<div class=\\\"ag-filter-list-panel\\\"></div>\";\n    __decorate$B([\n        agGridCommunity.Autowired(\"gridApi\")\n    ], FiltersToolPanelListPanel.prototype, \"gridApi\", void 0);\n    __decorate$B([\n        agGridCommunity.Autowired(\"columnApi\")\n    ], FiltersToolPanelListPanel.prototype, \"columnApi\", void 0);\n    __decorate$B([\n        agGridCommunity.Autowired('toolPanelColDefService')\n    ], FiltersToolPanelListPanel.prototype, \"toolPanelColDefService\", void 0);\n    __decorate$B([\n        agGridCommunity.Autowired('columnController')\n    ], FiltersToolPanelListPanel.prototype, \"columnController\", void 0);\n    return FiltersToolPanelListPanel;\n}(agGridCommunity.Component));\n\nvar __extends$E = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FiltersToolPanel = /** @class */ (function (_super) {\n    __extends$E(FiltersToolPanel, _super);\n    function FiltersToolPanel() {\n        var _this = _super.call(this, FiltersToolPanel.TEMPLATE) || this;\n        _this.initialised = false;\n        _this.listenerDestroyFuncs = [];\n        return _this;\n    }\n    FiltersToolPanel.prototype.init = function (params) {\n        // if initialised is true, means this is a refresh\n        if (this.initialised) {\n            this.listenerDestroyFuncs.forEach(function (func) { return func(); });\n            this.listenerDestroyFuncs = [];\n        }\n        this.initialised = true;\n        var defaultParams = {\n            suppressExpandAll: false,\n            suppressFilterSearch: false,\n            suppressSyncLayoutWithGrid: false,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        agGridCommunity._.mergeDeep(defaultParams, params);\n        this.params = defaultParams;\n        this.filtersToolPanelHeaderPanel.init(this.params);\n        this.filtersToolPanelListPanel.init(this.params);\n        var hideExpand = this.params.suppressExpandAll;\n        var hideSearch = this.params.suppressFilterSearch;\n        if (hideExpand && hideSearch) {\n            this.filtersToolPanelHeaderPanel.setDisplayed(false);\n        }\n        // this is necessary to prevent a memory leak while refreshing the tool panel\n        this.listenerDestroyFuncs.push(this.addManagedListener(this.filtersToolPanelHeaderPanel, 'expandAll', this.onExpandAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, 'collapseAll', this.onCollapseAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, 'searchChanged', this.onSearchChanged.bind(this)), this.addManagedListener(this.filtersToolPanelListPanel, 'groupExpanded', this.onGroupExpanded.bind(this)));\n    };\n    // lazy initialise the panel\n    FiltersToolPanel.prototype.setVisible = function (visible) {\n        _super.prototype.setDisplayed.call(this, visible);\n        if (visible && !this.initialised) {\n            this.init(this.params);\n        }\n    };\n    FiltersToolPanel.prototype.onExpandAll = function () {\n        this.filtersToolPanelListPanel.expandFilterGroups(true);\n    };\n    FiltersToolPanel.prototype.onCollapseAll = function () {\n        this.filtersToolPanelListPanel.expandFilterGroups(false);\n    };\n    FiltersToolPanel.prototype.onSearchChanged = function (event) {\n        this.filtersToolPanelListPanel.performFilterSearch(event.searchText);\n    };\n    FiltersToolPanel.prototype.setFilterLayout = function (colDefs) {\n        this.filtersToolPanelListPanel.setFiltersLayout(colDefs);\n    };\n    FiltersToolPanel.prototype.onGroupExpanded = function (event) {\n        this.filtersToolPanelHeaderPanel.setExpandState(event.state);\n    };\n    FiltersToolPanel.prototype.expandFilterGroups = function (groupIds) {\n        this.filtersToolPanelListPanel.expandFilterGroups(true, groupIds);\n    };\n    FiltersToolPanel.prototype.collapseFilterGroups = function (groupIds) {\n        this.filtersToolPanelListPanel.expandFilterGroups(false, groupIds);\n    };\n    FiltersToolPanel.prototype.expandFilters = function (colIds) {\n        this.filtersToolPanelListPanel.expandFilters(true, colIds);\n    };\n    FiltersToolPanel.prototype.collapseFilters = function (colIds) {\n        this.filtersToolPanelListPanel.expandFilters(false, colIds);\n    };\n    FiltersToolPanel.prototype.syncLayoutWithGrid = function () {\n        this.filtersToolPanelListPanel.syncFilterLayout();\n    };\n    FiltersToolPanel.prototype.refresh = function () {\n        this.init(this.params);\n    };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    FiltersToolPanel.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    FiltersToolPanel.TEMPLATE = \"<div class=\\\"ag-filter-toolpanel\\\">\\n            <ag-filters-tool-panel-header ref=\\\"filtersToolPanelHeaderPanel\\\"></ag-filters-tool-panel-header>\\n            <ag-filters-tool-panel-list ref=\\\"filtersToolPanelListPanel\\\"></ag-filters-tool-panel-list>\\n         </div>\";\n    __decorate$C([\n        agGridCommunity.RefSelector('filtersToolPanelHeaderPanel')\n    ], FiltersToolPanel.prototype, \"filtersToolPanelHeaderPanel\", void 0);\n    __decorate$C([\n        agGridCommunity.RefSelector('filtersToolPanelListPanel')\n    ], FiltersToolPanel.prototype, \"filtersToolPanelListPanel\", void 0);\n    __decorate$C([\n        agGridCommunity.Autowired('gridApi')\n    ], FiltersToolPanel.prototype, \"gridApi\", void 0);\n    __decorate$C([\n        agGridCommunity.Autowired('columnApi')\n    ], FiltersToolPanel.prototype, \"columnApi\", void 0);\n    return FiltersToolPanel;\n}(agGridCommunity.Component));\n\nvar FiltersToolPanelModule = {\n    moduleName: agGridCommunity.ModuleNames.FiltersToolPanelModule,\n    beans: [],\n    agStackComponents: [\n        { componentName: 'AgFiltersToolPanelHeader', componentClass: FiltersToolPanelHeaderPanel },\n        { componentName: 'AgFiltersToolPanelList', componentClass: FiltersToolPanelListPanel }\n    ],\n    userComponents: [\n        { componentName: 'agFiltersToolPanel', componentClass: FiltersToolPanel },\n    ],\n    dependantModules: [\n        SideBarModule,\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$F = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartDatasource = /** @class */ (function (_super) {\n    __extends$F(ChartDatasource, _super);\n    function ChartDatasource() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChartDatasource.prototype.getData = function (params) {\n        if (params.crossFiltering) {\n            if (params.grouping) {\n                console.warn(\"ag-grid: crossing filtering with row grouping is not supported.\");\n                return { data: [], columnNames: {} };\n            }\n            if (!this.gridOptionsWrapper.isRowModelDefault()) {\n                console.warn(\"ag-grid: crossing filtering is only supported in the client side row model.\");\n                return { data: [], columnNames: {} };\n            }\n        }\n        var isServerSide = this.gridOptionsWrapper.isRowModelServerSide();\n        if (isServerSide && params.pivoting) {\n            this.updatePivotKeysForSSRM();\n        }\n        var result = this.extractRowsFromGridRowModel(params);\n        result.data = this.aggregateRowsByDimension(params, result.data);\n        return result;\n    };\n    ChartDatasource.prototype.extractRowsFromGridRowModel = function (params) {\n        var _this = this;\n        var extractedRowData = [];\n        var columnNames = {};\n        // maps used to keep track of expanded groups that need to be removed\n        var groupNodeIndexes = {};\n        var groupsToRemove = {};\n        // only used when cross filtering\n        var filteredNodes = {};\n        var allRowNodes = [];\n        var numRows;\n        if (params.crossFiltering) {\n            filteredNodes = this.getFilteredRowNodes();\n            allRowNodes = this.getAllRowNodes();\n            numRows = allRowNodes.length;\n        }\n        else {\n            // make sure enough rows in range to chart. if user filters and less rows, then end row will be\n            // the last displayed row, not where the range ends.\n            var modelLastRow = this.gridRowModel.getRowCount() - 1;\n            var rangeLastRow = params.endRow >= 0 ? Math.min(params.endRow, modelLastRow) : modelLastRow;\n            numRows = rangeLastRow - params.startRow + 1;\n        }\n        var _loop_1 = function (i) {\n            var data = {};\n            var rowNode = params.crossFiltering ? allRowNodes[i] : this_1.gridRowModel.getRow(i + params.startRow);\n            // first get data for dimensions columns\n            params.dimensionCols.forEach(function (col) {\n                var colId = col.colId;\n                var column = _this.columnController.getGridColumn(colId);\n                if (column) {\n                    var valueObject = _this.valueService.getValue(column, rowNode);\n                    // when grouping we also need to build up multi category labels for charts\n                    if (params.grouping) {\n                        var valueString = valueObject && valueObject.toString ? String(valueObject.toString()) : '';\n                        // traverse parents to extract group label path\n                        var labels = ChartDatasource.getGroupLabels(rowNode, valueString);\n                        data[colId] = {\n                            labels: labels, toString: function () {\n                                return this.labels.filter(function (l) { return !!l; }).reverse().join(' - ');\n                            }\n                        };\n                        // keep track of group node indexes so they can be padded when other groups are expanded\n                        if (rowNode.group) {\n                            groupNodeIndexes[labels.toString()] = i;\n                        }\n                        // if node (group or leaf) has parents then it is expanded and should be removed\n                        var groupKey = labels.slice(1, labels.length).toString();\n                        if (groupKey) {\n                            groupsToRemove[groupKey] = groupNodeIndexes[groupKey];\n                        }\n                    }\n                    else {\n                        // leaf nodes can be directly added to dimension columns\n                        data[colId] = valueObject;\n                    }\n                }\n                else {\n                    // introduce a default category when no dimensions exist with a value based off row index (+1)\n                    data[ChartDataModel.DEFAULT_CATEGORY] = i + 1;\n                }\n            });\n            // then get data for value columns\n            params.valueCols.forEach(function (col) {\n                var columnNamesArr = [];\n                // pivot keys should be added first\n                var pivotKeys = col.getColDef().pivotKeys;\n                if (pivotKeys) {\n                    columnNamesArr = pivotKeys.slice();\n                }\n                // then add column header name to results\n                var headerName = col.getColDef().headerName;\n                if (headerName) {\n                    columnNamesArr.push(headerName);\n                }\n                // add array of column names to results\n                if (columnNamesArr.length > 0) {\n                    columnNames[col.getId()] = columnNamesArr;\n                }\n                var colId = col.getColId();\n                if (params.crossFiltering) {\n                    var filteredOutColId = colId + '-filtered-out';\n                    // add data value to value column\n                    var value = _this.valueService.getValue(col, rowNode);\n                    var actualValue = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n                    if (filteredNodes[rowNode.id]) {\n                        data[colId] = actualValue;\n                        data[filteredOutColId] = params.aggFunc || params.isScatter ? undefined : 0;\n                    }\n                    else {\n                        data[colId] = params.aggFunc || params.isScatter ? undefined : 0;\n                        data[filteredOutColId] = actualValue;\n                    }\n                }\n                else {\n                    // add data value to value column\n                    var value = _this.valueService.getValue(col, rowNode);\n                    data[colId] = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;\n                }\n            });\n            // add data to results\n            extractedRowData.push(data);\n        };\n        var this_1 = this;\n        for (var i = 0; i < numRows; i++) {\n            _loop_1(i);\n        }\n        if (params.grouping) {\n            var groupIndexesToRemove_1 = agGridCommunity._.values(groupsToRemove);\n            extractedRowData = extractedRowData.filter(function (_1, index) { return !agGridCommunity._.includes(groupIndexesToRemove_1, index); });\n        }\n        return { data: extractedRowData, columnNames: columnNames };\n    };\n    ChartDatasource.prototype.aggregateRowsByDimension = function (params, dataFromGrid) {\n        var _this = this;\n        var dimensionCols = params.dimensionCols;\n        if (!params.aggFunc || dimensionCols.length === 0) {\n            return dataFromGrid;\n        }\n        var lastCol = agGridCommunity._.last(dimensionCols);\n        var lastColId = lastCol && lastCol.colId;\n        var map = {};\n        var dataAggregated = [];\n        dataFromGrid.forEach(function (data) {\n            var currentMap = map;\n            dimensionCols.forEach(function (col) {\n                var colId = col.colId;\n                var key = data[colId];\n                if (colId === lastColId) {\n                    var groupItem_1 = currentMap[key];\n                    if (!groupItem_1) {\n                        groupItem_1 = { __children: [] };\n                        dimensionCols.forEach(function (dimCol) {\n                            var dimColId = dimCol.colId;\n                            groupItem_1[dimColId] = data[dimColId];\n                        });\n                        currentMap[key] = groupItem_1;\n                        dataAggregated.push(groupItem_1);\n                    }\n                    groupItem_1.__children.push(data);\n                }\n                else {\n                    // map of maps\n                    if (!currentMap[key]) {\n                        currentMap[key] = {};\n                    }\n                    currentMap = currentMap[key];\n                }\n            });\n        });\n        if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n            dataAggregated.forEach(function (groupItem) { return params.valueCols.forEach(function (col) {\n                if (params.crossFiltering) {\n                    params.valueCols.forEach(function (valueCol) {\n                        // filtered data\n                        var dataToAgg = groupItem.__children\n                            .filter(function (child) { return typeof child[valueCol.getColId()] !== 'undefined'; })\n                            .map(function (child) { return child[valueCol.getColId()]; });\n                        var aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n                        groupItem[valueCol.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;\n                        // filtered out data\n                        var filteredOutColId = valueCol.getId() + '-filtered-out';\n                        var dataToAggFiltered = groupItem.__children\n                            .filter(function (child) { return typeof child[filteredOutColId] !== 'undefined'; })\n                            .map(function (child) { return child[filteredOutColId]; });\n                        var aggResultFiltered = _this.aggregationStage.aggregateValues(dataToAggFiltered, params.aggFunc);\n                        groupItem[filteredOutColId] = aggResultFiltered && typeof aggResultFiltered.value !== 'undefined' ? aggResultFiltered.value : aggResultFiltered;\n                    });\n                }\n                else {\n                    var dataToAgg = groupItem.__children.map(function (child) { return child[col.getId()]; });\n                    var aggResult = 0;\n                    if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.RowGroupingModule, 'Charting Aggregation')) {\n                        aggResult = _this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);\n                    }\n                    groupItem[col.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;\n                }\n            }); });\n        }\n        return dataAggregated;\n    };\n    ChartDatasource.prototype.updatePivotKeysForSSRM = function () {\n        var secondaryColumns = this.columnController.getSecondaryColumns();\n        if (!secondaryColumns) {\n            return;\n        }\n        // we don't know what the application will use for the pivot key separator (i.e. '_' or '|' ) as the\n        // secondary columns are provided to grid by the application via columnApi.setSecondaryColumns()\n        var pivotKeySeparator = this.extractPivotKeySeparator(secondaryColumns);\n        // 'pivotKeys' is not used by the SSRM for pivoting so it is safe to reuse this colDef property, this way\n        // the same logic can be used for CSRM and SSRM to extract legend names in extractRowsFromGridRowModel()\n        secondaryColumns.forEach(function (col) {\n            var keys = col.getColId().split(pivotKeySeparator);\n            col.getColDef().pivotKeys = keys.slice(0, keys.length - 1);\n        });\n    };\n    ChartDatasource.prototype.extractPivotKeySeparator = function (secondaryColumns) {\n        if (secondaryColumns.length === 0) {\n            return \"\";\n        }\n        var extractSeparator = function (columnGroup, childId) {\n            var groupId = columnGroup.getGroupId();\n            if (!columnGroup.getParent()) {\n                // removing groupId ('2000') from childId ('2000|Swimming') yields '|Swimming' so first char is separator\n                return childId.split(groupId)[1][0];\n            }\n            return extractSeparator(columnGroup.getParent(), groupId);\n        };\n        var firstSecondaryCol = secondaryColumns[0];\n        return extractSeparator(firstSecondaryCol.getParent(), firstSecondaryCol.getColId());\n    };\n    ChartDatasource.getGroupLabels = function (rowNode, initialLabel) {\n        var labels = [initialLabel];\n        while (rowNode && rowNode.level !== 0) {\n            rowNode = rowNode.parent;\n            if (rowNode) {\n                labels.push(rowNode.key);\n            }\n        }\n        return labels;\n    };\n    ChartDatasource.prototype.getFilteredRowNodes = function () {\n        var filteredNodes = {};\n        this.gridRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {\n            filteredNodes[rowNode.id] = rowNode;\n        });\n        return filteredNodes;\n    };\n    ChartDatasource.prototype.getAllRowNodes = function () {\n        var allRowNodes = [];\n        this.gridRowModel.forEachNode(function (rowNode) {\n            allRowNodes.push(rowNode);\n        });\n        return this.sortRowNodes(allRowNodes);\n    };\n    ChartDatasource.prototype.sortRowNodes = function (rowNodes) {\n        var sortOptions = this.sortController.getSortOptions();\n        var noSort = !sortOptions || sortOptions.length == 0;\n        if (noSort)\n            return rowNodes;\n        return this.rowNodeSorter.doFullSort(rowNodes, sortOptions);\n    };\n    __decorate$D([\n        agGridCommunity.Autowired('rowModel')\n    ], ChartDatasource.prototype, \"gridRowModel\", void 0);\n    __decorate$D([\n        agGridCommunity.Autowired('valueService')\n    ], ChartDatasource.prototype, \"valueService\", void 0);\n    __decorate$D([\n        agGridCommunity.Autowired('columnController')\n    ], ChartDatasource.prototype, \"columnController\", void 0);\n    __decorate$D([\n        agGridCommunity.Autowired('rowNodeSorter')\n    ], ChartDatasource.prototype, \"rowNodeSorter\", void 0);\n    __decorate$D([\n        agGridCommunity.Autowired('sortController')\n    ], ChartDatasource.prototype, \"sortController\", void 0);\n    __decorate$D([\n        agGridCommunity.Optional('aggregationStage')\n    ], ChartDatasource.prototype, \"aggregationStage\", void 0);\n    return ChartDatasource;\n}(agGridCommunity.BeanStub));\n\nvar __extends$G = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays$3 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar ChartDataModel = /** @class */ (function (_super) {\n    __extends$G(ChartDataModel, _super);\n    function ChartDataModel(params) {\n        var _this = _super.call(this) || this;\n        _this.dimensionColState = [];\n        _this.valueColState = [];\n        _this.unlinked = false;\n        _this.grouping = false;\n        _this.crossFiltering = false;\n        _this.columnNames = {};\n        _this.pivotChart = params.pivotChart;\n        _this.chartType = params.chartType;\n        _this.chartThemeName = params.chartThemeName;\n        _this.aggFunc = params.aggFunc;\n        _this.referenceCellRange = params.cellRange;\n        _this.suppliedCellRange = params.cellRange;\n        _this.suppressChartRanges = params.suppressChartRanges;\n        _this.unlinked = !!params.unlinkChart;\n        _this.crossFiltering = !!params.crossFiltering;\n        // this is used to associate chart ranges with charts\n        _this.chartId = _this.generateId();\n        return _this;\n    }\n    ChartDataModel.prototype.init = function () {\n        this.datasource = this.createManagedBean(new ChartDatasource());\n        this.updateCellRanges();\n    };\n    ChartDataModel.prototype.updateCellRanges = function (updatedColState) {\n        if (this.valueCellRange) {\n            this.referenceCellRange = this.valueCellRange;\n        }\n        var _a = this.getAllChartColumns(), dimensionCols = _a.dimensionCols, valueCols = _a.valueCols;\n        var allColsFromRanges = this.getAllColumnsFromRanges();\n        if (updatedColState) {\n            this.updateColumnState(updatedColState);\n        }\n        this.setDimensionCellRange(dimensionCols, allColsFromRanges, updatedColState);\n        this.setValueCellRange(valueCols, allColsFromRanges, updatedColState);\n        if (!updatedColState) {\n            this.resetColumnState();\n            // dimension / category cell range could be out of sync after resetting column state when row grouping\n            this.syncDimensionCellRange();\n        }\n        this.updateData();\n    };\n    ChartDataModel.prototype.getData = function () {\n        return this.chartData;\n    };\n    ChartDataModel.prototype.isGroupActive = function () {\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        var groupedCols = usingTreeData ? null : this.columnController.getRowGroupColumns();\n        return usingTreeData || (groupedCols && groupedCols.length > 0);\n    };\n    ChartDataModel.prototype.isGrouping = function () {\n        // charts only group when the selected category is a group column\n        var colId = this.getSelectedDimension().colId;\n        var displayedGroupCols = this.columnController.getGroupDisplayColumns();\n        var groupDimensionSelected = displayedGroupCols.map(function (col) { return col.getColId(); }).some(function (id) { return id === colId; });\n        return !!this.isGroupActive() && groupDimensionSelected;\n    };\n    ChartDataModel.prototype.isPivotActive = function () {\n        return this.columnController.isPivotActive();\n    };\n    ChartDataModel.prototype.isPivotMode = function () {\n        return this.columnController.isPivotMode();\n    };\n    ChartDataModel.prototype.isPivotChart = function () {\n        return this.pivotChart;\n    };\n    ChartDataModel.prototype.getChartId = function () {\n        return this.chartId;\n    };\n    ChartDataModel.prototype.getValueColState = function () {\n        return this.valueColState.map(this.displayNameMapper.bind(this));\n    };\n    ChartDataModel.prototype.getDimensionColState = function () {\n        return this.dimensionColState;\n    };\n    ChartDataModel.prototype.getCellRanges = function () {\n        return [this.dimensionCellRange, this.valueCellRange].filter(function (r) { return r; });\n    };\n    ChartDataModel.prototype.getCellRangeParams = function () {\n        var cellRanges = this.getCellRanges();\n        var firstCellRange = cellRanges[0];\n        var startRow = (firstCellRange && firstCellRange.startRow) || null;\n        var endRow = (firstCellRange && firstCellRange.endRow) || null;\n        return {\n            rowStartIndex: startRow && startRow.rowIndex,\n            rowStartPinned: startRow && startRow.rowPinned,\n            rowEndIndex: endRow && endRow.rowIndex,\n            rowEndPinned: endRow && endRow.rowPinned,\n            columns: cellRanges.reduce(function (columns, value) { return columns.concat(value.columns.map(function (c) { return c.getId(); })); }, [])\n        };\n    };\n    ChartDataModel.prototype.setChartType = function (chartType) {\n        this.chartType = chartType;\n    };\n    ChartDataModel.prototype.getChartType = function () {\n        return this.chartType;\n    };\n    ChartDataModel.prototype.setChartThemeName = function (chartThemeName) {\n        this.chartThemeName = chartThemeName;\n    };\n    ChartDataModel.prototype.getChartThemeName = function () {\n        return this.chartThemeName;\n    };\n    ChartDataModel.prototype.isSuppressChartRanges = function () {\n        return this.suppressChartRanges;\n    };\n    ChartDataModel.prototype.isUnlinked = function () {\n        return this.unlinked;\n    };\n    ChartDataModel.prototype.toggleUnlinked = function () {\n        this.unlinked = !this.unlinked;\n    };\n    ChartDataModel.prototype.getAggFunc = function () {\n        return this.aggFunc;\n    };\n    ChartDataModel.prototype.getSelectedValueColState = function () {\n        return this.getValueColState().filter(function (cs) { return cs.selected; });\n    };\n    ChartDataModel.prototype.getSelectedValueCols = function () {\n        return this.valueColState.filter(function (cs) { return cs.selected; }).map(function (cs) { return cs.column; });\n    };\n    ChartDataModel.prototype.getSelectedDimension = function () {\n        return this.dimensionColState.filter(function (cs) { return cs.selected; })[0];\n    };\n    ChartDataModel.prototype.createCellRange = function (type) {\n        var columns = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            columns[_i - 1] = arguments[_i];\n        }\n        return {\n            id: this.chartId,\n            startRow: this.referenceCellRange.startRow,\n            endRow: this.referenceCellRange.endRow,\n            columns: columns,\n            startColumn: type === agGridCommunity.CellRangeType.DIMENSION ? columns[0] : this.referenceCellRange.startColumn,\n            type: type\n        };\n    };\n    ChartDataModel.prototype.getAllColumnsFromRanges = function () {\n        if (this.pivotChart) {\n            return agGridCommunity._.convertToSet(this.columnController.getAllDisplayedColumns());\n        }\n        var columns = this.dimensionCellRange || this.valueCellRange ? [] : this.referenceCellRange.columns;\n        if (this.dimensionCellRange) {\n            columns.push.apply(columns, this.dimensionCellRange.columns);\n        }\n        if (this.valueCellRange) {\n            columns.push.apply(columns, this.valueCellRange.columns);\n        }\n        return agGridCommunity._.convertToSet(columns);\n    };\n    ChartDataModel.prototype.getColDisplayName = function (col) {\n        return this.columnController.getDisplayNameForColumn(col, 'chart');\n    };\n    ChartDataModel.prototype.getRowIndexes = function () {\n        var startRow = 0, endRow = 0;\n        var rangeController = this.rangeController;\n        var range = this.valueCellRange;\n        if (rangeController && range) {\n            startRow = rangeController.getRangeStartRow(range).rowIndex;\n            endRow = rangeController.getRangeEndRow(range).rowIndex;\n        }\n        return { startRow: startRow, endRow: endRow };\n    };\n    ChartDataModel.prototype.getAllChartColumns = function () {\n        var _this = this;\n        var displayedCols = this.columnController.getAllDisplayedColumns();\n        var dimensionCols = new Set();\n        var valueCols = new Set();\n        displayedCols.forEach(function (col) {\n            var colDef = col.getColDef();\n            var chartDataType = colDef.chartDataType;\n            if (chartDataType) {\n                // chart data type was specified explicitly\n                switch (chartDataType) {\n                    case 'category':\n                    case 'time':\n                        dimensionCols.add(col);\n                        return;\n                    case 'series':\n                        valueCols.add(col);\n                        return;\n                    case 'excluded':\n                        return;\n                    default:\n                        console.warn(\"AG Grid: unexpected chartDataType value '\" + chartDataType + \"' supplied, instead use 'category', 'series' or 'excluded'\");\n                        break;\n                }\n            }\n            if (colDef.colId === 'ag-Grid-AutoColumn') {\n                dimensionCols.add(col);\n                return;\n            }\n            if (!col.isPrimary()) {\n                valueCols.add(col);\n                return;\n            }\n            // if 'chartDataType' is not provided then infer type based data contained in first row\n            (_this.isNumberCol(col) ? valueCols : dimensionCols).add(col);\n        });\n        return { dimensionCols: dimensionCols, valueCols: valueCols };\n    };\n    ChartDataModel.prototype.isNumberCol = function (col) {\n        if (col.getColId() === 'ag-Grid-AutoColumn') {\n            return false;\n        }\n        var row = this.rowRenderer.getRowNode({ rowIndex: 0, rowPinned: undefined });\n        if (!row) {\n            return false;\n        }\n        var cellValue = this.valueService.getValue(col, row);\n        if (cellValue == null) {\n            cellValue = this.extractLeafData(row, col);\n        }\n        if (cellValue != null && typeof cellValue.toNumber === 'function') {\n            cellValue = cellValue.toNumber();\n        }\n        return typeof cellValue === 'number';\n    };\n    ChartDataModel.prototype.extractLeafData = function (row, col) {\n        if (!row.allLeafChildren) {\n            return null;\n        }\n        for (var i = 0; i < row.allLeafChildren.length; i++) {\n            var childRow = row.allLeafChildren[i];\n            var value = this.valueService.getValue(col, childRow);\n            if (value != null) {\n                return value;\n            }\n        }\n        return null;\n    };\n    ChartDataModel.prototype.displayNameMapper = function (col) {\n        var columnNames = this.columnNames[col.colId];\n        col.displayName = columnNames ? columnNames.join(' - ') : this.getColDisplayName(col.column);\n        return col;\n    };\n    ChartDataModel.prototype.generateId = function () {\n        return 'id-' + Math.random().toString(36).substr(2, 16);\n    };\n    ChartDataModel.prototype.updateData = function () {\n        var _a = this.getRowIndexes(), startRow = _a.startRow, endRow = _a.endRow;\n        if (this.pivotChart) {\n            this.resetColumnState();\n        }\n        this.grouping = this.isGrouping();\n        var params = {\n            aggFunc: this.aggFunc,\n            dimensionCols: [this.getSelectedDimension()],\n            grouping: this.grouping,\n            pivoting: this.isPivotActive(),\n            crossFiltering: this.crossFiltering,\n            valueCols: this.getSelectedValueCols(),\n            startRow: startRow,\n            endRow: endRow,\n            isScatter: agGridCommunity._.includes([agGridCommunity.ChartType.Scatter, agGridCommunity.ChartType.Bubble], this.chartType)\n        };\n        var result = this.datasource.getData(params);\n        this.chartData = result.data;\n        this.columnNames = result.columnNames;\n    };\n    ChartDataModel.prototype.resetColumnState = function () {\n        var _this = this;\n        var _a = this.getAllChartColumns(), dimensionCols = _a.dimensionCols, valueCols = _a.valueCols;\n        var allCols = this.getAllColumnsFromRanges();\n        var isInitialising = this.valueColState.length < 1;\n        this.dimensionColState = [];\n        this.valueColState = [];\n        var hasSelectedDimension = false;\n        var order = 1;\n        var aggFuncDimension = this.suppliedCellRange.columns[0]; //TODO\n        dimensionCols.forEach(function (column) {\n            var isAutoGroupCol = column.getColId() === 'ag-Grid-AutoColumn';\n            var selected = false;\n            if (_this.crossFiltering && _this.aggFunc) {\n                if (aggFuncDimension.getColId() === column.getColId()) {\n                    selected = true;\n                }\n            }\n            else {\n                selected = isAutoGroupCol ? true : !hasSelectedDimension && allCols.has(column);\n            }\n            _this.dimensionColState.push({\n                column: column,\n                colId: column.getColId(),\n                displayName: _this.getColDisplayName(column),\n                selected: selected,\n                order: order++\n            });\n            if (selected) {\n                hasSelectedDimension = true;\n            }\n        });\n        var defaultCategory = {\n            colId: ChartDataModel.DEFAULT_CATEGORY,\n            displayName: this.chartTranslator.translate('defaultCategory'),\n            selected: !hasSelectedDimension,\n            order: 0\n        };\n        this.dimensionColState.unshift(defaultCategory);\n        var valueColumnsFromReferenceRange = this.referenceCellRange.columns.filter(function (c) { return valueCols.has(c); });\n        valueCols.forEach(function (column) {\n            // first time the value cell range is set, preserve the column order from the supplied range\n            if (isInitialising && agGridCommunity._.includes(_this.referenceCellRange.columns, column)) {\n                column = valueColumnsFromReferenceRange.shift();\n            }\n            _this.valueColState.push({\n                column: column,\n                colId: column.getColId(),\n                displayName: _this.getColDisplayName(column),\n                selected: allCols.has(column),\n                order: order++\n            });\n        });\n    };\n    ChartDataModel.prototype.updateColumnState = function (updatedCol) {\n        var idsMatch = function (cs) { return cs.colId === updatedCol.colId; };\n        var _a = this, dimensionColState = _a.dimensionColState, valueColState = _a.valueColState;\n        if (dimensionColState.filter(idsMatch).length > 0) {\n            // only one dimension should be selected\n            dimensionColState.forEach(function (cs) { return cs.selected = idsMatch(cs); });\n        }\n        else {\n            // just update the selected value on the supplied value column\n            valueColState.filter(idsMatch).forEach(function (cs) { return cs.selected = updatedCol.selected; });\n        }\n        var allColumns = __spreadArrays$3(dimensionColState, valueColState);\n        var orderedColIds = [];\n        // calculate new order\n        allColumns.forEach(function (col, i) {\n            if (i === updatedCol.order) {\n                orderedColIds.push(updatedCol.colId);\n            }\n            if (col.colId !== updatedCol.colId) {\n                orderedColIds.push(col.colId);\n            }\n        });\n        // update col state with new order\n        allColumns.forEach(function (col) {\n            var order = orderedColIds.indexOf(col.colId);\n            col.order = order >= 0 ? orderedColIds.indexOf(col.colId) : allColumns.length - 1;\n        });\n        this.reorderColState();\n    };\n    ChartDataModel.prototype.reorderColState = function () {\n        var _a = this, dimensionColState = _a.dimensionColState, valueColState = _a.valueColState;\n        dimensionColState.sort(function (a, b) { return a.order - b.order; });\n        valueColState.sort(function (a, b) { return a.order - b.order; });\n    };\n    ChartDataModel.prototype.setDimensionCellRange = function (dimensionCols, colsInRange, updatedColState) {\n        var _this = this;\n        this.dimensionCellRange = undefined;\n        var dimensionColState = this.dimensionColState;\n        if (!updatedColState && !dimensionColState.length) {\n            // use first dimension column in range by default\n            dimensionCols.forEach(function (col) {\n                if (_this.dimensionCellRange || !colsInRange.has(col)) {\n                    return;\n                }\n                _this.dimensionCellRange = _this.createCellRange(agGridCommunity.CellRangeType.DIMENSION, col);\n            });\n            return;\n        }\n        var selectedDimensionColState = updatedColState;\n        if (this.crossFiltering && this.aggFunc) {\n            var aggFuncDimension_1 = this.suppliedCellRange.columns[0]; //TODO\n            selectedDimensionColState = this.dimensionColState.filter(function (cs) { return cs.colId === aggFuncDimension_1.getColId(); })[0];\n        }\n        else if (!selectedDimensionColState || !dimensionCols.has(selectedDimensionColState.column)) {\n            selectedDimensionColState = this.dimensionColState.filter(function (cs) { return cs.selected; })[0];\n        }\n        if (selectedDimensionColState && selectedDimensionColState.colId !== ChartDataModel.DEFAULT_CATEGORY) {\n            this.dimensionCellRange = this.createCellRange(agGridCommunity.CellRangeType.DIMENSION, selectedDimensionColState.column);\n        }\n    };\n    ChartDataModel.prototype.setValueCellRange = function (valueCols, colsInRange, updatedColState) {\n        this.valueCellRange = undefined;\n        var selectedValueCols = [];\n        valueCols.forEach(function (col) {\n            if (updatedColState && updatedColState.colId === col.getColId()) {\n                if (updatedColState.selected) {\n                    selectedValueCols.push(updatedColState.column);\n                }\n            }\n            else if (colsInRange.has(col)) {\n                selectedValueCols.push(col);\n            }\n        });\n        if (selectedValueCols.length > 0) {\n            var orderedColIds_1 = [];\n            if (this.valueColState.length > 0) {\n                orderedColIds_1 = this.valueColState.map(function (c) { return c.colId; });\n            }\n            else {\n                colsInRange.forEach(function (c) { return orderedColIds_1.push(c.getColId()); });\n            }\n            selectedValueCols.sort(function (a, b) { return orderedColIds_1.indexOf(a.getColId()) - orderedColIds_1.indexOf(b.getColId()); });\n            this.valueCellRange = this.createCellRange.apply(this, __spreadArrays$3([agGridCommunity.CellRangeType.VALUE], selectedValueCols));\n        }\n    };\n    ChartDataModel.prototype.syncDimensionCellRange = function () {\n        var selectedDimension = this.getSelectedDimension();\n        if (selectedDimension && selectedDimension.column) {\n            this.dimensionCellRange = this.createCellRange(agGridCommunity.CellRangeType.DIMENSION, selectedDimension.column);\n        }\n    };\n    ChartDataModel.DEFAULT_CATEGORY = 'AG-GRID-DEFAULT-CATEGORY';\n    __decorate$E([\n        agGridCommunity.Autowired('columnController')\n    ], ChartDataModel.prototype, \"columnController\", void 0);\n    __decorate$E([\n        agGridCommunity.Autowired('valueService')\n    ], ChartDataModel.prototype, \"valueService\", void 0);\n    __decorate$E([\n        agGridCommunity.Autowired('rangeController')\n    ], ChartDataModel.prototype, \"rangeController\", void 0);\n    __decorate$E([\n        agGridCommunity.Autowired('rowRenderer')\n    ], ChartDataModel.prototype, \"rowRenderer\", void 0);\n    __decorate$E([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ChartDataModel.prototype, \"chartTranslator\", void 0);\n    __decorate$E([\n        agGridCommunity.PostConstruct\n    ], ChartDataModel.prototype, \"init\", null);\n    return ChartDataModel;\n}(agGridCommunity.BeanStub));\n\nvar Padding = /** @class */ (function () {\n    function Padding(top, right, bottom, left) {\n        if (top === void 0) { top = 0; }\n        if (right === void 0) { right = top; }\n        if (bottom === void 0) { bottom = top; }\n        if (left === void 0) { left = right; }\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n        this.left = left;\n    }\n    Padding.prototype.clear = function () {\n        this.top = this.right = this.bottom = this.left = 0;\n    };\n    return Padding;\n}());\n\n// For small data structs like a bounding box, objects are superior to arrays\n// in terms of performance (by 3-4% in Chrome 71, Safari 12 and by 20% in Firefox 64).\n// They are also self descriptive and harder to abuse.\n// For example, one has to do:\n// `ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);`\n// rather than become enticed by the much slower:\n// `ctx.strokeRect(...bbox);`\n// https://jsperf.com/array-vs-object-create-access\nvar BBox = /** @class */ (function () {\n    function BBox(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    BBox.prototype.isValid = function () {\n        return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n    };\n    BBox.prototype.dilate = function (value) {\n        this.x -= value;\n        this.y -= value;\n        this.width += value * 2;\n        this.height += value * 2;\n    };\n    BBox.prototype.containsPoint = function (x, y) {\n        return x >= this.x && x <= (this.x + this.width)\n            && y >= this.y && y <= (this.y + this.height);\n    };\n    BBox.prototype.render = function (ctx, params) {\n        if (params === void 0) { params = BBox.noParams; }\n        ctx.save();\n        if (params.resetTransform) {\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        }\n        ctx.strokeStyle = params.strokeStyle || 'cyan';\n        ctx.lineWidth = params.lineWidth || 1;\n        ctx.strokeRect(this.x, this.y, this.width, this.height);\n        if (params.label) {\n            ctx.fillStyle = params.fillStyle || 'black';\n            ctx.textBaseline = 'bottom';\n            ctx.fillText(params.label, this.x, this.y);\n        }\n        ctx.restore();\n    };\n    BBox.noParams = {};\n    return BBox;\n}());\n\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\nvar Matrix = /** @class */ (function () {\n    function Matrix(elements) {\n        if (elements === void 0) { elements = [1, 0, 0, 1, 0, 0]; }\n        this.elements = elements;\n    }\n    Matrix.prototype.setElements = function (elements) {\n        var e = this.elements;\n        // `this.elements = elements.slice()` is 4-5 times slower\n        // (in Chrome 71 and FF 64) than manually copying elements,\n        // since slicing allocates new memory.\n        // The performance of passing parameters individually\n        // vs as an array is about the same in both browsers, so we\n        // go with a single (array of elements) parameter, because\n        // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n        // calls give us roughly the same performance, versus\n        // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n        // where the spread operator causes a 20-30x performance drop\n        // (30x when compiled to ES5's `.apply(this, elements)`\n        //  20x when used natively).\n        e[0] = elements[0];\n        e[1] = elements[1];\n        e[2] = elements[2];\n        e[3] = elements[3];\n        e[4] = elements[4];\n        e[5] = elements[5];\n        return this;\n    };\n    Matrix.prototype.setIdentityElements = function () {\n        var e = this.elements;\n        e[0] = 1;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 1;\n        e[4] = 0;\n        e[5] = 0;\n        return this;\n    };\n    Object.defineProperty(Matrix.prototype, \"identity\", {\n        get: function () {\n            var e = this.elements;\n            return e[0] === 1 && e[1] === 0 && e[2] === 0 &&\n                e[3] === 1 && e[4] === 0 && e[5] === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"a\", {\n        get: function () {\n            return this.elements[0];\n        },\n        set: function (value) {\n            this.elements[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"b\", {\n        get: function () {\n            return this.elements[1];\n        },\n        set: function (value) {\n            this.elements[1] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"c\", {\n        get: function () {\n            return this.elements[2];\n        },\n        set: function (value) {\n            this.elements[2] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"d\", {\n        get: function () {\n            return this.elements[3];\n        },\n        set: function (value) {\n            this.elements[3] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"e\", {\n        get: function () {\n            return this.elements[4];\n        },\n        set: function (value) {\n            this.elements[4] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"f\", {\n        get: function () {\n            return this.elements[5];\n        },\n        set: function (value) {\n            this.elements[5] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Performs the AxB matrix multiplication and saves the result\n     * to `C`, if given, or to `A` otherwise.\n     */\n    Matrix.prototype.AxB = function (A, B, C) {\n        var m11 = A[0], m12 = A[1], m21 = A[2], m22 = A[3], m31 = A[4], m32 = A[5];\n        var o11 = B[0], o12 = B[1], o21 = B[2], o22 = B[3], o31 = B[4], o32 = B[5];\n        C = C || A;\n        C[0] = m11 * o11 + m21 * o12;\n        C[1] = m12 * o11 + m22 * o12;\n        C[2] = m11 * o21 + m21 * o22;\n        C[3] = m12 * o21 + m22 * o22;\n        C[4] = m11 * o31 + m21 * o32 + m31;\n        C[5] = m12 * o31 + m22 * o32 + m32;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns the current matrix.\n     * @param other\n     */\n    Matrix.prototype.multiplySelf = function (other) {\n        this.AxB(this.elements, other.elements);\n        return this;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns a new matrix.\n     * @param other\n     */\n    Matrix.prototype.multiply = function (other) {\n        var elements = new Array(6);\n        this.AxB(this.elements, other.elements, elements);\n        return new Matrix(elements);\n    };\n    Matrix.prototype.preMultiplySelf = function (other) {\n        this.AxB(other.elements, this.elements, this.elements);\n        return this;\n    };\n    /**\n     * Returns the inverse of this matrix as a new matrix.\n     */\n    Matrix.prototype.inverse = function () {\n        var _a = this.elements, a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    };\n    /**\n     * Save the inverse of this matrix to the given matrix.\n     */\n    Matrix.prototype.inverseTo = function (other) {\n        var _a = this.elements, a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n        return this;\n    };\n    Matrix.prototype.invertSelf = function () {\n        var elements = this.elements;\n        var a = elements[0], b = elements[1], c = elements[2], d = elements[3], e = elements[4], f = elements[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        elements[0] = d;\n        elements[1] = -b;\n        elements[2] = -c;\n        elements[3] = a;\n        elements[4] = c * f - d * e;\n        elements[5] = b * e - a * f;\n        return this;\n    };\n    Matrix.prototype.clone = function () {\n        return new Matrix(this.elements.slice());\n    };\n    Matrix.prototype.transformPoint = function (x, y) {\n        var e = this.elements;\n        return {\n            x: x * e[0] + y * e[2] + e[4],\n            y: x * e[1] + y * e[3] + e[5]\n        };\n    };\n    Matrix.prototype.transformBBox = function (bbox, radius, target) {\n        if (radius === void 0) { radius = 0; }\n        var elements = this.elements;\n        var xx = elements[0];\n        var xy = elements[1];\n        var yx = elements[2];\n        var yy = elements[3];\n        var h_w = bbox.width * 0.5;\n        var h_h = bbox.height * 0.5;\n        var cx = bbox.x + h_w;\n        var cy = bbox.y + h_h;\n        var w, h;\n        if (radius) {\n            h_w -= radius;\n            h_h -= radius;\n            var sx = Math.sqrt(xx * xx + yx * yx);\n            var sy = Math.sqrt(xy * xy + yy * yy);\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx) + Math.abs(sx * radius);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy) + Math.abs(sy * radius);\n        }\n        else {\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n        }\n        if (!target) {\n            target = new BBox(0, 0, 0, 0);\n        }\n        target.x = cx * xx + cy * yx + elements[4] - w;\n        target.y = cx * xy + cy * yy + elements[5] - h;\n        target.width = w + w;\n        target.height = h + h;\n        return target;\n    };\n    Matrix.prototype.toContext = function (ctx) {\n        // It's fair to say that matrix multiplications are not cheap.\n        // However, updating path definitions on every frame isn't either, so\n        // it may be cheaper to just translate paths. It's also fair to\n        // say, that most paths will have to be re-rendered anyway, say\n        // rectangle paths in a bar chart, where an animation would happen when\n        // the data set changes and existing bars are morphed into new ones.\n        // Or a pie chart, where old sectors are also morphed into new ones.\n        // Same for the line chart. The only plausible case where translating\n        // existing paths would be enough, is the scatter chart, where marker\n        // icons, typically circles, stay the same size. But if circle radii\n        // are bound to some data points, even circle paths would have to be\n        // updated. And thus it makes sense to optimize for fewer matrix\n        // transforms, where transform matrices of paths are mostly identity\n        // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n        // are used to define a path at specific coordinates. And only groups\n        // are used to collectively apply a transform to a set of nodes.\n        // If the matrix is mostly identity (95% of the time),\n        // the `if (this.isIdentity)` check can make this call 3-4 times\n        // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n        if (this.identity) {\n            return;\n        }\n        var e = this.elements;\n        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n    };\n    Matrix.flyweight = function (elements) {\n        if (elements) {\n            if (elements instanceof Matrix) {\n                Matrix.matrix.setElements(elements.elements);\n            }\n            else {\n                Matrix.matrix.setElements(elements);\n            }\n        }\n        else {\n            Matrix.matrix.setIdentityElements();\n        }\n        return Matrix.matrix;\n    };\n    Matrix.matrix = new Matrix();\n    return Matrix;\n}());\n\nfunction createId(instance) {\n    var constructor = instance.constructor;\n    var className = constructor.className;\n    if (!className) {\n        throw new Error(\"The \" + constructor + \" is missing the 'className' property.\");\n    }\n    return className + '-' + (constructor.id = (constructor.id || 0) + 1);\n}\n\nvar PointerEvents;\n(function (PointerEvents) {\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /**\n         * Unique node ID in the form `ClassName-NaturalNumber`.\n         */\n        this.id = createId(this);\n        /**\n         * Some number to identify this node, typically within a `Group` node.\n         * Usually this will be some enum value used as a selector.\n         */\n        this.tag = NaN;\n        /**\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\n         */\n        this.isContainerNode = false;\n        this._children = [];\n        // Used to check for duplicate nodes.\n        this.childSet = {}; // new Set<Node>()\n        // These matrices may need to have package level visibility\n        // for performance optimization purposes.\n        this.matrix = new Matrix();\n        this.inverseMatrix = new Matrix();\n        this._dirtyTransform = false;\n        this._scalingX = 1;\n        this._scalingY = 1;\n        /**\n         * The center of scaling.\n         * The default value of `null` means the scaling center will be\n         * determined automatically, as the center of the bounding box\n         * of a node.\n         */\n        this._scalingCenterX = null;\n        this._scalingCenterY = null;\n        this._rotationCenterX = null;\n        this._rotationCenterY = null;\n        /**\n         * Rotation angle in radians.\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n         * interval is performed.\n         */\n        this._rotation = 0;\n        this._translationX = 0;\n        this._translationY = 0;\n        /**\n         * Each time a property of the node that effects how it renders changes\n         * the `dirty` property of the node should be set to `true`. The change\n         * to the `dirty` property of the node will propagate up to its parents\n         * and eventually to the scene, at which point an animation frame callback\n         * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n         * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n         * Since changes to node properties are not rendered immediately, it's possible\n         * to change as many properties on as many nodes as needed and the rendering\n         * will still only happen once in the next animation frame callback.\n         * The animation frame callback is only scheduled if it hasn't been already.\n         */\n        this._dirty = true;\n        this._visible = true;\n        this.pointerEvents = PointerEvents.All;\n    }\n    /**\n     * This is meaningfully faster than `instanceof` and should be the preferred way\n     * of checking inside loops.\n     * @param node\n     */\n    Node.isNode = function (node) {\n        return node ? node.matrix !== undefined : false;\n    };\n    Node.prototype._setScene = function (value) {\n        this._scene = value;\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            children[i]._setScene(value);\n        }\n    };\n    Object.defineProperty(Node.prototype, \"scene\", {\n        get: function () {\n            return this._scene;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype._setParent = function (value) {\n        this._parent = value;\n    };\n    Object.defineProperty(Node.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"children\", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.countChildren = function (depth) {\n        if (depth === void 0) { depth = Node.MAX_SAFE_INTEGER; }\n        if (depth <= 0) {\n            return 0;\n        }\n        var children = this.children;\n        var n = children.length;\n        var size = n;\n        for (var i = 0; i < n; i++) {\n            size += children[i].countChildren(depth - 1);\n        }\n        return size;\n    };\n    /**\n     * Appends one or more new node instances to this parent.\n     * If one needs to:\n     * - move a child to the end of the list of children\n     * - move a child from one parent to another (including parents in other scenes)\n     * one should use the {@link insertBefore} method instead.\n     * @param nodes A node or nodes to append.\n     */\n    Node.prototype.append = function (nodes) {\n        // Passing a single parameter to an open-ended version of `append`\n        // would be 30-35% slower than this.\n        if (Node.isNode(nodes)) {\n            nodes = [nodes];\n        }\n        // The function takes an array rather than having open-ended\n        // arguments like `...nodes: Node[]` because the latter is\n        // transpiled to a function where the `arguments` object\n        // is copied to a temporary array inside a loop.\n        // So an array is created either way. And if we already have\n        // an array of nodes we want to add, we have to use the prohibitively\n        // expensive spread operator to pass it to the function,\n        // and, on top of that, the copy of the `arguments` is still made.\n        var n = nodes.length;\n        for (var i = 0; i < n; i++) {\n            var node = nodes[i];\n            if (node.parent) {\n                throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n            }\n            if (node.scene) {\n                throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n            }\n            if (this.childSet[node.id]) {\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n                throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n            }\n            this._children.push(node);\n            this.childSet[node.id] = true;\n            node._setParent(this);\n            node._setScene(this.scene);\n        }\n        this.dirty = true;\n    };\n    Node.prototype.appendChild = function (node) {\n        if (node.parent) {\n            throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n        }\n        if (node.scene) {\n            throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n        }\n        if (this.childSet[node.id]) {\n            // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n            throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n        }\n        this._children.push(node);\n        this.childSet[node.id] = true;\n        node._setParent(this);\n        node._setScene(this.scene);\n        this.dirty = true;\n        return node;\n    };\n    Node.prototype.removeChild = function (node) {\n        if (node.parent === this) {\n            var i = this.children.indexOf(node);\n            if (i >= 0) {\n                this._children.splice(i, 1);\n                delete this.childSet[node.id];\n                node._setParent();\n                node._setScene();\n                this.dirty = true;\n                return node;\n            }\n        }\n        throw new Error(\"The node to be removed is not a child of this node.\");\n    };\n    /**\n     * Inserts the node `node` before the existing child node `nextNode`.\n     * If `nextNode` is null, insert `node` at the end of the list of children.\n     * If the `node` belongs to another parent, it is first removed.\n     * Returns the `node`.\n     * @param node\n     * @param nextNode\n     */\n    Node.prototype.insertBefore = function (node, nextNode) {\n        var parent = node.parent;\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n        if (nextNode && nextNode.parent === this) {\n            var i = this.children.indexOf(nextNode);\n            if (i >= 0) {\n                this._children.splice(i, 0, node);\n                this.childSet[node.id] = true;\n                node._setParent(this);\n                node._setScene(this.scene);\n            }\n            else {\n                throw new Error(nextNode + \" has \" + parent + \" as the parent, \"\n                    + \"but is not in its list of children.\");\n            }\n            this.dirty = true;\n        }\n        else {\n            this.append(node);\n        }\n        return node;\n    };\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            var parent = this.parent;\n            if (parent) {\n                var children = parent.children;\n                var index = children.indexOf(this);\n                if (index >= 0 && index <= children.length - 1) {\n                    return children[index + 1];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.transformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.invertSelf().transformPoint(x, y);\n    };\n    Node.prototype.inverseTransformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.transformPoint(x, y);\n    };\n    Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n        get: function () {\n            return this._dirtyTransform;\n        },\n        set: function (value) {\n            this._dirtyTransform = value;\n            if (value) {\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingX\", {\n        get: function () {\n            return this._scalingX;\n        },\n        set: function (value) {\n            if (this._scalingX !== value) {\n                this._scalingX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingY\", {\n        get: function () {\n            return this._scalingY;\n        },\n        set: function (value) {\n            if (this._scalingY !== value) {\n                this._scalingY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n        get: function () {\n            return this._scalingCenterX;\n        },\n        set: function (value) {\n            if (this._scalingCenterX !== value) {\n                this._scalingCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n        get: function () {\n            return this._scalingCenterY;\n        },\n        set: function (value) {\n            if (this._scalingCenterY !== value) {\n                this._scalingCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n        get: function () {\n            return this._rotationCenterX;\n        },\n        set: function (value) {\n            if (this._rotationCenterX !== value) {\n                this._rotationCenterX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n        get: function () {\n            return this._rotationCenterY;\n        },\n        set: function (value) {\n            if (this._rotationCenterY !== value) {\n                this._rotationCenterY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotation\", {\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            if (this._rotation !== value) {\n                this._rotation = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"rotationDeg\", {\n        get: function () {\n            return this.rotation / Math.PI * 180;\n        },\n        /**\n         * For performance reasons the rotation angle's internal representation\n         * is in radians. Therefore, don't expect to get the same number you set.\n         * Even with integer angles about a quarter of them from 0 to 359 cannot\n         * be converted to radians and back without precision loss.\n         * For example:\n         *\n         *     node.rotationDeg = 11;\n         *     console.log(node.rotationDeg); // 10.999999999999998\n         *\n         * @param value Rotation angle in degrees.\n         */\n        set: function (value) {\n            this.rotation = value / 180 * Math.PI;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationX\", {\n        get: function () {\n            return this._translationX;\n        },\n        set: function (value) {\n            if (this._translationX !== value) {\n                this._translationX = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"translationY\", {\n        get: function () {\n            return this._translationY;\n        },\n        set: function (value) {\n            if (this._translationY !== value) {\n                this._translationY = value;\n                this.dirtyTransform = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.containsPoint = function (x, y) {\n        return false;\n    };\n    /**\n     * Hit testing method.\n     * Recursively checks if the given point is inside this node or any of its children.\n     * Returns the first matching node or `undefined`.\n     * Nodes that render later (show on top) are hit tested first.\n     * @param x\n     * @param y\n     */\n    Node.prototype.pickNode = function (x, y) {\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n            return;\n        }\n        var children = this.children;\n        if (children.length) {\n            // Nodes added later should be hit-tested first,\n            // as they are rendered on top of the previously added nodes.\n            for (var i = children.length - 1; i >= 0; i--) {\n                var hit = children[i].pickNode(x, y);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n        else if (!this.isContainerNode) { // a leaf node, but not a container leaf\n            return this;\n        }\n    };\n    Node.prototype.computeBBox = function () { return; };\n    Node.prototype.computeBBoxCenter = function () {\n        var bbox = this.computeBBox && this.computeBBox();\n        if (bbox) {\n            return [\n                bbox.x + bbox.width * 0.5,\n                bbox.y + bbox.height * 0.5\n            ];\n        }\n        return [0, 0];\n    };\n    Node.prototype.computeTransformMatrix = function () {\n        // TODO: transforms without center of scaling and rotation correspond directly\n        //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n        //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n        //       within a group, rotating groups at right angles (e.g. for axis) and translating\n        //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n        //       can be done using D3-like scales already by inverting the output range.\n        //       So for now, just assume that centers of scaling and rotation are at the origin.\n        // const [bbcx, bbcy] = this.computeBBoxCenter();\n        var _a = [0, 0], bbcx = _a[0], bbcy = _a[1];\n        var sx = this.scalingX;\n        var sy = this.scalingY;\n        var scx;\n        var scy;\n        if (sx === 1 && sy === 1) {\n            scx = 0;\n            scy = 0;\n        }\n        else {\n            scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n            scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n        }\n        var r = this.rotation;\n        var cos = Math.cos(r);\n        var sin = Math.sin(r);\n        var rcx;\n        var rcy;\n        if (r === 0) {\n            rcx = 0;\n            rcy = 0;\n        }\n        else {\n            rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n            rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n        }\n        var tx = this.translationX;\n        var ty = this.translationY;\n        // The transform matrix `M` is a result of the following transformations:\n        // 1) translate the center of scaling to the origin\n        // 2) scale\n        // 3) translate back\n        // 4) translate the center of rotation to the origin\n        // 5) rotate\n        // 6) translate back\n        // 7) translate\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n        // Translation after steps 1-4 above:\n        var tx4 = scx * (1 - sx) - rcx;\n        var ty4 = scy * (1 - sy) - rcy;\n        this.dirtyTransform = false;\n        this.matrix.setElements([\n            cos * sx, sin * sx,\n            -sin * sy, cos * sy,\n            cos * tx4 - sin * ty4 + rcx + tx,\n            sin * tx4 + cos * ty4 + rcy + ty\n        ]).inverseTo(this.inverseMatrix);\n    };\n    Object.defineProperty(Node.prototype, \"dirty\", {\n        get: function () {\n            return this._dirty;\n        },\n        set: function (value) {\n            // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n            //       if we are, then all parents and the scene have been\n            //       notified already, and we are doing redundant work\n            //       (but test if this is indeed the case)\n            this._dirty = value;\n            if (value) {\n                if (this.parent) {\n                    this.parent.dirty = true;\n                }\n                else if (this.scene) {\n                    this.scene.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"visible\", {\n        get: function () {\n            return this._visible;\n        },\n        set: function (value) {\n            if (this._visible !== value) {\n                this._visible = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n    return Node;\n}());\n\n/**\n * Creates a new object with a `parent` as its prototype\n * and copies properties from the `child` into it.\n * @param parent\n * @param child\n */\nfunction chainObjects(parent, child) {\n    var obj = Object.create(parent);\n    for (var prop in child) {\n        if (child.hasOwnProperty(prop)) {\n            obj[prop] = child[prop];\n        }\n    }\n    return obj;\n}\nfunction getValue(object, path) {\n    var parts = Array.isArray(path) ? path : path.split('.');\n    var value = object;\n    parts.forEach(function (part) {\n        value = value[part];\n    });\n    return value;\n}\nfunction emptyTarget(value) {\n    return Array.isArray(value) ? [] : {};\n}\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepMerge(emptyTarget(value), value, options)\n        : value;\n}\nfunction defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n        return cloneUnlessOtherwiseSpecified(element, options);\n    });\n}\nfunction getMergeFunction(key, options) {\n    if (!options.customMerge) {\n        return deepMerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepMerge;\n}\nfunction getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n            return target.propertyIsEnumerable(symbol);\n        })\n        : [];\n}\nfunction getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n}\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\nfunction mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n        getKeys(target).forEach(function (key) {\n            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n        });\n    }\n    getKeys(source).forEach(function (key) {\n        if (propertyIsUnsafe(target, key)) {\n            return;\n        }\n        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n        }\n        else {\n            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n        }\n    });\n    return destination;\n}\nfunction defaultIsMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n}\nfunction isNonNullObject(value) {\n    return !!value && typeof value === 'object';\n}\nfunction isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]';\n}\nfunction deepMerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified(source, options);\n    }\n    else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options);\n    }\n    else {\n        return mergeObject(target, source, options);\n    }\n}\nfunction isObject(value) {\n    return typeof value === 'object' && !Array.isArray(value);\n}\n\nvar __extends$H = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Shape = /** @class */ (function (_super) {\n    __extends$H(Shape, _super);\n    function Shape() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lastInstanceId = 0;\n        _this._fillOpacity = 1;\n        _this._strokeOpacity = 1;\n        _this._fill = Shape.defaultStyles.fill;\n        /**\n         * Note that `strokeStyle = null` means invisible stroke,\n         * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\n         * For example, a rect shape with an invisible stroke may not align to the pixel grid\n         * properly because the stroke affects the rules of alignment, and arc shapes forming\n         * a pie chart will have a gap between them if they have an invisible stroke, whereas\n         * there would be not gap if there was no stroke at all.\n         * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\n         * unless specific looks that is achieved by having an invisible stroke is desired.\n         */\n        _this._stroke = Shape.defaultStyles.stroke;\n        _this._strokeWidth = Shape.defaultStyles.strokeWidth;\n        _this._lineDash = Shape.defaultStyles.lineDash;\n        _this._lineDashOffset = Shape.defaultStyles.lineDashOffset;\n        _this._lineCap = Shape.defaultStyles.lineCap;\n        _this._lineJoin = Shape.defaultStyles.lineJoin;\n        _this._opacity = Shape.defaultStyles.opacity;\n        _this.onShadowChange = function () {\n            _this.dirty = true;\n        };\n        _this._fillShadow = Shape.defaultStyles.fillShadow;\n        _this._strokeShadow = Shape.defaultStyles.strokeShadow;\n        return _this;\n    }\n    /**\n     * Creates a light-weight instance of the given shape (that serves as a template).\n     * The created instance only stores the properites set on the instance itself\n     * and the rest of the properties come via the prototype chain from the template.\n     * This can greatly reduce memory usage in cases where one has many simular shapes,\n     * for example, circles of different size, position and color. The exact memory usage\n     * reduction will depend on the size of the template and the number of own properties\n     * set on its lightweight instances, but will typically be around an order of magnitude\n     * or more.\n     *\n     * Note: template shapes are not supposed to be part of the scene graph (they should not\n     * have a parent).\n     *\n     * @param template\n     */\n    Shape.createInstance = function (template) {\n        var shape = Object.create(template);\n        shape._setParent(undefined);\n        shape.id = template.id + '-Instance-' + String(++template.lastInstanceId);\n        return shape;\n    };\n    /**\n     * Restores the default styles introduced by this subclass.\n     */\n    Shape.prototype.restoreOwnStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        var keys = Object.getOwnPropertyNames(styles);\n        // getOwnPropertyNames is about 2.5 times faster than\n        // for..in with the hasOwnProperty check and in this\n        // case, where most properties are inherited, can be\n        // more then an order of magnitude faster.\n        for (var i = 0, n = keys.length; i < n; i++) {\n            var key = keys[i];\n            this[key] = styles[key];\n        }\n    };\n    Shape.prototype.restoreAllStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        for (var property in styles) {\n            this[property] = styles[property];\n        }\n    };\n    /**\n     * Restores the base class default styles that have been overridden by this subclass.\n     */\n    Shape.prototype.restoreOverriddenStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        var protoStyles = Object.getPrototypeOf(styles);\n        for (var property in styles) {\n            if (styles.hasOwnProperty(property) && protoStyles.hasOwnProperty(property)) {\n                this[property] = styles[property];\n            }\n        }\n    };\n    Object.defineProperty(Shape.prototype, \"fillOpacity\", {\n        get: function () {\n            return this._fillOpacity;\n        },\n        set: function (value) {\n            if (this._fillOpacity !== value) {\n                this._fillOpacity = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"strokeOpacity\", {\n        get: function () {\n            return this._strokeOpacity;\n        },\n        set: function (value) {\n            if (this._strokeOpacity !== value) {\n                this._strokeOpacity = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"fill\", {\n        get: function () {\n            return this._fill;\n        },\n        set: function (value) {\n            if (this._fill !== value) {\n                this._fill = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"stroke\", {\n        get: function () {\n            return this._stroke;\n        },\n        set: function (value) {\n            if (this._stroke !== value) {\n                this._stroke = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"alignment\", {\n        // An offset value to align to the pixel grid.\n        get: function () {\n            return Math.floor(this.strokeWidth) % 2 / 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the aligned `start` or `length` value.\n    // For example: `start` could be `y` and `length` could be `height` of a rectangle.\n    Shape.prototype.align = function (alignment, start, length) {\n        if (length != undefined) {\n            return Math.floor(length) + Math.floor(start % 1 + length % 1);\n        }\n        return Math.floor(start) + alignment;\n    };\n    Object.defineProperty(Shape.prototype, \"lineDash\", {\n        get: function () {\n            return this._lineDash;\n        },\n        set: function (value) {\n            var oldValue = this._lineDash;\n            if (oldValue !== value) {\n                if (oldValue && value && oldValue.length === value.length) {\n                    var identical = true;\n                    var n = value.length;\n                    for (var i = 0; i < n; i++) {\n                        if (oldValue[i] !== value[i]) {\n                            identical = false;\n                            break;\n                        }\n                    }\n                    if (identical) {\n                        return;\n                    }\n                }\n                this._lineDash = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"lineDashOffset\", {\n        get: function () {\n            return this._lineDashOffset;\n        },\n        set: function (value) {\n            if (this._lineDashOffset !== value) {\n                this._lineDashOffset = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"lineCap\", {\n        get: function () {\n            return this._lineCap;\n        },\n        set: function (value) {\n            if (this._lineCap !== value) {\n                this._lineCap = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"lineJoin\", {\n        get: function () {\n            return this._lineJoin;\n        },\n        set: function (value) {\n            if (this._lineJoin !== value) {\n                this._lineJoin = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"opacity\", {\n        get: function () {\n            return this._opacity;\n        },\n        set: function (value) {\n            value = Math.min(1, Math.max(0, value));\n            if (this._opacity !== value) {\n                this._opacity = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"fillShadow\", {\n        get: function () {\n            return this._fillShadow;\n        },\n        set: function (value) {\n            var oldValue = this._fillShadow;\n            if (oldValue !== value) {\n                if (oldValue) {\n                    oldValue.removeEventListener('change', this.onShadowChange);\n                }\n                if (value) {\n                    value.addEventListener('change', this.onShadowChange);\n                }\n                this._fillShadow = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Shape.prototype, \"strokeShadow\", {\n        get: function () {\n            return this._strokeShadow;\n        },\n        set: function (value) {\n            var oldValue = this._strokeShadow;\n            if (oldValue !== value) {\n                if (oldValue) {\n                    oldValue.removeEventListener('change', this.onShadowChange);\n                }\n                if (value) {\n                    value.addEventListener('change', this.onShadowChange);\n                }\n                this._strokeShadow = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Shape.prototype.fillStroke = function (ctx) {\n        if (!this.scene) {\n            return;\n        }\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        if (this.fill) {\n            ctx.fillStyle = this.fill;\n            ctx.globalAlpha = this.opacity * this.fillOpacity;\n            // The canvas context scaling (depends on the device's pixel ratio)\n            // has no effect on shadows, so we have to account for the pixel ratio\n            // manually here.\n            var fillShadow = this.fillShadow;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fill();\n        }\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n        if (this.stroke && this.strokeWidth) {\n            ctx.strokeStyle = this.stroke;\n            ctx.globalAlpha = this.opacity * this.strokeOpacity;\n            ctx.lineWidth = this.strokeWidth;\n            if (this.lineDash) {\n                ctx.setLineDash(this.lineDash);\n            }\n            if (this.lineDashOffset) {\n                ctx.lineDashOffset = this.lineDashOffset;\n            }\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineJoin) {\n                ctx.lineJoin = this.lineJoin;\n            }\n            var strokeShadow = this.strokeShadow;\n            if (strokeShadow && strokeShadow.enabled) {\n                ctx.shadowColor = strokeShadow.color;\n                ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n            }\n            ctx.stroke();\n        }\n    };\n    Shape.prototype.containsPoint = function (x, y) {\n        return this.isPointInPath(x, y);\n    };\n    /**\n     * Defaults for style properties. Note that properties that affect the position\n     * and shape of the node are not considered style properties, for example:\n     * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n     * Can be used to reset to the original styling after some custom styling\n     * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).\n     * These static defaults are meant to be inherited by subclasses.\n     */\n    Shape.defaultStyles = chainObjects({}, {\n        fill: 'black',\n        stroke: undefined,\n        strokeWidth: 0,\n        lineDash: undefined,\n        lineDashOffset: 0,\n        lineCap: undefined,\n        lineJoin: undefined,\n        opacity: 1,\n        fillShadow: undefined,\n        strokeShadow: undefined\n    });\n    return Shape;\n}(Node));\n\n/**\n * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to\n * provide resolution independent rendering based on `window.devicePixelRatio`.\n */\nvar HdpiCanvas = /** @class */ (function () {\n    // The width/height attributes of the Canvas element default to\n    // 300/150 according to w3.org.\n    function HdpiCanvas(document, width, height) {\n        if (document === void 0) { document = window.document; }\n        if (width === void 0) { width = 600; }\n        if (height === void 0) { height = 300; }\n        this._container = undefined;\n        // `NaN` is deliberate here, so that overrides are always applied\n        // and the `resetTransform` inside the `resize` method works in IE11.\n        this._pixelRatio = NaN;\n        this.document = document;\n        this.element = document.createElement('canvas');\n        this.context = this.element.getContext('2d');\n        this.element.style.userSelect = 'none';\n        this.element.style.display = 'block';\n        this.setPixelRatio();\n        this.resize(width, height);\n    }\n    Object.defineProperty(HdpiCanvas.prototype, \"container\", {\n        get: function () {\n            return this._container;\n        },\n        set: function (value) {\n            if (this._container !== value) {\n                this.remove();\n                if (value) {\n                    value.appendChild(this.element);\n                }\n                this._container = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HdpiCanvas.prototype.remove = function () {\n        var parentNode = this.element.parentNode;\n        if (parentNode != null) {\n            parentNode.removeChild(this.element);\n        }\n    };\n    HdpiCanvas.prototype.destroy = function () {\n        this.element.remove();\n        this._canvas = undefined;\n        Object.freeze(this);\n    };\n    HdpiCanvas.prototype.toImage = function () {\n        var img = this.document.createElement('img');\n        img.src = this.getDataURL();\n        return img;\n    };\n    HdpiCanvas.prototype.getDataURL = function (type) {\n        return this.element.toDataURL(type);\n    };\n    /**\n     * @param options.fileName The `.png` extension is going to be added automatically.\n     * @param [options.background] Defaults to `white`.\n     */\n    HdpiCanvas.prototype.download = function (fileName) {\n        fileName = ((fileName || '').trim() || 'image') + '.png';\n        // Chart images saved as JPEG are a few times larger at 50% quality than PNG images,\n        // so we don't support saving to JPEG.\n        var type = 'image/png';\n        var dataUrl = this.getDataURL(type);\n        var document = this.document;\n        if (navigator.msSaveOrOpenBlob) { // IE11\n            var binary = atob(dataUrl.split(',')[1]); // strip the `data:image/png;base64,` part\n            var array = [];\n            for (var i = 0, n = binary.length; i < n; i++) {\n                array.push(binary.charCodeAt(i));\n            }\n            var blob = new Blob([new Uint8Array(array)], { type: type });\n            navigator.msSaveOrOpenBlob(blob, fileName);\n        }\n        else {\n            var a = document.createElement('a');\n            a.href = dataUrl;\n            a.download = fileName;\n            a.style.display = 'none';\n            document.body.appendChild(a); // required for the `click` to work in Firefox\n            a.click();\n            document.body.removeChild(a);\n        }\n    };\n    Object.defineProperty(HdpiCanvas.prototype, \"pixelRatio\", {\n        get: function () {\n            return this._pixelRatio;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Changes the pixel ratio of the Canvas element to the given value,\n     * or uses the window.devicePixelRatio (default), then resizes the Canvas\n     * element accordingly (default).\n     */\n    HdpiCanvas.prototype.setPixelRatio = function (ratio) {\n        var pixelRatio = ratio || window.devicePixelRatio;\n        if (pixelRatio === this.pixelRatio) {\n            return;\n        }\n        HdpiCanvas.overrideScale(this.context, pixelRatio);\n        this._pixelRatio = pixelRatio;\n        this.resize(this.width, this.height);\n    };\n    Object.defineProperty(HdpiCanvas.prototype, \"pixelated\", {\n        get: function () {\n            return this.element.style.imageRendering === 'pixelated';\n        },\n        set: function (value) {\n            this.element.style.imageRendering = value ? 'pixelated' : 'auto';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HdpiCanvas.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HdpiCanvas.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HdpiCanvas.prototype.resize = function (width, height) {\n        var _a = this, element = _a.element, context = _a.context, pixelRatio = _a.pixelRatio;\n        element.width = Math.round(width * pixelRatio);\n        element.height = Math.round(height * pixelRatio);\n        element.style.width = width + 'px';\n        element.style.height = height + 'px';\n        context.resetTransform();\n        this._width = width;\n        this._height = height;\n    };\n    Object.defineProperty(HdpiCanvas, \"textMeasuringContext\", {\n        get: function () {\n            if (this._textMeasuringContext) {\n                return this._textMeasuringContext;\n            }\n            var canvas = document.createElement('canvas');\n            return this._textMeasuringContext = canvas.getContext('2d');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HdpiCanvas, \"svgText\", {\n        get: function () {\n            if (this._svgText) {\n                return this._svgText;\n            }\n            var xmlns = 'http://www.w3.org/2000/svg';\n            var svg = document.createElementNS(xmlns, 'svg');\n            svg.setAttribute('width', '100');\n            svg.setAttribute('height', '100');\n            // Add a descriptive class name in case someone sees this SVG element\n            // in devtools and wonders about its purpose:\n            if (svg.classList) {\n                svg.classList.add('text-measuring-svg');\n            }\n            else {\n                svg.setAttribute('class', 'text-measuring-svg');\n            }\n            svg.style.position = 'absolute';\n            svg.style.top = '-1000px';\n            svg.style.visibility = 'hidden';\n            var svgText = document.createElementNS(xmlns, 'text');\n            svgText.setAttribute('x', '0');\n            svgText.setAttribute('y', '30');\n            svgText.setAttribute('text', 'black');\n            svg.appendChild(svgText);\n            document.body.appendChild(svg);\n            this._svgText = svgText;\n            return svgText;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HdpiCanvas, \"has\", {\n        get: function () {\n            if (this._has) {\n                return this._has;\n            }\n            return this._has = Object.freeze({\n                textMetrics: this.textMeasuringContext.measureText('test').actualBoundingBoxDescent !== undefined\n                    // Firefox implemented advanced TextMetrics object in v74:\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584\n                    // but it's buggy, so we'll keed using the SVG for text measurement in Firefox for now.\n                    && !/Firefox\\/\\d+(.\\d)+/.test(window.navigator.userAgent),\n                getTransform: this.textMeasuringContext.getTransform !== undefined\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HdpiCanvas.measureText = function (text, font, textBaseline, textAlign) {\n        var ctx = this.textMeasuringContext;\n        ctx.font = font;\n        ctx.textBaseline = textBaseline;\n        ctx.textAlign = textAlign;\n        return ctx.measureText(text);\n    };\n    /**\n     * Returns the width and height of the measured text.\n     * @param text The single-line text to measure.\n     * @param font The font shorthand string.\n     */\n    HdpiCanvas.getTextSize = function (text, font) {\n        if (this.has.textMetrics) {\n            var ctx = this.textMeasuringContext;\n            ctx.font = font;\n            var metrics = ctx.measureText(text);\n            return {\n                width: metrics.width,\n                height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n            };\n        }\n        else {\n            return this.measureSvgText(text, font);\n        }\n    };\n    HdpiCanvas.measureSvgText = function (text, font) {\n        var cache = this.textSizeCache;\n        var fontCache = cache[font];\n        // Note: consider not caching the size of numeric strings.\n        // For example: if (isNaN(+text)) { // skip\n        if (fontCache) {\n            var size_1 = fontCache[text];\n            if (size_1) {\n                return size_1;\n            }\n        }\n        else {\n            cache[font] = {};\n        }\n        var svgText = this.svgText;\n        svgText.style.font = font;\n        svgText.textContent = text;\n        // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`\n        // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.\n        // But the `SVGRect` instance has half the properties of the `DOMRect`,\n        // so we use the `getBBox` method.\n        var bbox = svgText.getBBox();\n        var size = {\n            width: bbox.width,\n            height: bbox.height\n        };\n        cache[font][text] = size;\n        return size;\n    };\n    HdpiCanvas.overrideScale = function (ctx, scale) {\n        var depth = 0;\n        var overrides = {\n            save: function () {\n                this.$save();\n                depth++;\n            },\n            restore: function () {\n                if (depth > 0) {\n                    this.$restore();\n                    depth--;\n                }\n            },\n            setTransform: function (a, b, c, d, e, f) {\n                this.$setTransform(a * scale, b * scale, c * scale, d * scale, e * scale, f * scale);\n            },\n            resetTransform: function () {\n                // As of Jan 8, 2019, `resetTransform` is still an \"experimental technology\",\n                // and doesn't work in IE11 and Edge 44.\n                this.$setTransform(scale, 0, 0, scale, 0, 0);\n                this.save();\n                depth = 0;\n                // The scale above will be impossible to restore,\n                // because we override the `ctx.restore` above and\n                // check `depth` there.\n            }\n        };\n        for (var name_1 in overrides) {\n            if (overrides.hasOwnProperty(name_1)) {\n                // Save native methods under prefixed names,\n                // if this hasn't been done by the previous overrides already.\n                if (!ctx['$' + name_1]) {\n                    ctx['$' + name_1] = ctx[name_1];\n                }\n                // Replace native methods with overrides,\n                // or previous overrides with the new ones.\n                ctx[name_1] = overrides[name_1];\n            }\n        }\n    };\n    HdpiCanvas.textSizeCache = {};\n    return HdpiCanvas;\n}());\n\nvar __extends$I = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Text = /** @class */ (function (_super) {\n    __extends$I(Text, _super);\n    function Text() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._x = 0;\n        _this._y = 0;\n        _this.lineBreakRegex = /\\r?\\n/g;\n        _this.lines = [];\n        _this._text = '';\n        _this._dirtyFont = true;\n        _this._fontSize = 10;\n        _this._fontFamily = 'sans-serif';\n        _this._textAlign = Text.defaultStyles.textAlign;\n        _this._textBaseline = Text.defaultStyles.textBaseline;\n        _this._lineHeight = 14;\n        return _this;\n    }\n    Object.defineProperty(Text.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Text.prototype.splitText = function () {\n        this.lines = this._text.split(this.lineBreakRegex);\n    };\n    Object.defineProperty(Text.prototype, \"text\", {\n        get: function () {\n            return this._text;\n        },\n        set: function (value) {\n            var str = String(value); // `value` can be an object here\n            if (this._text !== str) {\n                this._text = str;\n                this.splitText();\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"font\", {\n        get: function () {\n            if (this.dirtyFont) {\n                this.dirtyFont = false;\n                this._font = [\n                    this.fontStyle || '',\n                    this.fontWeight || '',\n                    this.fontSize + 'px',\n                    this.fontFamily\n                ].join(' ').trim();\n            }\n            return this._font;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"dirtyFont\", {\n        get: function () {\n            return this._dirtyFont;\n        },\n        set: function (value) {\n            if (this._dirtyFont !== value) {\n                this._dirtyFont = value;\n                if (value) {\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"fontStyle\", {\n        get: function () {\n            return this._fontStyle;\n        },\n        set: function (value) {\n            if (this._fontStyle !== value) {\n                this._fontStyle = value;\n                this.dirtyFont = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"fontWeight\", {\n        get: function () {\n            return this._fontWeight;\n        },\n        set: function (value) {\n            if (this._fontWeight !== value) {\n                this._fontWeight = value;\n                this.dirtyFont = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"fontSize\", {\n        get: function () {\n            return this._fontSize;\n        },\n        set: function (value) {\n            if (!isFinite(value)) {\n                value = 10;\n            }\n            if (this._fontSize !== value) {\n                this._fontSize = value;\n                this.dirtyFont = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"fontFamily\", {\n        get: function () {\n            return this._fontFamily;\n        },\n        set: function (value) {\n            if (this._fontFamily !== value) {\n                this._fontFamily = value;\n                this.dirtyFont = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"textAlign\", {\n        get: function () {\n            return this._textAlign;\n        },\n        set: function (value) {\n            if (this._textAlign !== value) {\n                this._textAlign = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"textBaseline\", {\n        get: function () {\n            return this._textBaseline;\n        },\n        set: function (value) {\n            if (this._textBaseline !== value) {\n                this._textBaseline = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"lineHeight\", {\n        get: function () {\n            return this._lineHeight;\n        },\n        set: function (value) {\n            // Multi-line text is complicated because:\n            // - Canvas does not support it natively, so we have to implement it manually\n            // - need to know the height of each line -> need to parse the font shorthand ->\n            //   generally impossible to do because font size may not be in pixels\n            // - so, need to measure the text instead, each line individually -> expensive\n            // - or make the user provide the line height manually for multi-line text\n            // - computeBBox should use the lineHeight for multi-line text but ignore it otherwise\n            // - textBaseline kind of loses its meaning for multi-line text\n            if (this._lineHeight !== value) {\n                this._lineHeight = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Text.prototype.computeBBox = function () {\n        return HdpiCanvas.has.textMetrics\n            ? this.getPreciseBBox()\n            : this.getApproximateBBox();\n    };\n    Text.prototype.getPreciseBBox = function () {\n        var metrics = HdpiCanvas.measureText(this.text, this.font, this.textBaseline, this.textAlign);\n        return new BBox(this.x - metrics.actualBoundingBoxLeft, this.y - metrics.actualBoundingBoxAscent, metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);\n    };\n    Text.prototype.getApproximateBBox = function () {\n        var size = HdpiCanvas.getTextSize(this.text, this.font);\n        var _a = this, x = _a.x, y = _a.y;\n        switch (this.textAlign) {\n            case 'end':\n            case 'right':\n                x -= size.width;\n                break;\n            case 'center':\n                x -= size.width / 2;\n        }\n        switch (this.textBaseline) {\n            case 'alphabetic':\n                y -= size.height * 0.7;\n                break;\n            case 'middle':\n                y -= size.height * 0.45;\n                break;\n            case 'ideographic':\n                y -= size.height;\n                break;\n            case 'hanging':\n                y -= size.height * 0.2;\n                break;\n            case 'bottom':\n                y -= size.height;\n                break;\n        }\n        return new BBox(x, y, size.width, size.height);\n    };\n    Text.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return bbox ? bbox.containsPoint(point.x, point.y) : false;\n    };\n    Text.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Text.prototype.render = function (ctx) {\n        if (!this.lines.length || !this.scene) {\n            return;\n        }\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        // this.matrix.transformBBox(this.computeBBox!()).render(ctx); // debug\n        this.matrix.toContext(ctx);\n        var _a = this, fill = _a.fill, stroke = _a.stroke, strokeWidth = _a.strokeWidth;\n        ctx.font = this.font;\n        ctx.textAlign = this.textAlign;\n        ctx.textBaseline = this.textBaseline;\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        if (fill) {\n            ctx.fillStyle = fill;\n            ctx.globalAlpha = this.opacity * this.fillOpacity;\n            var _b = this, fillShadow = _b.fillShadow, text = _b.text, x = _b.x, y = _b.y;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fillText(text, x, y);\n        }\n        if (stroke && strokeWidth) {\n            ctx.strokeStyle = stroke;\n            ctx.lineWidth = strokeWidth;\n            ctx.globalAlpha = this.opacity * this.strokeOpacity;\n            var _c = this, lineDash = _c.lineDash, lineDashOffset = _c.lineDashOffset, lineCap = _c.lineCap, lineJoin = _c.lineJoin, strokeShadow = _c.strokeShadow, text = _c.text, x = _c.x, y = _c.y;\n            if (lineDash) {\n                ctx.setLineDash(lineDash);\n            }\n            if (lineDashOffset) {\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            if (lineCap) {\n                ctx.lineCap = lineCap;\n            }\n            if (lineJoin) {\n                ctx.lineJoin = lineJoin;\n            }\n            if (strokeShadow && strokeShadow.enabled) {\n                ctx.shadowColor = strokeShadow.color;\n                ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n            }\n            ctx.strokeText(text, x, y);\n        }\n        this.dirty = false;\n    };\n    Text.className = 'Text';\n    Text.defaultStyles = chainObjects(Shape.defaultStyles, {\n        textAlign: 'start',\n        fontStyle: undefined,\n        fontWeight: undefined,\n        fontSize: 10,\n        fontFamily: 'sans-serif',\n        textBaseline: 'alphabetic'\n    });\n    return Text;\n}(Shape));\n\nvar __assign$1 = (undefined && undefined.__assign) || function () {\n    __assign$1 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$1.apply(this, arguments);\n};\nvar Observable = /** @class */ (function () {\n    function Observable() {\n        // Note that these maps can't be specified generically, so they are kept untyped.\n        // Some methods in this class only need generics in their signatures, the generics inside the methods\n        // are just for clarity. The generics in signatures allow for static type checking of user provided\n        // listeners and for type inference, so that the users wouldn't have to specify the type of parameters\n        // of their inline lambdas.\n        this.allPropertyListeners = new Map(); // property name => property change listener => scopes\n        this.allEventListeners = new Map(); // event type => event listener => scopes\n    }\n    Observable.prototype.addPropertyListener = function (name, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (!propertyListeners) {\n            propertyListeners = new Map();\n            allPropertyListeners.set(name, propertyListeners);\n        }\n        if (!propertyListeners.has(listener)) {\n            var scopes_1 = new Set();\n            propertyListeners.set(listener, scopes_1);\n        }\n        var scopes = propertyListeners.get(listener);\n        if (scopes) {\n            scopes.add(scope);\n        }\n    };\n    Observable.prototype.removePropertyListener = function (name, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (propertyListeners) {\n            if (listener) {\n                var scopes = propertyListeners.get(listener);\n                if (scopes) {\n                    scopes.delete(scope);\n                    if (!scopes.size) {\n                        propertyListeners.delete(listener);\n                    }\n                }\n            }\n            else {\n                propertyListeners.clear();\n            }\n        }\n    };\n    Observable.prototype.notifyPropertyListeners = function (name, oldValue, value) {\n        var _this = this;\n        var allPropertyListeners = this.allPropertyListeners;\n        var propertyListeners = allPropertyListeners.get(name);\n        if (propertyListeners) {\n            propertyListeners.forEach(function (scopes, listener) {\n                scopes.forEach(function (scope) { return listener.call(scope, { type: name, source: _this, value: value, oldValue: oldValue }); });\n            });\n        }\n    };\n    Observable.prototype.addEventListener = function (type, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allEventListeners = this.allEventListeners;\n        var eventListeners = allEventListeners.get(type);\n        if (!eventListeners) {\n            eventListeners = new Map();\n            allEventListeners.set(type, eventListeners);\n        }\n        if (!eventListeners.has(listener)) {\n            var scopes_2 = new Set();\n            eventListeners.set(listener, scopes_2);\n        }\n        var scopes = eventListeners.get(listener);\n        if (scopes) {\n            scopes.add(scope);\n        }\n    };\n    Observable.prototype.removeEventListener = function (type, listener, scope) {\n        if (scope === void 0) { scope = this; }\n        var allEventListeners = this.allEventListeners;\n        var eventListeners = allEventListeners.get(type);\n        if (eventListeners) {\n            if (listener) {\n                var scopes = eventListeners.get(listener);\n                if (scopes) {\n                    scopes.delete(scope);\n                    if (!scopes.size) {\n                        eventListeners.delete(listener);\n                    }\n                }\n            }\n            else {\n                eventListeners.clear();\n            }\n        }\n    };\n    Observable.prototype.notifyEventListeners = function (types) {\n        var _this = this;\n        var allEventListeners = this.allEventListeners;\n        types.forEach(function (type) {\n            var listeners = allEventListeners.get(type);\n            if (listeners) {\n                listeners.forEach(function (scopes, listener) {\n                    scopes.forEach(function (scope) { return listener.call(scope, { type: type, source: _this }); });\n                });\n            }\n        });\n    };\n    // 'source' is added automatically and is always the object this method belongs to.\n    Observable.prototype.fireEvent = function (event) {\n        var _this = this;\n        var listeners = this.allEventListeners.get(event.type);\n        if (listeners) {\n            listeners.forEach(function (scopes, listener) {\n                scopes.forEach(function (scope) { return listener.call(scope, __assign$1(__assign$1({}, event), { source: _this })); });\n            });\n        }\n    };\n    Observable.privateKeyPrefix = '_';\n    return Observable;\n}());\nfunction reactive() {\n    var events = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        events[_i] = arguments[_i];\n    }\n    // let debug = events.indexOf('debugger') >= 0;\n    return function (target, key) {\n        // `target` is either a constructor (static member) or prototype (instance member)\n        var privateKey = Observable.privateKeyPrefix + key;\n        var privateKeyEvents = privateKey + 'Events';\n        if (!target[key]) {\n            if (events) {\n                target[privateKeyEvents] = events;\n            }\n            Object.defineProperty(target, key, {\n                set: function (value) {\n                    var oldValue = this[privateKey];\n                    // This is a way to stop inside the setter by adding the special\n                    // 'debugger' event to a reactive property, for example:\n                    //  @reactive('layoutChange', 'debugger') title?: Caption;\n                    // if (debug) { // DO NOT REMOVE\n                    //     debugger;\n                    // }\n                    if (value !== oldValue || (typeof value === 'object' && value !== null)) {\n                        this[privateKey] = value;\n                        this.notifyPropertyListeners(key, oldValue, value);\n                        var events_1 = this[privateKeyEvents];\n                        if (events_1) {\n                            this.notifyEventListeners(events_1);\n                        }\n                    }\n                },\n                get: function () {\n                    return this[privateKey];\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    };\n}\n\nvar __extends$J = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Caption = /** @class */ (function (_super) {\n    __extends$J(Caption, _super);\n    function Caption() {\n        var _this = _super.call(this) || this;\n        _this.node = new Text();\n        _this.enabled = false;\n        _this.padding = new Padding(10);\n        var node = _this.node;\n        node.textAlign = 'center';\n        node.textBaseline = 'top';\n        node.pointerEvents = PointerEvents.None;\n        return _this;\n    }\n    Object.defineProperty(Caption.prototype, \"text\", {\n        get: function () {\n            return this.node.text;\n        },\n        set: function (value) {\n            if (this.node.text !== value) {\n                this.node.text = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Caption.prototype, \"fontStyle\", {\n        get: function () {\n            return this.node.fontStyle;\n        },\n        set: function (value) {\n            if (this.node.fontStyle !== value) {\n                this.node.fontStyle = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Caption.prototype, \"fontWeight\", {\n        get: function () {\n            return this.node.fontWeight;\n        },\n        set: function (value) {\n            if (this.node.fontWeight !== value) {\n                this.node.fontWeight = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Caption.prototype, \"fontSize\", {\n        get: function () {\n            return this.node.fontSize;\n        },\n        set: function (value) {\n            if (this.node.fontSize !== value) {\n                this.node.fontSize = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Caption.prototype, \"fontFamily\", {\n        get: function () {\n            return this.node.fontFamily;\n        },\n        set: function (value) {\n            if (this.node.fontFamily !== value) {\n                this.node.fontFamily = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Caption.prototype, \"color\", {\n        get: function () {\n            return this.node.fill;\n        },\n        set: function (value) {\n            if (this.node.fill !== value) {\n                this.node.fill = value;\n                this.fireEvent({ type: 'change' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate$F([\n        reactive('change')\n    ], Caption.prototype, \"enabled\", void 0);\n    __decorate$F([\n        reactive('change')\n    ], Caption.prototype, \"padding\", void 0);\n    return Caption;\n}(Observable));\n\nvar constant = (function (x) { return function () { return x; }; });\n\nfunction interpolateNumber (a, b) {\n    a = +a;\n    b = +b;\n    return function (t) { return a * (1 - t) + b * t; };\n}\n\nfunction date (a, b) {\n    var date = new Date;\n    var msA = +a;\n    var msB = +b;\n    return function (t) {\n        date.setTime(msA * (1 - t) + msB * t);\n        return date;\n    };\n}\n\nfunction array (a, b) {\n    var nb = b ? b.length : 0;\n    var na = a ? Math.min(nb, a.length) : 0;\n    var x = new Array(na);\n    var c = new Array(nb);\n    var i;\n    for (i = 0; i < na; ++i) {\n        x[i] = interpolateValue(a[i], b[i]);\n    }\n    for (; i < nb; ++i) {\n        c[i] = b[i];\n    }\n    return function (t) {\n        for (i = 0; i < na; ++i) {\n            c[i] = x[i](t);\n        }\n        return c;\n    };\n}\n\nfunction object (a, b) {\n    var i = {};\n    var c = {};\n    var k;\n    if (a === null || typeof a !== 'object') {\n        a = {};\n    }\n    if (b === null || typeof b !== 'object') {\n        b = {};\n    }\n    for (k in b) {\n        if (k in a) {\n            i[k] = interpolateValue(a[k], b[k]);\n        }\n        else {\n            c[k] = b[k];\n        }\n    }\n    return function (t) {\n        for (k in i) {\n            c[k] = i[k](t);\n        }\n        return c;\n    };\n}\n\nvar Color = /** @class */ (function () {\n    /**\n     * Every color component should be in the [0, 1] range.\n     * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n     * So, when animating colors, if the source or target color components are already near\n     * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n     * component value to end up outside of that range mid-animation. For this reason the constructor\n     * performs range checking/constraining.\n     * @param r Red component.\n     * @param g Green component.\n     * @param b Blue component.\n     * @param a Alpha (opacity) component.\n     */\n    function Color(r, g, b, a) {\n        if (a === void 0) { a = 1; }\n        // NaN is treated as 0.\n        this.r = Math.min(1, Math.max(0, r || 0));\n        this.g = Math.min(1, Math.max(0, g || 0));\n        this.b = Math.min(1, Math.max(0, b || 0));\n        this.a = Math.min(1, Math.max(0, a || 0));\n    }\n    /**\n     * The given string can be in one of the following formats:\n     * - #rgb\n     * - #rrggbb\n     * - rgb(r, g, b)\n     * - rgba(r, g, b, a)\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\n     * @param str\n     */\n    Color.fromString = function (str) {\n        // hexadecimal notation\n        if (str.indexOf('#') >= 0) { // there can be some leading whitespace\n            return Color.fromHexString(str);\n        }\n        // color name\n        var hex = Color.nameToHex[str];\n        if (hex) {\n            return Color.fromHexString(hex);\n        }\n        // rgb(a) notation\n        if (str.indexOf('rgb') >= 0) {\n            return Color.fromRgbaString(str);\n        }\n        throw new Error(\"Invalid color string: '\" + str + \"'\");\n    };\n    // Using separate RegExp for the short hex notation because strings like `#abcd`\n    // are matched as ['#abcd', 'ab', 'c', 'd', undefined] when the `{1,2}` quantifier is used.\n    Color.fromHexString = function (str) {\n        var values = str.match(Color.hexRe);\n        if (values) {\n            var r = parseInt(values[1], 16);\n            var g = parseInt(values[2], 16);\n            var b = parseInt(values[3], 16);\n            var a = values[4] !== undefined ? parseInt(values[4], 16) : 255;\n            return new Color(r / 255, g / 255, b / 255, a / 255);\n        }\n        values = str.match(Color.shortHexRe);\n        if (values) {\n            var r = parseInt(values[1], 16);\n            var g = parseInt(values[2], 16);\n            var b = parseInt(values[3], 16);\n            var a = values[4] !== undefined ? parseInt(values[4], 16) : 15;\n            r += r * 16;\n            g += g * 16;\n            b += b * 16;\n            a += a * 16;\n            return new Color(r / 255, g / 255, b / 255, a / 255);\n        }\n        throw new Error(\"Malformed hexadecimal color string: '\" + str + \"'\");\n    };\n    Color.fromRgbaString = function (str) {\n        var values = str.match(Color.rgbRe);\n        if (values) {\n            return new Color(+values[1] / 255, +values[2] / 255, +values[3] / 255);\n        }\n        values = str.match(Color.rgbaRe);\n        if (values) {\n            return new Color(+values[1] / 255, +values[2] / 255, +values[3] / 255, +values[4]);\n        }\n        throw new Error(\"Malformed rgb/rgba color string: '\" + str + \"'\");\n    };\n    Color.fromArray = function (arr) {\n        if (arr.length === 4) {\n            return new Color(arr[0], arr[1], arr[2], arr[3]);\n        }\n        if (arr.length === 3) {\n            return new Color(arr[0], arr[1], arr[2]);\n        }\n        throw new Error('The given array should contain 3 or 4 color components (numbers).');\n    };\n    Color.fromHSB = function (h, s, b, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        var rgb = Color.HSBtoRGB(h, s, b);\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\n    };\n    Color.padHex = function (str) {\n        // Can't use `padStart(2, '0')` here because of IE.\n        return str.length === 1 ? '0' + str : str;\n    };\n    Color.prototype.toHexString = function () {\n        var hex = '#'\n            + Color.padHex(Math.round(this.r * 255).toString(16))\n            + Color.padHex(Math.round(this.g * 255).toString(16))\n            + Color.padHex(Math.round(this.b * 255).toString(16));\n        if (this.a < 1) {\n            hex += Color.padHex(Math.round(this.a * 255).toString(16));\n        }\n        return hex;\n    };\n    Color.prototype.toRgbaString = function (fractionDigits) {\n        if (fractionDigits === void 0) { fractionDigits = 3; }\n        var components = [\n            Math.round(this.r * 255),\n            Math.round(this.g * 255),\n            Math.round(this.b * 255)\n        ];\n        var k = Math.pow(10, fractionDigits);\n        if (this.a !== 1) {\n            components.push(Math.round(this.a * k) / k);\n            return \"rgba(\" + components.join(', ') + \")\";\n        }\n        return \"rgb(\" + components.join(', ') + \")\";\n    };\n    Color.prototype.toString = function () {\n        if (this.a === 1) {\n            return this.toHexString();\n        }\n        return this.toRgbaString();\n    };\n    Color.prototype.toHSB = function () {\n        return Color.RGBtoHSB(this.r, this.g, this.b);\n    };\n    /**\n     * Converts the given RGB triple to an array of HSB (HSV) components.\n     * The hue component will be `NaN` for achromatic colors.\n     */\n    Color.RGBtoHSB = function (r, g, b) {\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var S = max !== 0 ? (max - min) / max : 0;\n        var H = NaN;\n        // min == max, means all components are the same\n        // and the color is a shade of gray with no hue (H is NaN)\n        if (min !== max) {\n            var delta = max - min;\n            var rc = (max - r) / delta;\n            var gc = (max - g) / delta;\n            var bc = (max - b) / delta;\n            if (r === max) {\n                H = bc - gc;\n            }\n            else if (g === max) {\n                H = 2.0 + rc - bc;\n            }\n            else {\n                H = 4.0 + gc - rc;\n            }\n            H /= 6.0;\n            if (H < 0) {\n                H = H + 1.0;\n            }\n        }\n        return [H * 360, S, max];\n    };\n    /**\n     * Converts the given HSB (HSV) triple to an array of RGB components.\n     */\n    Color.HSBtoRGB = function (H, S, B) {\n        if (isNaN(H)) {\n            H = 0;\n        }\n        H = (((H % 360) + 360) % 360) / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        if (S === 0) {\n            r = g = b = B;\n        }\n        else {\n            var h = (H - Math.floor(H)) * 6;\n            var f = h - Math.floor(h);\n            var p = B * (1 - S);\n            var q = B * (1 - S * f);\n            var t = B * (1 - (S * (1 - f)));\n            switch (h >> 0) { // discard the floating point part of the number\n                case 0:\n                    r = B;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = B;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = B;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = B;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = B;\n                    break;\n                case 5:\n                    r = B;\n                    g = p;\n                    b = q;\n                    break;\n            }\n        }\n        return [r, g, b];\n    };\n    Color.prototype.derive = function (hueShift, saturationFactor, brightnessFactor, opacityFactor) {\n        var hsb = Color.RGBtoHSB(this.r, this.g, this.b);\n        var b = hsb[2];\n        if (b == 0 && brightnessFactor > 1.0) {\n            b = 0.05;\n        }\n        var h = (((hsb[0] + hueShift) % 360) + 360) % 360;\n        var s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);\n        b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);\n        var a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);\n        var rgba = Color.HSBtoRGB(h, s, b);\n        rgba.push(a);\n        return Color.fromArray(rgba);\n    };\n    Color.prototype.brighter = function () {\n        return this.derive(0, 1.0, 1.0 / 0.7, 1.0);\n    };\n    Color.prototype.darker = function () {\n        return this.derive(0, 1.0, 0.7, 1.0);\n    };\n    // See https://drafts.csswg.org/css-color/#hex-notation\n    Color.hexRe = /\\s*#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?\\s*$/;\n    Color.shortHexRe = /\\s*#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?\\s*$/;\n    Color.rgbRe = /\\s*rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)\\s*/;\n    Color.rgbaRe = /\\s*rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([.\\d]+)\\)\\s*/;\n    /**\n     * CSS Color Module Level 4:\n     * https://drafts.csswg.org/css-color/#named-colors\n     */\n    Color.nameToHex = Object.freeze({\n        aliceblue: '#F0F8FF',\n        antiquewhite: '#FAEBD7',\n        aqua: '#00FFFF',\n        aquamarine: '#7FFFD4',\n        azure: '#F0FFFF',\n        beige: '#F5F5DC',\n        bisque: '#FFE4C4',\n        black: '#000000',\n        blanchedalmond: '#FFEBCD',\n        blue: '#0000FF',\n        blueviolet: '#8A2BE2',\n        brown: '#A52A2A',\n        burlywood: '#DEB887',\n        cadetblue: '#5F9EA0',\n        chartreuse: '#7FFF00',\n        chocolate: '#D2691E',\n        coral: '#FF7F50',\n        cornflowerblue: '#6495ED',\n        cornsilk: '#FFF8DC',\n        crimson: '#DC143C',\n        cyan: '#00FFFF',\n        darkblue: '#00008B',\n        darkcyan: '#008B8B',\n        darkgoldenrod: '#B8860B',\n        darkgray: '#A9A9A9',\n        darkgreen: '#006400',\n        darkgrey: '#A9A9A9',\n        darkkhaki: '#BDB76B',\n        darkmagenta: '#8B008B',\n        darkolivegreen: '#556B2F',\n        darkorange: '#FF8C00',\n        darkorchid: '#9932CC',\n        darkred: '#8B0000',\n        darksalmon: '#E9967A',\n        darkseagreen: '#8FBC8F',\n        darkslateblue: '#483D8B',\n        darkslategray: '#2F4F4F',\n        darkslategrey: '#2F4F4F',\n        darkturquoise: '#00CED1',\n        darkviolet: '#9400D3',\n        deeppink: '#FF1493',\n        deepskyblue: '#00BFFF',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1E90FF',\n        firebrick: '#B22222',\n        floralwhite: '#FFFAF0',\n        forestgreen: '#228B22',\n        fuchsia: '#FF00FF',\n        gainsboro: '#DCDCDC',\n        ghostwhite: '#F8F8FF',\n        gold: '#FFD700',\n        goldenrod: '#DAA520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#ADFF2F',\n        grey: '#808080',\n        honeydew: '#F0FFF0',\n        hotpink: '#FF69B4',\n        indianred: '#CD5C5C',\n        indigo: '#4B0082',\n        ivory: '#FFFFF0',\n        khaki: '#F0E68C',\n        lavender: '#E6E6FA',\n        lavenderblush: '#FFF0F5',\n        lawngreen: '#7CFC00',\n        lemonchiffon: '#FFFACD',\n        lightblue: '#ADD8E6',\n        lightcoral: '#F08080',\n        lightcyan: '#E0FFFF',\n        lightgoldenrodyellow: '#FAFAD2',\n        lightgray: '#D3D3D3',\n        lightgreen: '#90EE90',\n        lightgrey: '#D3D3D3',\n        lightpink: '#FFB6C1',\n        lightsalmon: '#FFA07A',\n        lightseagreen: '#20B2AA',\n        lightskyblue: '#87CEFA',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#B0C4DE',\n        lightyellow: '#FFFFE0',\n        lime: '#00FF00',\n        limegreen: '#32CD32',\n        linen: '#FAF0E6',\n        magenta: '#FF00FF',\n        maroon: '#800000',\n        mediumaquamarine: '#66CDAA',\n        mediumblue: '#0000CD',\n        mediumorchid: '#BA55D3',\n        mediumpurple: '#9370DB',\n        mediumseagreen: '#3CB371',\n        mediumslateblue: '#7B68EE',\n        mediumspringgreen: '#00FA9A',\n        mediumturquoise: '#48D1CC',\n        mediumvioletred: '#C71585',\n        midnightblue: '#191970',\n        mintcream: '#F5FFFA',\n        mistyrose: '#FFE4E1',\n        moccasin: '#FFE4B5',\n        navajowhite: '#FFDEAD',\n        navy: '#000080',\n        oldlace: '#FDF5E6',\n        olive: '#808000',\n        olivedrab: '#6B8E23',\n        orange: '#FFA500',\n        orangered: '#FF4500',\n        orchid: '#DA70D6',\n        palegoldenrod: '#EEE8AA',\n        palegreen: '#98FB98',\n        paleturquoise: '#AFEEEE',\n        palevioletred: '#DB7093',\n        papayawhip: '#FFEFD5',\n        peachpuff: '#FFDAB9',\n        peru: '#CD853F',\n        pink: '#FFC0CB',\n        plum: '#DDA0DD',\n        powderblue: '#B0E0E6',\n        purple: '#800080',\n        rebeccapurple: '#663399',\n        red: '#FF0000',\n        rosybrown: '#BC8F8F',\n        royalblue: '#4169E1',\n        saddlebrown: '#8B4513',\n        salmon: '#FA8072',\n        sandybrown: '#F4A460',\n        seagreen: '#2E8B57',\n        seashell: '#FFF5EE',\n        sienna: '#A0522D',\n        silver: '#C0C0C0',\n        skyblue: '#87CEEB',\n        slateblue: '#6A5ACD',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#FFFAFA',\n        springgreen: '#00FF7F',\n        steelblue: '#4682B4',\n        tan: '#D2B48C',\n        teal: '#008080',\n        thistle: '#D8BFD8',\n        tomato: '#FF6347',\n        turquoise: '#40E0D0',\n        violet: '#EE82EE',\n        wheat: '#F5DEB3',\n        white: '#FFFFFF',\n        whitesmoke: '#F5F5F5',\n        yellow: '#FFFF00',\n        yellowgreen: '#9ACD32'\n    });\n    return Color;\n}());\n\nfunction color (a, b) {\n    if (typeof a === 'string') {\n        try {\n            a = Color.fromString(a);\n        }\n        catch (e) {\n            a = Color.fromArray([0, 0, 0]);\n        }\n    }\n    if (typeof b === 'string') {\n        try {\n            b = Color.fromString(b);\n        }\n        catch (e) {\n            b = Color.fromArray([0, 0, 0]);\n        }\n    }\n    var red = interpolateNumber(a.r, b.r);\n    var green = interpolateNumber(a.g, b.g);\n    var blue = interpolateNumber(a.b, b.b);\n    var alpha = interpolateNumber(a.a, b.a);\n    return function (t) {\n        return Color.fromArray([red(t), green(t), blue(t), alpha(t)]).toRgbaString();\n    };\n}\n\nfunction interpolateValue (a, b) {\n    var t = typeof b;\n    var c;\n    if (b == null || t === 'boolean') {\n        return constant(b);\n    }\n    if (t === 'number') {\n        return interpolateNumber(a, b);\n    }\n    if (t === 'string') {\n        try {\n            c = Color.fromString(b);\n            b = c;\n            return color(a, b);\n        }\n        catch (e) {\n            // return string(a, b);\n        }\n    }\n    if (b instanceof Color) {\n        return color(a, b);\n    }\n    if (b instanceof Date) {\n        return date(a, b);\n    }\n    if (Array.isArray(b)) {\n        return array(a, b);\n    }\n    if (typeof b.valueOf !== 'function' && typeof b.toString !== 'function' || isNaN(b)) {\n        return object(a, b);\n    }\n    return interpolateNumber(a, b);\n}\n\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisectRight(list, x, comparator, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) > 0) { // list[mid] > x\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    return lo;\n}\nfunction complexBisectRight(list, x, map, lo, hi) {\n    if (lo === void 0) { lo = 0; }\n    if (hi === void 0) { hi = list.length; }\n    var comparator = ascendingComparator(map);\n    while (lo < hi) {\n        var mid = (lo + hi) >>> 1;\n        if (comparator(list[mid], x) < 0) {\n            lo = mid + 1;\n        }\n        else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\nfunction ascendingComparator(map) {\n    return function (item, x) {\n        return ascending(map(item), x);\n    };\n}\n\nvar constant$1 = function (x) { return function () { return x; }; };\nvar identity = function (x) { return x; };\nfunction clamper(domain) {\n    var _a;\n    var a = domain[0];\n    var b = domain[domain.length - 1];\n    if (a > b) {\n        _a = [b, a], a = _a[0], b = _a[1];\n    }\n    return function (x) { return Math.max(a, Math.min(b, x)); };\n}\nvar ContinuousScale = /** @class */ (function () {\n    function ContinuousScale() {\n        /**\n         * The output value of the scale for `undefined` or `NaN` input values.\n         */\n        this.unknown = undefined;\n        this._clamp = identity;\n        this._domain = [0, 1];\n        this._range = [0, 1];\n        this.transform = identity; // transforms domain value\n        this.untransform = identity; // untransforms domain value\n        this._interpolate = interpolateValue;\n        this.rescale();\n    }\n    Object.defineProperty(ContinuousScale.prototype, \"clamp\", {\n        get: function () {\n            return this._clamp !== identity;\n        },\n        set: function (value) {\n            this._clamp = value ? clamper(this.domain) : identity;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContinuousScale.prototype.setDomain = function (values) {\n        this._domain = Array.prototype.map.call(values, function (v) { return +v; });\n        if (this._clamp !== identity) {\n            this._clamp = clamper(this.domain);\n        }\n        this.rescale();\n    };\n    ContinuousScale.prototype.getDomain = function () {\n        return this._domain.slice();\n    };\n    Object.defineProperty(ContinuousScale.prototype, \"domain\", {\n        get: function () {\n            return this.getDomain();\n        },\n        set: function (values) {\n            this.setDomain(values);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContinuousScale.prototype, \"range\", {\n        get: function () {\n            return this._range.slice();\n        },\n        set: function (values) {\n            this._range = Array.prototype.slice.call(values);\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContinuousScale.prototype, \"interpolate\", {\n        get: function () {\n            return this._interpolate;\n        },\n        set: function (value) {\n            this._interpolate = value;\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContinuousScale.prototype.rescale = function () {\n        if (Math.min(this.domain.length, this.range.length) > 2) {\n            this.piecewise = this.polymap;\n        }\n        else {\n            this.piecewise = this.bimap;\n        }\n        this.output = undefined;\n        this.input = undefined;\n    };\n    /**\n     * Returns a function that converts `x` in `[a, b]` to `t` in `[0, 1]`. Non-clamping.\n     * @param a\n     * @param b\n     */\n    ContinuousScale.prototype.normalize = function (a, b) {\n        return (b -= (a = +a))\n            ? function (x) { return (x - a) / b; }\n            : constant$1(isNaN(b) ? NaN : 0.5);\n    };\n    ContinuousScale.prototype.bimap = function (domain, range, interpolate) {\n        var x0 = domain[0];\n        var x1 = domain[1];\n        var y0 = range[0];\n        var y1 = range[1];\n        var xt;\n        var ty;\n        if (x1 < x0) {\n            xt = this.normalize(x1, x0);\n            ty = interpolate(y1, y0);\n        }\n        else {\n            xt = this.normalize(x0, x1);\n            ty = interpolate(y0, y1);\n        }\n        return function (x) { return ty(xt(x)); }; // domain value x --> t in [0, 1] --> range value y\n    };\n    ContinuousScale.prototype.polymap = function (domain, range, interpolate) {\n        var _this = this;\n        // number of segments in the polylinear scale\n        var n = Math.min(domain.length, range.length) - 1;\n        if (domain[n] < domain[0]) {\n            domain = domain.slice().reverse();\n            range = range.slice().reverse();\n        }\n        // deinterpolators from domain segment value to t\n        var dt = Array.from({ length: n }, function (_, i) { return _this.normalize(domain[i], domain[i + 1]); });\n        // reinterpolators from t to range segment value\n        var tr = Array.from({ length: n }, function (_, i) { return interpolate(range[i], range[i + 1]); });\n        return function (x) {\n            var i = bisectRight(domain, x, ascending, 1, n) - 1; // Find the domain segment that `x` belongs to.\n            // This also tells us which deinterpolator/reinterpolator pair to use.\n            return tr[i](dt[i](x));\n        };\n    };\n    ContinuousScale.prototype.convert = function (x) {\n        x = +x;\n        if (isNaN(x)) {\n            return this.unknown;\n        }\n        else {\n            if (!this.output) {\n                this.output = this.piecewise(this.domain.map(this.transform), this.range, this.interpolate);\n            }\n            return this.output(this.transform(this._clamp(x)));\n        }\n    };\n    ContinuousScale.prototype.invert = function (y) {\n        if (!this.input) {\n            this.input = this.piecewise(this.range, this.domain.map(this.transform), interpolateNumber);\n        }\n        return this._clamp(this.untransform(this.input(y)));\n    };\n    return ContinuousScale;\n}());\n\nvar __extends$K = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nfunction ticks (a, b, count) {\n    var step = tickStep(a, b, count);\n    a = Math.ceil(a / step) * step;\n    b = Math.floor(b / step) * step + step / 2;\n    // Add half a step here so that the array returned by `range` includes the last tick.\n    return range(a, b, step);\n}\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\nfunction tickStep(a, b, count) {\n    var rawStep = Math.abs(b - a) / Math.max(0, count);\n    var step = Math.pow(10, Math.floor(Math.log(rawStep) / Math.LN10)); // = Math.log10(rawStep)\n    var error = rawStep / step;\n    if (error >= e10) {\n        step *= 10;\n    }\n    else if (error >= e5) {\n        step *= 5;\n    }\n    else if (error >= e2) {\n        step *= 2;\n    }\n    return b < a ? -step : step;\n}\nfunction tickIncrement(a, b, count) {\n    var rawStep = (b - a) / Math.max(0, count);\n    var power = Math.floor(Math.log(rawStep) / Math.LN10);\n    var error = rawStep / Math.pow(10, power);\n    return power >= 0\n        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\nvar NumericTicks = /** @class */ (function (_super) {\n    __extends$K(NumericTicks, _super);\n    function NumericTicks(fractionDigits, size) {\n        if (size === void 0) { size = 0; }\n        var _this = _super.call(this, size) || this;\n        _this.fractionDigits = fractionDigits;\n        return _this;\n    }\n    return NumericTicks;\n}(Array));\nfunction range(a, b, step) {\n    if (step === void 0) { step = 1; }\n    var absStep = Math.abs(step);\n    var fractionDigits = (absStep > 0 && absStep < 1)\n        ? Math.abs(Math.floor(Math.log(absStep) / Math.LN10))\n        : 0;\n    var f = Math.pow(10, fractionDigits);\n    var n = Math.max(0, Math.ceil((b - a) / step)) || 0;\n    var values = new NumericTicks(fractionDigits, n);\n    for (var i = 0; i < n; i++) {\n        var value = a + step * i;\n        values[i] = Math.round(value * f) / f;\n    }\n    return values;\n}\n\nvar __extends$L = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Maps continuous domain to a continuous range.\n */\nvar LinearScale = /** @class */ (function (_super) {\n    __extends$L(LinearScale, _super);\n    function LinearScale() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LinearScale.prototype.ticks = function (count) {\n        if (count === void 0) { count = 10; }\n        var d = this._domain;\n        return ticks(d[0], d[d.length - 1], count);\n    };\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * @param count Tick count.\n     */\n    LinearScale.prototype.nice = function (count) {\n        if (count === void 0) { count = 10; }\n        var d = this.domain;\n        var i0 = 0;\n        var i1 = d.length - 1;\n        var start = d[i0];\n        var stop = d[i1];\n        var step;\n        if (stop < start) {\n            step = start;\n            start = stop;\n            stop = step;\n            step = i0;\n            i0 = i1;\n            i1 = step;\n        }\n        step = tickIncrement(start, stop, count);\n        if (step > 0) {\n            start = Math.floor(start / step) * step;\n            stop = Math.ceil(stop / step) * step;\n            step = tickIncrement(start, stop, count);\n        }\n        else if (step < 0) {\n            start = Math.ceil(start * step) / step;\n            stop = Math.floor(stop * step) / step;\n            step = tickIncrement(start, stop, count);\n        }\n        if (step > 0) {\n            d[i0] = Math.floor(start / step) * step;\n            d[i1] = Math.ceil(stop / step) * step;\n            this.domain = d;\n        }\n        else if (step < 0) {\n            d[i0] = Math.ceil(start * step) / step;\n            d[i1] = Math.floor(stop * step) / step;\n            this.domain = d;\n        }\n    };\n    return LinearScale;\n}(ContinuousScale));\n\nvar __extends$M = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Group = /** @class */ (function (_super) {\n    __extends$M(Group, _super);\n    function Group() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isContainerNode = true;\n        return _this;\n    }\n    // We consider a group to be boundless, thus any point belongs to it.\n    Group.prototype.containsPoint = function (x, y) {\n        return true;\n    };\n    Group.prototype.computeBBox = function () {\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.children.forEach(function (child) {\n            if (!child.visible) {\n                return;\n            }\n            var bbox = child.computeBBox();\n            if (!bbox) {\n                return;\n            }\n            if (!(child instanceof Group)) {\n                if (child.dirtyTransform) {\n                    child.computeTransformMatrix();\n                }\n                var matrix = Matrix.flyweight(child.matrix);\n                var parent_1 = child.parent;\n                while (parent_1) {\n                    matrix.preMultiplySelf(parent_1.matrix);\n                    parent_1 = parent_1.parent;\n                }\n                matrix.transformBBox(bbox, 0, bbox);\n            }\n            var x = bbox.x;\n            var y = bbox.y;\n            if (x < left) {\n                left = x;\n            }\n            if (y < top) {\n                top = y;\n            }\n            if (x + bbox.width > right) {\n                right = x + bbox.width;\n            }\n            if (y + bbox.height > bottom) {\n                bottom = y + bbox.height;\n            }\n        });\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    Group.prototype.render = function (ctx) {\n        // A group can have `scaling`, `rotation`, `translation` properties\n        // that are applied to the canvas context before children are rendered,\n        // so all children can be transformed at once.\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.matrix.toContext(ctx);\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            ctx.save();\n            var child = children[i];\n            if (child.visible) {\n                child.render(ctx);\n            }\n            ctx.restore();\n        }\n        // debug\n        // this.computeBBox().render(ctx, {\n        //     label: this.id,\n        //     resetTransform: true,\n        //     fillStyle: 'rgba(0, 0, 0, 0.5)'\n        // });\n    };\n    Group.className = 'Group';\n    return Group;\n}(Node));\n\nvar EnterNode = /** @class */ (function () {\n    function EnterNode(parent, datum) {\n        this.next = null;\n        this.scene = parent.scene;\n        this.parent = parent;\n        this.datum = datum;\n    }\n    EnterNode.prototype.appendChild = function (node) {\n        // This doesn't work without the `strict: true` in the `tsconfig.json`,\n        // so we must have two `if` checks below, instead of this single one.\n        // if (this.next && !Node.isNode(this.next)) {\n        //     throw new Error(`${this.next} is not a Node.`);\n        // }\n        if (this.next === null) {\n            return this.parent.insertBefore(node, null);\n        }\n        if (!Node.isNode(this.next)) {\n            throw new Error(this.next + \" is not a Node.\");\n        }\n        return this.parent.insertBefore(node, this.next);\n    };\n    EnterNode.prototype.insertBefore = function (node, nextNode) {\n        return this.parent.insertBefore(node, nextNode);\n    };\n    return EnterNode;\n}());\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\nvar Selection = /** @class */ (function () {\n    function Selection(groups, parents) {\n        this.groups = groups;\n        this.parents = parents;\n    }\n    Selection.select = function (node) {\n        return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n    };\n    Selection.selectAll = function (nodes) {\n        return new Selection([nodes == null ? [] : nodes], [undefined]);\n    };\n    /**\n     * Creates new nodes, appends them to the nodes of this selection and returns them\n     * as a new selection. The created nodes inherit the datums and the parents of the nodes\n     * they replace.\n     * @param Class The constructor function to use to create the new nodes.\n     */\n    Selection.prototype.append = function (Class) {\n        return this.select(function (node) {\n            return node.appendChild(new Class());\n        });\n    };\n    /**\n     * Same as the {@link append}, but accepts a custom creator function with the\n     * {@link NodeSelector} signature rather than a constructor function.\n     * @param creator\n     */\n    Selection.prototype.appendFn = function (creator) {\n        return this.select(function (node, data, index, group) {\n            return node.appendChild(creator(node, data, index, group));\n        });\n    };\n    /**\n     * Runs the given selector that returns a single node for every node in each group.\n     * The original nodes are then replaced by the nodes returned by the selector\n     * and returned as a new selection.\n     * The selected nodes inherit the datums and the parents of the original nodes.\n     */\n    Selection.prototype.select = function (selector) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        var subgroups = [];\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            var subgroup = subgroups[j] = new Array(groupSize);\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    var subnode = selector(node, node.datum, i, group);\n                    if (subnode) {\n                        subnode.datum = node.datum;\n                    }\n                    subgroup[i] = subnode;\n                }\n                // else this can be a group of the `enter` selection,\n                // for example, with no nodes at the i-th position,\n                // only nodes at the end of the group\n            }\n        }\n        return new Selection(subgroups, this.parents);\n    };\n    /**\n     * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n     * @param Class The constructor function to use to find matching nodes.\n     */\n    Selection.prototype.selectByClass = function (Class) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectByTag = function (tag) {\n        return this.select(function (node) {\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        return child;\n                    }\n                }\n            }\n        });\n    };\n    Selection.prototype.selectAllByClass = function (Class) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child instanceof Class) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectAllByTag = function (tag) {\n        return this.selectAll(function (node) {\n            var nodes = [];\n            if (Node.isNode(node)) {\n                var children = node.children;\n                var n = children.length;\n                for (var i = 0; i < n; i++) {\n                    var child = children[i];\n                    if (child.tag === tag) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    };\n    Selection.prototype.selectNone = function () {\n        return [];\n    };\n    /**\n     * Runs the given selector that returns a group of nodes for every node in each group.\n     * The original nodes are then replaced by the groups of nodes returned by the selector\n     * and returned as a new selection. The original nodes become the parent nodes for each\n     * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n     * If called without any parameters, creates a new selection with an empty group for each\n     * node in this selection.\n     */\n    Selection.prototype.selectAll = function (selectorAll) {\n        if (!selectorAll) {\n            selectorAll = this.selectNone;\n        }\n        // Each subgroup is populated with the selector (run on each group node) results.\n        var subgroups = [];\n        // In the new selection that we return, subgroups become groups,\n        // and group nodes become parents.\n        var parents = [];\n        var groups = this.groups;\n        var groupCount = groups.length;\n        for (var j = 0; j < groupCount; j++) {\n            var group = groups[j];\n            var groupLength = group.length;\n            for (var i = 0; i < groupLength; i++) {\n                var node = group[i];\n                if (node) {\n                    subgroups.push(selectorAll(node, node.datum, i, group));\n                    parents.push(node);\n                }\n            }\n        }\n        return new Selection(subgroups, parents);\n    };\n    /**\n     * Runs the given callback for every node in this selection and returns this selection.\n     * @param cb\n     */\n    Selection.prototype.each = function (cb) {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    cb(node, node.datum, i, group);\n                }\n            }\n        }\n        return this;\n    };\n    Selection.prototype.remove = function () {\n        return this.each(function (node) {\n            if (Node.isNode(node)) {\n                var parent_1 = node.parent;\n                if (parent_1) {\n                    parent_1.removeChild(node);\n                }\n            }\n        });\n    };\n    Selection.prototype.merge = function (other) {\n        var groups0 = this.groups;\n        var groups1 = other.groups;\n        var m0 = groups0.length;\n        var m1 = groups1.length;\n        var m = Math.min(m0, m1);\n        var merges = new Array(m0);\n        var j = 0;\n        for (; j < m; j++) {\n            var group0 = groups0[j];\n            var group1 = groups1[j];\n            var n = group0.length;\n            var merge = merges[j] = new Array(n);\n            for (var i = 0; i < n; i++) {\n                var node = group0[i] || group1[i];\n                merge[i] = node || undefined;\n            }\n        }\n        for (; j < m0; j++) {\n            merges[j] = groups0[j];\n        }\n        return new Selection(merges, this.parents);\n    };\n    /**\n     * Return the first non-null element in this selection.\n     * If the selection is empty, returns null.\n     */\n    Selection.prototype.node = function () {\n        var groups = this.groups;\n        var numGroups = groups.length;\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var groupSize = group.length;\n            for (var i = 0; i < groupSize; i++) {\n                var node = group[i];\n                if (node) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    };\n    Selection.prototype.attr = function (name, value) {\n        this.each(function (node) {\n            node[name] = value;\n        });\n        return this;\n    };\n    Selection.prototype.attrFn = function (name, value) {\n        this.each(function (node, datum, index, group) {\n            node[name] = value(node, datum, index, group);\n        });\n        return this;\n    };\n    /**\n     * Invokes the given function once, passing in this selection.\n     * Returns this selection. Facilitates method chaining.\n     * @param cb\n     */\n    Selection.prototype.call = function (cb) {\n        cb(this);\n        return this;\n    };\n    Object.defineProperty(Selection.prototype, \"size\", {\n        /**\n         * Returns the total number of nodes in this selection.\n         */\n        get: function () {\n            var size = 0;\n            this.each(function () { return size++; });\n            return size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"data\", {\n        /**\n         * Returns the array of data for the selected elements.\n         */\n        get: function () {\n            var data = [];\n            this.each(function (_, datum) { return data.push(datum); });\n            return data;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"enter\", {\n        get: function () {\n            return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selection.prototype, \"exit\", {\n        get: function () {\n            return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the given value to each selected node and returns this selection\n     * with its {@link GDatum} type changed to the type of the given value.\n     * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n     * This method can also be used to clear bound data.\n     * @param value\n     */\n    Selection.prototype.setDatum = function (value) {\n        return this.each(function (node) {\n            node.datum = value;\n        });\n    };\n    Object.defineProperty(Selection.prototype, \"datum\", {\n        /**\n         * Returns the bound datum for the first non-null element in the selection.\n         * This is generally useful only if you know the selection contains exactly one element.\n         */\n        get: function () {\n            var node = this.node();\n            return node ? node.datum : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Binds the specified array of values with the selected nodes, returning a new selection\n     * that represents the _update_ selection: the nodes successfully bound to the values.\n     * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n     * which can be used to add or remove the nodes to correspond to the new data.\n     * The `values` is an array of values of a particular type, or a function that returns\n     * an array of values for each group.\n     * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n     * @param values\n     * @param key\n     */\n    Selection.prototype.setData = function (values, key) {\n        if (typeof values !== 'function') {\n            var data_1 = values;\n            values = function () { return data_1; };\n        }\n        var groups = this.groups;\n        var parents = this.parents;\n        var numGroups = groups.length;\n        var updateGroups = new Array(numGroups);\n        var enterGroups = new Array(numGroups);\n        var exitGroups = new Array(numGroups);\n        for (var j = 0; j < numGroups; j++) {\n            var group = groups[j];\n            var parent_2 = parents[j];\n            if (!parent_2) {\n                throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n            }\n            var groupSize = group.length;\n            var data = values(parent_2, parent_2.datum, j, parents);\n            var dataSize = data.length;\n            var enterGroup = enterGroups[j] = new Array(dataSize);\n            var updateGroup = updateGroups[j] = new Array(dataSize);\n            var exitGroup = exitGroups[j] = new Array(groupSize);\n            if (key) {\n                this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);\n            }\n            else {\n                this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data);\n            }\n            // Now connect the enter nodes to their following update node, such that\n            // appendChild can insert the materialized enter node before this node,\n            // rather than at the end of the parent node.\n            for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n                var previous = enterGroup[i0];\n                if (previous) {\n                    if (i0 >= i1) {\n                        i1 = i0 + 1;\n                    }\n                    var next = void 0;\n                    while (!(next = updateGroup[i1]) && i1 < dataSize) {\n                        i1++;\n                    }\n                    previous.next = next || null;\n                }\n            }\n        }\n        var result = new Selection(updateGroups, parents);\n        result.enterGroups = enterGroups;\n        result.exitGroups = exitGroups;\n        return result;\n    };\n    Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var i = 0;\n        for (; i < dataSize; i++) {\n            var node = group[i];\n            if (node) {\n                node.datum = data[i];\n                update[i] = node;\n            }\n            else { // more datums than group nodes\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // more group nodes than datums\n        for (; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n        var groupSize = group.length;\n        var dataSize = data.length;\n        var keyValues = new Array(groupSize);\n        var nodeByKeyValue = {};\n        // Compute the key for each node.\n        // If multiple nodes have the same key, the duplicates are added to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node) {\n                var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n                if (keyValue in nodeByKeyValue) {\n                    exit[i] = node;\n                }\n                else {\n                    nodeByKeyValue[keyValue] = node;\n                }\n            }\n        }\n        // Compute the key for each datum.\n        // If there is a node associated with this key, join and add it to update.\n        // If there is not (or the key is a duplicate), add it to enter.\n        for (var i = 0; i < dataSize; i++) {\n            var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n            var node = nodeByKeyValue[keyValue];\n            if (node) {\n                update[i] = node;\n                node.datum = data[i];\n                nodeByKeyValue[keyValue] = undefined;\n            }\n            else {\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n        // Add any remaining nodes that were not bound to data to exit.\n        for (var i = 0; i < groupSize; i++) {\n            var node = group[i];\n            if (node && (nodeByKeyValue[keyValues[i]] === node)) {\n                exit[i] = node;\n            }\n        }\n    };\n    Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n    return Selection;\n}());\n\nvar __extends$N = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Line = /** @class */ (function (_super) {\n    __extends$N(Line, _super);\n    function Line() {\n        var _this = _super.call(this) || this;\n        _this._x1 = 0;\n        _this._y1 = 0;\n        _this._x2 = 0;\n        _this._y2 = 0;\n        _this.restoreOwnStyles();\n        return _this;\n    }\n    Object.defineProperty(Line.prototype, \"x1\", {\n        get: function () {\n            // TODO: Investigate getter performance further in the context\n            //       of the scene graph.\n            //       In isolated benchmarks using a getter has the same\n            //       performance as a direct property access in Firefox 64.\n            //       But in Chrome 71 the getter is 60% slower than direct access.\n            //       Direct read is 4.5+ times slower in Chrome than it is in Firefox.\n            //       Property access and direct read have the same performance\n            //       in Safari 12, which is 2+ times faster than Firefox at this.\n            // https://jsperf.com/es5-getters-setters-versus-getter-setter-methods/18\n            // This is a know Chrome issue. They say it's not a regression, since\n            // the behavior is observed since M60, but jsperf.com history shows the\n            // 10x slowdown happened between Chrome 48 and Chrome 57.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=908743\n            return this._x1;\n        },\n        set: function (value) {\n            if (this._x1 !== value) {\n                this._x1 = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Line.prototype, \"y1\", {\n        get: function () {\n            return this._y1;\n        },\n        set: function (value) {\n            if (this._y1 !== value) {\n                this._y1 = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Line.prototype, \"x2\", {\n        get: function () {\n            return this._x2;\n        },\n        set: function (value) {\n            if (this._x2 !== value) {\n                this._x2 = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Line.prototype, \"y2\", {\n        get: function () {\n            return this._y2;\n        },\n        set: function (value) {\n            if (this._y2 !== value) {\n                this._y2 = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Line.prototype.computeBBox = function () {\n        return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n    };\n    Line.prototype.isPointInPath = function (x, y) {\n        return false;\n    };\n    Line.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Line.prototype.render = function (ctx) {\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.matrix.toContext(ctx);\n        var x1 = this.x1;\n        var y1 = this.y1;\n        var x2 = this.x2;\n        var y2 = this.y2;\n        // Align to the pixel grid if the line is strictly vertical\n        // or horizontal (but not both, i.e. a dot).\n        if (x1 === x2) {\n            var x = Math.round(x1) + Math.floor(this.strokeWidth) % 2 / 2;\n            x1 = x;\n            x2 = x;\n        }\n        else if (y1 === y2) {\n            var y = Math.round(y1) + Math.floor(this.strokeWidth) % 2 / 2;\n            y1 = y;\n            y2 = y;\n        }\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        this.fillStroke(ctx);\n        this.dirty = false;\n    };\n    Line.className = 'Line';\n    Line.defaultStyles = chainObjects(Shape.defaultStyles, {\n        fill: undefined,\n        strokeWidth: 1\n    });\n    return Line;\n}(Shape));\n\nvar twoPi = Math.PI * 2;\n/**\n * Normalize the given angle to be in the [0, 2) interval.\n * @param radians Angle in radians.\n */\nfunction normalizeAngle360(radians) {\n    radians %= twoPi;\n    radians += twoPi;\n    radians %= twoPi;\n    return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n    radians %= twoPi;\n    radians += twoPi;\n    if (radians !== twoPi) {\n        radians %= twoPi;\n    }\n    return radians;\n}\n/**\n * Normalize the given angle to be in the [-, ) interval.\n * @param radians Angle in radians.\n */\nfunction normalizeAngle180(radians) {\n    radians %= twoPi;\n    if (radians < -Math.PI) {\n        radians += twoPi;\n    }\n    else if (radians >= Math.PI) {\n        radians -= twoPi;\n    }\n    return radians;\n}\nfunction toRadians(degrees) {\n    return degrees / 180 * Math.PI;\n}\n\n// @ts-ignore Suppress tsc error: Property 'sign' does not exist on type 'Math'\nvar sign = Math.sign ? Math.sign : function (x) {\n    x = +x;\n    if (x === 0 || isNaN(x)) {\n        return x;\n    }\n    return x > 0 ? 1 : -1;\n};\n/**\n * Finds the roots of a parametric linear equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n */\nfunction linearRoot(a, b) {\n    var t = -b / a;\n    return (a !== 0 && t >= 0 && t <= 1) ? [t] : [];\n}\n/**\n * Finds the roots of a parametric quadratic equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n */\nfunction quadraticRoots(a, b, c) {\n    if (a === 0) {\n        return linearRoot(b, c);\n    }\n    var D = b * b - 4 * a * c; // The polynomial's discriminant.\n    var roots = [];\n    if (D === 0) { // A single real root.\n        var t = -b / (2 * a);\n        if (t >= 0 && t <= 1) {\n            roots.push(t);\n        }\n    }\n    else if (D > 0) { // A pair of distinct real roots.\n        var rD = Math.sqrt(D);\n        var t1 = (-b - rD) / (2 * a);\n        var t2 = (-b + rD) / (2 * a);\n        if (t1 >= 0 && t1 <= 1) {\n            roots.push(t1);\n        }\n        if (t2 >= 0 && t2 <= 1) {\n            roots.push(t2);\n        }\n    }\n    // else -> Complex roots.\n    return roots;\n}\n/**\n * Finds the roots of a parametric cubic equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n * Returns an array of parametric intersection locations along the cubic,\n * excluding out-of-bounds intersections (before or after the end point\n * or in the imaginary plane).\n * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/\n */\nfunction cubicRoots(a, b, c, d) {\n    if (a === 0) {\n        return quadraticRoots(b, c, d);\n    }\n    var A = b / a;\n    var B = c / a;\n    var C = d / a;\n    var Q = (3 * B - A * A) / 9;\n    var R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n    var D = Q * Q * Q + R * R; // The polynomial's discriminant.\n    var third = 1 / 3;\n    var roots = [];\n    if (D >= 0) { // Complex or duplicate roots.\n        var rD = Math.sqrt(D);\n        var S = sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n        var T = sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n        var Im = Math.abs(Math.sqrt(3) * (S - T) / 2); // Complex part of the root pair.\n        var t = -third * A + (S + T); // A real root.\n        if (t >= 0 && t <= 1) {\n            roots.push(t);\n        }\n        if (Im === 0) {\n            var t_1 = -third * A - (S + T) / 2; // The real part of a complex root.\n            if (t_1 >= 0 && t_1 <= 1) {\n                roots.push(t_1);\n            }\n        }\n    }\n    else { // Distinct real roots.\n        var theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n        var thirdA = third * A;\n        var twoSqrtQ = 2 * Math.sqrt(-Q);\n        var t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n        var t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n        var t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n        if (t1 >= 0 && t1 <= 1) {\n            roots.push(t1);\n        }\n        if (t2 >= 0 && t2 <= 1) {\n            roots.push(t2);\n        }\n        if (t3 >= 0 && t3 <= 1) {\n            roots.push(t3);\n        }\n    }\n    return roots;\n}\n\n/**\n * Returns the intersection point for the given pair of line segments, or null,\n * if the segments are parallel or don't intersect.\n * Based on http://paulbourke.net/geometry/pointlineplane/\n */\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    var d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n    if (d === 0) { // The lines are parallel.\n        return null;\n    }\n    var ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n    var ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n        return {\n            x: ax1 + ua * (ax2 - ax1),\n            y: ay1 + ua * (ay2 - ay1)\n        };\n    }\n    return null; // The intersection point is outside either or both segments.\n}\n/**\n * Returns intersection points of the given cubic curve and the line segment.\n * Takes in x/y components of cubic control points and line segment start/end points\n * as parameters.\n */\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n    var intersections = [];\n    // Find line equation coefficients.\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * (y2 - y1) - y1 * (x2 - x1);\n    // Find cubic Bezier curve equation coefficients from control points.\n    var bx = bezierCoefficients(px1, px2, px3, px4);\n    var by = bezierCoefficients(py1, py2, py3, py4);\n    var a = A * bx[0] + B * by[0]; // t^3\n    var b = A * bx[1] + B * by[1]; // t^2\n    var c = A * bx[2] + B * by[2]; // t\n    var d = A * bx[3] + B * by[3] + C; // 1\n    var roots = cubicRoots(a, b, c, d);\n    // Verify that the roots are within bounds of the linear segment.\n    for (var i = 0; i < roots.length; i++) {\n        var t = roots[i];\n        var tt = t * t;\n        var ttt = t * tt;\n        // Find the cartesian plane coordinates for the parametric root `t`.\n        var x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n        var y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n        // The parametric cubic roots we found are intersection points\n        // with an infinite line, and so the x/y coordinates above are as well.\n        // Make sure the x/y is also within the bounds of the given segment.\n        var s = void 0;\n        if (x1 !== x2) {\n            s = (x - x1) / (x2 - x1);\n        }\n        else { // the line is vertical\n            s = (y - y1) / (y2 - y1);\n        }\n        if (s >= 0 && s <= 1) {\n            intersections.push({ x: x, y: y });\n        }\n    }\n    return intersections;\n}\n/**\n * Returns the given coordinates vector multiplied by the coefficient matrix\n * of the parametric cubic Bzier equation.\n */\nfunction bezierCoefficients(P1, P2, P3, P4) {\n    return [\n        -P1 + 3 * P2 - 3 * P3 + P4,\n        3 * P1 - 6 * P2 + 3 * P3,\n        -3 * P1 + 3 * P2,\n        P1 //                 | 1  0  0  0| |P4|\n    ];\n}\n\nvar Path2D = /** @class */ (function () {\n    function Path2D() {\n        // The methods of this class will likely be called many times per animation frame,\n        // and any allocation can trigger a GC cycle during animation, so we attempt\n        // to minimize the number of allocations.\n        this.commands = [];\n        this.params = [];\n        this._closedPath = false;\n    }\n    Path2D.prototype.moveTo = function (x, y) {\n        if (this.xy) {\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n        this.commands.push('M');\n        this.params.push(x, y);\n    };\n    Path2D.prototype.lineTo = function (x, y) {\n        if (this.xy) {\n            this.commands.push('L');\n            this.params.push(x, y);\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.moveTo(x, y);\n        }\n    };\n    Path2D.prototype.rect = function (x, y, width, height) {\n        this.moveTo(x, y);\n        this.lineTo(x + width, y);\n        this.lineTo(x + width, y + height);\n        this.lineTo(x, y + height);\n        this.closePath();\n    };\n    /**\n     * Adds an arc segment to the path definition.\n     * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n     * @param rx The major-axis radius.\n     * @param ry The minor-axis radius.\n     * @param rotation The x-axis rotation, expressed in radians.\n     * @param fA The large arc flag. `1` to use angle > .\n     * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n     * @param x2 The x coordinate to arc to.\n     * @param y2 The y coordinate to arc to.\n     */\n    Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n        // Convert from endpoint to center parametrization:\n        // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        var xy = this.xy;\n        if (!xy) {\n            return;\n        }\n        if (rx < 0) {\n            rx = -rx;\n        }\n        if (ry < 0) {\n            ry = -ry;\n        }\n        var x1 = xy[0];\n        var y1 = xy[1];\n        var hdx = (x1 - x2) / 2;\n        var hdy = (y1 - y2) / 2;\n        var sinPhi = Math.sin(rotation);\n        var cosPhi = Math.cos(rotation);\n        var xp = cosPhi * hdx + sinPhi * hdy;\n        var yp = -sinPhi * hdx + cosPhi * hdy;\n        var ratX = xp / rx;\n        var ratY = yp / ry;\n        var lambda = ratX * ratX + ratY * ratY;\n        var cx = (x1 + x2) / 2;\n        var cy = (y1 + y2) / 2;\n        var cpx = 0;\n        var cpy = 0;\n        if (lambda >= 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n            // me gives lambda == cpx == cpy == 0;\n        }\n        else {\n            lambda = Math.sqrt(1 / lambda - 1);\n            if (fA === fS) {\n                lambda = -lambda;\n            }\n            cpx = lambda * rx * ratY;\n            cpy = -lambda * ry * ratX;\n            cx += cosPhi * cpx - sinPhi * cpy;\n            cy += sinPhi * cpx + cosPhi * cpy;\n        }\n        var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n        var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;\n        // if (fS) {\n        //     if (deltaTheta <= 0) {\n        //         deltaTheta += Math.PI * 2;\n        //     }\n        // }\n        // else {\n        //     if (deltaTheta >= 0) {\n        //         deltaTheta -= Math.PI * 2;\n        //     }\n        // }\n        this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n    };\n    /**\n     * Approximates an elliptical arc with up to four cubic Bzier curves.\n     * @param commands The string array to write SVG command letters to.\n     * @param params The number array to write SVG command parameters (cubic control points) to.\n     * @param cx The x-axis coordinate for the ellipse's center.\n     * @param cy The y-axis coordinate for the ellipse's center.\n     * @param rx The ellipse's major-axis radius.\n     * @param ry The ellipse's minor-axis radius.\n     * @param phi The rotation for this ellipse, expressed in radians.\n     * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n     * even when `theta1 > theta2`, unless this flag is set to `1`.\n     */\n    Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        if (anticlockwise) {\n            var temp = theta1;\n            theta1 = theta2;\n            theta2 = temp;\n        }\n        var start = params.length;\n        // See https://pomax.github.io/bezierinfo/#circles_cubic\n        // Arc of unit circle (start angle = 0, end angle <= /2) in cubic Bzier coordinates:\n        // S = [1, 0]\n        // C1 = [1, f]\n        // C2 = [cos() + f * sin(), sin() - f * cos()]\n        // E = [cos(), sin()]\n        // f = 4/3 * tan(/4)\n        var f90 = 0.5522847498307935; // f for  = /2 is 4/3 * (Math.sqrt(2) - 1)\n        var sinTheta1 = Math.sin(theta1);\n        var cosTheta1 = Math.cos(theta1);\n        var sinPhi = Math.sin(phi);\n        var cosPhi = Math.cos(phi);\n        var rightAngle = Math.PI / 2;\n        // Since we know how to draw an arc of a unit circle with a cubic Bzier,\n        // to draw an elliptical arc with arbitrary rotation and radii we:\n        // 1) rotate the Bzier coordinates that represent a circular arc by \n        // 2) scale the circular arc separately along the x/y axes, making it elliptical\n        // 3) rotate elliptical arc by \n        // |cos() -sin()| |sx  0| |cos() -sin()| -> |xx xy|\n        // |sin()  cos()| | 0 sy| |sin()  cos()| -> |yx yy|\n        var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n        var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n        var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n        var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry;\n        // TODO: what if delta between 1 and 2 is greater than 2?\n        // Always draw clockwise from 1 to 2.\n        theta2 -= theta1;\n        if (theta2 < 0) {\n            theta2 += Math.PI * 2;\n        }\n        // Multiplying each point [x, y] by:\n        // |xx xy cx| |x|\n        // |yx yy cy| |y|\n        // | 0  0  1| |1|\n        // TODO: This move command may be redundant, if we are already at this point.\n        // The coordinates of the point calculated here may differ ever so slightly\n        // because of precision error.\n        commands.push('M');\n        params.push(xx + cx, yx + cy);\n        while (theta2 >= rightAngle) {\n            theta2 -= rightAngle;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xy + cx;\n            params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yy + cy);\n            // Prepend /2 rotation matrix.\n            // |xx xy| | 0 1| -> | xy -xx|\n            // |yx yy| |-1 0| -> | yy -yx|\n            // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n            // Compared to swapping with a temp variable, destructuring is:\n            // - 10% faster in Chrome 70\n            // - 99% slower in Firefox 63\n            // Temp variable solution is 45% faster in FF than Chrome.\n            // https://jsperf.com/multi-swap\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n            var temp = xx;\n            xx = xy;\n            xy = -temp;\n            temp = yx;\n            yx = yy;\n            yy = -temp;\n        }\n        if (theta2) {\n            var f = 4 / 3 * Math.tan(theta2 / 4);\n            var sinPhi2 = Math.sin(theta2);\n            var cosPhi2 = Math.cos(theta2);\n            var C2x = cosPhi2 + f * sinPhi2;\n            var C2y = sinPhi2 - f * cosPhi2;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xx * cosPhi2 + xy * sinPhi2 + cx;\n            params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yx * cosPhi2 + yy * sinPhi2 + cy);\n        }\n        if (anticlockwise) {\n            for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n                var temp = params[i];\n                params[i] = params[j];\n                params[j] = temp;\n                temp = params[i + 1];\n                params[i + 1] = params[j + 1];\n                params[j + 1] = temp;\n            }\n        }\n    };\n    Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        var commands = this.commands;\n        var params = this.params;\n        var start = commands.length;\n        Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n        var x = params[params.length - 2];\n        var y = params[params.length - 1];\n        if (this.xy) {\n            commands[start] = 'L';\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n    };\n    /**\n     * Returns the `[x, y]` coordinates of the curve at `t`.\n     * @param points `(n + 1) * 2` control point coordinates for a Bzier curve of n-th order.\n     * @param t\n     */\n    Path2D.prototype.deCasteljau = function (points, t) {\n        var n = points.length;\n        if (n < 2 || n % 2 === 1) {\n            throw new Error('Fewer than two points or not an even count.');\n        }\n        else if (n === 2 || t === 0) {\n            return points.slice(0, 2);\n        }\n        else if (t === 1) {\n            return points.slice(-2);\n        }\n        else {\n            var newPoints = [];\n            var last = n - 2;\n            for (var i = 0; i < last; i += 2) {\n                newPoints.push((1 - t) * points[i] + t * points[i + 2], // x\n                (1 - t) * points[i + 1] + t * points[i + 3] // y\n                );\n            }\n            return this.deCasteljau(newPoints, t);\n        }\n    };\n    /**\n     * Approximates the given curve using `n` line segments.\n     * @param points `(n + 1) * 2` control point coordinates for a Bzier curve of n-th order.\n     * @param n\n     */\n    Path2D.prototype.approximateCurve = function (points, n) {\n        var xy = this.deCasteljau(points, 0);\n        this.moveTo(xy[0], xy[1]);\n        var step = 1 / n;\n        for (var t = step; t <= 1; t += step) {\n            var xy_1 = this.deCasteljau(points, t);\n            this.lineTo(xy_1[0], xy_1[1]);\n        }\n    };\n    /**\n     * Adds a quadratic curve segment to the path definition.\n     * Note: the given quadratic segment is converted and stored as a cubic one.\n     * @param cx x-component of the curve's control point\n     * @param cy y-component of the curve's control point\n     * @param x x-component of the end point\n     * @param y y-component of the end point\n     */\n    Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx, cy);\n        }\n        // See https://pomax.github.io/bezierinfo/#reordering\n        this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3, // 1/3 start + 2/3 control\n        (2 * cx + x) / 3, (2 * cy + y) / 3, // 2/3 control + 1/3 end\n        x, y);\n    };\n    Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx1, cy1);\n        }\n        this.commands.push('C');\n        this.params.push(cx1, cy1, cx2, cy2, x, y);\n        this.xy[0] = x;\n        this.xy[1] = y;\n    };\n    Object.defineProperty(Path2D.prototype, \"closedPath\", {\n        get: function () {\n            return this._closedPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path2D.prototype.closePath = function () {\n        if (this.xy) {\n            this.xy = undefined;\n            this.commands.push('Z');\n            this._closedPath = true;\n        }\n    };\n    Path2D.prototype.clear = function () {\n        this.commands.length = 0;\n        this.params.length = 0;\n        this.xy = undefined;\n        this._closedPath = false;\n    };\n    Path2D.prototype.isPointInPath = function (x, y) {\n        var commands = this.commands;\n        var params = this.params;\n        var cn = commands.length;\n        // Hit testing using ray casting method, where the ray's origin is some point\n        // outside the path. In this case, an offscreen point that is remote enough, so that\n        // even if the path itself is large and is partially offscreen, the ray's origin\n        // will likely be outside the path anyway. To test if the given point is inside the\n        // path or not, we cast a ray from the origin to the given point and check the number\n        // of intersections of this segment with the path. If the number of intersections is\n        // even, then the ray both entered and exited the path an equal number of times,\n        // therefore the point is outside the path, and inside the path, if the number of\n        // intersections is odd. Since the path is compound, we check if the ray segment\n        // intersects with each of the path's segments, which can be either a line segment\n        // (one or no intersection points) or a Bzier curve segment (up to 3 intersection\n        // points).\n        var ox = -10000;\n        var oy = -10000;\n        // the starting point of the  current path\n        var sx = NaN;\n        var sy = NaN;\n        // the previous point of the current path\n        var px = 0;\n        var py = 0;\n        var intersectionCount = 0;\n        for (var ci = 0, pi = 0; ci < cn; ci++) {\n            switch (commands[ci]) {\n                case 'M':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    sx = px = params[pi++];\n                    sy = py = params[pi++];\n                    break;\n                case 'L':\n                    if (segmentIntersection(px, py, px = params[pi++], py = params[pi++], ox, oy, x, y)) {\n                        intersectionCount++;\n                    }\n                    break;\n                case 'C':\n                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], px = params[pi++], py = params[pi++], ox, oy, x, y).length;\n                    break;\n                case 'Z':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    break;\n            }\n        }\n        return intersectionCount % 2 === 1;\n    };\n    Path2D.fromString = function (value) {\n        var path = new Path2D();\n        path.setFromString(value);\n        return path;\n    };\n    /**\n     * Split the SVG path at command letters,\n     * then extract the command letter and parameters from each substring.\n     * @param value\n     */\n    Path2D.parseSvgPath = function (value) {\n        return value.trim().split(Path2D.splitCommandsRe).map(function (part) {\n            var strParams = part.match(Path2D.matchParamsRe);\n            return {\n                command: part.substr(0, 1),\n                params: strParams ? strParams.map(parseFloat) : []\n            };\n        });\n    };\n    Path2D.prettifySvgPath = function (value) {\n        return Path2D.parseSvgPath(value).map(function (d) { return d.command + d.params.join(','); }).join('\\n');\n    };\n    /**\n     * See https://www.w3.org/TR/SVG11/paths.html\n     * @param value\n     */\n    Path2D.prototype.setFromString = function (value) {\n        var _this = this;\n        this.clear();\n        var parts = Path2D.parseSvgPath(value);\n        // Current point.\n        var x;\n        var y;\n        // Last control point. Used to calculate the reflection point\n        // for `S`, `s`, `T`, `t` commands.\n        var cpx;\n        var cpy;\n        var lastCommand;\n        function checkQuadraticCP() {\n            if (!lastCommand.match(Path2D.quadraticCommandRe)) {\n                cpx = x;\n                cpy = y;\n            }\n        }\n        function checkCubicCP() {\n            if (!lastCommand.match(Path2D.cubicCommandRe)) {\n                cpx = x;\n                cpy = y;\n            }\n        }\n        // But that will make compiler complain about x/y, cpx/cpy\n        // being used without being set first.\n        parts.forEach(function (part) {\n            var p = part.params;\n            var n = p.length;\n            var i = 0;\n            switch (part.command) {\n                case 'M':\n                    _this.moveTo(x = p[i++], y = p[i++]);\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'm':\n                    _this.moveTo(x += p[i++], y += p[i++]);\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'L':\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'l':\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'C':\n                    while (i < n) {\n                        _this.cubicCurveTo(p[i++], p[i++], cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'c':\n                    while (i < n) {\n                        _this.cubicCurveTo(x + p[i++], y + p[i++], cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'S':\n                    checkCubicCP();\n                    while (i < n) {\n                        _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 's':\n                    checkCubicCP();\n                    while (i < n) {\n                        _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'Q':\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'q':\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'T':\n                    checkQuadraticCP();\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 't':\n                    checkQuadraticCP();\n                    while (i < n) {\n                        _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'A':\n                    while (i < n) {\n                        _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x = p[i++], y = p[i++]);\n                    }\n                    break;\n                case 'a':\n                    while (i < n) {\n                        _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x += p[i++], y += p[i++]);\n                    }\n                    break;\n                case 'Z':\n                case 'z':\n                    _this.closePath();\n                    break;\n                case 'H':\n                    while (i < n) {\n                        _this.lineTo(x = p[i++], y);\n                    }\n                    break;\n                case 'h':\n                    while (i < n) {\n                        _this.lineTo(x += p[i++], y);\n                    }\n                    break;\n                case 'V':\n                    while (i < n) {\n                        _this.lineTo(x, y = p[i++]);\n                    }\n                    break;\n                case 'v':\n                    while (i < n) {\n                        _this.lineTo(x, y += p[i++]);\n                    }\n                    break;\n            }\n            lastCommand = part.command;\n        });\n    };\n    Path2D.prototype.toString = function () {\n        var c = this.commands;\n        var p = this.params;\n        var cn = c.length;\n        var out = [];\n        for (var ci = 0, pi = 0; ci < cn; ci++) {\n            switch (c[ci]) {\n                case 'M':\n                    out.push('M' + p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'L':\n                    out.push('L' + p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'C':\n                    out.push('C' + p[pi++] + ',' + p[pi++] + ' ' +\n                        p[pi++] + ',' + p[pi++] + ' ' +\n                        p[pi++] + ',' + p[pi++]);\n                    break;\n                case 'Z':\n                    out.push('Z');\n                    break;\n            }\n        }\n        return out.join('');\n    };\n    Path2D.prototype.toPrettyString = function () {\n        return Path2D.prettifySvgPath(this.toString());\n    };\n    Path2D.prototype.toSvg = function () {\n        return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 50\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + this.toString() + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n    };\n    Path2D.prototype.toDebugSvg = function () {\n        var d = Path2D.prettifySvgPath(this.toString());\n        return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 100 100\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + d + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n    };\n    /**\n     * Returns an array of sub-paths of this Path,\n     * where each sub-path is represented exclusively by cubic segments.\n     */\n    Path2D.prototype.toCubicPaths = function () {\n        // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n        // where `n` is the number of segments.\n        var paths = [];\n        var params = this.params;\n        // current path\n        var path;\n        // the starting point of the  current path\n        var sx;\n        var sy;\n        // the previous point of the current path\n        var px;\n        var py;\n        var i = 0; // current parameter\n        this.commands.forEach(function (command) {\n            switch (command) {\n                case 'M':\n                    path = [\n                        sx = px = params[i++],\n                        sy = py = params[i++]\n                    ];\n                    paths.push(path);\n                    break;\n                case 'L':\n                    var x = params[i++];\n                    var y = params[i++];\n                    // Place control points along the line `a + (b - a) * t`\n                    // at t = 1/3 and 2/3:\n                    path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, px = x, py = y);\n                    break;\n                case 'C':\n                    path.push(params[i++], params[i++], params[i++], params[i++], px = params[i++], py = params[i++]);\n                    break;\n                case 'Z':\n                    path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, px = sx, py = sy);\n                    break;\n            }\n        });\n        return paths;\n    };\n    Path2D.cubicPathToString = function (path) {\n        var n = path.length;\n        if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n            throw new Error('Invalid path.');\n        }\n        return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n    };\n    Path2D.splitCommandsRe = /(?=[AaCcHhLlMmQqSsTtVvZz])/g;\n    Path2D.matchParamsRe = /-?[0-9]*\\.?\\d+/g;\n    Path2D.quadraticCommandRe = /[QqTt]/;\n    Path2D.cubicCommandRe = /[CcSs]/;\n    Path2D.xmlDeclaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n    Path2D.xmlns = 'http://www.w3.org/2000/svg';\n    return Path2D;\n}());\n\nvar __extends$O = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Path = /** @class */ (function (_super) {\n    __extends$O(Path, _super);\n    function Path() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * Declare a path to retain for later rendering and hit testing\n         * using custom Path2D class. Think of it as a TypeScript version\n         * of the native Path2D (with some differences) that works in all browsers.\n         */\n        _this.path = new Path2D();\n        /**\n        * The path only has to be updated when certain attributes change.\n        * For example, if transform attributes (such as `translationX`)\n        * are changed, we don't have to update the path. The `dirtyPath` flag\n        * is how we keep track if the path has to be updated or not.\n        */\n        _this._dirtyPath = true;\n        /**\n         * Path definition in SVG path syntax:\n         * https://www.w3.org/TR/SVG11/paths.html#DAttribute\n         */\n        _this._svgPath = '';\n        return _this;\n    }\n    Object.defineProperty(Path.prototype, \"dirtyPath\", {\n        get: function () {\n            return this._dirtyPath;\n        },\n        set: function (value) {\n            if (this._dirtyPath !== value) {\n                this._dirtyPath = value;\n                if (value) {\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Path.prototype, \"svgPath\", {\n        get: function () {\n            return this._svgPath;\n        },\n        set: function (value) {\n            if (this._svgPath !== value) {\n                this._svgPath = value;\n                this.path.setFromString(value);\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n    };\n    Path.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Path.prototype.updatePath = function () { };\n    Path.prototype.render = function (ctx) {\n        var scene = this.scene;\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        // if (scene.debug.renderBoundingBoxes) {\n        //     const bbox = this.computeBBox();\n        //     if (bbox) {\n        //         this.matrix.transformBBox(bbox).render(ctx);\n        //     }\n        // }\n        this.matrix.toContext(ctx);\n        if (this.dirtyPath) {\n            this.updatePath();\n            this.dirtyPath = false;\n        }\n        scene.appendPath(this.path);\n        this.fillStroke(ctx);\n        this.dirty = false;\n    };\n    Path.className = 'Path';\n    return Path;\n}(Shape));\n\nfunction isEqual(a, b, epsilon) {\n    if (epsilon === void 0) { epsilon = 1e-10; }\n    return Math.abs(a - b) < epsilon;\n}\n/**\n * `Number.toFixed(n)` always formats a number so that it has `n` digits after the decimal point.\n * For example, `Number(0.00003427).toFixed(2)` returns `0.00`.\n * That's not very helpful, because all the meaningful information is lost.\n * In this case we would want the formatted value to have at least two significant digits: `0.000034`,\n * not two fraction digits.\n * @param value\n * @param fractionOrSignificantDigits\n */\nfunction toFixed(value, fractionOrSignificantDigits) {\n    if (fractionOrSignificantDigits === void 0) { fractionOrSignificantDigits = 2; }\n    var power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n    if (power >= 0 || !isFinite(power)) {\n        return value.toFixed(fractionOrSignificantDigits); // fraction digits\n    }\n    return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits); // significant digits\n}\n\nvar __extends$P = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ArcType;\n(function (ArcType) {\n    ArcType[ArcType[\"Open\"] = 0] = \"Open\";\n    ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\n    ArcType[ArcType[\"Round\"] = 2] = \"Round\";\n})(ArcType || (ArcType = {}));\n/**\n * Elliptical arc node.\n */\nvar Arc = /** @class */ (function (_super) {\n    __extends$P(Arc, _super);\n    function Arc() {\n        var _this = _super.call(this) || this;\n        _this._centerX = 0;\n        _this._centerY = 0;\n        _this._radiusX = 10;\n        _this._radiusY = 10;\n        _this._startAngle = 0;\n        _this._endAngle = Math.PI * 2;\n        _this._counterClockwise = false;\n        /**\n         * The type of arc to render:\n         * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\n         * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\n         * - {@link ArcType.Round} - each of the end points of the arc segment are connected\n         *                           to the center of the arc\n         * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\n         * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\n         * would require using two paths - one for rendering, another for hit testing - and there\n         * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\n         * to create a closed path.\n         */\n        _this._type = ArcType.Open;\n        _this.restoreOwnStyles();\n        return _this;\n    }\n    Object.defineProperty(Arc.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (value) {\n            if (this._centerX !== value) {\n                this._centerX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (value) {\n            if (this._centerY !== value) {\n                this._centerY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"radiusX\", {\n        get: function () {\n            return this._radiusX;\n        },\n        set: function (value) {\n            if (this._radiusX !== value) {\n                this._radiusX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"radiusY\", {\n        get: function () {\n            return this._radiusY;\n        },\n        set: function (value) {\n            if (this._radiusY !== value) {\n                this._radiusY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"startAngle\", {\n        get: function () {\n            return this._startAngle;\n        },\n        set: function (value) {\n            if (this._startAngle !== value) {\n                this._startAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"endAngle\", {\n        get: function () {\n            return this._endAngle;\n        },\n        set: function (value) {\n            if (this._endAngle !== value) {\n                this._endAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"fullPie\", {\n        get: function () {\n            return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"counterClockwise\", {\n        get: function () {\n            return this._counterClockwise;\n        },\n        set: function (value) {\n            if (this._counterClockwise !== value) {\n                this._counterClockwise = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Arc.prototype, \"type\", {\n        get: function () {\n            return this._type;\n        },\n        set: function (value) {\n            if (this._type !== value) {\n                this._type = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Arc.prototype.updatePath = function () {\n        var path = this.path;\n        path.clear(); // No need to recreate the Path, can simply clear the existing one.\n        // This is much faster than the native Path2D implementation even though this `cubicArc`\n        // method is pure TypeScript and actually produces the definition of an elliptical arc,\n        // where you can specify two radii and rotation, while Path2D's `arc` method simply produces\n        // a circular arc. Maybe it's due to the experimental nature of the Path2D class,\n        // maybe it's because we have to create a new instance of it on each render, who knows...\n        path.cubicArc(this.centerX, this.centerY, this.radiusX, this.radiusY, 0, this.startAngle, this.endAngle, this.counterClockwise ? 1 : 0);\n        if (this.type === ArcType.Chord) {\n            path.closePath();\n        }\n        else if (this.type === ArcType.Round && !this.fullPie) {\n            path.lineTo(this.centerX, this.centerY);\n            path.closePath();\n        }\n    };\n    Arc.prototype.computeBBox = function () {\n        // Only works with full arcs (circles) and untransformed ellipses.\n        return new BBox(this.centerX - this.radiusX, this.centerY - this.radiusY, this.radiusX * 2, this.radiusY * 2);\n    };\n    Arc.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return this.type !== ArcType.Open\n            && bbox.containsPoint(point.x, point.y)\n            && this.path.isPointInPath(point.x, point.y);\n    };\n    Arc.className = 'Arc';\n    Arc.defaultStyles = chainObjects(Shape.defaultStyles, {\n        lineWidth: 1,\n        fillStyle: null\n    });\n    return Arc;\n}(Path));\n\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\nvar Tags;\n(function (Tags) {\n    Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n    Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisTick = /** @class */ (function () {\n    function AxisTick() {\n        /**\n         * The line width to be used by axis ticks.\n         */\n        this.width = 1;\n        /**\n         * The line length to be used by axis ticks.\n         */\n        this.size = 6;\n        /**\n         * The color of the axis ticks.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n         */\n        this.color = 'rgba(195, 195, 195, 1)';\n        /**\n         * A hint of how many ticks to use (the exact number of ticks might differ),\n         * a `TimeInterval` or a `CountableTimeInterval`.\n         * For example:\n         *\n         *     axis.tick.count = 5;\n         *     axis.tick.count = year;\n         *     axis.tick.count = month.every(6);\n         */\n        this.count = 10;\n    }\n    return AxisTick;\n}());\nvar AxisLabel = /** @class */ (function () {\n    function AxisLabel() {\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the labels and the ticks.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        /**\n         * Custom label rotation in degrees.\n         * Labels are rendered perpendicular to the axis line by default.\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n         * The value of this config is used as the angular offset/deflection\n         * from the default rotation.\n         */\n        this.rotation = 0;\n        /**\n         * By default labels and ticks are positioned to the left of the axis line.\n         * `true` positions the labels to the right of the axis line.\n         * However, if the axis is rotated, its easier to think in terms\n         * of this side or the opposite side, rather than left and right.\n         * We use the term `mirror` for conciseness, although it's not\n         * true mirroring - for example, when a label is rotated, so that\n         * it is inclined at the 45 degree angle, text flowing from north-west\n         * to south-east, ending at the tick to the left of the axis line,\n         * and then we set this config to `true`, the text will still be flowing\n         * from north-west to south-east, _starting_ at the tick to the right\n         * of the axis line.\n         */\n        this.mirrored = false;\n        /**\n         * Labels are rendered perpendicular to the axis line by default.\n         * Setting this config to `true` makes labels render parallel to the axis line\n         * and center aligns labels' text at the ticks.\n         */\n        this.parallel = false;\n    }\n    Object.defineProperty(AxisLabel.prototype, \"format\", {\n        get: function () {\n            return this._format;\n        },\n        set: function (value) {\n            // See `TimeLocaleObject` docs for the list of supported format directives.\n            if (this._format !== value) {\n                this._format = value;\n                if (this.onFormatChange) {\n                    this.onFormatChange(value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return AxisLabel;\n}());\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */ (function () {\n    function Axis(scale) {\n        // debug (bbox)\n        // private bboxRect = (() => {\n        //     const rect = new Rect();\n        //     rect.fill = undefined;\n        //     rect.stroke = 'red';\n        //     rect.strokeWidth = 1;\n        //     rect.strokeOpacity = 0.2;\n        //     return rect;\n        // })();\n        this.id = createId(this);\n        this.lineNode = new Line();\n        this.group = new Group();\n        this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        this.tick = new AxisTick();\n        this.label = new AxisLabel();\n        this.translation = { x: 0, y: 0 };\n        this.rotation = 0; // axis rotation angle in degrees\n        this._visibleRange = [0, 1];\n        this._title = undefined;\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n         * (in degrees).\n         */\n        this._gridLength = 0;\n        /**\n         * The array of styles to cycle through when rendering grid lines.\n         * For example, use two {@link GridStyle} objects for alternating styles.\n         * Contains only one {@link GridStyle} object by default, meaning all grid lines\n         * have the same style.\n         */\n        this.gridStyle = [{\n                stroke: 'rgba(219, 219, 219, 1)',\n                lineDash: [4, 2]\n            }];\n        /**\n         * `false` - render grid as lines of {@link gridLength} that extend the ticks\n         *           on the opposite side of the axis\n         * `true` - render grid as concentric circles that go through the ticks\n         */\n        this._radialGrid = false;\n        this.scale = scale;\n        this.requestedRange = scale.range.slice();\n        this.groupSelection = Selection.select(this.group).selectAll();\n        this.label.onFormatChange = this.onTickFormatChange.bind(this);\n        this.group.append(this.lineNode);\n        this.onTickFormatChange();\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Axis.prototype.getMeta = function () { };\n    Axis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        scale.range = [start, start + span];\n    };\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    Axis.prototype.inRange = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        return this.inRangeEx(x, width, tolerance) === 0;\n    };\n    Axis.prototype.inRangeEx = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        var range = this.range;\n        if ((x + width) < (range[0] - tolerance)) {\n            return -1; // left or range\n        }\n        if (x > (range[1] + tolerance)) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    };\n    Object.defineProperty(Axis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"visibleRange\", {\n        get: function () {\n            return this._visibleRange.slice();\n        },\n        set: function (value) {\n            if (value && value.length === 2) {\n                var min = value[0], max = value[1];\n                min = Math.max(0, min);\n                max = Math.min(1, max);\n                min = Math.min(min, max);\n                max = Math.max(min, max);\n                this._visibleRange = [min, max];\n                this.updateRange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain.slice();\n        },\n        set: function (value) {\n            this.scale.domain = value.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.onTickFormatChange = function (format) {\n        if (format) {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, format);\n            }\n        }\n        else {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, undefined);\n            }\n            else {\n                this.tickFormatter = undefined;\n            }\n        }\n    };\n    Object.defineProperty(Axis.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    this.group.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.rotation = -Math.PI / 2;\n                    this.group.appendChild(value.node);\n                }\n                this._title = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"radialGrid\", {\n        get: function () {\n            return this._radialGrid;\n        },\n        set: function (value) {\n            if (this._radialGrid !== value) {\n                this._radialGrid = value;\n                this.groupSelection = this.groupSelection.remove().setData([]);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    Axis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, tick = _a.tick, label = _a.label, gridStyle = _a.gridStyle, requestedRange = _a.requestedRange;\n        var requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n        var requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n        var rotation = toRadians(this.rotation);\n        var parallelLabels = label.parallel;\n        var labelRotation = normalizeAngle360(toRadians(label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var halfBandwidth = (scale.bandwidth || 0) / 2;\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, ] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n        var ticks = scale.ticks(this.tick.count);\n        var update = this.groupSelection.setData(ticks);\n        update.exit.remove();\n        var enter = update.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enter.append(Line).each(function (node) { return node.tag = Tags.Tick; });\n        if (this.gridLength) {\n            if (this.radialGrid) {\n                enter.append(Arc).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n            else {\n                enter.append(Line).each(function (node) { return node.tag = Tags.GridLine; });\n            }\n        }\n        enter.append(Text);\n        var groupSelection = update.merge(enter);\n        groupSelection\n            .attrFn('translationY', function (_, datum) {\n            return Math.round(scale.convert(datum) + halfBandwidth);\n        })\n            .attrFn('visible', function (node) {\n            return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n        });\n        groupSelection.selectByTag(Tags.Tick)\n            .each(function (line) {\n            line.strokeWidth = tick.width;\n            line.stroke = tick.color;\n        })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n        if (this.gridLength && gridStyle.length) {\n            var styleCount_1 = gridStyle.length;\n            var gridLines = void 0;\n            if (this.radialGrid) {\n                var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(this.gridLength));\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (arc, datum) {\n                    var radius = Math.round(scale.convert(datum) + halfBandwidth);\n                    arc.centerX = 0;\n                    arc.centerY = scale.range[0] - radius;\n                    arc.endAngle = angularGridLength_1;\n                    arc.radiusX = radius;\n                    arc.radiusY = radius;\n                });\n            }\n            else {\n                gridLines = groupSelection.selectByTag(Tags.GridLine)\n                    .each(function (line) {\n                    line.x1 = 0;\n                    line.x2 = -sideFlag * _this.gridLength;\n                    line.y1 = 0;\n                    line.y2 = 0;\n                    line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n                });\n            }\n            gridLines.each(function (gridLine, _, index) {\n                var style = gridStyle[index % styleCount_1];\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n        var tickFormatter = this.tickFormatter;\n        var meta = this.getMeta();\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        var fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n        var labelSelection = groupSelection.selectByClass(Text)\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelLabels && !labelRotation\n                ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                : 'middle';\n            node.text = label.formatter\n                ? label.formatter({\n                    value: fractionDigits >= 0 ? datum : String(datum),\n                    index: index,\n                    fractionDigits: fractionDigits,\n                    formatter: tickFormatter,\n                    axis: meta\n                })\n                : fractionDigits\n                    // the `datum` is a floating point number\n                    ? datum.toFixed(fractionDigits)\n                    // the `datum` is an integer, a string or an object\n                    : tickFormatter\n                        ? tickFormatter(datum)\n                        : String(datum);\n            node.textAlign = parallelLabels\n                ? labelRotation ? (sideFlag * alignFlag === -1 ? 'end' : 'start') : 'center'\n                : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n        });\n        var labelX = sideFlag * (tick.size + label.padding);\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        labelSelection.each(function (label) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = autoRotation + labelRotation;\n        });\n        this.groupSelection = groupSelection;\n        // Render axis line.\n        var lineNode = this.lineNode;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = ticks.length > 0;\n        var title = this.title;\n        var titleVisible = false;\n        if (title && title.enabled) {\n            titleVisible = true;\n            var padding = title.padding.bottom;\n            var titleNode = title.node;\n            var bbox = this.computeBBox({ excludeTitle: true });\n            var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n            titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n            if (sideFlag === -1) {\n                titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n            }\n            else {\n                titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n            }\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    Axis.prototype.computeBBox = function (options) {\n        var _a = this, title = _a.title, lineNode = _a.lineNode;\n        var labels = this.groupSelection.selectByClass(Text);\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        labels.each(function (label) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var group = label.parent;\n            group.computeTransformMatrix();\n            matrix.preMultiplySelf(group.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        });\n        if (title && title.enabled && (!options || !options.excludeTitle)) {\n            var label = title.node;\n            label.computeTransformMatrix();\n            var matrix = Matrix.flyweight(label.matrix);\n            var labelBBox = label.computeBBox();\n            if (labelBBox) {\n                var bbox = matrix.transformBBox(labelBBox);\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        }\n        left = Math.min(left, 0);\n        right = Math.max(right, 0);\n        top = Math.min(top, lineNode.y1, lineNode.y2);\n        bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    return Axis;\n}());\n\nvar __extends$Q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ChartAxisDirection;\n(function (ChartAxisDirection) {\n    ChartAxisDirection[\"X\"] = \"x\";\n    ChartAxisDirection[\"Y\"] = \"y\"; // means 'radius' in polar charts\n})(ChartAxisDirection || (ChartAxisDirection = {}));\nfunction flipChartAxisDirection(direction) {\n    if (direction === ChartAxisDirection.X) {\n        return ChartAxisDirection.Y;\n    }\n    else {\n        return ChartAxisDirection.X;\n    }\n}\nvar ChartAxisPosition;\n(function (ChartAxisPosition) {\n    ChartAxisPosition[\"Top\"] = \"top\";\n    ChartAxisPosition[\"Right\"] = \"right\";\n    ChartAxisPosition[\"Bottom\"] = \"bottom\";\n    ChartAxisPosition[\"Left\"] = \"left\";\n    ChartAxisPosition[\"Angle\"] = \"angle\";\n    ChartAxisPosition[\"Radius\"] = \"radius\";\n})(ChartAxisPosition || (ChartAxisPosition = {}));\nvar ChartAxis = /** @class */ (function (_super) {\n    __extends$Q(ChartAxis, _super);\n    function ChartAxis() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.keys = [];\n        _this.boundSeries = [];\n        return _this;\n    }\n    Object.defineProperty(ChartAxis.prototype, \"type\", {\n        get: function () {\n            return this.constructor.type || '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChartAxis.prototype.getMeta = function () {\n        return {\n            id: this.id,\n            direction: this.direction,\n            boundSeries: this.boundSeries,\n        };\n    };\n    Object.defineProperty(ChartAxis.prototype, \"position\", {\n        get: function () {\n            return this._position;\n        },\n        set: function (value) {\n            if (this._position !== value) {\n                this._position = value;\n                switch (value) {\n                    case ChartAxisPosition.Top:\n                        this.direction = ChartAxisDirection.X;\n                        this.rotation = -90;\n                        this.label.mirrored = true;\n                        this.label.parallel = true;\n                        break;\n                    case ChartAxisPosition.Right:\n                        this.direction = ChartAxisDirection.Y;\n                        this.rotation = 0;\n                        this.label.mirrored = true;\n                        this.label.parallel = false;\n                        break;\n                    case ChartAxisPosition.Bottom:\n                        this.direction = ChartAxisDirection.X;\n                        this.rotation = -90;\n                        this.label.mirrored = false;\n                        this.label.parallel = true;\n                        break;\n                    case ChartAxisPosition.Left:\n                        this.direction = ChartAxisDirection.Y;\n                        this.rotation = 0;\n                        this.label.mirrored = false;\n                        this.label.parallel = false;\n                        break;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ChartAxis;\n}(Axis));\n\nvar __extends$R = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar NumberAxis = /** @class */ (function (_super) {\n    __extends$R(NumberAxis, _super);\n    function NumberAxis() {\n        var _this = _super.call(this, new LinearScale()) || this;\n        _this._nice = true;\n        _this._min = NaN;\n        _this._max = NaN;\n        _this.scale.clamp = true;\n        return _this;\n    }\n    Object.defineProperty(NumberAxis.prototype, \"nice\", {\n        get: function () {\n            return this._nice;\n        },\n        set: function (value) {\n            if (this._nice !== value) {\n                this._nice = value;\n                if (value && this.scale.nice) {\n                    this.scale.nice(10);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumberAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (value) {\n            var _a = this, min = _a.min, max = _a.max;\n            value = [\n                isNaN(min) ? value[0] : min,\n                isNaN(max) ? value[1] : max\n            ];\n            this.scale.domain = value;\n            if (this.nice && this.scale.nice) {\n                this.scale.nice(10);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumberAxis.prototype, \"min\", {\n        get: function () {\n            return this._min;\n        },\n        set: function (value) {\n            if (this._min !== value) {\n                this._min = value;\n                if (!isNaN(value)) {\n                    this.scale.domain = [value, this.scale.domain[1]];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NumberAxis.prototype, \"max\", {\n        get: function () {\n            return this._max;\n        },\n        set: function (value) {\n            if (this._max !== value) {\n                this._max = value;\n                if (!isNaN(value)) {\n                    this.scale.domain = [this.scale.domain[0], value];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NumberAxis.className = 'NumberAxis';\n    NumberAxis.type = 'number';\n    return NumberAxis;\n}(ChartAxis));\n\n/**\n * Maps a discrete domain to a continuous numeric range.\n * See https://github.com/d3/d3-scale#band-scales for more info.\n */\nvar BandScale = /** @class */ (function () {\n    function BandScale() {\n        /**\n         * Maps datum to its index in the {@link domain} array.\n         * Used to check for duplicate datums (not allowed).\n         */\n        this.index = new Map();\n        /**\n         * The output range values for datum at each index.\n         */\n        this.ordinalRange = [];\n        /**\n         * Contains unique datums only. Since `{}` is used in place of `Map`\n         * for IE11 compatibility, the datums are converted `toString` before\n         * the uniqueness check.\n         */\n        this._domain = [];\n        this._range = [0, 1];\n        this._bandwidth = 1;\n        /**\n         * The ratio of the range that is reserved for space between bands.\n         */\n        this._paddingInner = 0;\n        /**\n         * The ratio of the range that is reserved for space before the first\n         * and after the last band.\n         */\n        this._paddingOuter = 0;\n        this._round = false;\n        /**\n         * How the leftover range is distributed.\n         * `0.5` - equal distribution of space before the first and after the last band,\n         * with bands effectively centered within the range.\n         */\n        this._align = 0.5;\n    }\n    Object.defineProperty(BandScale.prototype, \"domain\", {\n        get: function () {\n            return this._domain;\n        },\n        set: function (values) {\n            var domain = this._domain;\n            domain.length = 0;\n            this.index = new Map();\n            var index = this.index;\n            // In case one wants to have duplicate domain values, for example, two 'Italy' categories,\n            // one should use objects rather than strings for domain values like so:\n            // { toString: () => 'Italy' }\n            // { toString: () => 'Italy' }\n            values.forEach(function (value) {\n                if (index.get(value) === undefined) {\n                    index.set(value, domain.push(value) - 1);\n                }\n            });\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"range\", {\n        get: function () {\n            return this._range;\n        },\n        set: function (values) {\n            this._range[0] = values[0];\n            this._range[1] = values[1];\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BandScale.prototype.ticks = function () {\n        return this._domain;\n    };\n    BandScale.prototype.convert = function (d) {\n        var i = this.index.get(d);\n        if (i === undefined) {\n            return NaN;\n        }\n        var r = this.ordinalRange[i];\n        if (r === undefined) {\n            return NaN;\n        }\n        return r;\n    };\n    Object.defineProperty(BandScale.prototype, \"bandwidth\", {\n        get: function () {\n            return this._bandwidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"padding\", {\n        get: function () {\n            return this._paddingInner;\n        },\n        set: function (value) {\n            value = Math.max(0, Math.min(1, value));\n            this._paddingInner = value;\n            this._paddingOuter = value;\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"paddingInner\", {\n        get: function () {\n            return this._paddingInner;\n        },\n        set: function (value) {\n            this._paddingInner = Math.max(0, Math.min(1, value)); // [0, 1]\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"paddingOuter\", {\n        get: function () {\n            return this._paddingOuter;\n        },\n        set: function (value) {\n            this._paddingOuter = Math.max(0, Math.min(1, value)); // [0, 1]\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"round\", {\n        get: function () {\n            return this._round;\n        },\n        set: function (value) {\n            this._round = value;\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BandScale.prototype, \"align\", {\n        get: function () {\n            return this._align;\n        },\n        set: function (value) {\n            this._align = Math.max(0, Math.min(1, value)); // [0, 1]\n            this.rescale();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BandScale.prototype.rescale = function () {\n        var _a;\n        var n = this._domain.length;\n        if (!n) {\n            return;\n        }\n        var _b = this._range, a = _b[0], b = _b[1];\n        var reversed = b < a;\n        if (reversed) {\n            _a = [b, a], a = _a[0], b = _a[1];\n        }\n        var step = (b - a) / Math.max(1, n - this._paddingInner + this._paddingOuter * 2);\n        if (this._round) {\n            step = Math.floor(step);\n        }\n        a += (b - a - step * (n - this._paddingInner)) * this._align;\n        this._bandwidth = step * (1 - this._paddingInner);\n        if (this._round) {\n            a = Math.round(a);\n            this._bandwidth = Math.round(this._bandwidth);\n        }\n        var values = [];\n        for (var i = 0; i < n; i++) {\n            values.push(a + step * i);\n        }\n        this.ordinalRange = reversed ? values.reverse() : values;\n    };\n    return BandScale;\n}());\n\nvar __extends$S = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar CategoryAxis = /** @class */ (function (_super) {\n    __extends$S(CategoryAxis, _super);\n    function CategoryAxis() {\n        var _this = this;\n        var scale = new BandScale();\n        scale.paddingInner = 0.2;\n        scale.paddingOuter = 0.3;\n        _this = _super.call(this, scale) || this;\n        return _this;\n    }\n    Object.defineProperty(CategoryAxis.prototype, \"paddingInner\", {\n        get: function () {\n            return this.scale.paddingInner;\n        },\n        set: function (value) {\n            this.scale.paddingInner = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryAxis.prototype, \"paddingOuter\", {\n        get: function () {\n            return this.scale.paddingOuter;\n        },\n        set: function (value) {\n            this.scale.paddingOuter = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CategoryAxis.className = 'CategoryAxis';\n    CategoryAxis.type = 'category';\n    return CategoryAxis;\n}(ChartAxis));\n\n// Custom `Array.find` implementation for legacy browsers.\nfunction find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\nfunction finiteExtent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value && isFinite(value)) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null && isFinite(value)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nfunction numericExtent(values) {\n    var calculatedExtent = finiteExtent(values);\n    if (typeof calculatedExtent === 'undefined') {\n        return;\n    }\n    var a = calculatedExtent[0], b = calculatedExtent[1];\n    var min = a instanceof Date ? a.getTime() : a;\n    var max = b instanceof Date ? b.getTime() : b;\n    if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n        return [min, max];\n    }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nfunction findMinMax(values) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var value = values_1[_i];\n        if (value < 0) {\n            min += value;\n        }\n        else {\n            max += value;\n        }\n    }\n    return { min: min, max: max };\n}\nfunction copy(array, start, count) {\n    if (start === void 0) { start = 0; }\n    if (count === void 0) { count = array.length; }\n    var result = [];\n    var n = array.length;\n    if (n) {\n        for (var i = 0; i < count; i++) {\n            result.push(array[(start + i) % n]);\n        }\n    }\n    return result;\n}\n\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(label, parent, number) {\n        if (label === void 0) { label = ''; }\n        if (number === void 0) { number = 0; }\n        this.x = 0;\n        this.y = 0;\n        this.subtreeLeft = NaN;\n        this.subtreeRight = NaN;\n        this.screenX = 0;\n        this.screenY = 0;\n        this.children = [];\n        this.leafCount = 0;\n        this.prelim = 0;\n        this.mod = 0;\n        this.ancestor = this;\n        this.change = 0;\n        this.shift = 0;\n        this.label = label;\n        // screenX and screenY are meant to be recomputed from (layout) x and y\n        // when the tree is resized (without performing another layout)\n        this.parent = parent;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.number = number;\n    }\n    TreeNode.prototype.getLeftSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n    };\n    TreeNode.prototype.getLeftmostSibling = function () {\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n    };\n    // traverse the left contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextLeft = function () {\n        return this.children ? this.children[0] : this.thread;\n    };\n    // traverse the right contour of a subtree, return the successor of v on this contour\n    TreeNode.prototype.nextRight = function () {\n        return this.children ? this.children[this.children.length - 1] : this.thread;\n    };\n    TreeNode.prototype.getSiblings = function () {\n        var _this = this;\n        return this.parent ? this.parent.children.filter(function (_, i) { return i !== _this.number; }) : [];\n    };\n    return TreeNode;\n}());\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\nfunction ticksToTree(ticks, pad) {\n    if (pad === void 0) { pad = true; }\n    var root = new TreeNode();\n    var depth = 0;\n    if (pad) {\n        ticks.forEach(function (tick) { return depth = Math.max(depth, tick.labels.length); });\n    }\n    ticks.forEach(function (tick) {\n        if (pad) {\n            while (tick.labels.length < depth) {\n                tick.labels.unshift('');\n            }\n        }\n        insertTick(root, tick);\n    });\n    return root;\n}\nfunction insertTick(root, tick) {\n    var pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n    var lastPartIndex = pathParts.length - 1;\n    pathParts.forEach(function (pathPart, partIndex) {\n        var children = root.children;\n        var existingNode = find(children, function (child) { return child.label === pathPart; });\n        var isNotLeaf = partIndex !== lastPartIndex;\n        if (existingNode && isNotLeaf) { // the isNotLeaf check is to allow duplicate leafs\n            root = existingNode;\n        }\n        else {\n            var node = new TreeNode(pathPart, root);\n            node.number = children.length;\n            children.push(node);\n            if (isNotLeaf) {\n                root = node;\n            }\n        }\n    });\n}\n// Shift the subtree.\nfunction moveSubtree(wm, wp, shift) {\n    var subtrees = wp.number - wm.number;\n    var ratio = shift / subtrees;\n    wp.change -= ratio;\n    wp.shift += shift;\n    wm.change += ratio;\n    wp.prelim += shift;\n    wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n// Spaces out the children.\nfunction executeShifts(v) {\n    var children = v.children;\n    if (children) {\n        var shift = 0;\n        var change = 0;\n        for (var i = children.length - 1; i >= 0; i--) {\n            var w = children[i];\n            w.prelim += shift;\n            w.mod += shift;\n            change += w.change;\n            shift += w.shift + change;\n        }\n    }\n}\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v, defaultAncestor, distance) {\n    var w = v.getLeftSibling();\n    if (w) {\n        var vop = v;\n        var vip = v;\n        var vim = w;\n        var vom = vip.getLeftmostSibling();\n        var sip = vip.mod;\n        var sop = vop.mod;\n        var sim = vim.mod;\n        var som = vom.mod;\n        while (vim.nextRight() && vip.nextLeft()) {\n            vim = vim.nextRight();\n            vip = vip.nextLeft();\n            vom = vom.nextLeft();\n            vop = vop.nextRight();\n            vop.ancestor = v;\n            var shift = (vim.prelim + sim) - (vip.prelim + sip) + distance;\n            if (shift > 0) {\n                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n                sip += shift;\n                sop += shift;\n            }\n            sim += vim.mod;\n            sip += vip.mod;\n            som += vom.mod;\n            sop += vop.mod;\n        }\n        if (vim.nextRight() && !vop.nextRight()) {\n            vop.thread = vim.nextRight();\n            vop.mod += sim - sop;\n        }\n        else {\n            if (vip.nextLeft() && !vom.nextLeft()) {\n                vom.thread = vip.nextLeft();\n                vom.mod += sip - som;\n            }\n            defaultAncestor = v;\n        }\n    }\n    return defaultAncestor;\n}\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node, distance) {\n    var children = node.children;\n    if (children.length) {\n        var defaultAncestor_1 = children[0];\n        children.forEach(function (child) {\n            firstWalk(child, distance);\n            defaultAncestor_1 = apportion(child, defaultAncestor_1, distance);\n        });\n        executeShifts(node);\n        var midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n        var leftSibling = node.getLeftSibling();\n        if (leftSibling) {\n            node.prelim = leftSibling.prelim + distance;\n            node.mod = node.prelim - midpoint;\n        }\n        else {\n            node.prelim = midpoint;\n        }\n    }\n    else {\n        var leftSibling = node.getLeftSibling();\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n    }\n}\nvar Dimensions = /** @class */ (function () {\n    function Dimensions() {\n        this.top = Infinity;\n        this.right = -Infinity;\n        this.bottom = -Infinity;\n        this.left = Infinity;\n    }\n    Dimensions.prototype.update = function (node, xy) {\n        var _a = xy(node), x = _a.x, y = _a.y;\n        if (x > this.right) {\n            this.right = x;\n        }\n        if (x < this.left) {\n            this.left = x;\n        }\n        if (y > this.bottom) {\n            this.bottom = y;\n        }\n        if (y < this.top) {\n            this.top = y;\n        }\n    };\n    return Dimensions;\n}());\nfunction secondWalk(v, m, layout) {\n    v.x = v.prelim + m;\n    v.y = v.depth;\n    layout.update(v);\n    v.children.forEach(function (w) { return secondWalk(w, m + v.mod, layout); });\n}\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v) {\n    var children = v.children;\n    var leafCount = 0;\n    children.forEach(function (w) {\n        thirdWalk(w);\n        if (w.children.length) {\n            leafCount += w.leafCount;\n        }\n        else {\n            leafCount++;\n        }\n    });\n    v.leafCount = leafCount;\n    if (children.length) {\n        v.subtreeLeft = children[0].subtreeLeft;\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n    }\n    else {\n        v.subtreeLeft = v.x;\n        v.subtreeRight = v.x;\n    }\n}\nfunction treeLayout(root) {\n    var layout = new TreeLayout;\n    firstWalk(root, 1);\n    secondWalk(root, -root.prelim, layout);\n    thirdWalk(root);\n    return layout;\n}\nvar TreeLayout = /** @class */ (function () {\n    function TreeLayout() {\n        this.dimensions = new Dimensions;\n        this.leafCount = 0;\n        this.nodes = [];\n        // One might want to process leaf nodes separately from the rest of the tree.\n        // For example, position labels corresponding to leafs vertically, rather than horizontally.\n        this.leafNodes = [];\n        this.nonLeafNodes = [];\n        this.depth = 0;\n    }\n    TreeLayout.prototype.update = function (node) {\n        this.dimensions.update(node, function (node) { return ({ x: node.x, y: node.y }); });\n        if (!node.children.length) {\n            this.leafCount++;\n            this.leafNodes.push(node);\n        }\n        else {\n            this.nonLeafNodes.push(node);\n        }\n        if (node.depth > this.depth) {\n            this.depth = node.depth;\n        }\n        this.nodes.push(node);\n    };\n    TreeLayout.prototype.resize = function (width, height, shiftX, shiftY, flipX) {\n        if (shiftX === void 0) { shiftX = 0; }\n        if (shiftY === void 0) { shiftY = 0; }\n        if (flipX === void 0) { flipX = false; }\n        var xSteps = this.leafCount - 1;\n        var ySteps = this.depth;\n        var dimensions = this.dimensions;\n        var scalingX = 1;\n        var scalingY = 1;\n        if (width > 0 && xSteps) {\n            var existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n            var desiredSpacingX = width / xSteps;\n            scalingX = desiredSpacingX / existingSpacingX;\n            if (flipX) {\n                scalingX = -scalingX;\n            }\n        }\n        if (height > 0 && ySteps) {\n            var existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n            var desiredSpacingY = height / ySteps;\n            scalingY = desiredSpacingY / existingSpacingY;\n        }\n        var screenDimensions = new Dimensions();\n        this.nodes.forEach(function (node) {\n            node.screenX = node.x * scalingX;\n            node.screenY = node.y * scalingY;\n            screenDimensions.update(node, function (node) { return ({ x: node.screenX, y: node.screenY }); });\n        });\n        // Normalize so that root top and leftmost leaf left start at zero.\n        var offsetX = -screenDimensions.left;\n        var offsetY = -screenDimensions.top;\n        this.nodes.forEach(function (node) {\n            node.screenX += offsetX + shiftX;\n            node.screenY += offsetY + shiftY;\n        });\n    };\n    return TreeLayout;\n}());\n\nvar __extends$T = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar GroupedCategoryAxisLabel = /** @class */ (function (_super) {\n    __extends$T(GroupedCategoryAxisLabel, _super);\n    function GroupedCategoryAxisLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.grid = false;\n        return _this;\n    }\n    return GroupedCategoryAxisLabel;\n}(AxisLabel));\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar GroupedCategoryAxis = /** @class */ (function (_super) {\n    __extends$T(GroupedCategoryAxis, _super);\n    function GroupedCategoryAxis() {\n        var _this = _super.call(this, new BandScale()) || this;\n        _this.id = createId(_this);\n        _this.tickScale = new BandScale();\n        _this.group = new Group();\n        _this.longestSeparatorLength = 0;\n        _this.translation = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * Axis rotation angle in degrees.\n         */\n        _this.rotation = 0;\n        _this.line = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n        // readonly tick = new AxisTick();\n        _this.label = new GroupedCategoryAxisLabel();\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        _this.labelColor = 'rgba(87, 87, 87, 1)';\n        var _a = _this, group = _a.group, scale = _a.scale, tickScale = _a.tickScale;\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        _this.requestedRange = scale.range.slice();\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n        _this.gridLineSelection = Selection.select(group).selectAll();\n        _this.axisLineSelection = Selection.select(group).selectAll();\n        _this.separatorSelection = Selection.select(group).selectAll();\n        _this.labelSelection = Selection.select(group).selectAll();\n        return _this;\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (value) {\n            this.scale.domain = value;\n            var tickTree = ticksToTree(value);\n            this.tickTreeLayout = treeLayout(tickTree);\n            var domain = value.slice();\n            domain.push('');\n            this.tickScale.domain = domain;\n            this.resizeTickTree();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    };\n    GroupedCategoryAxis.prototype.resizeTickTree = function () {\n        var s = this.scale;\n        var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        var layout = this.tickTreeLayout;\n        var lineHeight = this.lineHeight;\n        if (layout) {\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, (range[1] - range[0]) < 0);\n        }\n    };\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n        get: function () {\n            return this.label.fontSize * 1.5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         */\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if (this._gridLength && !value || !this._gridLength && value) {\n                this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n                this.labelSelection = this.labelSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    GroupedCategoryAxis.prototype.update = function () {\n        var _this = this;\n        var _a = this, group = _a.group, scale = _a.scale, label = _a.label, tickScale = _a.tickScale, requestedRange = _a.requestedRange;\n        var rangeStart = scale.range[0];\n        var rangeEnd = scale.range[1];\n        var rangeLength = Math.abs(rangeEnd - rangeStart);\n        var bandwidth = (rangeLength / scale.domain.length) || 0;\n        var parallelLabels = label.parallel;\n        var rotation = toRadians(this.rotation);\n        var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        var labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n        var title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        var lineHeight = this.lineHeight;\n        // Render ticks and labels.\n        var tickTreeLayout = this.tickTreeLayout;\n        var labels = scale.ticks();\n        var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        var ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, ] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = (!labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI) ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = (!labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI) ? -1 : 1;\n        var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        var enterGridLines = updateGridLines.enter.append(Line);\n        var gridLineSelection = updateGridLines.merge(enterGridLines);\n        var updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n        var enterLabels = updateLabels.enter.append(Text);\n        var labelSelection = updateLabels.merge(enterLabels);\n        var labelFormatter = label.formatter;\n        var maxLeafLabelWidth = 0;\n        labelSelection\n            .each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n            // label.textBaseline = parallelLabels && !labelRotation\n            //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n            //     : 'middle';\n            node.textAlign = 'center';\n            node.translationX = datum.screenY - label.fontSize * 0.25;\n            node.translationY = datum.screenX;\n            if (index === 0) { // use the phantom root as the axis title\n                if (title && title.enabled && labels.length > 0) {\n                    node.visible = true;\n                    node.text = title.text;\n                    node.fontSize = title.fontSize;\n                    node.fontStyle = title.fontStyle;\n                    node.fontWeight = title.fontWeight;\n                    node.fontFamily = title.fontFamily;\n                    node.textBaseline = 'hanging';\n                }\n                else {\n                    node.visible = false;\n                }\n            }\n            else {\n                node.text = labelFormatter\n                    ? labelFormatter({\n                        value: String(datum.label),\n                        index: index\n                    })\n                    : String(datum.label);\n                node.visible =\n                    datum.screenX >= requestedRange[0] &&\n                        datum.screenX <= requestedRange[1];\n            }\n            var bbox = node.computeBBox();\n            if (bbox && bbox.width > maxLeafLabelWidth) {\n                maxLeafLabelWidth = bbox.width;\n            }\n        });\n        var labelX = sideFlag * label.padding;\n        var autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n        var labelGrid = this.label.grid;\n        var separatorData = [];\n        labelSelection.each(function (label, datum, index) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n            }\n            else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n                if (isHorizontal) {\n                    label.rotation = autoRotation;\n                }\n                else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                var y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - datum.leafCount * bandwidth / 2;\n                if (!datum.children.length) {\n                    if ((datum.number !== datum.children.length - 1) || labelGrid) {\n                        separatorData.push({\n                            y: y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - _this.label.padding * 2,\n                            toString: function () { return String(index); }\n                        });\n                    }\n                }\n                else {\n                    var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y: y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: function () { return String(index); }\n                    });\n                }\n            }\n        });\n        // Calculate the position of the long separator on the far bottom of the axis.\n        var minX = 0;\n        separatorData.forEach(function (d) { return minX = Math.min(minX, d.x2); });\n        this.longestSeparatorLength = Math.abs(minX);\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: function () { return String(separatorData.length); }\n        });\n        var updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        var enterSeparators = updateSeparators.enter.append(Line);\n        var separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n        var epsilon = 0.0000001;\n        separatorSelection.each(function (line, datum, i) {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = _this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n        // Render axis lines.\n        var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        var lines = [];\n        for (var i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n        var updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        var enterAxisLines = updateAxisLines.enter.append(Line);\n        var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n        axisLineSelection.each(function (line, _, index) {\n            var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = _this.line.width;\n            line.stroke = _this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n        if (this.gridLength) {\n            var styles_1 = this.gridStyle;\n            var styleCount_1 = styles_1.length;\n            gridLineSelection\n                .each(function (line, datum, index) {\n                var y = Math.round(tickScale.convert(datum));\n                line.x1 = 0;\n                line.x2 = -sideFlag * _this.gridLength;\n                line.y1 = y;\n                line.y2 = y;\n                line.visible = y >= requestedRange[0] && y <= requestedRange[1] &&\n                    Math.abs(line.parent.translationY - rangeStart) > 1;\n                var style = styles_1[index % styleCount_1];\n                line.stroke = style.stroke;\n                line.strokeWidth = _this.tick.width;\n                line.lineDash = style.lineDash;\n                line.fill = undefined;\n            });\n        }\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    };\n    GroupedCategoryAxis.prototype.computeBBox = function (options) {\n        var includeTitle = !options || !options.excludeTitle;\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        this.labelSelection.each(function (label, _, index) {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            if (index > 0 || includeTitle) { // first node is the root (title)\n                label.computeTransformMatrix();\n                var matrix = Matrix.flyweight(label.matrix);\n                var labelBBox = label.computeBBox();\n                if (labelBBox) {\n                    var bbox = matrix.transformBBox(labelBBox);\n                    left = Math.min(left, bbox.x);\n                    right = Math.max(right, bbox.x + bbox.width);\n                    top = Math.min(top, bbox.y);\n                    bottom = Math.max(bottom, bbox.y + bbox.height);\n                }\n            }\n        });\n        return new BBox(left, top, Math.max(right - left, this.longestSeparatorLength), bottom - top);\n    };\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.7;\n    //     return rect;\n    // })();\n    GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n    GroupedCategoryAxis.type = 'groupedCategory';\n    return GroupedCategoryAxis;\n}(ChartAxis));\n\nvar __extends$U = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar t0 = new Date;\nvar t1 = new Date;\n/**\n * The interval methods don't mutate Date parameters.\n */\nvar TimeInterval = /** @class */ (function () {\n    function TimeInterval(floor, offset) {\n        this._floor = floor;\n        this._offset = offset;\n    }\n    /**\n     * Returns a new date representing the latest interval boundary date before or equal to date.\n     * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n     * @param date\n     */\n    TimeInterval.prototype.floor = function (date) {\n        date = new Date(+date);\n        this._floor(date);\n        return date;\n    };\n    /**\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\n     * @param date\n     */\n    TimeInterval.prototype.ceil = function (date) {\n        date = new Date(+date - 1);\n        this._floor(date);\n        this._offset(date, 1);\n        this._floor(date);\n        return date;\n    };\n    /**\n     * Returns a new date representing the closest interval boundary date to date.\n     * @param date\n     */\n    TimeInterval.prototype.round = function (date) {\n        var d0 = this.floor(date);\n        var d1 = this.ceil(date);\n        var ms = +date;\n        return ms - d0.getTime() < d1.getTime() - ms ? d0 : d1;\n    };\n    /**\n     * Returns a new date equal to date plus step intervals.\n     * @param date\n     * @param step\n     */\n    TimeInterval.prototype.offset = function (date, step) {\n        if (step === void 0) { step = 1; }\n        date = new Date(+date);\n        this._offset(date, Math.floor(step));\n        return date;\n    };\n    /**\n     * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n     * @param start\n     * @param stop\n     * @param step\n     */\n    TimeInterval.prototype.range = function (start, stop, step) {\n        if (step === void 0) { step = 1; }\n        var range = [];\n        start = this.ceil(start);\n        step = Math.floor(step);\n        if (start > stop || step <= 0) {\n            return range;\n        }\n        var previous;\n        do {\n            previous = new Date(+start);\n            range.push(previous);\n            this._offset(start, step);\n            this._floor(start);\n        } while (previous < start && start < stop);\n        return range;\n    };\n    // Returns an interval that is a subset of this interval.\n    // For example, to create an interval that return 1st, 11th, 21st and 31st of each month:\n    // day.filter(date => (date.getDate() - 1) % 10 === 0)\n    TimeInterval.prototype.filter = function (test) {\n        var _this = this;\n        var floor = function (date) {\n            if (date >= date) {\n                while (_this._floor(date), !test(date)) {\n                    date.setTime(date.getTime() - 1);\n                }\n            }\n            return date;\n        };\n        var offset = function (date, step) {\n            if (date >= date) {\n                if (step < 0) {\n                    while (++step <= 0) {\n                        do {\n                            _this._offset(date, -1);\n                        } while (!test(date));\n                    }\n                }\n                else {\n                    while (--step >= 0) {\n                        do {\n                            _this._offset(date, 1);\n                        } while (!test(date));\n                    }\n                }\n            }\n            return date;\n        };\n        return new TimeInterval(floor, offset);\n    };\n    return TimeInterval;\n}());\nvar CountableTimeInterval = /** @class */ (function (_super) {\n    __extends$U(CountableTimeInterval, _super);\n    function CountableTimeInterval(floor, offset, count, field) {\n        var _this = _super.call(this, floor, offset) || this;\n        _this._count = count;\n        _this._field = field;\n        return _this;\n    }\n    /**\n     * Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive).\n     * @param start\n     * @param end\n     */\n    CountableTimeInterval.prototype.count = function (start, end) {\n        t0.setTime(+start);\n        t1.setTime(+end);\n        this._floor(t0);\n        this._floor(t1);\n        return Math.floor(this._count(t0, t1));\n    };\n    /**\n     * Returns a filtered view of this interval representing every step'th date.\n     * The meaning of step is dependent on this intervals parent interval as defined by the `field` function.\n     * @param step\n     */\n    CountableTimeInterval.prototype.every = function (step) {\n        var _this = this;\n        var result;\n        step = Math.floor(step);\n        if (isFinite(step) && step > 0) {\n            if (step > 1) {\n                var field_1 = this._field;\n                if (field_1) {\n                    result = this.filter(function (d) { return field_1(d) % step === 0; });\n                }\n                else {\n                    result = this.filter(function (d) { return _this.count(0, d) % step === 0; });\n                }\n            }\n            else {\n                result = this;\n            }\n        }\n        return result;\n    };\n    return CountableTimeInterval;\n}(TimeInterval));\n\nfunction floor(date) {\n    return date;\n}\nfunction offset(date, milliseconds) {\n    date.setTime(date.getTime() + milliseconds);\n}\nfunction count(start, end) {\n    return end.getTime() - start.getTime();\n}\nvar millisecond = new CountableTimeInterval(floor, offset, count);\n\n// Common time unit sizes in milliseconds.\nvar durationSecond = 1000;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\nfunction floor$1(date) {\n    date.setTime(date.getTime() - date.getMilliseconds());\n}\nfunction offset$1(date, seconds) {\n    date.setTime(date.getTime() + seconds * durationSecond);\n}\nfunction count$1(start, end) {\n    return (end.getTime() - start.getTime()) / durationSecond;\n}\nvar second = new CountableTimeInterval(floor$1, offset$1, count$1);\n\nfunction floor$2(date) {\n    date.setTime(date.getTime() - date.getMilliseconds() - date.getSeconds() * durationSecond);\n}\nfunction offset$2(date, minutes) {\n    date.setTime(date.getTime() + minutes * durationMinute);\n}\nfunction count$2(start, end) {\n    return (end.getTime() - start.getTime()) / durationMinute;\n}\nfunction field(date) {\n    return date.getMinutes();\n}\nvar minute = new CountableTimeInterval(floor$2, offset$2, count$2, field);\n\nfunction floor$3(date) {\n    date.setTime(date.getTime() - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);\n}\nfunction offset$3(date, hours) {\n    date.setTime(date.getTime() + hours * durationHour);\n}\nfunction count$3(start, end) {\n    return (end.getTime() - start.getTime()) / durationHour;\n}\nfunction field$1(date) {\n    return date.getHours();\n}\nvar hour = new CountableTimeInterval(floor$3, offset$3, count$3, field$1);\n\nfunction floor$4(date) {\n    date.setHours(0, 0, 0, 0);\n}\nfunction offset$4(date, days) {\n    date.setDate(date.getDate() + days);\n}\nfunction count$4(start, end) {\n    var tzMinuteDelta = end.getTimezoneOffset() - start.getTimezoneOffset();\n    return (end.getTime() - start.getTime() - tzMinuteDelta * durationMinute) / durationDay;\n}\nfunction field$2(date) {\n    return date.getDate() - 1;\n}\nvar day = new CountableTimeInterval(floor$4, offset$4, count$4, field$2);\n\n// Set date to n-th day of the week.\nfunction weekday(n) {\n    // Sets the `date` to the start of the `n`-th day of the current week.\n    // n == 0 is Sunday.\n    function floor(date) {\n        //                  1..31            1..7\n        date.setDate(date.getDate() - (date.getDay() + 7 - n) % 7);\n        date.setHours(0, 0, 0, 0); // h, m, s, ms\n    }\n    // Offset the date by the given number of weeks.\n    function offset(date, weeks) {\n        date.setDate(date.getDate() + weeks * 7);\n    }\n    // Count the number of weeks between the start and end dates.\n    function count(start, end) {\n        var msDelta = end.getTime() - start.getTime();\n        var tzMinuteDelta = end.getTimezoneOffset() - start.getTimezoneOffset();\n        return (msDelta - tzMinuteDelta * durationMinute) / durationWeek;\n    }\n    return new CountableTimeInterval(floor, offset, count);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\nfunction floor$5(date) {\n    date.setDate(1);\n    date.setHours(0, 0, 0, 0);\n}\nfunction offset$5(date, months) {\n    date.setMonth(date.getMonth() + months);\n}\nfunction count$5(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}\nfunction field$3(date) {\n    return date.getMonth();\n}\nvar month = new CountableTimeInterval(floor$5, offset$5, count$5, field$3);\n\nfunction floor$6(date) {\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n}\nfunction offset$6(date, years) {\n    date.setFullYear(date.getFullYear() + years);\n}\nfunction count$6(start, end) {\n    return end.getFullYear() - start.getFullYear();\n}\nfunction field$4(date) {\n    return date.getFullYear();\n}\nvar year = new CountableTimeInterval(floor$6, offset$6, count$6, field$4);\n\nfunction floor$7(date) {\n    date.setUTCHours(0, 0, 0, 0);\n}\nfunction offset$7(date, days) {\n    date.setUTCDate(date.getUTCDate() + days);\n}\nfunction count$7(start, end) {\n    return (end.getTime() - start.getTime()) / durationDay;\n}\nfunction field$5(date) {\n    return date.getUTCDate() - 1;\n}\nvar utcDay = new CountableTimeInterval(floor$7, offset$7, count$7, field$5);\n\nfunction floor$8(date) {\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n}\nfunction offset$8(date, years) {\n    date.setUTCFullYear(date.getUTCFullYear() + years);\n}\nfunction count$8(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n}\nfunction field$6(date) {\n    return date.getUTCFullYear();\n}\nvar utcYear = new CountableTimeInterval(floor$8, offset$8, count$8, field$6);\n\n// Set date to n-th day of the week.\nfunction weekday$1(n) {\n    // Sets the `date` to the start of the `n`-th day of the current week.\n    // n == 0 is Sunday.\n    function floor(date) {\n        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - n) % 7);\n        date.setHours(0, 0, 0, 0); // h, m, s, ms\n    }\n    // Offset the date by the given number of weeks.\n    function offset(date, weeks) {\n        date.setUTCDate(date.getUTCDate() + weeks * 7);\n    }\n    // Count the number of weeks between the start and end dates.\n    function count(start, end) {\n        return (end.getTime() - start.getTime()) / durationWeek;\n    }\n    return new CountableTimeInterval(floor, offset, count);\n}\nvar utcSunday = weekday$1(0);\nvar utcMonday = weekday$1(1);\nvar utcTuesday = weekday$1(2);\nvar utcWednesday = weekday$1(3);\nvar utcThursday = weekday$1(4);\nvar utcFriday = weekday$1(5);\nvar utcSaturday = weekday$1(6);\n\nfunction localDate(d) {\n    // For JS Dates the [0, 100) interval is a time warp, a fast forward to the 20th century.\n    // For example, -1 is -0001 BC, 0 is already 1900 AD.\n    if (d.y >= 0 && d.y < 100) {\n        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n        date.setFullYear(d.y);\n        return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\nfunction utcDate(d) {\n    if (d.y >= 0 && d.y < 100) {\n        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n        date.setUTCFullYear(d.y);\n        return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n/**\n * Creates a lookup map for array of names to go from a name to index.\n * @param names\n */\nfunction formatLookup(names) {\n    var map = {};\n    for (var i = 0, n = names.length; i < n; i++) {\n        map[names[i].toLowerCase()] = i;\n    }\n    return map;\n}\nfunction newYear(y) {\n    return {\n        y: y,\n        m: 0,\n        d: 1,\n        H: 0,\n        M: 0,\n        S: 0,\n        L: 0\n    };\n}\nvar percentCharCode = 37;\nvar numberRe = /^\\s*\\d+/; // ignores next directive\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\n/**\n * Prepends any character in the `requoteRe` set with a backslash.\n * @param s\n */\nvar requote = function (s) { return s.replace(requoteRe, '\\\\$&'); }; // $& - matched substring\n/**\n * Returns a RegExp that matches any string that starts with any of the given names (case insensitive).\n * @param names\n */\nvar formatRe = function (names) { return new RegExp('^(?:' + names.map(requote).join('|') + ')', 'i'); };\n// A map of padding modifiers to padding strings. Default is `0`.\nvar pads = {\n    '-': '',\n    '_': ' ',\n    '0': '0'\n};\nfunction pad(value, fill, width) {\n    var sign = value < 0 ? '-' : '';\n    var string = String(sign ? -value : value);\n    var length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n/**\n * Create a new time-locale-based object which exposes time-formatting\n * methods for the specified locale definition.\n *\n * @param timeLocale A time locale definition.\n */\nfunction formatLocale(timeLocale) {\n    var lDateTime = timeLocale.dateTime;\n    var lDate = timeLocale.date;\n    var lTime = timeLocale.time;\n    var lPeriods = timeLocale.periods;\n    var lWeekdays = timeLocale.days;\n    var lShortWeekdays = timeLocale.shortDays;\n    var lMonths = timeLocale.months;\n    var lShortMonths = timeLocale.shortMonths;\n    var periodRe = formatRe(lPeriods);\n    var periodLookup = formatLookup(lPeriods);\n    var weekdayRe = formatRe(lWeekdays);\n    var weekdayLookup = formatLookup(lWeekdays);\n    var shortWeekdayRe = formatRe(lShortWeekdays);\n    var shortWeekdayLookup = formatLookup(lShortWeekdays);\n    var monthRe = formatRe(lMonths);\n    var monthLookup = formatLookup(lMonths);\n    var shortMonthRe = formatRe(lShortMonths);\n    var shortMonthLookup = formatLookup(lShortMonths);\n    var formats = {\n        'a': formatShortWeekday,\n        'A': formatWeekday,\n        'b': formatShortMonth,\n        'B': formatMonth,\n        'c': undefined,\n        'd': formatDayOfMonth,\n        'e': formatDayOfMonth,\n        'f': formatMicroseconds,\n        'H': formatHour24,\n        'I': formatHour12,\n        'j': formatDayOfYear,\n        'L': formatMilliseconds,\n        'm': formatMonthNumber,\n        'M': formatMinutes,\n        'p': formatPeriod,\n        'Q': formatUnixTimestamp,\n        's': formatUnixTimestampSeconds,\n        'S': formatSeconds,\n        'u': formatWeekdayNumberMonday,\n        'U': formatWeekNumberSunday,\n        'V': formatWeekNumberISO,\n        'w': formatWeekdayNumberSunday,\n        'W': formatWeekNumberMonday,\n        'x': undefined,\n        'X': undefined,\n        'y': formatYear,\n        'Y': formatFullYear,\n        'Z': formatZone,\n        '%': formatLiteralPercent\n    };\n    var utcFormats = {\n        'a': formatUTCShortWeekday,\n        'A': formatUTCWeekday,\n        'b': formatUTCShortMonth,\n        'B': formatUTCMonth,\n        'c': undefined,\n        'd': formatUTCDayOfMonth,\n        'e': formatUTCDayOfMonth,\n        'f': formatUTCMicroseconds,\n        'H': formatUTCHour24,\n        'I': formatUTCHour12,\n        'j': formatUTCDayOfYear,\n        'L': formatUTCMilliseconds,\n        'm': formatUTCMonthNumber,\n        'M': formatUTCMinutes,\n        'p': formatUTCPeriod,\n        'Q': formatUnixTimestamp,\n        's': formatUnixTimestampSeconds,\n        'S': formatUTCSeconds,\n        'u': formatUTCWeekdayNumberMonday,\n        'U': formatUTCWeekNumberSunday,\n        'V': formatUTCWeekNumberISO,\n        'w': formatUTCWeekdayNumberSunday,\n        'W': formatUTCWeekNumberMonday,\n        'x': undefined,\n        'X': undefined,\n        'y': formatUTCYear,\n        'Y': formatUTCFullYear,\n        'Z': formatUTCZone,\n        '%': formatLiteralPercent\n    };\n    var parses = {\n        'a': parseShortWeekday,\n        'A': parseWeekday,\n        'b': parseShortMonth,\n        'B': parseMonth,\n        'c': parseLocaleDateTime,\n        'd': parseDayOfMonth,\n        'e': parseDayOfMonth,\n        'f': parseMicroseconds,\n        'H': parseHour24,\n        'I': parseHour24,\n        'j': parseDayOfYear,\n        'L': parseMilliseconds,\n        'm': parseMonthNumber,\n        'M': parseMinutes,\n        'p': parsePeriod,\n        'Q': parseUnixTimestamp,\n        's': parseUnixTimestampSeconds,\n        'S': parseSeconds,\n        'u': parseWeekdayNumberMonday,\n        'U': parseWeekNumberSunday,\n        'V': parseWeekNumberISO,\n        'w': parseWeekdayNumberSunday,\n        'W': parseWeekNumberMonday,\n        'x': parseLocaleDate,\n        'X': parseLocaleTime,\n        'y': parseYear,\n        'Y': parseFullYear,\n        'Z': parseZone,\n        '%': parseLiteralPercent\n    };\n    // Recursive definitions.\n    formats.x = newFormat(lDate, formats);\n    formats.X = newFormat(lTime, formats);\n    formats.c = newFormat(lDateTime, formats);\n    utcFormats.x = newFormat(lDate, utcFormats);\n    utcFormats.X = newFormat(lTime, utcFormats);\n    utcFormats.c = newFormat(lDateTime, utcFormats);\n    function newParse(specifier, newDate) {\n        return function (str) {\n            var d = newYear(1900);\n            var i = parseSpecifier(d, specifier, str += '', 0);\n            if (i != str.length) {\n                return undefined;\n            }\n            // If a UNIX timestamp is specified, return it.\n            if ('Q' in d) {\n                return new Date(d.Q);\n            }\n            // The am-pm flag is 0 for AM, and 1 for PM.\n            if ('p' in d) {\n                d.H = d.H % 12 + d.p * 12;\n            }\n            // Convert day-of-week and week-of-year to day-of-year.\n            if ('V' in d) {\n                if (d.V < 1 || d.V > 53) {\n                    return undefined;\n                }\n                if (!('w' in d)) {\n                    d.w = 1;\n                }\n                if ('Z' in d) {\n                    var week = utcDate(newYear(d.y));\n                    var day$1 = week.getUTCDay();\n                    week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday.floor(week);\n                    week = utcDay.offset(week, (d.V - 1) * 7);\n                    d.y = week.getUTCFullYear();\n                    d.m = week.getUTCMonth();\n                    d.d = week.getUTCDate() + (d.w + 6) % 7;\n                }\n                else {\n                    var week = newDate(newYear(d.y));\n                    var day$1 = week.getDay();\n                    week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday.floor(week);\n                    week = day.offset(week, (d.V - 1) * 7);\n                    d.y = week.getFullYear();\n                    d.m = week.getMonth();\n                    d.d = week.getDate() + (d.w + 6) % 7;\n                }\n            }\n            else if ('W' in d || 'U' in d) {\n                if (!('w' in d)) {\n                    d.w = 'u' in d\n                        ? d.u % 7\n                        : 'W' in d ? 1 : 0;\n                }\n                var day$1 = 'Z' in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n                d.m = 0;\n                d.d = 'W' in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;\n            }\n            // If a time zone is specified, all fields are interpreted as UTC and then\n            // offset according to the specified time zone.\n            if ('Z' in d) {\n                d.H += d.Z / 100 | 0;\n                d.M += d.Z % 100;\n                return utcDate(d);\n            }\n            // Otherwise, all fields are in local time.\n            return newDate(d);\n        };\n    }\n    /**\n     * Creates a new function that formats the given Date or timestamp according to specifier.\n     * @param specifier\n     * @param formats\n     */\n    function newFormat(specifier, formats) {\n        return function (date) {\n            var string = [];\n            var n = specifier.length;\n            var i = -1;\n            var j = 0;\n            if (!(date instanceof Date)) {\n                date = new Date(+date);\n            }\n            while (++i < n) {\n                if (specifier.charCodeAt(i) === percentCharCode) {\n                    string.push(specifier.slice(j, i)); // copy the chunks of specifier with no directives as is\n                    var c = specifier.charAt(++i);\n                    var pad_1 = pads[c];\n                    if (pad_1 != undefined) { // if format directive has a padding modifier in front of it\n                        c = specifier.charAt(++i); // fetch the directive itself\n                    }\n                    else {\n                        pad_1 = c === 'e' ? ' ' : '0'; // use the default padding modifier\n                    }\n                    var format = formats[c];\n                    if (format) { // if the directive has a corresponding formatting function\n                        c = format(date, pad_1); // replace the directive with the formatted date\n                    }\n                    string.push(c);\n                    j = i + 1;\n                }\n            }\n            string.push(specifier.slice(j, i));\n            return string.join('');\n        };\n    }\n    // Simultaneously walks over the specifier and the parsed string, populating the `d` map with parsed values.\n    // The returned number is expected to equal the length of the parsed `string`, if parsing succeeded.\n    function parseSpecifier(d, specifier, string, j) {\n        // i - `specifier` string index\n        // j - parsed `string` index\n        var i = 0;\n        var n = specifier.length;\n        var m = string.length;\n        while (i < n) {\n            if (j >= m) {\n                return -1;\n            }\n            var code = specifier.charCodeAt(i++);\n            if (code === percentCharCode) {\n                var char = specifier.charAt(i++);\n                var parse = parses[(char in pads ? specifier.charAt(i++) : char)];\n                if (!parse || ((j = parse(d, string, j)) < 0)) {\n                    return -1;\n                }\n            }\n            else if (code != string.charCodeAt(j++)) {\n                return -1;\n            }\n        }\n        return j;\n    }\n    // ----------------------------- formats ----------------------------------\n    function formatMicroseconds(date, fill) {\n        return formatMilliseconds(date, fill) + '000';\n    }\n    function formatMilliseconds(date, fill) {\n        return pad(date.getMilliseconds(), fill, 3);\n    }\n    function formatSeconds(date, fill) {\n        return pad(date.getSeconds(), fill, 2);\n    }\n    function formatMinutes(date, fill) {\n        return pad(date.getMinutes(), fill, 2);\n    }\n    function formatHour12(date, fill) {\n        return pad(date.getHours() % 12 || 12, fill, 2);\n    }\n    function formatHour24(date, fill) {\n        return pad(date.getHours(), fill, 2);\n    }\n    function formatPeriod(date) {\n        return lPeriods[date.getHours() >= 12 ? 1 : 0];\n    }\n    function formatShortWeekday(date) {\n        return lShortWeekdays[date.getDay()];\n    }\n    function formatWeekday(date) {\n        return lWeekdays[date.getDay()];\n    }\n    function formatWeekdayNumberMonday(date) {\n        var dayOfWeek = date.getDay();\n        return dayOfWeek === 0 ? 7 : dayOfWeek;\n    }\n    function formatWeekNumberSunday(date, fill) {\n        return pad(sunday.count(year.floor(date), date), fill, 2);\n    }\n    function formatWeekNumberISO(date, fill) {\n        var day = date.getDay();\n        date = (day >= 4 || day === 0) ? thursday.floor(date) : thursday.ceil(date);\n        var yearStart = year.floor(date);\n        return pad(thursday.count(yearStart, date) + (yearStart.getDay() === 4 ? 1 : 0), fill, 2);\n    }\n    function formatWeekdayNumberSunday(date) {\n        return date.getDay();\n    }\n    function formatWeekNumberMonday(date, fill) {\n        return pad(monday.count(year.floor(date), date), fill, 2);\n    }\n    function formatDayOfMonth(date, fill) {\n        return pad(date.getDate(), fill, 2);\n    }\n    function formatDayOfYear(date, fill) {\n        return pad(1 + day.count(year.floor(date), date), fill, 3);\n    }\n    function formatShortMonth(date) {\n        return lShortMonths[date.getMonth()];\n    }\n    function formatMonth(date) {\n        return lMonths[date.getMonth()];\n    }\n    function formatMonthNumber(date, fill) {\n        return pad(date.getMonth() + 1, fill, 2);\n    }\n    function formatYear(date, fill) {\n        return pad(date.getFullYear() % 100, fill, 2);\n    }\n    function formatFullYear(date, fill) {\n        return pad(date.getFullYear() % 10000, fill, 4);\n    }\n    function formatZone(date) {\n        var z = date.getTimezoneOffset();\n        return (z > 0 ? '-' : (z *= -1, '+')) + pad(Math.floor(z / 60), '0', 2) + pad(z % 60, '0', 2);\n    }\n    // -------------------------- UTC formats -----------------------------------\n    function formatUTCMicroseconds(date, fill) {\n        return formatUTCMilliseconds(date, fill) + '000';\n    }\n    function formatUTCMilliseconds(date, fill) {\n        return pad(date.getUTCMilliseconds(), fill, 3);\n    }\n    function formatUTCSeconds(date, fill) {\n        return pad(date.getUTCSeconds(), fill, 2);\n    }\n    function formatUTCMinutes(date, fill) {\n        return pad(date.getUTCMinutes(), fill, 2);\n    }\n    function formatUTCHour12(date, fill) {\n        return pad(date.getUTCHours() % 12 || 12, fill, 2);\n    }\n    function formatUTCHour24(date, fill) {\n        return pad(date.getUTCHours(), fill, 2);\n    }\n    function formatUTCPeriod(date) {\n        return lPeriods[date.getUTCHours() >= 12 ? 1 : 0];\n    }\n    function formatUTCDayOfMonth(date, fill) {\n        return pad(date.getUTCDate(), fill, 2);\n    }\n    function formatUTCDayOfYear(date, fill) {\n        return pad(1 + utcDay.count(utcYear.floor(date), date), fill, 3);\n    }\n    function formatUTCMonthNumber(date, fill) {\n        return pad(date.getUTCMonth() + 1, fill, 2);\n    }\n    function formatUTCShortMonth(date) {\n        return lShortMonths[date.getUTCMonth()];\n    }\n    function formatUTCMonth(date) {\n        return lMonths[date.getUTCMonth()];\n    }\n    function formatUTCShortWeekday(date) {\n        return lShortWeekdays[date.getUTCDay()];\n    }\n    function formatUTCWeekday(date) {\n        return lWeekdays[date.getUTCDay()];\n    }\n    function formatUTCWeekdayNumberMonday(date) {\n        var dayOfWeek = date.getUTCDay();\n        return dayOfWeek === 0 ? 7 : dayOfWeek;\n    }\n    function formatUTCWeekNumberSunday(date, fill) {\n        return pad(utcSunday.count(utcYear.floor(date), date), fill, 2);\n    }\n    function formatUTCWeekNumberISO(date, fill) {\n        var day = date.getUTCDay();\n        date = (day >= 4 || day === 0) ? utcThursday.floor(date) : utcThursday.ceil(date);\n        var yearStart = utcYear.floor(date);\n        return pad(utcThursday.count(yearStart, date) + (yearStart.getUTCDay() === 4 ? 1 : 0), fill, 4);\n    }\n    function formatUTCWeekdayNumberSunday(date) {\n        return date.getUTCDay();\n    }\n    function formatUTCWeekNumberMonday(date, fill) {\n        return pad(utcMonday.count(utcYear.floor(date), date), fill, 2);\n    }\n    function formatUTCYear(date, fill) {\n        return pad(date.getUTCFullYear() % 100, fill, 2);\n    }\n    function formatUTCFullYear(date, fill) {\n        return pad(date.getUTCFullYear() % 10000, fill, 4);\n    }\n    function formatUTCZone() {\n        return '+0000';\n    }\n    function formatLiteralPercent(date) {\n        return '%';\n    }\n    function formatUnixTimestamp(date) {\n        return date.getTime();\n    }\n    function formatUnixTimestampSeconds(date) {\n        return Math.floor(date.getTime() / 1000);\n    }\n    // ------------------------------- parsers ------------------------------------\n    function parseMicroseconds(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 6));\n        return n ? (d.L = Math.floor(parseFloat(n[0]) / 1000), i + n[0].length) : -1;\n    }\n    function parseMilliseconds(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 3));\n        return n ? (d.L = +n[0], i + n[0].length) : -1;\n    }\n    function parseSeconds(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.S = +n[0], i + n[0].length) : -1;\n    }\n    function parseMinutes(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.M = +n[0], i + n[0].length) : -1;\n    }\n    function parseHour24(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.H = +n[0], i + n[0].length) : -1;\n    }\n    function parsePeriod(d, string, i) {\n        var n = periodRe.exec(string.slice(i));\n        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseDayOfMonth(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.d = +n[0], i + n[0].length) : -1;\n    }\n    function parseDayOfYear(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 3));\n        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n    }\n    function parseShortWeekday(d, string, i) {\n        var n = shortWeekdayRe.exec(string.slice(i));\n        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseWeekday(d, string, i) {\n        var n = weekdayRe.exec(string.slice(i));\n        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseWeekdayNumberMonday(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 1));\n        return n ? (d.u = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberSunday(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.U = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberISO(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.V = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberMonday(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.W = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekdayNumberSunday(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 1));\n        return n ? (d.w = +n[0], i + n[0].length) : -1;\n    }\n    function parseShortMonth(d, string, i) {\n        var n = shortMonthRe.exec(string.slice(i));\n        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseMonth(d, string, i) {\n        var n = monthRe.exec(string.slice(i));\n        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseMonthNumber(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.m = parseFloat(n[0]) - 1, i + n[0].length) : -1;\n    }\n    function parseLocaleDateTime(d, string, i) {\n        return parseSpecifier(d, lDateTime, string, i);\n    }\n    function parseLocaleDate(d, string, i) {\n        return parseSpecifier(d, lDate, string, i);\n    }\n    function parseLocaleTime(d, string, i) {\n        return parseSpecifier(d, lTime, string, i);\n    }\n    function parseUnixTimestamp(d, string, i) {\n        var n = numberRe.exec(string.slice(i));\n        return n ? (d.Q = +n[0], i + n[0].length) : -1;\n    }\n    function parseUnixTimestampSeconds(d, string, i) {\n        var n = numberRe.exec(string.slice(i));\n        return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;\n    }\n    function parseYear(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n    }\n    function parseFullYear(d, string, i) {\n        var n = numberRe.exec(string.slice(i, i + 4));\n        return n ? (d.y = +n[0], i + n[0].length) : -1;\n    }\n    function parseZone(d, string, i) {\n        var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i, i + 6));\n        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || '00')), i + n[0].length) : -1;\n    }\n    function parseLiteralPercent(d, string, i) {\n        var n = percentRe.exec(string.slice(i, i + 1));\n        return n ? i + n[0].length : -1;\n    }\n    return {\n        format: function (specifier) {\n            var f = newFormat(specifier, formats);\n            f.toString = function () { return specifier; };\n            return f;\n        },\n        parse: function (specifier) {\n            var p = newParse(specifier, localDate);\n            p.toString = function () { return specifier; };\n            return p;\n        },\n        utcFormat: function (specifier) {\n            var f = newFormat(specifier, utcFormats);\n            f.toString = function () { return specifier; };\n            return f;\n        },\n        utcParse: function (specifier) {\n            var p = newParse(specifier, utcDate);\n            p.toString = function () { return specifier; };\n            return p;\n        }\n    };\n}\n\nvar locale;\nsetDefaultLocale({\n    dateTime: '%x, %X',\n    date: '%-m/%-d/%Y',\n    time: '%-I:%M:%S %p',\n    periods: ['AM', 'PM'],\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n});\nfunction setDefaultLocale(definition) {\n    return locale = formatLocale(definition);\n}\n\nvar __extends$V = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TimeScale = /** @class */ (function (_super) {\n    __extends$V(TimeScale, _super);\n    function TimeScale() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.year = year;\n        _this.month = month;\n        _this.week = sunday;\n        _this.day = day;\n        _this.hour = hour;\n        _this.minute = minute;\n        _this.second = second;\n        _this.millisecond = millisecond;\n        _this.format = locale.format;\n        /**\n         * Array of default tick intervals in the following format:\n         *\n         *     [\n         *         interval (unit of time),\n         *         number of units (step),\n         *         the length of that number of units in milliseconds\n         *     ]\n         */\n        _this.tickIntervals = [\n            [_this.second, 1, durationSecond],\n            [_this.second, 5, 5 * durationSecond],\n            [_this.second, 15, 15 * durationSecond],\n            [_this.second, 30, 30 * durationSecond],\n            [_this.minute, 1, durationMinute],\n            [_this.minute, 5, 5 * durationMinute],\n            [_this.minute, 15, 15 * durationMinute],\n            [_this.minute, 30, 30 * durationMinute],\n            [_this.hour, 1, durationHour],\n            [_this.hour, 3, 3 * durationHour],\n            [_this.hour, 6, 6 * durationHour],\n            [_this.hour, 12, 12 * durationHour],\n            [_this.day, 1, durationDay],\n            [_this.day, 2, 2 * durationDay],\n            [_this.week, 1, durationWeek],\n            [_this.month, 1, durationMonth],\n            [_this.month, 3, 3 * durationMonth],\n            [_this.year, 1, durationYear]\n        ];\n        _this.formatMillisecond = _this.format('.%L');\n        _this.formatSecond = _this.format(':%S');\n        _this.formatMinute = _this.format('%I:%M');\n        _this.formatHour = _this.format('%I %p');\n        _this.formatDay = _this.format('%a %d');\n        _this.formatWeek = _this.format('%b %d');\n        _this.formatMonth = _this.format('%B');\n        _this.formatYear = _this.format('%Y');\n        _this._domain = [new Date(2000, 0, 1), new Date(2000, 0, 2)];\n        return _this;\n    }\n    TimeScale.prototype.defaultTickFormat = function (date) {\n        return (this.second.floor(date) < date\n            ? this.formatMillisecond\n            : this.minute.floor(date) < date\n                ? this.formatSecond\n                : this.hour.floor(date) < date\n                    ? this.formatMinute\n                    : this.day.floor(date) < date\n                        ? this.formatHour\n                        : this.month.floor(date) < date\n                            ? (this.week.floor(date) < date ? this.formatDay : this.formatWeek)\n                            : this.year.floor(date) < date\n                                ? this.formatMonth\n                                : this.formatYear)(date);\n    };\n    /**\n     *\n     * @param interval If the `interval` is a number, it's interpreted as the desired tick count\n     * and the method tries to pick an appropriate interval automatically, based on the extent of the domain.\n     * If the `interval` is `undefined`, it defaults to `10`.\n     * If the `interval` is a time interval, simply use it.\n     * @param start The start time (timestamp).\n     * @param stop The end time (timestamp).\n     * @param step Number of intervals between ticks.\n     */\n    TimeScale.prototype.tickInterval = function (interval, start, stop, step) {\n        var _a;\n        if (typeof interval === 'number') {\n            var tickCount = interval;\n            var tickIntervals = this.tickIntervals;\n            var target = Math.abs(stop - start) / tickCount;\n            var i = complexBisectRight(tickIntervals, target, function (interval) { return interval[2]; });\n            if (i === tickIntervals.length) {\n                step = tickStep(start / durationYear, stop / durationYear, tickCount);\n                interval = this.year;\n            }\n            else if (i) {\n                _a = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i], interval = _a[0], step = _a[1];\n            }\n            else {\n                step = Math.max(tickStep(start, stop, interval), 1);\n                interval = this.millisecond;\n            }\n        }\n        return step == undefined ? interval : interval.every(step);\n    };\n    Object.defineProperty(TimeScale.prototype, \"domain\", {\n        get: function () {\n            return _super.prototype.getDomain.call(this).map(function (t) { return new Date(t); });\n        },\n        set: function (values) {\n            _super.prototype.setDomain.call(this, Array.prototype.map.call(values, function (t) { return t instanceof Date ? +t : +new Date(+t); }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TimeScale.prototype.invert = function (y) {\n        return new Date(_super.prototype.invert.call(this, y));\n    };\n    /**\n     * Returns uniformly-spaced dates that represent the scale's domain.\n     * @param interval The desired tick count or a time interval object.\n     */\n    TimeScale.prototype.ticks = function (interval) {\n        if (interval === void 0) { interval = 10; }\n        var d = _super.prototype.getDomain.call(this);\n        var t0 = d[0];\n        var t1 = d[d.length - 1];\n        var reverse = t1 < t0;\n        if (reverse) {\n            var _ = t0;\n            t0 = t1;\n            t1 = _;\n        }\n        var t = this.tickInterval(interval, t0, t1);\n        var i = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n        return reverse ? i.reverse() : i;\n    };\n    /**\n     * Returns a time format function suitable for displaying tick values.\n     * @param count Ignored. Used only to satisfy the {@link Scale} interface.\n     * @param specifier If the specifier string is provided, this method is equivalent to\n     * the {@link TimeLocaleObject.format} method.\n     * If no specifier is provided, this method returns the default time format function.\n     */\n    TimeScale.prototype.tickFormat = function (count, specifier) {\n        return specifier == undefined ? this.defaultTickFormat.bind(this) : this.format(specifier);\n    };\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.\n     * @param interval\n     */\n    TimeScale.prototype.nice = function (interval) {\n        if (interval === void 0) { interval = 10; }\n        var d = _super.prototype.getDomain.call(this);\n        var i = this.tickInterval(interval, d[0], d[d.length - 1]);\n        if (i) {\n            this.domain = this._nice(d, i);\n        }\n    };\n    TimeScale.prototype._nice = function (domain, interval) {\n        var _a, _b;\n        domain = domain.slice();\n        var i0 = 0;\n        var i1 = domain.length - 1;\n        var x0 = domain[i0];\n        var x1 = domain[i1];\n        if (x1 < x0) {\n            _a = [i1, i0], i0 = _a[0], i1 = _a[1];\n            _b = [x1, x0], x0 = _b[0], x1 = _b[1];\n        }\n        domain[i0] = interval.floor(x0);\n        domain[i1] = interval.ceil(x1);\n        return domain;\n    };\n    return TimeScale;\n}(ContinuousScale));\n\nvar __extends$W = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TimeAxis = /** @class */ (function (_super) {\n    __extends$W(TimeAxis, _super);\n    function TimeAxis() {\n        var _this = _super.call(this, new TimeScale()) || this;\n        _this._nice = true;\n        _this.scale.clamp = true;\n        return _this;\n    }\n    Object.defineProperty(TimeAxis.prototype, \"nice\", {\n        get: function () {\n            return this._nice;\n        },\n        set: function (value) {\n            if (this._nice !== value) {\n                this._nice = value;\n                if (value && this.scale.nice) {\n                    this.scale.nice(10);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TimeAxis.prototype, \"domain\", {\n        get: function () {\n            return this.scale.domain;\n        },\n        set: function (value) {\n            this.scale.domain = value;\n            if (this.nice && this.scale.nice) {\n                this.scale.nice(10);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TimeAxis.className = 'TimeAxis';\n    TimeAxis.type = 'time';\n    return TimeAxis;\n}(ChartAxis));\n\nvar Scene = /** @class */ (function () {\n    // As a rule of thumb, constructors with no parameters are preferred.\n    // A few exceptions are:\n    // - we absolutely need to know something at construction time (document)\n    // - knowing something at construction time meaningfully improves performance (width, height)\n    function Scene(document, width, height) {\n        var _this = this;\n        if (document === void 0) { document = window.document; }\n        this.id = createId(this);\n        this._dirty = false;\n        this.animationFrameId = 0;\n        this._root = null;\n        this.debug = {\n            renderFrameIndex: false,\n            renderBoundingBoxes: false\n        };\n        this._frameIndex = 0;\n        this.render = function () {\n            var _a;\n            var _b = _this, ctx = _b.ctx, root = _b.root, pendingSize = _b.pendingSize;\n            _this.animationFrameId = 0;\n            if (pendingSize) {\n                (_a = _this.canvas).resize.apply(_a, pendingSize);\n                _this.pendingSize = undefined;\n            }\n            if (root && !root.visible) {\n                _this.dirty = false;\n                return;\n            }\n            // start with a blank canvas, clear previous drawing\n            ctx.clearRect(0, 0, _this.width, _this.height);\n            if (root) {\n                ctx.save();\n                if (root.visible) {\n                    root.render(ctx);\n                }\n                ctx.restore();\n            }\n            _this._frameIndex++;\n            if (_this.debug.renderFrameIndex) {\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, 40, 15);\n                ctx.fillStyle = 'black';\n                ctx.fillText(_this.frameIndex.toString(), 2, 10);\n            }\n            _this.dirty = false;\n        };\n        this.canvas = new HdpiCanvas(document, width, height);\n        this.ctx = this.canvas.context;\n    }\n    Object.defineProperty(Scene.prototype, \"container\", {\n        get: function () {\n            return this.canvas.container;\n        },\n        set: function (value) {\n            this.canvas.container = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Scene.prototype.download = function (fileName) {\n        this.canvas.download(fileName);\n    };\n    Scene.prototype.getDataURL = function (type) {\n        return this.canvas.getDataURL(type);\n    };\n    Object.defineProperty(Scene.prototype, \"width\", {\n        get: function () {\n            return this.pendingSize ? this.pendingSize[0] : this.canvas.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Scene.prototype, \"height\", {\n        get: function () {\n            return this.pendingSize ? this.pendingSize[1] : this.canvas.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Scene.prototype.resize = function (width, height) {\n        width = Math.round(width);\n        height = Math.round(height);\n        if (width === this.width && height === this.height) {\n            return;\n        }\n        this.pendingSize = [width, height];\n        this.dirty = true;\n    };\n    Object.defineProperty(Scene.prototype, \"dirty\", {\n        get: function () {\n            return this._dirty;\n        },\n        set: function (dirty) {\n            if (dirty && !this._dirty) {\n                this.animationFrameId = requestAnimationFrame(this.render);\n            }\n            this._dirty = dirty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Scene.prototype.cancelRender = function () {\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = 0;\n            this._dirty = false;\n        }\n    };\n    Object.defineProperty(Scene.prototype, \"root\", {\n        get: function () {\n            return this._root;\n        },\n        set: function (node) {\n            if (node === this._root) {\n                return;\n            }\n            if (this._root) {\n                this._root._setScene();\n            }\n            this._root = node;\n            if (node) {\n                // If `node` is the root node of another scene ...\n                if (node.parent === null && node.scene && node.scene !== this) {\n                    node.scene.root = null;\n                }\n                node._setScene(this);\n            }\n            this.dirty = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Scene.prototype.appendPath = function (path) {\n        var ctx = this.ctx;\n        var commands = path.commands;\n        var params = path.params;\n        var n = commands.length;\n        var j = 0;\n        ctx.beginPath();\n        for (var i = 0; i < n; i++) {\n            switch (commands[i]) {\n                case 'M':\n                    ctx.moveTo(params[j++], params[j++]);\n                    break;\n                case 'L':\n                    ctx.lineTo(params[j++], params[j++]);\n                    break;\n                case 'C':\n                    ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\n                    break;\n                case 'Z':\n                    ctx.closePath();\n                    break;\n            }\n        }\n    };\n    Object.defineProperty(Scene.prototype, \"frameIndex\", {\n        get: function () {\n            return this._frameIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Scene.className = 'Scene';\n    return Scene;\n}());\n\nvar Gradient = /** @class */ (function () {\n    function Gradient() {\n        this.stops = [];\n    }\n    return Gradient;\n}());\n\nvar __extends$X = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar LinearGradient = /** @class */ (function (_super) {\n    __extends$X(LinearGradient, _super);\n    function LinearGradient() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.angle = 0;\n        return _this;\n    }\n    LinearGradient.prototype.generateGradient = function (ctx, bbox) {\n        var stops = this.stops;\n        var radians = (this.angle % 360) * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var w = bbox.width;\n        var h = bbox.height;\n        var cx = bbox.x + w * 0.5;\n        var cy = bbox.y + h * 0.5;\n        if (w > 0 && h > 0) {\n            var l = (Math.sqrt(h * h + w * w) * Math.abs(Math.cos(radians - Math.atan(h / w)))) / 2;\n            var gradient_1 = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n            stops.forEach(function (stop) {\n                gradient_1.addColorStop(stop.offset, stop.color);\n            });\n            return gradient_1;\n        }\n        return 'black';\n    };\n    return LinearGradient;\n}(Gradient));\n\nvar __extends$Y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RectSizing;\n(function (RectSizing) {\n    RectSizing[RectSizing[\"Content\"] = 0] = \"Content\";\n    RectSizing[RectSizing[\"Border\"] = 1] = \"Border\";\n})(RectSizing || (RectSizing = {}));\nvar Rect = /** @class */ (function (_super) {\n    __extends$Y(Rect, _super);\n    function Rect() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._x = 0;\n        _this._y = 0;\n        _this._width = 10;\n        _this._height = 10;\n        _this._radius = 0;\n        /**\n         * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\n         * Animated rects may not look nice with this option enabled, for example\n         * when a rect is translated by a sub-pixel value on each frame.\n         */\n        _this._crisp = false;\n        _this._gradient = false;\n        _this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n        /**\n         * Similar to https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing\n         */\n        _this._sizing = RectSizing.Content;\n        return _this;\n    }\n    Object.defineProperty(Rect.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            if (this._width !== value) {\n                this._width = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            if (this._height !== value) {\n                this._height = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"radius\", {\n        get: function () {\n            return this._radius;\n        },\n        set: function (value) {\n            if (this._radius !== value) {\n                this._radius = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"crisp\", {\n        get: function () {\n            return this._crisp;\n        },\n        set: function (value) {\n            if (this._crisp !== value) {\n                this._crisp = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"gradient\", {\n        get: function () {\n            return this._gradient;\n        },\n        set: function (value) {\n            if (this._gradient !== value) {\n                this._gradient = value;\n                this.updateGradientInstance();\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Rect.prototype.updateGradientInstance = function () {\n        if (this.gradient) {\n            var fill = this.fill;\n            if (fill) {\n                var gradient = new LinearGradient();\n                gradient.angle = 270;\n                gradient.stops = [{\n                        offset: 0,\n                        color: Color.fromString(fill).brighter().toString()\n                    }, {\n                        offset: 1,\n                        color: Color.fromString(fill).darker().toString()\n                    }];\n                this.gradientInstance = gradient;\n            }\n        }\n        else {\n            this.gradientInstance = undefined;\n        }\n    };\n    Object.defineProperty(Rect.prototype, \"fill\", {\n        get: function () {\n            return this._fill;\n        },\n        set: function (value) {\n            if (this._fill !== value) {\n                this._fill = value;\n                this.updateGradientInstance();\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                // Normally, when the `lineWidth` changes, we only need to repaint the rect\n                // without updating the path. If the `isCrisp` is set to `true` however,\n                // we need to update the path to make sure the new stroke aligns to\n                // the pixel grid. This is the reason we override the `lineWidth` setter\n                // and getter here.\n                if (this.crisp || this.sizing === RectSizing.Border) {\n                    this.dirtyPath = true;\n                }\n                else {\n                    this.effectiveStrokeWidth = value;\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"sizing\", {\n        get: function () {\n            return this._sizing;\n        },\n        set: function (value) {\n            if (this._sizing !== value) {\n                this._sizing = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Rect.prototype.updatePath = function () {\n        var borderSizing = this.sizing === RectSizing.Border;\n        var path = this.path;\n        path.clear();\n        var x = this.x;\n        var y = this.y;\n        var width = this.width;\n        var height = this.height;\n        var strokeWidth;\n        if (borderSizing) {\n            var halfWidth = width / 2;\n            var halfHeight = height / 2;\n            strokeWidth = Math.min(this.strokeWidth, halfWidth, halfHeight);\n            x = Math.min(x + strokeWidth / 2, x + halfWidth);\n            y = Math.min(y + strokeWidth / 2, y + halfHeight);\n            width = Math.max(width - strokeWidth, 0);\n            height = Math.max(height - strokeWidth, 0);\n        }\n        else {\n            strokeWidth = this.strokeWidth;\n        }\n        this.effectiveStrokeWidth = strokeWidth;\n        if (this.crisp && !borderSizing) {\n            var _a = this, a = _a.alignment, al = _a.align;\n            path.rect(al(a, x), al(a, y), al(a, x, width), al(a, y, height));\n        }\n        else {\n            path.rect(x, y, width, height);\n        }\n    };\n    Rect.prototype.computeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        return new BBox(x, y, width, height);\n    };\n    Rect.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return bbox.containsPoint(point.x, point.y);\n    };\n    Rect.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Rect.prototype.fillStroke = function (ctx) {\n        if (!this.scene) {\n            return;\n        }\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        if (this.fill) {\n            if (this.gradientInstance) {\n                ctx.fillStyle = this.gradientInstance.generateGradient(ctx, this.computeBBox());\n            }\n            else {\n                ctx.fillStyle = this.fill;\n            }\n            ctx.globalAlpha = this.opacity * this.fillOpacity;\n            // The canvas context scaling (depends on the device's pixel ratio)\n            // has no effect on shadows, so we have to account for the pixel ratio\n            // manually here.\n            var fillShadow = this.fillShadow;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fill();\n        }\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n        if (this.stroke && this.effectiveStrokeWidth) {\n            ctx.strokeStyle = this.stroke;\n            ctx.globalAlpha = this.opacity * this.strokeOpacity;\n            ctx.lineWidth = this.effectiveStrokeWidth;\n            if (this.lineDash) {\n                ctx.setLineDash(this.lineDash);\n            }\n            if (this.lineDashOffset) {\n                ctx.lineDashOffset = this.lineDashOffset;\n            }\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineJoin) {\n                ctx.lineJoin = this.lineJoin;\n            }\n            var strokeShadow = this.strokeShadow;\n            if (strokeShadow && strokeShadow.enabled) {\n                ctx.shadowColor = strokeShadow.color;\n                ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n            }\n            ctx.stroke();\n        }\n    };\n    Rect.className = 'Rect';\n    return Rect;\n}(Path));\n\nvar __extends$Z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Marker = /** @class */ (function (_super) {\n    __extends$Z(Marker, _super);\n    function Marker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._x = 0;\n        _this._y = 0;\n        _this._size = 12;\n        return _this;\n    }\n    Object.defineProperty(Marker.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Marker.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Marker.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        set: function (value) {\n            if (this._size !== value) {\n                this._size = Math.abs(value);\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Marker.prototype.computeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, size = _a.size;\n        var half = size / 2;\n        return new BBox(x - half, y - half, size, size);\n    };\n    return Marker;\n}(Path));\n\nvar __extends$_ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Square = /** @class */ (function (_super) {\n    __extends$_(Square, _super);\n    function Square() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Square.prototype.updatePath = function () {\n        var _a = this, path = _a.path, x = _a.x, y = _a.y;\n        var hs = this.size / 2;\n        var _b = this, a = _b.alignment, al = _b.align;\n        path.clear();\n        path.moveTo(al(a, x - hs), al(a, y - hs));\n        path.lineTo(al(a, x + hs), al(a, y - hs));\n        path.lineTo(al(a, x + hs), al(a, y + hs));\n        path.lineTo(al(a, x - hs), al(a, y + hs));\n        path.closePath();\n    };\n    Square.className = 'Square';\n    return Square;\n}(Marker));\n\nvar __extends$$ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MarkerLabel = /** @class */ (function (_super) {\n    __extends$$(MarkerLabel, _super);\n    function MarkerLabel() {\n        var _this = _super.call(this) || this;\n        _this.label = new Text();\n        _this._marker = new Square();\n        _this._markerSize = 15;\n        _this._spacing = 8;\n        var label = _this.label;\n        label.textBaseline = 'middle';\n        label.fontSize = 12;\n        label.fontFamily = 'Verdana, sans-serif';\n        label.fill = 'black';\n        // For better looking vertical alignment of labels to markers.\n        label.y = HdpiCanvas.has.textMetrics ? 1 : 0;\n        _this.append([_this.marker, label]);\n        _this.update();\n        return _this;\n    }\n    Object.defineProperty(MarkerLabel.prototype, \"text\", {\n        get: function () {\n            return this.label.text;\n        },\n        set: function (value) {\n            this.label.text = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"fontStyle\", {\n        get: function () {\n            return this.label.fontStyle;\n        },\n        set: function (value) {\n            this.label.fontStyle = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"fontWeight\", {\n        get: function () {\n            return this.label.fontWeight;\n        },\n        set: function (value) {\n            this.label.fontWeight = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"fontSize\", {\n        get: function () {\n            return this.label.fontSize;\n        },\n        set: function (value) {\n            this.label.fontSize = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"fontFamily\", {\n        get: function () {\n            return this.label.fontFamily;\n        },\n        set: function (value) {\n            this.label.fontFamily = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"color\", {\n        get: function () {\n            return this.label.fill;\n        },\n        set: function (value) {\n            this.label.fill = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"marker\", {\n        get: function () {\n            return this._marker;\n        },\n        set: function (value) {\n            if (this._marker !== value) {\n                this.removeChild(this._marker);\n                this._marker = value;\n                this.appendChild(value);\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerSize\", {\n        get: function () {\n            return this._markerSize;\n        },\n        set: function (value) {\n            if (this._markerSize !== value) {\n                this._markerSize = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerFill\", {\n        get: function () {\n            return this.marker.fill;\n        },\n        set: function (value) {\n            this.marker.fill = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerStroke\", {\n        get: function () {\n            return this.marker.stroke;\n        },\n        set: function (value) {\n            this.marker.stroke = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerStrokeWidth\", {\n        get: function () {\n            return this.marker.strokeWidth;\n        },\n        set: function (value) {\n            this.marker.strokeWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerFillOpacity\", {\n        get: function () {\n            return this.marker.fillOpacity;\n        },\n        set: function (value) {\n            this.marker.fillOpacity = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"markerStrokeOpacity\", {\n        get: function () {\n            return this.marker.strokeOpacity;\n        },\n        set: function (value) {\n            this.marker.strokeOpacity = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"opacity\", {\n        get: function () {\n            return this.marker.opacity;\n        },\n        set: function (value) {\n            this.marker.opacity = value;\n            this.label.opacity = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MarkerLabel.prototype, \"spacing\", {\n        get: function () {\n            return this._spacing;\n        },\n        set: function (value) {\n            if (this._spacing !== value) {\n                this._spacing = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MarkerLabel.prototype.update = function () {\n        var marker = this.marker;\n        var markerSize = this.markerSize;\n        marker.size = markerSize;\n        this.label.x = markerSize / 2 + this.spacing;\n    };\n    MarkerLabel.className = 'MarkerLabel';\n    return MarkerLabel;\n}(Group));\n\nvar __extends$10 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Circle = /** @class */ (function (_super) {\n    __extends$10(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.updatePath = function () {\n        var _a = this, x = _a.x, y = _a.y, path = _a.path, size = _a.size;\n        var r = size / 2;\n        path.clear();\n        path.cubicArc(x, y, r, r, 0, 0, Math.PI * 2, 0);\n        path.closePath();\n    };\n    Circle.className = 'Circle';\n    return Circle;\n}(Marker));\n\nvar __extends$11 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Cross = /** @class */ (function (_super) {\n    __extends$11(Cross, _super);\n    function Cross() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Cross.prototype.updatePath = function () {\n        var _a = this, x = _a.x, y = _a.y;\n        var _b = this, path = _b.path, size = _b.size;\n        var s = size / 4.2;\n        path.clear();\n        path.moveTo(x -= s, y);\n        path.lineTo(x -= s, y -= s);\n        path.lineTo(x += s, y -= s);\n        path.lineTo(x += s, y += s);\n        path.lineTo(x += s, y -= s);\n        path.lineTo(x += s, y += s);\n        path.lineTo(x -= s, y += s);\n        path.lineTo(x += s, y += s);\n        path.lineTo(x -= s, y += s);\n        path.lineTo(x -= s, y -= s);\n        path.lineTo(x -= s, y += s);\n        path.lineTo(x -= s, y -= s);\n        path.closePath();\n    };\n    Cross.className = 'Cross';\n    return Cross;\n}(Marker));\n\nvar __extends$12 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Diamond = /** @class */ (function (_super) {\n    __extends$12(Diamond, _super);\n    function Diamond() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Diamond.prototype.updatePath = function () {\n        var _a = this, x = _a.x, y = _a.y;\n        var _b = this, path = _b.path, size = _b.size;\n        var s = size / 2;\n        path.clear();\n        path.moveTo(x, y -= s);\n        path.lineTo(x += s, y += s);\n        path.lineTo(x -= s, y += s);\n        path.lineTo(x -= s, y -= s);\n        path.lineTo(x += s, y -= s);\n        path.closePath();\n    };\n    Diamond.className = 'Diamond';\n    return Diamond;\n}(Marker));\n\nvar __extends$13 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Heart = /** @class */ (function (_super) {\n    __extends$13(Heart, _super);\n    function Heart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Heart.prototype.rad = function (degree) {\n        return degree / 180 * Math.PI;\n    };\n    Heart.prototype.updatePath = function () {\n        var _a = this, x = _a.x, path = _a.path, size = _a.size, rad = _a.rad;\n        var r = size / 4;\n        var y = this.y + r / 2;\n        path.clear();\n        path.cubicArc(x - r, y - r, r, r, 0, rad(130), rad(330), 0);\n        path.cubicArc(x + r, y - r, r, r, 0, rad(220), rad(50), 0);\n        path.lineTo(x, y + r);\n        path.closePath();\n    };\n    Heart.className = 'Heart';\n    return Heart;\n}(Marker));\n\nvar __extends$14 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Plus = /** @class */ (function (_super) {\n    __extends$14(Plus, _super);\n    function Plus() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Plus.prototype.updatePath = function () {\n        var _a = this, x = _a.x, y = _a.y;\n        var _b = this, path = _b.path, size = _b.size;\n        var s = size / 3;\n        var hs = s / 2;\n        path.clear();\n        path.moveTo(x -= hs, y -= hs);\n        path.lineTo(x, y -= s);\n        path.lineTo(x += s, y);\n        path.lineTo(x, y += s);\n        path.lineTo(x += s, y);\n        path.lineTo(x, y += s);\n        path.lineTo(x -= s, y);\n        path.lineTo(x, y += s);\n        path.lineTo(x -= s, y);\n        path.lineTo(x, y -= s);\n        path.lineTo(x -= s, y);\n        path.lineTo(x, y -= s);\n        path.closePath();\n    };\n    Plus.className = 'Plus';\n    return Plus;\n}(Marker));\n\nvar __extends$15 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Triangle = /** @class */ (function (_super) {\n    __extends$15(Triangle, _super);\n    function Triangle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Triangle.prototype.updatePath = function () {\n        var _a = this, x = _a.x, y = _a.y;\n        var _b = this, path = _b.path, size = _b.size;\n        var s = size * 1.1;\n        path.clear();\n        path.moveTo(x, y -= s * 0.48);\n        path.lineTo(x += s * 0.5, y += s * 0.87);\n        path.lineTo(x -= s, y);\n        path.closePath();\n    };\n    Triangle.className = 'Triangle';\n    return Triangle;\n}(Marker));\n\n// This function is in its own file because putting it into SeriesMarker makes the Legend\n// suddenly aware of the series (it's an agnostic component), and putting it into Marker\n// introduces circular dependencies.\nfunction getMarker(shape) {\n    if (shape === void 0) { shape = Square; }\n    if (typeof shape === 'string') {\n        switch (shape) {\n            case 'circle':\n                return Circle;\n            case 'cross':\n                return Cross;\n            case 'diamond':\n                return Diamond;\n            case 'heart':\n                return Heart;\n            case 'plus':\n                return Plus;\n            case 'triangle':\n                return Triangle;\n            default:\n                return Square;\n        }\n    }\n    if (typeof shape === 'function') {\n        return shape;\n    }\n    return Square;\n}\n\nvar __extends$16 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation || (LegendOrientation = {}));\nvar LegendPosition;\n(function (LegendPosition) {\n    LegendPosition[\"Top\"] = \"top\";\n    LegendPosition[\"Right\"] = \"right\";\n    LegendPosition[\"Bottom\"] = \"bottom\";\n    LegendPosition[\"Left\"] = \"left\";\n})(LegendPosition || (LegendPosition = {}));\nvar LegendLabel = /** @class */ (function (_super) {\n    __extends$16(LegendLabel, _super);\n    function LegendLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.color = 'black';\n        _this.fontSize = 12;\n        _this.fontFamily = 'Verdana, sans-serif';\n        return _this;\n    }\n    __decorate$G([\n        reactive('change')\n    ], LegendLabel.prototype, \"color\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendLabel.prototype, \"fontStyle\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendLabel.prototype, \"fontWeight\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendLabel.prototype, \"fontSize\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendLabel.prototype, \"fontFamily\", void 0);\n    return LegendLabel;\n}(Observable));\nvar LegendMarker = /** @class */ (function (_super) {\n    __extends$16(LegendMarker, _super);\n    function LegendMarker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.size = 15;\n        /**\n         * Padding between the marker and the label within each legend item.\n         */\n        _this.padding = 8;\n        _this.strokeWidth = 1;\n        return _this;\n    }\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendMarker.prototype, \"size\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendMarker.prototype, \"shape\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendMarker.prototype, \"padding\", void 0);\n    __decorate$G([\n        reactive('change')\n    ], LegendMarker.prototype, \"strokeWidth\", void 0);\n    return LegendMarker;\n}(Observable));\nvar LegendItem = /** @class */ (function (_super) {\n    __extends$16(LegendItem, _super);\n    function LegendItem() {\n        var _this = _super.call(this) || this;\n        _this.marker = new LegendMarker();\n        _this.label = new LegendLabel();\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\n         * padding between legend items.\n         */\n        _this.paddingX = 16;\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\n         * padding between legend items.\n         */\n        _this.paddingY = 8;\n        var changeListener = function () { return _this.fireEvent({ type: 'change' }); };\n        _this.marker.addEventListener('change', changeListener);\n        _this.label.addEventListener('change', changeListener);\n        var layoutChangeListener = function () { return _this.fireEvent({ type: 'layoutChange' }); };\n        _this.marker.addEventListener('layoutChange', layoutChangeListener);\n        _this.label.addEventListener('layoutChange', layoutChangeListener);\n        return _this;\n    }\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendItem.prototype, \"paddingX\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], LegendItem.prototype, \"paddingY\", void 0);\n    return LegendItem;\n}(Observable));\nvar Legend = /** @class */ (function (_super) {\n    __extends$16(Legend, _super);\n    function Legend() {\n        var _this = _super.call(this) || this;\n        _this.id = createId(_this);\n        _this.group = new Group();\n        _this.itemSelection = Selection.select(_this.group).selectAll();\n        _this.oldSize = [0, 0];\n        _this.item = new LegendItem();\n        _this.data = [];\n        _this.enabled = true;\n        _this.orientation = LegendOrientation.Vertical;\n        _this.position = LegendPosition.Right;\n        /**\n         * Spacing between the legend and the edge of the chart's element.\n         */\n        _this.spacing = 20;\n        _this._size = [0, 0];\n        _this.addPropertyListener('data', _this.onDataChange);\n        _this.addPropertyListener('enabled', _this.onEnabledChange);\n        _this.addPropertyListener('position', _this.onPositionChange);\n        _this.item.marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n        _this.addEventListener('change', _this.update);\n        _this.item.addEventListener('change', function () { return _this.fireEvent({ type: 'change' }); });\n        _this.item.addEventListener('layoutChange', function () { return _this.fireEvent({ type: 'layoutChange' }); });\n        return _this;\n    }\n    Object.defineProperty(Legend.prototype, \"layoutHorizontalSpacing\", {\n        get: function () {\n            return this.item.paddingX;\n        },\n        /**\n         * @deprecated Please use {@link item.paddingX} instead.\n         */\n        set: function (value) {\n            this.item.paddingX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"layoutVerticalSpacing\", {\n        get: function () {\n            return this.item.paddingY;\n        },\n        /**\n         * @deprecated Please use {@link item.paddingY} instead.\n         */\n        set: function (value) {\n            this.item.paddingY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"itemSpacing\", {\n        get: function () {\n            return this.item.marker.padding;\n        },\n        /**\n         * @deprecated Please use {@link item.marker.padding} instead.\n         */\n        set: function (value) {\n            this.item.marker.padding = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"markerShape\", {\n        get: function () {\n            return this.item.marker.shape;\n        },\n        /**\n         * @deprecated Please use {@link item.marker.shape} instead.\n         */\n        set: function (value) {\n            this.item.marker.shape = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"markerSize\", {\n        get: function () {\n            return this.item.marker.size;\n        },\n        /**\n         * @deprecated Please use {@link item.marker.size} instead.\n         */\n        set: function (value) {\n            this.item.marker.size = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"strokeWidth\", {\n        get: function () {\n            return this.item.marker.strokeWidth;\n        },\n        /**\n         * @deprecated Please use {@link item.marker.strokeWidth} instead.\n         */\n        set: function (value) {\n            this.item.marker.strokeWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"color\", {\n        get: function () {\n            return this.item.label.color;\n        },\n        /**\n         * @deprecated Please use {@link item.label.color} instead.\n         */\n        set: function (value) {\n            this.item.label.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"fontStyle\", {\n        get: function () {\n            return this.item.label.fontStyle;\n        },\n        /**\n         * @deprecated Please use {@link item.label.fontStyle} instead.\n         */\n        set: function (value) {\n            this.item.label.fontStyle = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"fontWeight\", {\n        get: function () {\n            return this.item.label.fontWeight;\n        },\n        /**\n         * @deprecated Please use {@link item.label.fontWeight} instead.\n         */\n        set: function (value) {\n            this.item.label.fontWeight = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"fontSize\", {\n        get: function () {\n            return this.item.label.fontSize;\n        },\n        /**\n         * @deprecated Please use {@link item.label.fontSize} instead.\n         */\n        set: function (value) {\n            this.item.label.fontSize = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"fontFamily\", {\n        get: function () {\n            return this.item.label.fontFamily;\n        },\n        /**\n         * @deprecated Please use {@link item.label.fontFamily} instead.\n         */\n        set: function (value) {\n            this.item.label.fontFamily = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Legend.prototype.onDataChange = function (event) {\n        this.group.visible = event.value.length > 0 && this.enabled;\n    };\n    Legend.prototype.onEnabledChange = function (event) {\n        this.group.visible = event.value && this.data.length > 0;\n    };\n    Legend.prototype.onPositionChange = function (event) {\n        switch (event.value) {\n            case 'right':\n            case 'left':\n                this.orientation = LegendOrientation.Vertical;\n                break;\n            case 'bottom':\n            case 'top':\n                this.orientation = LegendOrientation.Horizontal;\n                break;\n        }\n    };\n    Legend.prototype.onMarkerShapeChange = function () {\n        this.itemSelection = this.itemSelection.setData([]);\n        this.itemSelection.exit.remove();\n    };\n    /**\n     * The method is given the desired size of the legend, which only serves as a hint.\n     * The vertically oriented legend will take as much horizontal space as needed, but will\n     * respect the height constraints, and the horizontal legend will take as much vertical\n     * space as needed in an attempt not to exceed the given width.\n     * After the layout is done, the {@link size} will contain the actual size of the legend.\n     * If the actual size is not the same as the previous actual size, the legend will fire\n     * the 'layoutChange' event to communicate that another layout is needed, and the above\n     * process should be repeated.\n     * @param width\n     * @param height\n     */\n    Legend.prototype.performLayout = function (width, height) {\n        var item = this.item;\n        var marker = item.marker, paddingX = item.paddingX, paddingY = item.paddingY;\n        var updateSelection = this.itemSelection.setData(this.data, function (_, datum) {\n            var MarkerShape = getMarker(marker.shape || datum.marker.shape);\n            return datum.id + '-' + datum.itemId + '-' + MarkerShape.name;\n        });\n        updateSelection.exit.remove();\n        var enterSelection = updateSelection.enter.append(MarkerLabel).each(function (node, datum) {\n            var MarkerShape = getMarker(marker.shape || datum.marker.shape);\n            node.marker = new MarkerShape();\n        });\n        var itemSelection = this.itemSelection = updateSelection.merge(enterSelection);\n        var itemCount = itemSelection.size;\n        // Update properties that affect the size of the legend items and measure them.\n        var bboxes = [];\n        var itemMarker = this.item.marker;\n        var itemLabel = this.item.label;\n        itemSelection.each(function (markerLabel, datum) {\n            // TODO: measure only when one of these properties or data change (in a separate routine)\n            markerLabel.markerSize = itemMarker.size;\n            markerLabel.spacing = itemMarker.padding;\n            markerLabel.fontStyle = itemLabel.fontStyle;\n            markerLabel.fontWeight = itemLabel.fontWeight;\n            markerLabel.fontSize = itemLabel.fontSize;\n            markerLabel.fontFamily = itemLabel.fontFamily;\n            markerLabel.text = datum.label.text;\n            bboxes.push(markerLabel.computeBBox());\n        });\n        var itemHeight = bboxes.length && bboxes[0].height;\n        var rowCount = 0;\n        var columnWidth = 0;\n        var paddedItemsWidth = 0;\n        var paddedItemsHeight = 0;\n        switch (this.orientation) {\n            case LegendOrientation.Horizontal:\n                if (!(isFinite(width) && width > 0)) {\n                    return false;\n                }\n                rowCount = 0;\n                var columnCount = 0;\n                // Split legend items into columns until the width is suitable.\n                do {\n                    var itemsWidth = 0;\n                    columnCount = 0;\n                    columnWidth = 0;\n                    rowCount++;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount - 1) * paddingX;\n                } while (paddedItemsWidth > width && columnCount > 1);\n                paddedItemsHeight = itemHeight * rowCount + (rowCount - 1) * paddingY;\n                break;\n            case LegendOrientation.Vertical:\n                if (!(isFinite(height) && height > 0)) {\n                    return false;\n                }\n                rowCount = itemCount * 2;\n                // Split legend items into columns until the height is suitable.\n                do {\n                    rowCount = (rowCount >> 1) + (rowCount % 2);\n                    columnWidth = 0;\n                    var itemsWidth = 0;\n                    var itemsHeight = 0;\n                    var columnCount_1 = 0;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (!columnCount_1) {\n                            itemsHeight += bbox.height;\n                        }\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount_1++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount_1++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount_1 - 1) * paddingX;\n                    paddedItemsHeight = itemsHeight + (rowCount - 1) * paddingY;\n                } while (paddedItemsHeight > height && rowCount > 1);\n                break;\n        }\n        // Top-left corner of the first legend item.\n        var startX = (width - paddedItemsWidth) / 2;\n        var startY = (height - paddedItemsHeight) / 2;\n        var x = 0;\n        var y = 0;\n        columnWidth = 0;\n        // Position legend items using the layout computed above.\n        itemSelection.each(function (markerLabel, datum, i) {\n            // Round off for pixel grid alignment to work properly.\n            markerLabel.translationX = Math.floor(startX + x);\n            markerLabel.translationY = Math.floor(startY + y);\n            var bbox = bboxes[i];\n            if (bbox.width > columnWidth) {\n                columnWidth = bbox.width;\n            }\n            if ((i + 1) % rowCount === 0) {\n                x += columnWidth + paddingX;\n                y = 0;\n                columnWidth = 0;\n            }\n            else {\n                y += bbox.height + paddingY;\n            }\n        });\n        // Update legend item properties that don't affect the layout.\n        this.update();\n        var size = this._size;\n        var oldSize = this.oldSize;\n        size[0] = paddedItemsWidth;\n        size[1] = paddedItemsHeight;\n        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n            oldSize[0] = size[0];\n            oldSize[1] = size[1];\n        }\n    };\n    Legend.prototype.update = function () {\n        var _this = this;\n        this.itemSelection.each(function (markerLabel, datum) {\n            var marker = datum.marker;\n            markerLabel.markerFill = marker.fill;\n            markerLabel.markerStroke = marker.stroke;\n            markerLabel.markerStrokeWidth = _this.item.marker.strokeWidth;\n            markerLabel.markerFillOpacity = marker.fillOpacity;\n            markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n            markerLabel.opacity = datum.enabled ? 1 : 0.5;\n            markerLabel.color = _this.item.label.color;\n        });\n    };\n    Legend.prototype.getDatumForPoint = function (x, y) {\n        var node = this.group.pickNode(x, y);\n        if (node && node.parent) {\n            return node.parent.datum;\n        }\n    };\n    Legend.className = 'Legend';\n    __decorate$G([\n        reactive('layoutChange')\n    ], Legend.prototype, \"data\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], Legend.prototype, \"enabled\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], Legend.prototype, \"orientation\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], Legend.prototype, \"position\", void 0);\n    __decorate$G([\n        reactive('layoutChange')\n    ], Legend.prototype, \"spacing\", void 0);\n    return Legend;\n}(Observable));\n\nvar SizeMonitor = /** @class */ (function () {\n    function SizeMonitor() {\n    }\n    SizeMonitor.init = function () {\n        var _this = this;\n        var NativeResizeObserver = window.ResizeObserver;\n        if (NativeResizeObserver) {\n            this.resizeObserver = new NativeResizeObserver(function (entries) {\n                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                    var entry = entries_1[_i];\n                    var _a = entry.contentRect, width = _a.width, height = _a.height;\n                    _this.checkSize(_this.elements.get(entry.target), entry.target, width, height);\n                }\n            });\n        }\n        else { // polyfill (more reliable even in browsers that support ResizeObserver)\n            var step = function () {\n                _this.elements.forEach(function (entry, element) {\n                    var width = element.clientWidth ? element.clientWidth : 0;\n                    var height = element.clientHeight ? element.clientHeight : 0;\n                    _this.checkSize(entry, element, width, height);\n                });\n            };\n            window.setInterval(step, 100);\n        }\n        this.ready = true;\n    };\n    SizeMonitor.checkSize = function (entry, element, width, height) {\n        if (entry) {\n            if (!entry.size || width !== entry.size.width || height !== entry.size.height) {\n                entry.size = { width: width, height: height };\n                entry.cb(entry.size, element);\n            }\n        }\n    };\n    // Only a single callback is supported.\n    SizeMonitor.observe = function (element, cb) {\n        if (!this.ready) {\n            this.init();\n        }\n        this.unobserve(element);\n        if (this.resizeObserver) {\n            this.resizeObserver.observe(element);\n        }\n        this.elements.set(element, { cb: cb });\n    };\n    SizeMonitor.unobserve = function (element) {\n        if (this.resizeObserver) {\n            this.resizeObserver.unobserve(element);\n        }\n        this.elements.delete(element);\n    };\n    SizeMonitor.elements = new Map();\n    SizeMonitor.requestAnimationFrameId = 0;\n    SizeMonitor.ready = false;\n    return SizeMonitor;\n}());\n\nvar __extends$17 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SeriesTooltip = /** @class */ (function (_super) {\n    __extends$17(SeriesTooltip, _super);\n    function SeriesTooltip() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.enabled = true;\n        return _this;\n    }\n    __decorate$H([\n        reactive('change')\n    ], SeriesTooltip.prototype, \"enabled\", void 0);\n    return SeriesTooltip;\n}(Observable));\nvar Series = /** @class */ (function (_super) {\n    __extends$17(Series, _super);\n    function Series() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.id = createId(_this);\n        /**\n         * The group node that contains all the nodes used to render this series.\n         */\n        _this.group = new Group();\n        _this.directions = [ChartAxisDirection.X, ChartAxisDirection.Y];\n        /**\n         * @deprecated Use {@link tooltip.enabled} instead.\n         */\n        _this.tooltipEnabled = true;\n        _this.data = undefined;\n        _this.visible = true;\n        _this.showInLegend = true;\n        _this.scheduleLayout = function () {\n            _this.fireEvent({ type: 'layoutChange' });\n        };\n        _this.scheduleData = function () {\n            _this.fireEvent({ type: 'dataChange' });\n        };\n        return _this;\n    }\n    Object.defineProperty(Series.prototype, \"type\", {\n        get: function () {\n            return this.constructor.type || '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Series.prototype.setColors = function (fills, strokes) { };\n    /**\n     * Returns the actual keys used (to fetch the values from `data` items) for the given direction.\n     */\n    Series.prototype.getKeys = function (direction) {\n        var _this = this;\n        var directionKeys = this.directionKeys;\n        var keys = directionKeys && directionKeys[direction];\n        var values = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var value = _this[key];\n                if (value) {\n                    if (Array.isArray(value)) {\n                        values.push.apply(values, value);\n                    }\n                    else {\n                        values.push(value);\n                    }\n                }\n            });\n        }\n        return values;\n    };\n    // Returns node data associated with the rendered portion of the series' data.\n    Series.prototype.getNodeData = function () {\n        return [];\n    };\n    Series.prototype.fireNodeClickEvent = function (event, datum) { };\n    Series.prototype.toggleSeriesItem = function (itemId, enabled) {\n        this.visible = enabled;\n    };\n    // Each series is expected to have its own logic to efficiently update its nodes\n    // on hightlight changes.\n    Series.prototype.onHighlightChange = function () { };\n    Series.prototype.fixNumericExtent = function (extent, type) {\n        if (!extent) {\n            // if (type) {\n            //     console.warn(`The ${type}-domain could not be found (no valid values), using the default of [0, 1].`);\n            // }\n            return [0, 1];\n        }\n        var min = extent[0], max = extent[1];\n        if (min instanceof Date) {\n            min = min.getTime();\n        }\n        if (max instanceof Date) {\n            max = max.getTime();\n        }\n        if (min === max) {\n            var padding = Math.abs(min * 0.01);\n            min -= padding;\n            max += padding;\n            // if (type) {\n            //     console.warn(`The ${type}-domain has zero length and has been automatically expanded`\n            //         + ` by 1 in each direction (from the single valid ${type}-value: ${min}).`);\n            // }\n        }\n        if (!isFinite(min) || !isFinite(max)) {\n            min = 0;\n            max = 1;\n            // if (type) {\n            //     console.warn(`The ${type}-domain has infinite length, using the default of [0, 1].`);\n            // }\n        }\n        return [min, max];\n    };\n    __decorate$H([\n        reactive('dataChange')\n    ], Series.prototype, \"data\", void 0);\n    __decorate$H([\n        reactive('dataChange')\n    ], Series.prototype, \"visible\", void 0);\n    __decorate$H([\n        reactive('layoutChange')\n    ], Series.prototype, \"showInLegend\", void 0);\n    return Series;\n}(Observable));\n\nvar __extends$18 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SeriesMarker = /** @class */ (function (_super) {\n    __extends$18(SeriesMarker, _super);\n    function SeriesMarker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.enabled = true;\n        /**\n         * One of the predefined marker names, or a marker constructor function (for user-defined markers).\n         * A series will create one marker instance per data point.\n         */\n        _this.shape = Circle;\n        _this.size = 6;\n        /**\n         * In case a series has the `sizeKey` set, the `sizeKey` values along with the `size` and `maxSize` configs\n         * will be used to determine the size of the marker. All values will be mapped to a marker size\n         * within the `[size, maxSize]` range, where the largest values will correspond to the `maxSize`\n         * and the lowest to the `size`.\n         */\n        _this.maxSize = 30;\n        _this.strokeWidth = 1;\n        return _this;\n    }\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"enabled\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"shape\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"size\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"maxSize\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"domain\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"fill\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"stroke\", void 0);\n    __decorate$I([\n        reactive('change')\n    ], SeriesMarker.prototype, \"strokeWidth\", void 0);\n    return SeriesMarker;\n}(Observable));\n\nvar __extends$19 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar CartesianSeries = /** @class */ (function (_super) {\n    __extends$19(CartesianSeries, _super);\n    function CartesianSeries() {\n        var _a;\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.directionKeys = (_a = {},\n            _a[ChartAxisDirection.X] = ['xKey'],\n            _a[ChartAxisDirection.Y] = ['yKey'],\n            _a);\n        return _this;\n    }\n    return CartesianSeries;\n}(Series));\nvar CartesianSeriesMarker = /** @class */ (function (_super) {\n    __extends$19(CartesianSeriesMarker, _super);\n    function CartesianSeriesMarker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CartesianSeriesMarker;\n}(SeriesMarker));\n\nvar __extends$1a = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$2 = (undefined && undefined.__assign) || function () {\n    __assign$2 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$2.apply(this, arguments);\n};\nvar __decorate$J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar defaultTooltipCss = \"\\n.ag-chart-tooltip {\\n    display: table;\\n    position: absolute;\\n    user-select: none;\\n    pointer-events: none;\\n    white-space: nowrap;\\n    z-index: 99999;\\n    font: 12px Verdana, sans-serif;\\n    color: black;\\n    background: rgb(244, 244, 244);\\n    border-radius: 5px;\\n    box-shadow: 0 0 1px rgba(3, 3, 3, 0.7), 0.5vh 0.5vh 1vh rgba(3, 3, 3, 0.25);\\n}\\n\\n.ag-chart-tooltip-hidden {\\n    top: -10000px !important;\\n}\\n\\n.ag-chart-tooltip-title {\\n    font-weight: bold;\\n    padding: 7px;\\n    border-top-left-radius: 5px;\\n    border-top-right-radius: 5px;\\n    color: white;\\n    background-color: #888888;\\n    border-top-left-radius: 5px;\\n    border-top-right-radius: 5px;\\n}\\n\\n.ag-chart-tooltip-content {\\n    padding: 7px;\\n    line-height: 1.7em;\\n    border-bottom-left-radius: 5px;\\n    border-bottom-right-radius: 5px;\\n    overflow: hidden;\\n}\\n\\n.ag-chart-tooltip-content:empty {\\n    padding: 0;\\n    height: 7px;\\n}\\n\\n.ag-chart-tooltip-arrow::before {\\n    content: \\\"\\\";\\n\\n    position: absolute;\\n    top: 100%;\\n    left: 50%;\\n    transform: translateX(-50%);\\n\\n    border: 6px solid #989898;\\n\\n    border-left-color: transparent;\\n    border-right-color: transparent;\\n    border-top-color: #989898;\\n    border-bottom-color: transparent;\\n\\n    width: 0;\\n    height: 0;\\n\\n    margin: 0 auto;\\n}\\n\\n.ag-chart-tooltip-arrow::after {\\n    content: \\\"\\\";\\n\\n    position: absolute;\\n    top: 100%;\\n    left: 50%;\\n    transform: translateX(-50%);\\n\\n    border: 5px solid black;\\n\\n    border-left-color: transparent;\\n    border-right-color: transparent;\\n    border-top-color: rgb(244, 244, 244);\\n    border-bottom-color: transparent;\\n\\n    width: 0;\\n    height: 0;\\n\\n    margin: 0 auto;\\n}\\n\\n.ag-chart-wrapper {\\n    box-sizing: border-box;\\n    overflow: hidden;\\n}\\n\";\nfunction toTooltipHtml(input, defaults) {\n    if (typeof input === 'string') {\n        return input;\n    }\n    defaults = defaults || {};\n    var _a = input.content, content = _a === void 0 ? defaults.content || '' : _a, _b = input.title, title = _b === void 0 ? defaults.title || undefined : _b, _c = input.color, color = _c === void 0 ? defaults.color || 'white' : _c, _d = input.backgroundColor, backgroundColor = _d === void 0 ? defaults.backgroundColor || '#888' : _d;\n    var titleHtml = title ? \"<div class=\\\"\" + Chart.defaultTooltipClass + \"-title\\\"\\n        style=\\\"color: \" + color + \"; background-color: \" + backgroundColor + \"\\\">\" + title + \"</div>\" : '';\n    return titleHtml + \"<div class=\\\"\" + Chart.defaultTooltipClass + \"-content\\\">\" + content + \"</div>\";\n}\nvar ChartTooltip = /** @class */ (function (_super) {\n    __extends$1a(ChartTooltip, _super);\n    function ChartTooltip(chart) {\n        var _this = _super.call(this) || this;\n        _this.element = document.createElement('div');\n        _this.enabled = true;\n        _this.class = Chart.defaultTooltipClass;\n        _this.delay = 0;\n        /**\n         * If `true`, the tooltip will be shown for the marker closest to the mouse cursor.\n         * Only has effect on series with markers.\n         */\n        _this.tracking = true;\n        _this.showTimeout = 0;\n        _this.constrained = false;\n        _this.chart = chart;\n        _this.class = '';\n        var tooltipRoot = document.body;\n        tooltipRoot.appendChild(_this.element);\n        // Detect when the chart becomes invisible and hide the tooltip as well.\n        if (window.IntersectionObserver) {\n            var target_1 = _this.chart.scene.canvas.element;\n            var observer = new IntersectionObserver(function (entries) {\n                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                    var entry = entries_1[_i];\n                    if (entry.target === target_1 && entry.intersectionRatio === 0) {\n                        _this.toggle(false);\n                    }\n                }\n            }, { root: tooltipRoot });\n            observer.observe(target_1);\n            _this.observer = observer;\n        }\n        return _this;\n    }\n    ChartTooltip.prototype.isVisible = function () {\n        var element = this.element;\n        if (element.classList) { // if not IE11\n            return !element.classList.contains(Chart.defaultTooltipClass + '-hidden');\n        }\n        // IE11 part.\n        var classes = element.getAttribute('class');\n        if (classes) {\n            return classes.split(' ').indexOf(Chart.defaultTooltipClass + '-hidden') < 0;\n        }\n        return false;\n    };\n    ChartTooltip.prototype.updateClass = function (visible, constrained) {\n        var classList = [Chart.defaultTooltipClass, this.class];\n        if (visible !== true) {\n            classList.push(Chart.defaultTooltipClass + \"-hidden\");\n        }\n        if (constrained !== true) {\n            classList.push(Chart.defaultTooltipClass + \"-arrow\");\n        }\n        this.element.setAttribute('class', classList.join(' '));\n    };\n    /**\n     * Shows tooltip at the given event's coordinates.\n     * If the `html` parameter is missing, moves the existing tooltip to the new position.\n     */\n    ChartTooltip.prototype.show = function (meta, html, instantly) {\n        var _this = this;\n        if (instantly === void 0) { instantly = false; }\n        var el = this.element;\n        if (html !== undefined) {\n            el.innerHTML = html;\n        }\n        else if (!el.innerHTML) {\n            return;\n        }\n        var left = meta.pageX - el.clientWidth / 2;\n        var top = meta.pageY - el.clientHeight - 8;\n        this.constrained = false;\n        if (this.chart.container) {\n            var tooltipRect = el.getBoundingClientRect();\n            var minLeft = 0;\n            var maxLeft = window.innerWidth - tooltipRect.width;\n            if (left < minLeft) {\n                left = minLeft;\n                this.updateClass(true, this.constrained = true);\n            }\n            else if (left > maxLeft) {\n                left = maxLeft;\n                this.updateClass(true, this.constrained = true);\n            }\n            if (top < window.pageYOffset) {\n                top = meta.pageY + 20;\n                this.updateClass(true, this.constrained = true);\n            }\n        }\n        el.style.left = left + \"px\";\n        el.style.top = top + \"px\";\n        if (this.delay > 0 && !instantly) {\n            this.toggle(false);\n            this.showTimeout = window.setTimeout(function () {\n                _this.toggle(true);\n            }, this.delay);\n            return;\n        }\n        this.toggle(true);\n    };\n    ChartTooltip.prototype.toggle = function (visible) {\n        if (!visible) {\n            window.clearTimeout(this.showTimeout);\n            if (this.chart.lastPick && !this.delay) {\n                this.chart.dehighlightDatum();\n                this.chart.lastPick = undefined;\n            }\n        }\n        this.updateClass(visible, this.constrained);\n    };\n    ChartTooltip.prototype.destroy = function () {\n        var parentNode = this.element.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(this.element);\n        }\n        if (this.observer) {\n            this.observer.unobserve(this.chart.scene.canvas.element);\n        }\n    };\n    __decorate$J([\n        reactive()\n    ], ChartTooltip.prototype, \"enabled\", void 0);\n    __decorate$J([\n        reactive()\n    ], ChartTooltip.prototype, \"class\", void 0);\n    __decorate$J([\n        reactive()\n    ], ChartTooltip.prototype, \"delay\", void 0);\n    __decorate$J([\n        reactive()\n    ], ChartTooltip.prototype, \"tracking\", void 0);\n    return ChartTooltip;\n}(Observable));\nvar Chart = /** @class */ (function (_super) {\n    __extends$1a(Chart, _super);\n    function Chart(document) {\n        if (document === void 0) { document = window.document; }\n        var _this = _super.call(this) || this;\n        _this.id = createId(_this);\n        _this.background = new Rect();\n        _this.legend = new Legend();\n        _this.legendAutoPadding = new Padding();\n        _this.captionAutoPadding = 0; // top padding only\n        _this._container = undefined;\n        _this._data = [];\n        _this._autoSize = false;\n        _this._tooltipClass = Chart.defaultTooltipClass;\n        /**\n         * @deprecated Please use {@link tooltip.tracking} instead.\n         */\n        _this.tooltipTracking = true;\n        _this.padding = new Padding(20);\n        _this._axes = [];\n        _this._series = [];\n        _this._axesChanged = false;\n        _this._seriesChanged = false;\n        _this.layoutCallbackId = 0;\n        _this._performLayout = function () {\n            _this.layoutCallbackId = 0;\n            _this.background.width = _this.width;\n            _this.background.height = _this.height;\n            _this.performLayout();\n            if (!_this.layoutPending) {\n                _this.fireEvent({ type: 'layoutDone' });\n            }\n        };\n        _this.dataCallbackId = 0;\n        _this._onMouseDown = _this.onMouseDown.bind(_this);\n        _this._onMouseUp = _this.onMouseUp.bind(_this);\n        _this._onMouseMove = _this.onMouseMove.bind(_this);\n        _this._onMouseOut = _this.onMouseOut.bind(_this);\n        _this._onClick = _this.onClick.bind(_this);\n        var root = new Group();\n        var background = _this.background;\n        background.fill = 'white';\n        root.appendChild(background);\n        var element = _this._element = document.createElement('div');\n        element.setAttribute('class', 'ag-chart-wrapper');\n        var scene = new Scene(document);\n        _this.scene = scene;\n        scene.root = root;\n        scene.container = element;\n        _this.autoSize = true;\n        var legend = _this.legend;\n        legend.addEventListener('layoutChange', _this.onLayoutChange, _this);\n        legend.addPropertyListener('position', _this.onLegendPositionChange, _this);\n        _this.tooltip = new ChartTooltip(_this);\n        _this.tooltip.addPropertyListener('class', function () { return _this.tooltip.toggle(); });\n        if (Chart.tooltipDocuments.indexOf(document) < 0) {\n            var styleElement = document.createElement('style');\n            styleElement.innerHTML = defaultTooltipCss;\n            // Make sure the default tooltip style goes before other styles so it can be overridden.\n            document.head.insertBefore(styleElement, document.head.querySelector('style'));\n            Chart.tooltipDocuments.push(document);\n        }\n        _this.setupDomListeners(scene.canvas.element);\n        _this.addPropertyListener('title', _this.onCaptionChange);\n        _this.addPropertyListener('subtitle', _this.onCaptionChange);\n        _this.addEventListener('layoutChange', function () { return _this.layoutPending = true; });\n        return _this;\n    }\n    Object.defineProperty(Chart.prototype, \"container\", {\n        get: function () {\n            return this._container;\n        },\n        set: function (value) {\n            if (this._container !== value) {\n                var parentNode = this.element.parentNode;\n                if (parentNode != null) {\n                    parentNode.removeChild(this.element);\n                }\n                if (value) {\n                    value.appendChild(this.element);\n                }\n                this._container = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"data\", {\n        get: function () {\n            return this._data;\n        },\n        set: function (data) {\n            this._data = data;\n            this.series.forEach(function (series) { return series.data = data; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"width\", {\n        get: function () {\n            return this.scene.width;\n        },\n        set: function (value) {\n            this.autoSize = false;\n            if (this.width !== value) {\n                this.scene.resize(value, this.height);\n                this.fireEvent({ type: 'layoutChange' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"height\", {\n        get: function () {\n            return this.scene.height;\n        },\n        set: function (value) {\n            this.autoSize = false;\n            if (this.height !== value) {\n                this.scene.resize(this.width, value);\n                this.fireEvent({ type: 'layoutChange' });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"autoSize\", {\n        get: function () {\n            return this._autoSize;\n        },\n        set: function (value) {\n            if (this._autoSize !== value) {\n                this._autoSize = value;\n                var style = this.element.style;\n                if (value) {\n                    var chart_1 = this; // capture `this` for IE11\n                    SizeMonitor.observe(this.element, function (size) {\n                        if (size.width !== chart_1.width || size.height !== chart_1.height) {\n                            chart_1.scene.resize(size.width, size.height);\n                            chart_1.fireEvent({ type: 'layoutChange' });\n                        }\n                    });\n                    style.display = 'block';\n                    style.width = '100%';\n                    style.height = '100%';\n                }\n                else {\n                    SizeMonitor.unobserve(this.element);\n                    style.display = 'inline-block';\n                    style.width = 'auto';\n                    style.height = 'auto';\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"tooltipClass\", {\n        get: function () {\n            return this.tooltip.class;\n        },\n        /**\n         * @deprecated Please use {@link tooltip.class} instead.\n         */\n        set: function (value) {\n            this.tooltip.class = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Chart.prototype.download = function (fileName) {\n        this.scene.download(fileName);\n    };\n    Chart.prototype.destroy = function () {\n        this.tooltip.destroy();\n        SizeMonitor.unobserve(this.element);\n        this.container = undefined;\n        this.cleanupDomListeners(this.scene.canvas.element);\n        this.scene.container = undefined;\n    };\n    Chart.prototype.onLayoutChange = function () {\n        this.layoutPending = true;\n    };\n    Chart.prototype.onLegendPositionChange = function () {\n        this.legendAutoPadding.clear();\n        this.layoutPending = true;\n    };\n    Chart.prototype.onCaptionChange = function (event) {\n        var value = event.value, oldValue = event.oldValue;\n        if (oldValue) {\n            oldValue.removeEventListener('change', this.onLayoutChange, this);\n            this.scene.root.removeChild(oldValue.node);\n        }\n        if (value) {\n            value.addEventListener('change', this.onLayoutChange, this);\n            this.scene.root.appendChild(value.node);\n        }\n    };\n    Object.defineProperty(Chart.prototype, \"element\", {\n        get: function () {\n            return this._element;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"axes\", {\n        get: function () {\n            return this._axes;\n        },\n        set: function (values) {\n            var _this = this;\n            this._axes.forEach(function (axis) { return _this.detachAxis(axis); });\n            // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)\n            this._axes = values.filter(function (a) { return !a.linkedTo; }).concat(values.filter(function (a) { return a.linkedTo; }));\n            this._axes.forEach(function (axis) { return _this.attachAxis(axis); });\n            this.axesChanged = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Chart.prototype.attachAxis = function (axis) {\n        this.scene.root.insertBefore(axis.group, this.seriesRoot);\n    };\n    Chart.prototype.detachAxis = function (axis) {\n        this.scene.root.removeChild(axis.group);\n    };\n    Object.defineProperty(Chart.prototype, \"series\", {\n        get: function () {\n            return this._series;\n        },\n        set: function (values) {\n            var _this = this;\n            this.removeAllSeries();\n            values.forEach(function (series) { return _this.addSeries(series); });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Chart.prototype.scheduleLayout = function () {\n        this.layoutPending = true;\n    };\n    Chart.prototype.scheduleData = function () {\n        // To prevent the chart from thinking the cursor is over the same node\n        // after a change to data (the nodes are reused on data changes).\n        this.dehighlightDatum();\n        this.dataPending = true;\n    };\n    Chart.prototype.addSeries = function (series, before) {\n        var _a = this, allSeries = _a.series, seriesRoot = _a.seriesRoot;\n        var canAdd = allSeries.indexOf(series) < 0;\n        if (canAdd) {\n            var beforeIndex = before ? allSeries.indexOf(before) : -1;\n            if (beforeIndex >= 0) {\n                allSeries.splice(beforeIndex, 0, series);\n                seriesRoot.insertBefore(series.group, before.group);\n            }\n            else {\n                allSeries.push(series);\n                seriesRoot.append(series.group);\n            }\n            this.initSeries(series);\n            this.seriesChanged = true;\n            this.axesChanged = true;\n            return true;\n        }\n        return false;\n    };\n    Chart.prototype.initSeries = function (series) {\n        series.chart = this;\n        if (!series.data) {\n            series.data = this.data;\n        }\n        series.addEventListener('layoutChange', this.scheduleLayout, this);\n        series.addEventListener('dataChange', this.scheduleData, this);\n        series.addEventListener('legendChange', this.updateLegend, this);\n        series.addEventListener('nodeClick', this.onSeriesNodeClick, this);\n    };\n    Chart.prototype.freeSeries = function (series) {\n        series.chart = undefined;\n        series.removeEventListener('layoutChange', this.scheduleLayout, this);\n        series.removeEventListener('dataChange', this.scheduleData, this);\n        series.removeEventListener('legendChange', this.updateLegend, this);\n        series.removeEventListener('nodeClick', this.onSeriesNodeClick, this);\n    };\n    Chart.prototype.addSeriesAfter = function (series, after) {\n        var _a = this, allSeries = _a.series, seriesRoot = _a.seriesRoot;\n        var canAdd = allSeries.indexOf(series) < 0;\n        if (canAdd) {\n            var afterIndex = after ? this.series.indexOf(after) : -1;\n            if (afterIndex >= 0) {\n                if (afterIndex + 1 < allSeries.length) {\n                    seriesRoot.insertBefore(series.group, allSeries[afterIndex + 1].group);\n                }\n                else {\n                    seriesRoot.append(series.group);\n                }\n                this.initSeries(series);\n                allSeries.splice(afterIndex + 1, 0, series);\n            }\n            else {\n                if (allSeries.length > 0) {\n                    seriesRoot.insertBefore(series.group, allSeries[0].group);\n                }\n                else {\n                    seriesRoot.append(series.group);\n                }\n                this.initSeries(series);\n                allSeries.unshift(series);\n            }\n            this.seriesChanged = true;\n            this.axesChanged = true;\n        }\n        return false;\n    };\n    Chart.prototype.removeSeries = function (series) {\n        var index = this.series.indexOf(series);\n        if (index >= 0) {\n            this.series.splice(index, 1);\n            this.freeSeries(series);\n            this.seriesRoot.removeChild(series.group);\n            this.seriesChanged = true;\n            return true;\n        }\n        return false;\n    };\n    Chart.prototype.removeAllSeries = function () {\n        var _this = this;\n        this.series.forEach(function (series) {\n            _this.freeSeries(series);\n            _this.seriesRoot.removeChild(series.group);\n        });\n        this._series = []; // using `_series` instead of `series` to prevent infinite recursion\n        this.seriesChanged = true;\n    };\n    Chart.prototype.assignSeriesToAxes = function () {\n        var _this = this;\n        this.axes.forEach(function (axis) {\n            var axisName = axis.direction + 'Axis';\n            var boundSeries = [];\n            _this.series.forEach(function (series) {\n                if (series[axisName] === axis) {\n                    boundSeries.push(series);\n                }\n            });\n            axis.boundSeries = boundSeries;\n        });\n        this.seriesChanged = false;\n    };\n    Chart.prototype.assignAxesToSeries = function (force) {\n        var _this = this;\n        if (force === void 0) { force = false; }\n        // This method has to run before `assignSeriesToAxes`.\n        var directionToAxesMap = {};\n        this.axes.forEach(function (axis) {\n            var direction = axis.direction;\n            var directionAxes = directionToAxesMap[direction] || (directionToAxesMap[direction] = []);\n            directionAxes.push(axis);\n        });\n        this.series.forEach(function (series) {\n            series.directions.forEach(function (direction) {\n                var axisName = direction + 'Axis';\n                if (!series[axisName] || force) {\n                    var directionAxes = directionToAxesMap[direction];\n                    if (directionAxes) {\n                        var axis = _this.findMatchingAxis(directionAxes, series.getKeys(direction));\n                        if (axis) {\n                            series[axisName] = axis;\n                        }\n                    }\n                }\n            });\n            if (series instanceof CartesianSeries) {\n                if (!series.xAxis) {\n                    console.warn(\"Could not find a matching xAxis for the \" + series.id + \" series.\");\n                    return;\n                }\n                if (!series.yAxis) {\n                    console.warn(\"Could not find a matching yAxis for the \" + series.id + \" series.\");\n                    return;\n                }\n            }\n        });\n        this.axesChanged = false;\n    };\n    Chart.prototype.findMatchingAxis = function (directionAxes, directionKeys) {\n        for (var i = 0; i < directionAxes.length; i++) {\n            var axis = directionAxes[i];\n            var axisKeys = axis.keys;\n            if (!axisKeys.length) {\n                return axis;\n            }\n            else if (directionKeys) {\n                for (var j = 0; j < directionKeys.length; j++) {\n                    if (axisKeys.indexOf(directionKeys[j]) >= 0) {\n                        return axis;\n                    }\n                }\n            }\n        }\n    };\n    Object.defineProperty(Chart.prototype, \"axesChanged\", {\n        get: function () {\n            return this._axesChanged;\n        },\n        set: function (value) {\n            this._axesChanged = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"seriesChanged\", {\n        get: function () {\n            return this._seriesChanged;\n        },\n        set: function (value) {\n            this._seriesChanged = value;\n            if (value) {\n                this.dataPending = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"layoutPending\", {\n        /**\n         * Only `true` while we are waiting for the layout to start.\n         * This will be `false` if the layout has already started and is ongoing.\n         */\n        get: function () {\n            return !!this.layoutCallbackId;\n        },\n        set: function (value) {\n            if (value) {\n                if (!(this.layoutCallbackId || this.dataPending)) {\n                    this.layoutCallbackId = requestAnimationFrame(this._performLayout);\n                }\n            }\n            else if (this.layoutCallbackId) {\n                cancelAnimationFrame(this.layoutCallbackId);\n                this.layoutCallbackId = 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Chart.prototype, \"dataPending\", {\n        get: function () {\n            return !!this.dataCallbackId;\n        },\n        set: function (value) {\n            var _this = this;\n            if (this.dataCallbackId) {\n                clearTimeout(this.dataCallbackId);\n                this.dataCallbackId = 0;\n            }\n            if (value) {\n                this.dataCallbackId = window.setTimeout(function () {\n                    _this.dataPending = false;\n                    _this.processData();\n                }, 0);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Chart.prototype.processData = function () {\n        this.layoutPending = false;\n        if (this.axesChanged) {\n            this.assignAxesToSeries(true);\n            this.assignSeriesToAxes();\n        }\n        if (this.seriesChanged) {\n            this.assignSeriesToAxes();\n        }\n        this.series.filter(function (s) { return s.visible; }).forEach(function (series) { return series.processData(); });\n        this.updateLegend();\n        this.layoutPending = true;\n    };\n    Chart.prototype.updateLegend = function () {\n        var legendData = [];\n        this.series.filter(function (s) { return s.showInLegend; }).forEach(function (series) { return series.listSeriesItems(legendData); });\n        this.legend.data = legendData;\n    };\n    Chart.prototype.positionCaptions = function () {\n        var _a = this, title = _a.title, subtitle = _a.subtitle;\n        var titleVisible = false;\n        var subtitleVisible = false;\n        var spacing = 10;\n        var paddingTop = spacing;\n        if (title && title.enabled) {\n            title.node.x = this.width / 2;\n            title.node.y = paddingTop;\n            titleVisible = true;\n            var titleBBox = title.node.computeBBox(); // make sure to set node's x/y, then computeBBox\n            if (titleBBox) {\n                paddingTop = titleBBox.y + titleBBox.height;\n            }\n            if (subtitle && subtitle.enabled) {\n                subtitle.node.x = this.width / 2;\n                subtitle.node.y = paddingTop + spacing;\n                subtitleVisible = true;\n                var subtitleBBox = subtitle.node.computeBBox();\n                if (subtitleBBox) {\n                    paddingTop = subtitleBBox.y + subtitleBBox.height;\n                }\n            }\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        if (subtitle) {\n            subtitle.node.visible = subtitleVisible;\n        }\n        this.captionAutoPadding = Math.floor(paddingTop);\n    };\n    Chart.prototype.positionLegend = function () {\n        if (!this.legend.enabled || !this.legend.data.length) {\n            return;\n        }\n        var _a = this, legend = _a.legend, captionAutoPadding = _a.captionAutoPadding, legendAutoPadding = _a.legendAutoPadding;\n        var width = this.width;\n        var height = this.height - captionAutoPadding;\n        var legendGroup = legend.group;\n        var legendSpacing = legend.spacing;\n        var translationX = 0;\n        var translationY = 0;\n        var legendBBox;\n        switch (legend.position) {\n            case 'bottom':\n                legend.performLayout(width - legendSpacing * 2, 0);\n                legendBBox = legendGroup.computeBBox();\n                translationX = (width - legendBBox.width) / 2 - legendBBox.x;\n                translationY = captionAutoPadding + height - legendBBox.height - legendBBox.y - legendSpacing;\n                legendAutoPadding.bottom = legendBBox.height;\n                break;\n            case 'top':\n                legend.performLayout(width - legendSpacing * 2, 0);\n                legendBBox = legendGroup.computeBBox();\n                translationX = (width - legendBBox.width) / 2 - legendBBox.x;\n                translationY = captionAutoPadding + legendSpacing - legendBBox.y;\n                legendAutoPadding.top = legendBBox.height;\n                break;\n            case 'left':\n                legend.performLayout(0, height - legendSpacing * 2);\n                legendBBox = legendGroup.computeBBox();\n                translationX = legendSpacing - legendBBox.x;\n                translationY = captionAutoPadding + (height - legendBBox.height) / 2 - legendBBox.y;\n                legendAutoPadding.left = legendBBox.width;\n                break;\n            default: // case 'right':\n                legend.performLayout(0, height - legendSpacing * 2);\n                legendBBox = legendGroup.computeBBox();\n                translationX = width - legendBBox.width - legendBBox.x - legendSpacing;\n                translationY = captionAutoPadding + (height - legendBBox.height) / 2 - legendBBox.y;\n                legendAutoPadding.right = legendBBox.width;\n                break;\n        }\n        // Round off for pixel grid alignment to work properly.\n        legendGroup.translationX = Math.floor(translationX + legendGroup.translationX);\n        legendGroup.translationY = Math.floor(translationY + legendGroup.translationY);\n    };\n    Chart.prototype.setupDomListeners = function (chartElement) {\n        chartElement.addEventListener('mousedown', this._onMouseDown);\n        chartElement.addEventListener('mousemove', this._onMouseMove);\n        chartElement.addEventListener('mouseup', this._onMouseUp);\n        chartElement.addEventListener('mouseout', this._onMouseOut);\n        chartElement.addEventListener('click', this._onClick);\n    };\n    Chart.prototype.cleanupDomListeners = function (chartElement) {\n        chartElement.removeEventListener('mousedown', this._onMouseDown);\n        chartElement.removeEventListener('mousemove', this._onMouseMove);\n        chartElement.removeEventListener('mouseup', this._onMouseUp);\n        chartElement.removeEventListener('mouseout', this._onMouseOut);\n        chartElement.removeEventListener('click', this._onClick);\n    };\n    Chart.prototype.getSeriesRect = function () {\n        return this.seriesRect;\n    };\n    // x/y are local canvas coordinates in CSS pixels, not actual pixels\n    Chart.prototype.pickSeriesNode = function (x, y) {\n        if (!this.seriesRect || !this.seriesRect.containsPoint(x, y)) {\n            return undefined;\n        }\n        var allSeries = this.series;\n        var node = undefined;\n        for (var i = allSeries.length - 1; i >= 0; i--) {\n            var series = allSeries[i];\n            node = series.group.pickNode(x, y);\n            if (node) {\n                return {\n                    series: series,\n                    node: node\n                };\n            }\n        }\n    };\n    // Provided x/y are in canvas coordinates.\n    Chart.prototype.pickClosestSeriesNodeDatum = function (x, y) {\n        if (!this.seriesRect || !this.seriesRect.containsPoint(x, y)) {\n            return undefined;\n        }\n        var allSeries = this.series;\n        function getDistance(p1, p2) {\n            return Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2));\n        }\n        var minDistance = Infinity;\n        var closestDatum;\n        var _loop_1 = function (i) {\n            var series = allSeries[i];\n            if (!series.visible) {\n                return \"continue\";\n            }\n            var hitPoint = series.group.transformPoint(x, y);\n            series.getNodeData().forEach(function (datum) {\n                if (!datum.point) {\n                    return;\n                }\n                var distance = getDistance(hitPoint, datum.point);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestDatum = datum;\n                }\n            });\n        };\n        for (var i = allSeries.length - 1; i >= 0; i--) {\n            _loop_1(i);\n        }\n        if (closestDatum) {\n            return closestDatum;\n        }\n    };\n    Chart.prototype.onMouseMove = function (event) {\n        if (this.tooltip.enabled) {\n            if (this.tooltip.delay > 0) {\n                this.tooltip.toggle(false);\n            }\n            this.handleTooltip(event);\n        }\n    };\n    Chart.prototype.handleTooltip = function (event) {\n        var _a = this, lastPick = _a.lastPick, tooltipTracking = _a.tooltip.tracking;\n        var offsetX = event.offsetX, offsetY = event.offsetY;\n        var pick = this.pickSeriesNode(offsetX, offsetY);\n        var nodeDatum;\n        if (pick && pick.node instanceof Shape) {\n            var node = pick.node;\n            nodeDatum = node.datum;\n            if (lastPick && lastPick.datum === nodeDatum) {\n                lastPick.node = node;\n                lastPick.event = event;\n            }\n            // Marker nodes will have the `point` info in their datums.\n            // Highlight if not a marker node or, if not in the tracking mode, highlight markers too.\n            if ((!node.datum.point || !tooltipTracking)) {\n                if (!lastPick // cursor moved from empty space to a node\n                    || lastPick.node !== node) { // cursor moved from one node to another\n                    this.onSeriesDatumPick(event, node.datum, node, event);\n                }\n                else if (pick.series.tooltip.enabled) { // cursor moved within the same node\n                    this.tooltip.show(event);\n                }\n                // A non-marker node (takes precedence over marker nodes) was highlighted.\n                // Or we are not in the tracking mode.\n                // Either way, we are done at this point.\n                return;\n            }\n        }\n        var hideTooltip = false;\n        // In tracking mode a tooltip is shown for the closest rendered datum.\n        // This makes it easier to show tooltips when markers are small and/or plentiful\n        // and also gives the ability to show tooltips even when the series were configured\n        // to not render markers.\n        if (tooltipTracking) {\n            var closestDatum = this.pickClosestSeriesNodeDatum(offsetX, offsetY);\n            if (closestDatum && closestDatum.point) {\n                var _b = closestDatum.point, x = _b.x, y = _b.y;\n                var canvas = this.scene.canvas;\n                var point = closestDatum.series.group.inverseTransformPoint(x, y);\n                var canvasRect = canvas.element.getBoundingClientRect();\n                this.onSeriesDatumPick({\n                    pageX: Math.round(canvasRect.left + window.pageXOffset + point.x),\n                    pageY: Math.round(canvasRect.top + window.pageYOffset + point.y)\n                }, closestDatum, nodeDatum === closestDatum && pick ? pick.node : undefined, event);\n            }\n            else {\n                hideTooltip = true;\n            }\n        }\n        if (lastPick && (hideTooltip || !tooltipTracking)) {\n            // Cursor moved from a non-marker node to empty space.\n            this.dehighlightDatum();\n            this.tooltip.toggle(false);\n            this.lastPick = undefined;\n        }\n    };\n    Chart.prototype.onMouseDown = function (event) { };\n    Chart.prototype.onMouseUp = function (event) { };\n    Chart.prototype.onMouseOut = function (event) {\n        this.tooltip.toggle(false);\n    };\n    Chart.prototype.onClick = function (event) {\n        if (this.checkSeriesNodeClick()) {\n            return;\n        }\n        if (this.checkLegendClick(event)) {\n            return;\n        }\n        this.fireEvent({\n            type: 'click',\n            event: event\n        });\n    };\n    Chart.prototype.checkSeriesNodeClick = function () {\n        var lastPick = this.lastPick;\n        if (lastPick && lastPick.event && lastPick.node) {\n            var event_1 = lastPick.event, datum = lastPick.datum;\n            datum.series.fireNodeClickEvent(event_1, datum);\n            return true;\n        }\n        return false;\n    };\n    Chart.prototype.onSeriesNodeClick = function (event) {\n        this.fireEvent(__assign$2(__assign$2({}, event), { type: 'seriesNodeClick' }));\n    };\n    Chart.prototype.checkLegendClick = function (event) {\n        var datum = this.legend.getDatumForPoint(event.offsetX, event.offsetY);\n        if (datum) {\n            var id_1 = datum.id, itemId = datum.itemId, enabled = datum.enabled;\n            var series = find(this.series, function (series) { return series.id === id_1; });\n            if (series) {\n                series.toggleSeriesItem(itemId, !enabled);\n                if (enabled) {\n                    this.tooltip.toggle(false);\n                }\n                this.legend.fireEvent({\n                    type: 'click',\n                    event: event,\n                    itemId: itemId,\n                    enabled: !enabled\n                });\n                return true;\n            }\n        }\n        return false;\n    };\n    Chart.prototype.onSeriesDatumPick = function (meta, datum, node, event) {\n        if (this.lastPick) {\n            this.dehighlightDatum();\n        }\n        this.lastPick = {\n            datum: datum,\n            node: node,\n            event: event\n        };\n        this.highlightDatum(datum);\n        var html = datum.series.tooltip.enabled && datum.series.getTooltipHtml(datum);\n        if (html) {\n            this.tooltip.show(meta, html);\n        }\n    };\n    Chart.prototype.highlightDatum = function (datum) {\n        this.highlightedDatum = datum;\n        this.series.forEach(function (s) { return s.onHighlightChange(); });\n    };\n    Chart.prototype.dehighlightDatum = function () {\n        if (this.highlightedDatum) {\n            this.highlightedDatum = undefined;\n            this.series.forEach(function (s) { return s.onHighlightChange(); });\n        }\n    };\n    Chart.defaultTooltipClass = 'ag-chart-tooltip';\n    Chart.tooltipDocuments = [];\n    __decorate$J([\n        reactive('layoutChange')\n    ], Chart.prototype, \"padding\", void 0);\n    __decorate$J([\n        reactive('layoutChange')\n    ], Chart.prototype, \"title\", void 0);\n    __decorate$J([\n        reactive('layoutChange')\n    ], Chart.prototype, \"subtitle\", void 0);\n    return Chart;\n}(Observable));\n\nvar __extends$1b = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Acts as `Group` node but with specified bounds that form a rectangle.\n * Any parts of the child nodes outside that rectangle will not be visible.\n * Unlike the `Group` node, the `ClipRect` node cannot be transformed.\n */\nvar ClipRect = /** @class */ (function (_super) {\n    __extends$1b(ClipRect, _super);\n    function ClipRect() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isContainerNode = true;\n        _this.path = new Path2D();\n        _this._enabled = true;\n        _this._dirtyPath = true;\n        _this._x = 0;\n        _this._y = 0;\n        _this._width = 10;\n        _this._height = 10;\n        return _this;\n    }\n    ClipRect.prototype.containsPoint = function (x, y) {\n        var point = this.transformPoint(x, y);\n        return point.x >= this.x && point.x <= this.x + this.width\n            && point.y >= this.y && point.y <= this.y + this.height;\n    };\n    Object.defineProperty(ClipRect.prototype, \"enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            if (this._enabled !== value) {\n                this._enabled = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClipRect.prototype, \"dirtyPath\", {\n        get: function () {\n            return this._dirtyPath;\n        },\n        set: function (value) {\n            if (this._dirtyPath !== value) {\n                this._dirtyPath = value;\n                if (value) {\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClipRect.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClipRect.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClipRect.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            if (this._width !== value) {\n                this._width = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClipRect.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            if (this._height !== value) {\n                this._height = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ClipRect.prototype.updatePath = function () {\n        var path = this.path;\n        path.clear();\n        path.rect(this.x, this.y, this.width, this.height);\n        this.dirtyPath = false;\n    };\n    ClipRect.prototype.computeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        return new BBox(x, y, width, height);\n    };\n    ClipRect.prototype.render = function (ctx) {\n        if (this.enabled) {\n            if (this.dirtyPath) {\n                this.updatePath();\n            }\n            this.scene.appendPath(this.path);\n            ctx.clip();\n        }\n        var children = this.children;\n        var n = children.length;\n        for (var i = 0; i < n; i++) {\n            ctx.save();\n            var child = children[i];\n            if (child.visible) {\n                child.render(ctx);\n            }\n            ctx.restore();\n        }\n        // debug\n        // this.computeBBox().render(ctx, {\n        //     label: this.id,\n        //     resetTransform: true,\n        //     fillStyle: 'rgba(0, 0, 0, 0.5)'\n        // });\n    };\n    ClipRect.className = 'ClipRect';\n    return ClipRect;\n}(Node));\n\nvar __extends$1c = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RangeHandle = /** @class */ (function (_super) {\n    __extends$1c(RangeHandle, _super);\n    function RangeHandle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._fill = '#f2f2f2';\n        _this._stroke = '#999999';\n        _this._strokeWidth = 1;\n        _this._lineCap = 'square';\n        _this._centerX = 0;\n        _this._centerY = 0;\n        // Use an even number for better looking results.\n        _this._width = 8;\n        // Use an even number for better looking results.\n        _this._gripLineGap = 2;\n        // Use an even number for better looking results.\n        _this._gripLineLength = 8;\n        _this._height = 16;\n        return _this;\n    }\n    Object.defineProperty(RangeHandle.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (value) {\n            if (this._centerX !== value) {\n                this._centerX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeHandle.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (value) {\n            if (this._centerY !== value) {\n                this._centerY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeHandle.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            if (this._width !== value) {\n                this._width = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeHandle.prototype, \"gripLineGap\", {\n        get: function () {\n            return this._gripLineGap;\n        },\n        set: function (value) {\n            if (this._gripLineGap !== value) {\n                this._gripLineGap = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeHandle.prototype, \"gripLineLength\", {\n        get: function () {\n            return this._gripLineLength;\n        },\n        set: function (value) {\n            if (this._gripLineLength !== value) {\n                this._gripLineLength = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeHandle.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            if (this._height !== value) {\n                this._height = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RangeHandle.prototype.computeBBox = function () {\n        var _a = this, centerX = _a.centerX, centerY = _a.centerY, width = _a.width, height = _a.height;\n        var x = centerX - width / 2;\n        var y = centerY - height / 2;\n        return new BBox(x, y, width, height);\n    };\n    RangeHandle.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return bbox.containsPoint(point.x, point.y);\n    };\n    RangeHandle.prototype.updatePath = function () {\n        var _a = this, path = _a.path, centerX = _a.centerX, centerY = _a.centerY, width = _a.width, height = _a.height;\n        var _b = this, a = _b.alignment, al = _b.align;\n        path.clear();\n        var x = centerX - width / 2;\n        var y = centerY - height / 2;\n        var ax = al(a, x);\n        var ay = al(a, y);\n        var axw = ax + al(a, x, width);\n        var ayh = ay + al(a, y, height);\n        // Handle.\n        path.moveTo(ax, ay);\n        path.lineTo(axw, ay);\n        path.lineTo(axw, ayh);\n        path.lineTo(ax, ayh);\n        path.lineTo(ax, ay);\n        // Grip lines.\n        var dx = this.gripLineGap / 2;\n        var dy = this.gripLineLength / 2;\n        path.moveTo(al(a, centerX - dx), al(a, centerY - dy));\n        path.lineTo(al(a, centerX - dx), al(a, centerY + dy));\n        path.moveTo(al(a, centerX + dx), al(a, centerY - dy));\n        path.lineTo(al(a, centerX + dx), al(a, centerY + dy));\n    };\n    RangeHandle.className = 'RangeHandle';\n    return RangeHandle;\n}(Path));\n\nvar __extends$1d = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RangeMask = /** @class */ (function (_super) {\n    __extends$1d(RangeMask, _super);\n    function RangeMask() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._stroke = '#999999';\n        _this._strokeWidth = 1;\n        _this._fill = '#999999';\n        _this._fillOpacity = 0.2;\n        _this._lineCap = 'square';\n        _this._x = 0;\n        _this._y = 0;\n        _this._width = 200;\n        _this._height = 30;\n        _this.minRange = 0.05;\n        _this._min = 0;\n        _this._max = 1;\n        return _this;\n    }\n    Object.defineProperty(RangeMask.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMask.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMask.prototype, \"width\", {\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            if (this._width !== value) {\n                this._width = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMask.prototype, \"height\", {\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            if (this._height !== value) {\n                this._height = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMask.prototype, \"min\", {\n        get: function () {\n            return this._min;\n        },\n        set: function (value) {\n            value = Math.min(Math.max(value, 0), this.max - this.minRange);\n            if (isNaN(value)) {\n                return;\n            }\n            if (this._min !== value) {\n                this._min = value;\n                this.dirtyPath = true;\n                this.onRangeChange && this.onRangeChange(value, this.max);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMask.prototype, \"max\", {\n        get: function () {\n            return this._max;\n        },\n        set: function (value) {\n            value = Math.max(Math.min(value, 1), this.min + this.minRange);\n            if (isNaN(value)) {\n                return;\n            }\n            if (this._max !== value) {\n                this._max = value;\n                this.dirtyPath = true;\n                this.onRangeChange && this.onRangeChange(this.min, value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RangeMask.prototype.computeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        return new BBox(x, y, width, height);\n    };\n    RangeMask.prototype.computeVisibleRangeBBox = function () {\n        var _a = this, x = _a.x, y = _a.y, width = _a.width, height = _a.height, min = _a.min, max = _a.max;\n        var minX = x + width * min;\n        var maxX = x + width * max;\n        return new BBox(minX, y, maxX - minX, height);\n    };\n    RangeMask.prototype.updatePath = function () {\n        var _a = this, path = _a.path, x = _a.x, y = _a.y, width = _a.width, height = _a.height, min = _a.min, max = _a.max;\n        var _b = this, a = _b.alignment, al = _b.align;\n        path.clear();\n        var ax = al(a, x);\n        var ay = al(a, y);\n        var axw = ax + al(a, x, width);\n        var ayh = ay + al(a, y, height);\n        // Whole range.\n        path.moveTo(ax, ay);\n        path.lineTo(axw, ay);\n        path.lineTo(axw, ayh);\n        path.lineTo(ax, ayh);\n        path.lineTo(ax, ay);\n        var minX = al(a, x + width * min);\n        var maxX = al(a, x + width * max);\n        // Visible range.\n        path.moveTo(minX, ay);\n        path.lineTo(minX, ayh);\n        path.lineTo(maxX, ayh);\n        path.lineTo(maxX, ay);\n        path.lineTo(minX, ay);\n    };\n    RangeMask.className = 'RangeMask';\n    return RangeMask;\n}(Path));\n\nvar __extends$1e = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar RangeSelector = /** @class */ (function (_super) {\n    __extends$1e(RangeSelector, _super);\n    function RangeSelector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isContainerNode = true;\n        _this.minHandle = new RangeHandle();\n        _this.maxHandle = new RangeHandle();\n        _this.mask = (function () {\n            var _a = RangeSelector.defaults, x = _a.x, y = _a.y, width = _a.width, height = _a.height, min = _a.min, max = _a.max;\n            var mask = new RangeMask();\n            mask.x = x;\n            mask.y = y;\n            mask.width = width;\n            mask.height = height;\n            mask.min = min;\n            mask.max = max;\n            var _b = _this, minHandle = _b.minHandle, maxHandle = _b.maxHandle;\n            minHandle.centerX = x;\n            maxHandle.centerX = x + width;\n            minHandle.centerY = maxHandle.centerY = y + height / 2;\n            _this.append([mask, minHandle, maxHandle]);\n            mask.onRangeChange = function (min, max) {\n                _this.updateHandles();\n                _this.onRangeChange && _this.onRangeChange(min, max);\n            };\n            return mask;\n        })();\n        _this._x = RangeSelector.defaults.x;\n        _this._y = RangeSelector.defaults.y;\n        _this._width = RangeSelector.defaults.width;\n        _this._height = RangeSelector.defaults.height;\n        _this._min = RangeSelector.defaults.min;\n        _this._max = RangeSelector.defaults.max;\n        return _this;\n    }\n    Object.defineProperty(RangeSelector.prototype, \"x\", {\n        get: function () {\n            return this.mask.x;\n        },\n        set: function (value) {\n            this.mask.x = value;\n            this.updateHandles();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeSelector.prototype, \"y\", {\n        get: function () {\n            return this.mask.y;\n        },\n        set: function (value) {\n            this.mask.y = value;\n            this.updateHandles();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeSelector.prototype, \"width\", {\n        get: function () {\n            return this.mask.width;\n        },\n        set: function (value) {\n            this.mask.width = value;\n            this.updateHandles();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeSelector.prototype, \"height\", {\n        get: function () {\n            return this.mask.height;\n        },\n        set: function (value) {\n            this.mask.height = value;\n            this.updateHandles();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeSelector.prototype, \"min\", {\n        get: function () {\n            return this.mask.min;\n        },\n        set: function (value) {\n            this.mask.min = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeSelector.prototype, \"max\", {\n        get: function () {\n            return this.mask.max;\n        },\n        set: function (value) {\n            this.mask.max = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RangeSelector.prototype.updateHandles = function () {\n        var _a = this, minHandle = _a.minHandle, maxHandle = _a.maxHandle, x = _a.x, y = _a.y, width = _a.width, height = _a.height, mask = _a.mask;\n        minHandle.centerX = x + width * mask.min;\n        maxHandle.centerX = x + width * mask.max;\n        minHandle.centerY = maxHandle.centerY = y + height / 2;\n    };\n    RangeSelector.prototype.computeBBox = function () {\n        return this.mask.computeBBox();\n    };\n    RangeSelector.prototype.computeVisibleRangeBBox = function () {\n        return this.mask.computeVisibleRangeBBox();\n    };\n    RangeSelector.prototype.render = function (ctx) {\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.matrix.toContext(ctx);\n        var _a = this, mask = _a.mask, minHandle = _a.minHandle, maxHandle = _a.maxHandle;\n        [mask, minHandle, maxHandle].forEach(function (child) {\n            ctx.save();\n            if (child.visible) {\n                child.render(ctx);\n            }\n            ctx.restore();\n        });\n    };\n    RangeSelector.className = 'Range';\n    RangeSelector.defaults = {\n        x: 0,\n        y: 0,\n        width: 200,\n        height: 30,\n        min: 0,\n        max: 1\n    };\n    return RangeSelector;\n}(Group));\n\nvar NavigatorMask = /** @class */ (function () {\n    function NavigatorMask(rangeMask) {\n        this.rm = rangeMask;\n    }\n    Object.defineProperty(NavigatorMask.prototype, \"fill\", {\n        get: function () {\n            return this.rm.fill;\n        },\n        set: function (value) {\n            this.rm.fill = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorMask.prototype, \"stroke\", {\n        get: function () {\n            return this.rm.stroke;\n        },\n        set: function (value) {\n            this.rm.stroke = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorMask.prototype, \"strokeWidth\", {\n        get: function () {\n            return this.rm.strokeWidth;\n        },\n        set: function (value) {\n            this.rm.strokeWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorMask.prototype, \"fillOpacity\", {\n        get: function () {\n            return this.rm.fillOpacity;\n        },\n        set: function (value) {\n            this.rm.fillOpacity = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NavigatorMask;\n}());\n\nvar NavigatorHandle = /** @class */ (function () {\n    function NavigatorHandle(rangeHandle) {\n        this.rh = rangeHandle;\n    }\n    Object.defineProperty(NavigatorHandle.prototype, \"fill\", {\n        get: function () {\n            return this.rh.fill;\n        },\n        set: function (value) {\n            this.rh.fill = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"stroke\", {\n        get: function () {\n            return this.rh.stroke;\n        },\n        set: function (value) {\n            this.rh.stroke = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"strokeWidth\", {\n        get: function () {\n            return this.rh.strokeWidth;\n        },\n        set: function (value) {\n            this.rh.strokeWidth = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"width\", {\n        get: function () {\n            return this.rh.width;\n        },\n        set: function (value) {\n            this.rh.width = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"height\", {\n        get: function () {\n            return this.rh.height;\n        },\n        set: function (value) {\n            this.rh.height = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"gripLineGap\", {\n        get: function () {\n            return this.rh.gripLineGap;\n        },\n        set: function (value) {\n            this.rh.gripLineGap = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavigatorHandle.prototype, \"gripLineLength\", {\n        get: function () {\n            return this.rh.gripLineLength;\n        },\n        set: function (value) {\n            this.rh.gripLineLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return NavigatorHandle;\n}());\n\nvar Navigator = /** @class */ (function () {\n    function Navigator(chart) {\n        var _this = this;\n        this.rs = new RangeSelector();\n        this.mask = new NavigatorMask(this.rs.mask);\n        this.minHandle = new NavigatorHandle(this.rs.minHandle);\n        this.maxHandle = new NavigatorHandle(this.rs.maxHandle);\n        this.minHandleDragging = false;\n        this.maxHandleDragging = false;\n        this.panHandleOffset = NaN;\n        this._margin = 10;\n        this.chart = chart;\n        chart.scene.root.append(this.rs);\n        this.rs.onRangeChange = function (min, max) { return _this.updateAxes(min, max); };\n    }\n    Object.defineProperty(Navigator.prototype, \"enabled\", {\n        get: function () {\n            return this.rs.visible;\n        },\n        set: function (value) {\n            this.rs.visible = value;\n            this.chart.layoutPending = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"x\", {\n        get: function () {\n            return this.rs.x;\n        },\n        set: function (value) {\n            this.rs.x = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"y\", {\n        get: function () {\n            return this.rs.y;\n        },\n        set: function (value) {\n            this.rs.y = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"width\", {\n        get: function () {\n            return this.rs.width;\n        },\n        set: function (value) {\n            this.rs.width = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"height\", {\n        get: function () {\n            return this.rs.height;\n        },\n        set: function (value) {\n            this.rs.height = value;\n            this.chart.layoutPending = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"margin\", {\n        get: function () {\n            return this._margin;\n        },\n        set: function (value) {\n            this._margin = value;\n            this.chart.layoutPending = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"min\", {\n        get: function () {\n            return this.rs.min;\n        },\n        set: function (value) {\n            this.rs.min = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Navigator.prototype, \"max\", {\n        get: function () {\n            return this.rs.max;\n        },\n        set: function (value) {\n            this.rs.max = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Navigator.prototype.updateAxes = function (min, max) {\n        var chart = this.chart;\n        var clipSeries = false;\n        chart.axes.forEach(function (axis) {\n            if (axis.direction === ChartAxisDirection.X) {\n                if (!clipSeries && (min > 0 || max < 1)) {\n                    clipSeries = true;\n                }\n                axis.visibleRange = [min, max];\n                axis.update();\n            }\n        });\n        chart.seriesRoot.enabled = clipSeries;\n        chart.series.forEach(function (series) { return series.update(); });\n    };\n    Navigator.prototype.onDragStart = function (offset) {\n        if (!this.enabled) {\n            return;\n        }\n        var offsetX = offset.offsetX, offsetY = offset.offsetY;\n        var rs = this.rs;\n        var minHandle = rs.minHandle, maxHandle = rs.maxHandle, x = rs.x, width = rs.width, min = rs.min;\n        var visibleRange = rs.computeVisibleRangeBBox();\n        if (!(this.minHandleDragging || this.maxHandleDragging)) {\n            if (minHandle.containsPoint(offsetX, offsetY)) {\n                this.minHandleDragging = true;\n            }\n            else if (maxHandle.containsPoint(offsetX, offsetY)) {\n                this.maxHandleDragging = true;\n            }\n            else if (visibleRange.containsPoint(offsetX, offsetY)) {\n                this.panHandleOffset = (offsetX - x) / width - min;\n            }\n        }\n    };\n    Navigator.prototype.onDrag = function (offset) {\n        if (!this.enabled) {\n            return;\n        }\n        var _a = this, rs = _a.rs, panHandleOffset = _a.panHandleOffset;\n        var x = rs.x, y = rs.y, width = rs.width, height = rs.height, minHandle = rs.minHandle, maxHandle = rs.maxHandle;\n        var style = this.chart.element.style;\n        var offsetX = offset.offsetX, offsetY = offset.offsetY;\n        var minX = x + width * rs.min;\n        var maxX = x + width * rs.max;\n        var visibleRange = new BBox(minX, y, maxX - minX, height);\n        function getRatio() {\n            return Math.min(Math.max((offsetX - x) / width, 0), 1);\n        }\n        if (minHandle.containsPoint(offsetX, offsetY)) {\n            style.cursor = 'ew-resize';\n        }\n        else if (maxHandle.containsPoint(offsetX, offsetY)) {\n            style.cursor = 'ew-resize';\n        }\n        else if (visibleRange.containsPoint(offsetX, offsetY)) {\n            style.cursor = 'grab';\n        }\n        else {\n            style.cursor = 'default';\n        }\n        if (this.minHandleDragging) {\n            rs.min = getRatio();\n        }\n        else if (this.maxHandleDragging) {\n            rs.max = getRatio();\n        }\n        else if (!isNaN(panHandleOffset)) {\n            var span = rs.max - rs.min;\n            var min = Math.min(getRatio() - panHandleOffset, 1 - span);\n            if (min <= rs.min) { // pan left\n                rs.min = min;\n                rs.max = rs.min + span;\n            }\n            else { // pan right\n                rs.max = min + span;\n                rs.min = rs.max - span;\n            }\n        }\n    };\n    Navigator.prototype.onDragStop = function () {\n        this.stopHandleDragging();\n    };\n    Navigator.prototype.stopHandleDragging = function () {\n        this.minHandleDragging = this.maxHandleDragging = false;\n        this.panHandleOffset = NaN;\n    };\n    return Navigator;\n}());\n\nvar __extends$1f = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar CartesianChart = /** @class */ (function (_super) {\n    __extends$1f(CartesianChart, _super);\n    function CartesianChart(document) {\n        if (document === void 0) { document = window.document; }\n        var _this = _super.call(this, document) || this;\n        _this._seriesRoot = new ClipRect();\n        _this.navigator = new Navigator(_this);\n        // Prevent the scene from rendering chart components in an invalid state\n        // (before first layout is performed).\n        _this.scene.root.visible = false;\n        var root = _this.scene.root;\n        root.append(_this.seriesRoot);\n        root.append(_this.legend.group);\n        _this.navigator.enabled = false;\n        return _this;\n    }\n    Object.defineProperty(CartesianChart.prototype, \"seriesRoot\", {\n        get: function () {\n            return this._seriesRoot;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CartesianChart.prototype.performLayout = function () {\n        if (this.dataPending) {\n            return;\n        }\n        this.scene.root.visible = true;\n        var _a = this, width = _a.width, height = _a.height, axes = _a.axes, legend = _a.legend, navigator = _a.navigator;\n        var shrinkRect = new BBox(0, 0, width, height);\n        this.positionCaptions();\n        this.positionLegend();\n        if (legend.enabled && legend.data.length) {\n            var legendAutoPadding = this.legendAutoPadding;\n            var legendPadding = this.legend.spacing;\n            shrinkRect.x += legendAutoPadding.left;\n            shrinkRect.y += legendAutoPadding.top;\n            shrinkRect.width -= legendAutoPadding.left + legendAutoPadding.right;\n            shrinkRect.height -= legendAutoPadding.top + legendAutoPadding.bottom;\n            switch (this.legend.position) {\n                case 'right':\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'bottom':\n                    shrinkRect.height -= legendPadding;\n                    break;\n                case 'left':\n                    shrinkRect.x += legendPadding;\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'top':\n                    shrinkRect.y += legendPadding;\n                    shrinkRect.height -= legendPadding;\n                    break;\n            }\n        }\n        var _b = this, captionAutoPadding = _b.captionAutoPadding, padding = _b.padding;\n        this.updateAxes();\n        shrinkRect.x += padding.left;\n        shrinkRect.width -= padding.left + padding.right;\n        shrinkRect.y += padding.top + captionAutoPadding;\n        shrinkRect.height -= padding.top + captionAutoPadding + padding.bottom;\n        if (navigator.enabled) {\n            shrinkRect.height -= navigator.height + navigator.margin;\n        }\n        var bottomAxesHeight = 0;\n        axes.forEach(function (axis) {\n            axis.group.visible = true;\n            var axisThickness = Math.floor(axis.computeBBox().width);\n            switch (axis.position) {\n                case ChartAxisPosition.Top:\n                    shrinkRect.y += axisThickness;\n                    shrinkRect.height -= axisThickness;\n                    axis.translation.y = Math.floor(shrinkRect.y + 1);\n                    axis.label.mirrored = true;\n                    break;\n                case ChartAxisPosition.Right:\n                    shrinkRect.width -= axisThickness;\n                    axis.translation.x = Math.floor(shrinkRect.x + shrinkRect.width);\n                    axis.label.mirrored = true;\n                    break;\n                case ChartAxisPosition.Bottom:\n                    shrinkRect.height -= axisThickness;\n                    bottomAxesHeight += axisThickness;\n                    axis.translation.y = Math.floor(shrinkRect.y + shrinkRect.height + 1);\n                    break;\n                case ChartAxisPosition.Left:\n                    shrinkRect.x += axisThickness;\n                    shrinkRect.width -= axisThickness;\n                    axis.translation.x = Math.floor(shrinkRect.x);\n                    break;\n            }\n        });\n        axes.forEach(function (axis) {\n            switch (axis.position) {\n                case ChartAxisPosition.Top:\n                case ChartAxisPosition.Bottom:\n                    axis.translation.x = Math.floor(shrinkRect.x);\n                    axis.range = [0, shrinkRect.width];\n                    axis.gridLength = shrinkRect.height;\n                    break;\n                case ChartAxisPosition.Left:\n                case ChartAxisPosition.Right:\n                    axis.translation.y = Math.floor(shrinkRect.y);\n                    if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {\n                        axis.range = [0, shrinkRect.height];\n                    }\n                    else {\n                        axis.range = [shrinkRect.height, 0];\n                    }\n                    axis.gridLength = shrinkRect.width;\n                    break;\n            }\n        });\n        this.seriesRect = shrinkRect;\n        this.series.forEach(function (series) {\n            series.group.translationX = Math.floor(shrinkRect.x);\n            series.group.translationY = Math.floor(shrinkRect.y);\n            series.update(); // this has to happen after the `updateAxes` call\n        });\n        var seriesRoot = this.seriesRoot;\n        seriesRoot.x = shrinkRect.x;\n        seriesRoot.y = shrinkRect.y;\n        seriesRoot.width = shrinkRect.width;\n        seriesRoot.height = shrinkRect.height;\n        if (navigator.enabled) {\n            navigator.x = shrinkRect.x;\n            navigator.y = shrinkRect.y + shrinkRect.height + bottomAxesHeight + navigator.margin;\n            navigator.width = shrinkRect.width;\n        }\n        this.axes.forEach(function (axis) { return axis.update(); });\n    };\n    CartesianChart.prototype.initSeries = function (series) {\n        _super.prototype.initSeries.call(this, series);\n        series.addEventListener('dataProcessed', this.updateAxes, this);\n    };\n    CartesianChart.prototype.freeSeries = function (series) {\n        _super.prototype.freeSeries.call(this, series);\n        series.removeEventListener('dataProcessed', this.updateAxes, this);\n    };\n    CartesianChart.prototype.setupDomListeners = function (chartElement) {\n        _super.prototype.setupDomListeners.call(this, chartElement);\n        this._onTouchStart = this.onTouchStart.bind(this);\n        this._onTouchMove = this.onTouchMove.bind(this);\n        this._onTouchEnd = this.onTouchEnd.bind(this);\n        this._onTouchCancel = this.onTouchCancel.bind(this);\n        chartElement.addEventListener('touchstart', this._onTouchStart);\n        chartElement.addEventListener('touchmove', this._onTouchMove);\n        chartElement.addEventListener('touchend', this._onTouchEnd);\n        chartElement.addEventListener('touchcancel', this._onTouchCancel);\n    };\n    CartesianChart.prototype.cleanupDomListeners = function (chartElement) {\n        _super.prototype.cleanupDomListeners.call(this, chartElement);\n        chartElement.removeEventListener('touchstart', this._onTouchStart);\n        chartElement.removeEventListener('touchmove', this._onTouchMove);\n        chartElement.removeEventListener('touchend', this._onTouchEnd);\n        chartElement.removeEventListener('touchcancel', this._onTouchCancel);\n    };\n    CartesianChart.prototype.getTouchOffset = function (event) {\n        var rect = this.scene.canvas.element.getBoundingClientRect();\n        var touch = event.touches[0];\n        return touch ? {\n            offsetX: touch.clientX - rect.left,\n            offsetY: touch.clientY - rect.top\n        } : undefined;\n    };\n    CartesianChart.prototype.onTouchStart = function (event) {\n        var offset = this.getTouchOffset(event);\n        if (offset) {\n            this.navigator.onDragStart(offset);\n        }\n    };\n    CartesianChart.prototype.onTouchMove = function (event) {\n        var offset = this.getTouchOffset(event);\n        if (offset) {\n            this.navigator.onDrag(offset);\n        }\n    };\n    CartesianChart.prototype.onTouchEnd = function (event) {\n        this.navigator.onDragStop();\n    };\n    CartesianChart.prototype.onTouchCancel = function (event) {\n        this.navigator.onDragStop();\n    };\n    CartesianChart.prototype.onMouseDown = function (event) {\n        _super.prototype.onMouseDown.call(this, event);\n        this.navigator.onDragStart(event);\n    };\n    CartesianChart.prototype.onMouseMove = function (event) {\n        _super.prototype.onMouseMove.call(this, event);\n        this.navigator.onDrag(event);\n    };\n    CartesianChart.prototype.onMouseUp = function (event) {\n        _super.prototype.onMouseUp.call(this, event);\n        this.navigator.onDragStop();\n    };\n    CartesianChart.prototype.onMouseOut = function (event) {\n        _super.prototype.onMouseOut.call(this, event);\n        this.navigator.onDragStop();\n    };\n    CartesianChart.prototype.updateAxes = function () {\n        var navigator = this.navigator;\n        var clipSeries = false;\n        this.axes.forEach(function (axis) {\n            var _a;\n            var direction = axis.direction, boundSeries = axis.boundSeries;\n            if (axis.linkedTo) {\n                axis.domain = axis.linkedTo.domain;\n            }\n            else {\n                var domains_1 = [];\n                boundSeries.filter(function (s) { return s.visible; }).forEach(function (series) {\n                    domains_1.push(series.getDomain(direction));\n                });\n                var domain = (_a = new Array()).concat.apply(_a, domains_1);\n                axis.domain = numericExtent(domain) || domain; // if numeric extent can't be found, it's categories\n            }\n            if (axis.direction === ChartAxisDirection.X) {\n                axis.visibleRange = [navigator.min, navigator.max];\n            }\n            if (!clipSeries && (axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1)) {\n                clipSeries = true;\n            }\n            axis.update();\n        });\n        this.seriesRoot.enabled = clipSeries;\n    };\n    CartesianChart.className = 'CartesianChart';\n    CartesianChart.type = 'cartesian';\n    return CartesianChart;\n}(Chart));\n\nvar __extends$1g = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar HierarchyChart = /** @class */ (function (_super) {\n    __extends$1g(HierarchyChart, _super);\n    function HierarchyChart(document) {\n        if (document === void 0) { document = window.document; }\n        var _this = _super.call(this, document) || this;\n        _this._data = {};\n        _this._seriesRoot = new ClipRect();\n        // Prevent the scene from rendering chart components in an invalid state\n        // (before first layout is performed).\n        _this.scene.root.visible = false;\n        var root = _this.scene.root;\n        root.append(_this.seriesRoot);\n        root.append(_this.legend.group);\n        return _this;\n    }\n    Object.defineProperty(HierarchyChart.prototype, \"seriesRoot\", {\n        get: function () {\n            return this._seriesRoot;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HierarchyChart.prototype.performLayout = function () {\n        if (this.dataPending) {\n            return;\n        }\n        this.scene.root.visible = true;\n        var _a = this, width = _a.width, height = _a.height, legend = _a.legend;\n        var shrinkRect = new BBox(0, 0, width, height);\n        this.positionCaptions();\n        this.positionLegend();\n        if (legend.enabled && legend.data.length) {\n            var legendAutoPadding = this.legendAutoPadding;\n            var legendPadding = this.legend.spacing;\n            shrinkRect.x += legendAutoPadding.left;\n            shrinkRect.y += legendAutoPadding.top;\n            shrinkRect.width -= legendAutoPadding.left + legendAutoPadding.right;\n            shrinkRect.height -= legendAutoPadding.top + legendAutoPadding.bottom;\n            switch (this.legend.position) {\n                case 'right':\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'bottom':\n                    shrinkRect.height -= legendPadding;\n                    break;\n                case 'left':\n                    shrinkRect.x += legendPadding;\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'top':\n                    shrinkRect.y += legendPadding;\n                    shrinkRect.height -= legendPadding;\n                    break;\n            }\n        }\n        var _b = this, captionAutoPadding = _b.captionAutoPadding, padding = _b.padding;\n        shrinkRect.x += padding.left;\n        shrinkRect.width -= padding.left + padding.right;\n        shrinkRect.y += padding.top + captionAutoPadding;\n        shrinkRect.height -= padding.top + captionAutoPadding + padding.bottom;\n        this.seriesRect = shrinkRect;\n        this.series.forEach(function (series) {\n            series.group.translationX = Math.floor(shrinkRect.x);\n            series.group.translationY = Math.floor(shrinkRect.y);\n            series.update(); // this has to happen after the `updateAxes` call\n        });\n        var seriesRoot = this.seriesRoot;\n        seriesRoot.x = shrinkRect.x;\n        seriesRoot.y = shrinkRect.y;\n        seriesRoot.width = shrinkRect.width;\n        seriesRoot.height = shrinkRect.height;\n    };\n    HierarchyChart.className = 'HierarchyChart';\n    HierarchyChart.type = 'hierarchy';\n    return HierarchyChart;\n}(Chart));\n\nvar __extends$1h = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar GroupedCategoryChart = /** @class */ (function (_super) {\n    __extends$1h(GroupedCategoryChart, _super);\n    function GroupedCategoryChart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GroupedCategoryChart.prototype.updateAxes = function () {\n        this.axes.forEach(function (axis) {\n            var _a;\n            var direction = axis.direction, boundSeries = axis.boundSeries;\n            var domains = [];\n            var isNumericX = undefined;\n            boundSeries.filter(function (s) { return s.visible; }).forEach(function (series) {\n                if (direction === ChartAxisDirection.X) {\n                    if (isNumericX === undefined) {\n                        // always add first X domain\n                        var domain_1 = series.getDomain(direction);\n                        domains.push(domain_1);\n                        isNumericX = typeof domain_1[0] === 'number';\n                    }\n                    else if (isNumericX) {\n                        // only add further X domains if the axis is numeric\n                        domains.push(series.getDomain(direction));\n                    }\n                }\n                else {\n                    domains.push(series.getDomain(direction));\n                }\n            });\n            var domain = (_a = new Array()).concat.apply(_a, domains);\n            axis.domain = numericExtent(domain) || domain;\n            axis.update();\n        });\n    };\n    GroupedCategoryChart.className = 'GroupedCategoryChart';\n    GroupedCategoryChart.type = 'groupedCategory';\n    return GroupedCategoryChart;\n}(CartesianChart));\n\nvar __extends$1i = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar PolarSeries = /** @class */ (function (_super) {\n    __extends$1i(PolarSeries, _super);\n    function PolarSeries() {\n        var _a;\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.directionKeys = (_a = {},\n            _a[ChartAxisDirection.X] = ['angleKey'],\n            _a[ChartAxisDirection.Y] = ['radiusKey'],\n            _a);\n        /**\n         * The center of the polar series (for example, the center of a pie).\n         * If the polar chart has multiple series, all of them will have their\n         * center set to the same value as a result of the polar chart layout.\n         * The center coordinates are not supposed to be set by the user.\n         */\n        _this.centerX = 0;\n        _this.centerY = 0;\n        /**\n         * The maximum radius the series can use.\n         * This value is set automatically as a result of the polar chart layout\n         * and is not supposed to be set by the user.\n         */\n        _this.radius = 0;\n        return _this;\n    }\n    return PolarSeries;\n}(Series));\nvar PolarSeriesMarker = /** @class */ (function (_super) {\n    __extends$1i(PolarSeriesMarker, _super);\n    function PolarSeriesMarker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PolarSeriesMarker;\n}(SeriesMarker));\n\nvar __extends$1j = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PolarChart = /** @class */ (function (_super) {\n    __extends$1j(PolarChart, _super);\n    function PolarChart(document) {\n        if (document === void 0) { document = window.document; }\n        var _this = _super.call(this, document) || this;\n        _this.padding = new Padding(40);\n        _this.scene.root.append(_this.legend.group);\n        return _this;\n    }\n    Object.defineProperty(PolarChart.prototype, \"seriesRoot\", {\n        get: function () {\n            return this.scene.root;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PolarChart.prototype.performLayout = function () {\n        var shrinkRect = new BBox(0, 0, this.width, this.height);\n        this.positionCaptions();\n        this.positionLegend();\n        var captionAutoPadding = this.captionAutoPadding;\n        shrinkRect.y += captionAutoPadding;\n        shrinkRect.height -= captionAutoPadding;\n        if (this.legend.enabled && this.legend.data.length) {\n            var legendAutoPadding = this.legendAutoPadding;\n            shrinkRect.x += legendAutoPadding.left;\n            shrinkRect.y += legendAutoPadding.top;\n            shrinkRect.width -= legendAutoPadding.left + legendAutoPadding.right;\n            shrinkRect.height -= legendAutoPadding.top + legendAutoPadding.bottom;\n            var legendPadding = this.legend.spacing;\n            switch (this.legend.position) {\n                case 'right':\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'bottom':\n                    shrinkRect.height -= legendPadding;\n                    break;\n                case 'left':\n                    shrinkRect.x += legendPadding;\n                    shrinkRect.width -= legendPadding;\n                    break;\n                case 'top':\n                    shrinkRect.y += legendPadding;\n                    shrinkRect.height -= legendPadding;\n                    break;\n            }\n        }\n        var padding = this.padding;\n        shrinkRect.x += padding.left;\n        shrinkRect.y += padding.top;\n        shrinkRect.width -= padding.left + padding.right;\n        shrinkRect.height -= padding.top + padding.bottom;\n        this.seriesRect = shrinkRect;\n        var centerX = shrinkRect.x + shrinkRect.width / 2;\n        var centerY = shrinkRect.y + shrinkRect.height / 2;\n        var radius = Math.min(shrinkRect.width, shrinkRect.height) / 2;\n        this.series.forEach(function (series) {\n            if (series instanceof PolarSeries) {\n                series.centerX = centerX;\n                series.centerY = centerY;\n                series.radius = radius;\n                series.update();\n            }\n        });\n    };\n    PolarChart.className = 'PolarChart';\n    PolarChart.type = 'polar';\n    __decorate$K([\n        reactive('layoutChange')\n    ], PolarChart.prototype, \"padding\", void 0);\n    return PolarChart;\n}(Chart));\n\nfunction equal(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        if (a.constructor !== b.constructor)\n            return false;\n        var length_1, i = void 0;\n        if (Array.isArray(a)) {\n            length_1 = a.length;\n            if (length_1 != b.length)\n                return false;\n            for (i = length_1; i-- !== 0;)\n                if (!equal(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        // if ((a instanceof Map) && (b instanceof Map)) {\n        //     if (a.size !== b.size) return false;\n        //     for (i of a.entries())\n        //         if (!b.has(i[0])) return false;\n        //     for (i of a.entries())\n        //         if (!equal(i[1], b.get(i[0]))) return false;\n        //     return true;\n        // }\n        //\n        // if ((a instanceof Set) && (b instanceof Set)) {\n        //     if (a.size !== b.size) return false;\n        //     for (i of a.entries())\n        //         if (!b.has(i[0])) return false;\n        //     return true;\n        // }\n        //\n        // if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n        //     length = a.length;\n        //     if (length != b.length) return false;\n        //     for (i = length; i-- !== 0;)\n        //         if (a[i] !== b[i]) return false;\n        //     return true;\n        // }\n        if (a.constructor === RegExp)\n            return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf)\n            return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString)\n            return a.toString() === b.toString();\n        var keys = Object.keys(a);\n        length_1 = keys.length;\n        if (length_1 !== Object.keys(b).length)\n            return false;\n        for (i = length_1; i-- !== 0;)\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))\n                return false;\n        for (i = length_1; i-- !== 0;) {\n            var key = keys[i];\n            if (!equal(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n}\n\nvar interpolatePattern = /(#\\{(.*?)\\})/g;\nfunction interpolate(input, values, formats) {\n    return input.replace(interpolatePattern, function () {\n        var name = arguments[2];\n        var _a = name.split(':'), valueName = _a[0], formatName = _a[1];\n        var value = values[valueName];\n        if (typeof value === 'number') {\n            var format = formatName && formats && formats[formatName];\n            if (format) {\n                var _b = format, locales = _b.locales, options = _b.options;\n                return value.toLocaleString(locales, options);\n            }\n            return String(value);\n        }\n        if (value instanceof Date) {\n            var format = formatName && formats && formats[formatName];\n            if (typeof format === 'string') {\n                var formatter = locale.format(format);\n                return formatter(value);\n            }\n            return value.toDateString();\n        }\n        if (typeof value === 'string' || (value && value.toString)) {\n            return String(value);\n        }\n        return '';\n    });\n}\n\nvar __extends$1k = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AreaSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1k(AreaSeriesTooltip, _super);\n    function AreaSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$L([\n        reactive('change')\n    ], AreaSeriesTooltip.prototype, \"renderer\", void 0);\n    __decorate$L([\n        reactive('change')\n    ], AreaSeriesTooltip.prototype, \"format\", void 0);\n    return AreaSeriesTooltip;\n}(SeriesTooltip));\nvar AreaSeries = /** @class */ (function (_super) {\n    __extends$1k(AreaSeries, _super);\n    function AreaSeries() {\n        var _this = _super.call(this) || this;\n        _this.tooltip = new AreaSeriesTooltip();\n        _this.areaGroup = _this.group.appendChild(new Group);\n        _this.strokeGroup = _this.group.appendChild(new Group);\n        _this.markerGroup = _this.group.appendChild(new Group);\n        _this.areaSelection = Selection.select(_this.areaGroup).selectAll();\n        _this.strokeSelection = Selection.select(_this.strokeGroup).selectAll();\n        _this.markerSelection = Selection.select(_this.markerGroup).selectAll();\n        _this.markerSelectionData = [];\n        /**\n         * The assumption is that the values will be reset (to `true`)\n         * in the {@link yKeys} setter.\n         */\n        _this.seriesItemEnabled = new Map();\n        _this.xData = [];\n        _this.yData = [];\n        _this.yDomain = [];\n        _this.directionKeys = {\n            x: ['xKey'],\n            y: ['yKeys']\n        };\n        _this.marker = new CartesianSeriesMarker();\n        _this.fills = [\n            '#c16068',\n            '#a2bf8a',\n            '#ebcc87',\n            '#80a0c3',\n            '#b58dae',\n            '#85c0d1'\n        ];\n        _this.strokes = [\n            '#874349',\n            '#718661',\n            '#a48f5f',\n            '#5a7088',\n            '#7f637a',\n            '#5d8692'\n        ];\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        _this._xKey = '';\n        _this.xName = '';\n        _this._yKeys = [];\n        _this.yNames = [];\n        _this.strokeWidth = 2;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.addEventListener('update', _this.update);\n        _this.marker.enabled = false;\n        _this.marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n        _this.marker.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    AreaSeries.prototype.onMarkerShapeChange = function () {\n        this.markerSelection = this.markerSelection.setData([]);\n        this.markerSelection.exit.remove();\n        this.update();\n        this.fireEvent({ type: 'legendChange' });\n    };\n    Object.defineProperty(AreaSeries.prototype, \"xKey\", {\n        get: function () {\n            return this._xKey;\n        },\n        set: function (value) {\n            if (this._xKey !== value) {\n                this._xKey = value;\n                this.xData = [];\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AreaSeries.prototype, \"yKeys\", {\n        get: function () {\n            return this._yKeys;\n        },\n        set: function (values) {\n            if (!equal(this._yKeys, values)) {\n                this._yKeys = values;\n                this.yData = [];\n                var seriesItemEnabled_1 = this.seriesItemEnabled;\n                seriesItemEnabled_1.clear();\n                values.forEach(function (key) { return seriesItemEnabled_1.set(key, true); });\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AreaSeries.prototype.setColors = function (fills, strokes) {\n        this.fills = fills;\n        this.strokes = strokes;\n    };\n    Object.defineProperty(AreaSeries.prototype, \"normalizedTo\", {\n        get: function () {\n            return this._normalizedTo;\n        },\n        set: function (value) {\n            var absValue = value ? Math.abs(value) : undefined;\n            if (this._normalizedTo !== absValue) {\n                this._normalizedTo = absValue;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AreaSeries.prototype.onHighlightChange = function () {\n        this.updateMarkerNodes();\n    };\n    AreaSeries.prototype.processData = function () {\n        var _a = this, xKey = _a.xKey, yKeys = _a.yKeys, seriesItemEnabled = _a.seriesItemEnabled;\n        var data = xKey && yKeys.length && this.data ? this.data : [];\n        // if (!(chart && chart.xAxis && chart.yAxis)) {\n        //     return false;\n        // }\n        // If the data is an array of rows like so:\n        //\n        // [{\n        //   xKy: 'Jan',\n        //   yKey1: 5,\n        //   yKey2: 7,\n        //   yKey3: -9,\n        // }, {\n        //   xKey: 'Feb',\n        //   yKey1: 10,\n        //   yKey2: -15,\n        //   yKey3: 20\n        // }]\n        //\n        var keysFound = true; // only warn once\n        this.xData = data.map(function (datum) {\n            if (keysFound && !(xKey in datum)) {\n                keysFound = false;\n                console.warn(\"The key '\" + xKey + \"' was not found in the data: \", datum);\n            }\n            return datum[xKey];\n        });\n        this.yData = data.map(function (datum) { return yKeys.map(function (yKey) {\n            if (keysFound && !(yKey in datum)) {\n                keysFound = false;\n                console.warn(\"The key '\" + yKey + \"' was not found in the data: \", datum);\n            }\n            var value = datum[yKey];\n            return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n        }); });\n        // xData: ['Jan', 'Feb']\n        //\n        // yData: [\n        //   [5, 7, -9],\n        //   [10, -15, 20]\n        // ]\n        var _b = this, yData = _b.yData, normalizedTo = _b.normalizedTo;\n        var yMinMax = yData.map(function (values) { return findMinMax(values); }); // used for normalization\n        var yLargestMinMax = this.findLargestMinMax(yMinMax);\n        var yMin;\n        var yMax;\n        if (normalizedTo && isFinite(normalizedTo)) {\n            yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n            yMax = normalizedTo;\n            yData.forEach(function (stack, i) { return stack.forEach(function (y, j) {\n                if (y < 0) {\n                    stack[j] = -y / yMinMax[i].min * normalizedTo;\n                }\n                else {\n                    stack[j] = y / yMinMax[i].max * normalizedTo;\n                }\n            }); });\n        }\n        else {\n            yMin = yLargestMinMax.min;\n            yMax = yLargestMinMax.max;\n        }\n        if (yMin === 0 && yMax === 0) {\n            yMax = 1;\n        }\n        this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n        this.fireEvent({ type: 'dataProcessed' });\n        return true;\n    };\n    AreaSeries.prototype.findLargestMinMax = function (totals) {\n        var min = 0;\n        var max = 0;\n        for (var _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {\n            var total = totals_1[_i];\n            if (total.min < min) {\n                min = total.min;\n            }\n            if (total.max > max) {\n                max = total.max;\n            }\n        }\n        return { min: min, max: max };\n    };\n    AreaSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.xData;\n        }\n        else {\n            return this.yDomain;\n        }\n    };\n    AreaSeries.prototype.update = function () {\n        var _a = this, visible = _a.visible, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis, xData = _a.xData, yData = _a.yData;\n        this.group.visible = visible && !!(xData.length && yData.length);\n        if (!xAxis || !yAxis || !visible || !chart || chart.layoutPending || chart.dataPending || !xData.length || !yData.length) {\n            return;\n        }\n        var selectionData = this.generateSelectionData();\n        if (!selectionData) {\n            return;\n        }\n        var areaSelectionData = selectionData.areaSelectionData, markerSelectionData = selectionData.markerSelectionData;\n        this.updateAreaSelection(areaSelectionData);\n        this.updateStrokeSelection(areaSelectionData);\n        this.updateMarkerSelection(markerSelectionData);\n        this.updateMarkerNodes();\n        this.markerSelectionData = markerSelectionData;\n    };\n    AreaSeries.prototype.generateSelectionData = function () {\n        var _this = this;\n        if (!this.data) {\n            return;\n        }\n        var _a = this, yKeys = _a.yKeys, data = _a.data, xData = _a.xData, yData = _a.yData, marker = _a.marker, fills = _a.fills, strokes = _a.strokes, xScale = _a.xAxis.scale, yScale = _a.yAxis.scale;\n        var xOffset = (xScale.bandwidth || 0) / 2;\n        var yOffset = (yScale.bandwidth || 0) / 2;\n        var areaSelectionData = [];\n        var markerSelectionData = [];\n        var last = xData.length * 2 - 1;\n        xData.forEach(function (xDatum, i) {\n            var yDatum = yData[i];\n            var seriesDatum = data[i];\n            var x = xScale.convert(xDatum) + xOffset;\n            var prevMin = 0;\n            var prevMax = 0;\n            yDatum.forEach(function (curr, j) {\n                var prev = curr < 0 ? prevMin : prevMax;\n                var y = yScale.convert(prev + curr) + yOffset;\n                var yKey = yKeys[j];\n                var yValue = seriesDatum[yKey];\n                if (marker) {\n                    markerSelectionData.push({\n                        series: _this,\n                        seriesDatum: seriesDatum,\n                        yValue: yValue,\n                        yKey: yKey,\n                        point: { x: x, y: y },\n                        fill: fills[j % fills.length],\n                        stroke: strokes[j % strokes.length]\n                    });\n                }\n                var areaDatum = areaSelectionData[j] || (areaSelectionData[j] = { yKey: yKey, points: [] });\n                var areaPoints = areaDatum.points;\n                areaPoints[i] = { x: x, y: y };\n                areaPoints[last - i] = { x: x, y: yScale.convert(prev) + yOffset }; // bottom y\n                if (curr < 0) {\n                    prevMin += curr;\n                }\n                else {\n                    prevMax += curr;\n                }\n            });\n        });\n        return { areaSelectionData: areaSelectionData, markerSelectionData: markerSelectionData };\n    };\n    AreaSeries.prototype.updateAreaSelection = function (areaSelectionData) {\n        var _this = this;\n        var _a = this, fills = _a.fills, fillOpacity = _a.fillOpacity, strokes = _a.strokes, strokeOpacity = _a.strokeOpacity, strokeWidth = _a.strokeWidth, seriesItemEnabled = _a.seriesItemEnabled, shadow = _a.shadow;\n        var updateAreas = this.areaSelection.setData(areaSelectionData);\n        updateAreas.exit.remove();\n        var enterAreas = updateAreas.enter.append(Path)\n            .each(function (path) {\n            path.lineJoin = 'round';\n            path.stroke = undefined;\n            path.pointerEvents = PointerEvents.None;\n        });\n        var areaSelection = updateAreas.merge(enterAreas);\n        areaSelection.each(function (shape, datum, index) {\n            var path = shape.path;\n            shape.fill = fills[index % fills.length];\n            shape.fillOpacity = fillOpacity;\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeOpacity = strokeOpacity;\n            shape.strokeWidth = strokeWidth;\n            shape.lineDash = _this.lineDash;\n            shape.lineDashOffset = _this.lineDashOffset;\n            shape.fillShadow = shadow;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n            path.clear();\n            var points = datum.points;\n            points.forEach(function (_a, i) {\n                var x = _a.x, y = _a.y;\n                if (i > 0) {\n                    path.lineTo(x, y);\n                }\n                else {\n                    path.moveTo(x, y);\n                }\n            });\n            path.closePath();\n        });\n        this.areaSelection = areaSelection;\n    };\n    AreaSeries.prototype.updateStrokeSelection = function (areaSelectionData) {\n        var _this = this;\n        if (!this.data) {\n            return;\n        }\n        var _a = this, strokes = _a.strokes, strokeWidth = _a.strokeWidth, strokeOpacity = _a.strokeOpacity, data = _a.data, seriesItemEnabled = _a.seriesItemEnabled;\n        var updateStrokes = this.strokeSelection.setData(areaSelectionData);\n        updateStrokes.exit.remove();\n        var enterStrokes = updateStrokes.enter.append(Path)\n            .each(function (path) {\n            path.fill = undefined;\n            path.lineJoin = path.lineCap = 'round';\n            path.pointerEvents = PointerEvents.None;\n        });\n        var strokeSelection = updateStrokes.merge(enterStrokes);\n        strokeSelection.each(function (shape, datum, index) {\n            var path = shape.path;\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeWidth = strokeWidth;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n            shape.strokeOpacity = strokeOpacity;\n            shape.lineDash = _this.lineDash;\n            shape.lineDashOffset = _this.lineDashOffset;\n            path.clear();\n            var points = datum.points;\n            // The stroke doesn't go all the way around the fill, only on top,\n            // that's why we iterate until `data.length` (rather than `points.length`) and stop.\n            for (var i = 0; i < data.length; i++) {\n                var _a = points[i], x = _a.x, y = _a.y;\n                if (i > 0) {\n                    path.lineTo(x, y);\n                }\n                else {\n                    path.moveTo(x, y);\n                }\n            }\n        });\n        this.strokeSelection = strokeSelection;\n    };\n    AreaSeries.prototype.updateMarkerSelection = function (markerSelectionData) {\n        var marker = this.marker;\n        var data = marker.shape ? markerSelectionData : [];\n        var MarkerShape = getMarker(marker.shape);\n        var updateMarkers = this.markerSelection.setData(data);\n        updateMarkers.exit.remove();\n        var enterMarkers = updateMarkers.enter.append(MarkerShape);\n        this.markerSelection = updateMarkers.merge(enterMarkers);\n    };\n    AreaSeries.prototype.updateMarkerNodes = function () {\n        if (!this.chart) {\n            return;\n        }\n        var marker = this.marker;\n        var markerFormatter = marker.formatter;\n        var markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : this.strokeWidth;\n        var markerSize = marker.size;\n        var _a = this, xKey = _a.xKey, seriesItemEnabled = _a.seriesItemEnabled;\n        var highlightedDatum = this.chart.highlightedDatum;\n        var _b = this.highlightStyle, highlightFill = _b.fill, highlightStroke = _b.stroke;\n        this.markerSelection.each(function (node, datum) {\n            var highlighted = datum === highlightedDatum;\n            var markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || datum.fill;\n            var markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || datum.stroke;\n            var markerFormat = undefined;\n            if (markerFormatter) {\n                markerFormat = markerFormatter({\n                    datum: datum.seriesDatum,\n                    xKey: xKey,\n                    yKey: datum.yKey,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted: highlighted\n                });\n            }\n            node.fill = markerFormat && markerFormat.fill || markerFill;\n            node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n            node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                ? markerFormat.strokeWidth\n                : markerStrokeWidth;\n            node.size = markerFormat && markerFormat.size !== undefined\n                ? markerFormat.size\n                : markerSize;\n            node.translationX = datum.point.x;\n            node.translationY = datum.point.y;\n            node.visible = marker.enabled && node.size > 0 && !!seriesItemEnabled.get(datum.yKey);\n        });\n    };\n    AreaSeries.prototype.getNodeData = function () {\n        return this.markerSelectionData;\n    };\n    AreaSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: datum.yKey\n        });\n    };\n    AreaSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var xKey = this.xKey;\n        var yKey = nodeDatum.yKey;\n        if (!xKey || !yKey) {\n            return '';\n        }\n        var _a = this, xName = _a.xName, yKeys = _a.yKeys, yNames = _a.yNames, fills = _a.fills, tooltip = _a.tooltip;\n        var _b = tooltip.renderer, tooltipRenderer = _b === void 0 ? this.tooltipRenderer : _b, tooltipFormat = tooltip.format;\n        var datum = nodeDatum.seriesDatum;\n        var xValue = datum[xKey];\n        var yValue = datum[yKey];\n        var yKeyIndex = yKeys.indexOf(yKey);\n        var yName = yNames[yKeyIndex];\n        var color = fills[yKeyIndex % fills.length];\n        var xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        var yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        var title = yName;\n        var content = xString + ': ' + yString;\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipFormat || tooltipRenderer) {\n            var params = {\n                datum: datum,\n                xKey: xKey,\n                xName: xName,\n                xValue: xValue,\n                yKey: yKey,\n                yValue: yValue,\n                yName: yName,\n                color: color\n            };\n            if (tooltipFormat) {\n                return toTooltipHtml({\n                    content: interpolate(tooltipFormat, params)\n                }, defaults);\n            }\n            if (tooltipRenderer) {\n                return toTooltipHtml(tooltipRenderer(params), defaults);\n            }\n        }\n        return toTooltipHtml(defaults);\n    };\n    AreaSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, data = _a.data, id = _a.id, xKey = _a.xKey, yKeys = _a.yKeys, yNames = _a.yNames, seriesItemEnabled = _a.seriesItemEnabled, marker = _a.marker, fills = _a.fills, strokes = _a.strokes, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length && xKey && yKeys.length) {\n            yKeys.forEach(function (yKey, index) {\n                legendData.push({\n                    id: id,\n                    itemId: yKey,\n                    enabled: seriesItemEnabled.get(yKey) || false,\n                    label: {\n                        text: yNames[index] || yKeys[index]\n                    },\n                    marker: {\n                        shape: marker.shape,\n                        fill: marker.fill || fills[index % fills.length],\n                        stroke: marker.stroke || strokes[index % strokes.length],\n                        fillOpacity: fillOpacity,\n                        strokeOpacity: strokeOpacity\n                    }\n                });\n            });\n        }\n    };\n    AreaSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n        this.seriesItemEnabled.set(itemId, enabled);\n        this.scheduleData();\n    };\n    AreaSeries.className = 'AreaSeries';\n    AreaSeries.type = 'area';\n    __decorate$L([\n        reactive('dataChange')\n    ], AreaSeries.prototype, \"fills\", void 0);\n    __decorate$L([\n        reactive('dataChange')\n    ], AreaSeries.prototype, \"strokes\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"fillOpacity\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"lineDash\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"lineDashOffset\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"xName\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"yNames\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"strokeWidth\", void 0);\n    __decorate$L([\n        reactive('update')\n    ], AreaSeries.prototype, \"shadow\", void 0);\n    return AreaSeries;\n}(CartesianSeries));\n\nvar __extends$1l = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Label = /** @class */ (function (_super) {\n    __extends$1l(Label, _super);\n    function Label() {\n        var _this = _super.call(this) || this;\n        _this.enabled = true;\n        _this.fontSize = 12;\n        _this.fontFamily = 'Verdana, sans-serif';\n        _this.color = 'rgba(70, 70, 70, 1)';\n        return _this;\n    }\n    __decorate$M([\n        reactive('change', 'dataChange')\n    ], Label.prototype, \"enabled\", void 0);\n    __decorate$M([\n        reactive('change')\n    ], Label.prototype, \"fontStyle\", void 0);\n    __decorate$M([\n        reactive('change')\n    ], Label.prototype, \"fontWeight\", void 0);\n    __decorate$M([\n        reactive('change')\n    ], Label.prototype, \"fontSize\", void 0);\n    __decorate$M([\n        reactive('change')\n    ], Label.prototype, \"fontFamily\", void 0);\n    __decorate$M([\n        reactive('change')\n    ], Label.prototype, \"color\", void 0);\n    return Label;\n}(Observable));\n\nvar __extends$1m = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar BarSeriesNodeTag;\n(function (BarSeriesNodeTag) {\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Bar\"] = 0] = \"Bar\";\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Label\"] = 1] = \"Label\";\n})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));\nvar BarSeriesLabel = /** @class */ (function (_super) {\n    __extends$1m(BarSeriesLabel, _super);\n    function BarSeriesLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$N([\n        reactive('change')\n    ], BarSeriesLabel.prototype, \"formatter\", void 0);\n    return BarSeriesLabel;\n}(Label));\nvar BarSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1m(BarSeriesTooltip, _super);\n    function BarSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$N([\n        reactive('change')\n    ], BarSeriesTooltip.prototype, \"renderer\", void 0);\n    return BarSeriesTooltip;\n}(SeriesTooltip));\nfunction flat(arr, target) {\n    if (target === void 0) { target = []; }\n    arr.forEach(function (v) {\n        if (Array.isArray(v)) {\n            flat(v, target);\n        }\n        else {\n            target.push(v);\n        }\n    });\n    return target;\n}\nvar BarSeries = /** @class */ (function (_super) {\n    __extends$1m(BarSeries, _super);\n    function BarSeries() {\n        var _a;\n        var _this = _super.call(this) || this;\n        // Need to put bar and label nodes into separate groups, because even though label nodes are\n        // created after the bar nodes, this only guarantees that labels will always be on top of bars\n        // on the first run. If on the next run more bars are added, they might clip the labels\n        // rendered during the previous run.\n        _this.rectGroup = _this.group.appendChild(new Group);\n        _this.textGroup = _this.group.appendChild(new Group);\n        _this.rectSelection = Selection.select(_this.rectGroup).selectAll();\n        _this.textSelection = Selection.select(_this.textGroup).selectAll();\n        _this.xData = [];\n        _this.yData = [];\n        _this.yDomain = [];\n        _this.label = new BarSeriesLabel();\n        /**\n         * The assumption is that the values will be reset (to `true`)\n         * in the {@link yKeys} setter.\n         */\n        _this.seriesItemEnabled = new Map();\n        _this.tooltip = new BarSeriesTooltip();\n        _this.flipXY = false;\n        _this.fills = [\n            '#c16068',\n            '#a2bf8a',\n            '#ebcc87',\n            '#80a0c3',\n            '#b58dae',\n            '#85c0d1'\n        ];\n        _this.strokes = [\n            '#874349',\n            '#718661',\n            '#a48f5f',\n            '#5a7088',\n            '#7f637a',\n            '#5d8692'\n        ];\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        /**\n         * Used to get the position of bars within each group.\n         */\n        _this.groupScale = new BandScale();\n        _this.directionKeys = (_a = {},\n            _a[ChartAxisDirection.X] = ['xKey'],\n            _a[ChartAxisDirection.Y] = ['yKeys'],\n            _a);\n        _this._xKey = '';\n        _this._xName = '';\n        _this.cumYKeyCount = [];\n        _this.flatYKeys = undefined; // only set when a user used a flat array for yKeys\n        _this.hideInLegend = [];\n        /**\n         * yKeys: [['coffee']] - regular bars, each category has a single bar that shows a value for coffee\n         * yKeys: [['coffee'], ['tea'], ['milk']] - each category has three bars that show values for coffee, tea and milk\n         * yKeys: [['coffee', 'tea', 'milk']] - each category has a single bar with three stacks that show values for coffee, tea and milk\n         * yKeys: [['coffee', 'tea', 'milk'], ['paper', 'ink']] - each category has 2 stacked bars,\n         *     first showing values for coffee, tea and milk and second values for paper and ink\n         */\n        _this._yKeys = [];\n        _this._grouped = false;\n        /**\n         * A map of `yKeys` to their names (used in legends and tooltips).\n         * For example, if a key is `product_name` it's name can be a more presentable `Product Name`.\n         */\n        _this._yNames = {};\n        _this._strokeWidth = 1;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.addEventListener('update', _this.update);\n        _this.label.enabled = false;\n        _this.label.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    BarSeries.prototype.getKeys = function (direction) {\n        var _this = this;\n        var directionKeys = this.directionKeys;\n        var keys = directionKeys && directionKeys[this.flipXY ? flipChartAxisDirection(direction) : direction];\n        var values = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var value = _this[key];\n                if (value) {\n                    if (Array.isArray(value)) {\n                        values = values.concat(flat(value));\n                    }\n                    else {\n                        values.push(value);\n                    }\n                }\n            });\n        }\n        return values;\n    };\n    Object.defineProperty(BarSeries.prototype, \"xKey\", {\n        get: function () {\n            return this._xKey;\n        },\n        set: function (value) {\n            if (this._xKey !== value) {\n                this._xKey = value;\n                this.xData = [];\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"xName\", {\n        get: function () {\n            return this._xName;\n        },\n        set: function (value) {\n            if (this._xName !== value) {\n                this._xName = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"yKeys\", {\n        get: function () {\n            return this._yKeys;\n        },\n        set: function (yKeys) {\n            var _this = this;\n            if (!equal(this._yKeys, yKeys)) {\n                // Convert from flat y-keys to grouped y-keys.\n                if (yKeys.length && !Array.isArray(yKeys[0])) {\n                    var keys = this.flatYKeys = yKeys;\n                    if (this.grouped) {\n                        yKeys = keys.map(function (k) { return [k]; });\n                    }\n                    else {\n                        yKeys = [keys];\n                    }\n                }\n                else {\n                    this.flatYKeys = undefined;\n                }\n                this._yKeys = yKeys;\n                var prevYKeyCount_1 = 0;\n                this.cumYKeyCount = [];\n                var visibleStacks_1 = [];\n                yKeys.forEach(function (stack, index) {\n                    if (stack.length > 0) {\n                        visibleStacks_1.push(String(index));\n                    }\n                    _this.cumYKeyCount.push(prevYKeyCount_1);\n                    prevYKeyCount_1 += stack.length;\n                });\n                this.yData = [];\n                var seriesItemEnabled_1 = this.seriesItemEnabled;\n                seriesItemEnabled_1.clear();\n                yKeys.forEach(function (stack) {\n                    stack.forEach(function (yKey) { return seriesItemEnabled_1.set(yKey, true); });\n                });\n                var groupScale = this.groupScale;\n                groupScale.domain = visibleStacks_1;\n                groupScale.padding = 0.1;\n                groupScale.round = true;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"grouped\", {\n        get: function () {\n            return this._grouped;\n        },\n        set: function (value) {\n            if (this._grouped !== value) {\n                this._grouped = value;\n                if (this.flatYKeys) {\n                    this.yKeys = this.flatYKeys;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"yNames\", {\n        get: function () {\n            return this._yNames;\n        },\n        set: function (values) {\n            if (Array.isArray(values) && this.flatYKeys) {\n                var map_1 = {};\n                this.flatYKeys.forEach(function (k, i) {\n                    map_1[k] = values[i];\n                });\n                values = map_1;\n            }\n            this._yNames = values;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BarSeries.prototype.setColors = function (fills, strokes) {\n        this.fills = fills;\n        this.strokes = strokes;\n    };\n    Object.defineProperty(BarSeries.prototype, \"normalizedTo\", {\n        get: function () {\n            return this._normalizedTo;\n        },\n        set: function (value) {\n            var absValue = value ? Math.abs(value) : undefined;\n            if (this._normalizedTo !== absValue) {\n                this._normalizedTo = absValue;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BarSeries.prototype, \"shadow\", {\n        get: function () {\n            return this._shadow;\n        },\n        set: function (value) {\n            if (this._shadow !== value) {\n                this._shadow = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BarSeries.prototype.onHighlightChange = function () {\n        this.updateRectNodes();\n    };\n    BarSeries.prototype.processData = function () {\n        var _a = this, xKey = _a.xKey, yKeys = _a.yKeys, seriesItemEnabled = _a.seriesItemEnabled;\n        var data = xKey && yKeys.length && this.data ? this.data : [];\n        var keysFound = true; // only warn once\n        this.xData = data.map(function (datum) {\n            if (keysFound && !(xKey in datum)) {\n                keysFound = false;\n                console.warn(\"The key '\" + xKey + \"' was not found in the data: \", datum);\n            }\n            return datum[xKey];\n        });\n        this.yData = data.map(function (datum) { return yKeys.map(function (stack) {\n            return stack.map(function (yKey) {\n                if (keysFound && !(yKey in datum)) {\n                    keysFound = false;\n                    console.warn(\"The key '\" + yKey + \"' was not found in the data: \", datum);\n                }\n                var value = datum[yKey];\n                return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n            });\n        }); });\n        // Used for normalization of stacked bars. Contains min/max values for each stack in each group,\n        // where min is zero and max is a positive total of all values in the stack\n        // or min is a negative total of all values in the stack and max is zero.\n        var yMinMax = this.yData.map(function (group) { return group.map(function (stack) { return findMinMax(stack); }); });\n        var _b = this, yData = _b.yData, normalizedTo = _b.normalizedTo;\n        var yLargestMinMax = this.findLargestMinMax(yMinMax);\n        var yMin;\n        var yMax;\n        if (normalizedTo && isFinite(normalizedTo)) {\n            yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n            yMax = normalizedTo;\n            yData.forEach(function (group, i) {\n                group.forEach(function (stack, j) {\n                    stack.forEach(function (y, k) {\n                        if (y < 0) {\n                            stack[k] = -y / yMinMax[i][j].min * normalizedTo;\n                        }\n                        else {\n                            stack[k] = y / yMinMax[i][j].max * normalizedTo;\n                        }\n                    });\n                });\n            });\n        }\n        else {\n            yMin = yLargestMinMax.min;\n            yMax = yLargestMinMax.max;\n        }\n        this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n        this.fireEvent({ type: 'dataProcessed' });\n        return true;\n    };\n    BarSeries.prototype.findLargestMinMax = function (groups) {\n        var tallestStackMin = 0;\n        var tallestStackMax = 0;\n        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n            var group = groups_1[_i];\n            for (var _a = 0, group_1 = group; _a < group_1.length; _a++) {\n                var stack = group_1[_a];\n                if (stack.min < tallestStackMin) {\n                    tallestStackMin = stack.min;\n                }\n                if (stack.max > tallestStackMax) {\n                    tallestStackMax = stack.max;\n                }\n            }\n        }\n        return { min: tallestStackMin, max: tallestStackMax };\n    };\n    BarSeries.prototype.getDomain = function (direction) {\n        if (this.flipXY) {\n            direction = flipChartAxisDirection(direction);\n        }\n        if (direction === ChartAxisDirection.X) {\n            return this.xData;\n        }\n        else {\n            return this.yDomain;\n        }\n    };\n    BarSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: datum.yKey\n        });\n    };\n    BarSeries.prototype.generateNodeData = function () {\n        var _this = this;\n        if (!this.data) {\n            return [];\n        }\n        var flipXY = this.flipXY;\n        var xAxis = flipXY ? this.yAxis : this.xAxis;\n        var yAxis = flipXY ? this.xAxis : this.yAxis;\n        var xScale = xAxis.scale;\n        var yScale = yAxis.scale;\n        var _a = this, groupScale = _a.groupScale, yKeys = _a.yKeys, cumYKeyCount = _a.cumYKeyCount, fills = _a.fills, strokes = _a.strokes, strokeWidth = _a.strokeWidth, seriesItemEnabled = _a.seriesItemEnabled, data = _a.data, xData = _a.xData, yData = _a.yData;\n        var label = this.label;\n        var labelFontStyle = label.fontStyle;\n        var labelFontWeight = label.fontWeight;\n        var labelFontSize = label.fontSize;\n        var labelFontFamily = label.fontFamily;\n        var labelColor = label.color;\n        var labelFormatter = label.formatter;\n        groupScale.range = [0, xScale.bandwidth];\n        var barWidth =  groupScale.bandwidth ;\n        var nodeData = [];\n        xData.forEach(function (group, groupIndex) {\n            var seriesDatum = data[groupIndex];\n            var x = xScale.convert(group);\n            var groupYs = yData[groupIndex]; // y-data for groups of stacks\n            for (var stackIndex = 0; stackIndex < groupYs.length; stackIndex++) {\n                var stackYs = groupYs[stackIndex]; // y-data for a stack withing a group\n                var prevMinY = 0;\n                var prevMaxY = 0;\n                for (var levelIndex = 0; levelIndex < stackYs.length; levelIndex++) {\n                    var currY = stackYs[levelIndex];\n                    var yKey = yKeys[stackIndex][levelIndex];\n                    var barX =  x + groupScale.convert(String(stackIndex)) ;\n                    // Bars outside of visible range are not rendered, so we generate node data\n                    // only for the visible subset of user data.\n                    if (!xAxis.inRange(barX, barWidth)) {\n                        continue;\n                    }\n                    var prevY = currY < 0 ? prevMinY : prevMaxY;\n                    var y = yScale.convert(prevY + currY);\n                    var bottomY = yScale.convert(prevY);\n                    var yValue = seriesDatum[yKey]; // unprocessed y-value\n                    var yValueIsNumber = typeof yValue === 'number';\n                    var labelText = void 0;\n                    if (labelFormatter) {\n                        labelText = labelFormatter({ value: yValueIsNumber ? yValue : undefined });\n                    }\n                    else {\n                        labelText = yValueIsNumber && isFinite(yValue) ? yValue.toFixed(2) : '';\n                    }\n                    var colorIndex = cumYKeyCount[stackIndex] + levelIndex;\n                    nodeData.push({\n                        series: _this,\n                        seriesDatum: seriesDatum,\n                        yValue: yValue,\n                        yKey: yKey,\n                        x: flipXY ? Math.min(y, bottomY) : barX,\n                        y: flipXY ? barX : Math.min(y, bottomY),\n                        width: flipXY ? Math.abs(bottomY - y) : barWidth,\n                        height: flipXY ? barWidth : Math.abs(bottomY - y),\n                        fill: fills[colorIndex % fills.length],\n                        stroke: strokes[colorIndex % strokes.length],\n                        strokeWidth: strokeWidth,\n                        label: seriesItemEnabled.get(yKey) && labelText ? {\n                            text: labelText,\n                            fontStyle: labelFontStyle,\n                            fontWeight: labelFontWeight,\n                            fontSize: labelFontSize,\n                            fontFamily: labelFontFamily,\n                            fill: labelColor,\n                            x: flipXY ? y + (yValue >= 0 ? -1 : 1) * Math.abs(bottomY - y) / 2 : barX + barWidth / 2,\n                            y: flipXY ? barX + barWidth / 2 : y + (yValue >= 0 ? 1 : -1) * Math.abs(bottomY - y) / 2\n                        } : undefined\n                    });\n                    if (currY < 0) {\n                        prevMinY += currY;\n                    }\n                    else {\n                        prevMaxY += currY;\n                    }\n                }\n            }\n        });\n        return nodeData;\n    };\n    BarSeries.prototype.update = function () {\n        var _a = this, visible = _a.visible, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis, xData = _a.xData, yData = _a.yData;\n        this.group.visible = visible;\n        if (!chart || chart.layoutPending || chart.dataPending ||\n            !xAxis || !yAxis || !visible || !xData.length || !yData.length) {\n            return;\n        }\n        var nodeData = this.generateNodeData();\n        this.updateRectSelection(nodeData);\n        this.updateRectNodes();\n        this.updateTextSelection(nodeData);\n        this.updateTextNodes();\n    };\n    BarSeries.prototype.updateRectSelection = function (selectionData) {\n        var updateRects = this.rectSelection.setData(selectionData);\n        updateRects.exit.remove();\n        var enterRects = updateRects.enter.append(Rect).each(function (rect) {\n            rect.tag = BarSeriesNodeTag.Bar;\n            rect.crisp = true;\n        });\n        this.rectSelection = updateRects.merge(enterRects);\n    };\n    BarSeries.prototype.updateRectNodes = function () {\n        var _this = this;\n        if (!this.chart) {\n            return;\n        }\n        var _a = this, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, _b = _a.highlightStyle, fill = _b.fill, stroke = _b.stroke, shadow = _a.shadow, formatter = _a.formatter, xKey = _a.xKey, flipXY = _a.flipXY;\n        var highlightedDatum = this.chart.highlightedDatum;\n        this.rectSelection.each(function (rect, datum) {\n            var highlighted = datum === highlightedDatum;\n            var rectFill = highlighted && fill !== undefined ? fill : datum.fill;\n            var rectStroke = highlighted && stroke !== undefined ? stroke : datum.stroke;\n            var format = undefined;\n            if (formatter) {\n                format = formatter({\n                    datum: datum.seriesDatum,\n                    fill: rectFill,\n                    stroke: rectStroke,\n                    strokeWidth: datum.strokeWidth,\n                    highlighted: highlighted,\n                    xKey: xKey,\n                    yKey: datum.yKey\n                });\n            }\n            rect.x = datum.x;\n            rect.y = datum.y;\n            rect.width = datum.width;\n            rect.height = datum.height;\n            rect.fill = format && format.fill || rectFill;\n            rect.stroke = format && format.stroke || rectStroke;\n            rect.strokeWidth = format && format.strokeWidth !== undefined ? format.strokeWidth : datum.strokeWidth;\n            rect.fillOpacity = fillOpacity;\n            rect.strokeOpacity = strokeOpacity;\n            rect.lineDash = _this.lineDash;\n            rect.lineDashOffset = _this.lineDashOffset;\n            rect.fillShadow = shadow;\n            // Prevent stroke from rendering for zero height columns and zero width bars.\n            rect.visible = flipXY ? datum.width > 0 : datum.height > 0;\n        });\n    };\n    BarSeries.prototype.updateTextSelection = function (selectionData) {\n        var updateTexts = this.textSelection.setData(selectionData);\n        updateTexts.exit.remove();\n        var enterTexts = updateTexts.enter.append(Text).each(function (text) {\n            text.tag = BarSeriesNodeTag.Label;\n            text.pointerEvents = PointerEvents.None;\n            text.textAlign = 'center';\n            text.textBaseline = 'middle';\n        });\n        this.textSelection = updateTexts.merge(enterTexts);\n    };\n    BarSeries.prototype.updateTextNodes = function () {\n        var labelEnabled = this.label.enabled;\n        this.textSelection.each(function (text, datum) {\n            var label = datum.label;\n            if (label && labelEnabled) {\n                text.fontStyle = label.fontStyle;\n                text.fontWeight = label.fontWeight;\n                text.fontSize = label.fontSize;\n                text.fontFamily = label.fontFamily;\n                text.text = label.text;\n                text.x = label.x;\n                text.y = label.y;\n                text.fill = label.fill;\n                text.visible = true;\n            }\n            else {\n                text.visible = false;\n            }\n        });\n    };\n    BarSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var _a = this, xKey = _a.xKey, yKeys = _a.yKeys;\n        var yKey = nodeDatum.yKey;\n        if (!xKey || !yKey) {\n            return '';\n        }\n        var yKeyIndex = 0;\n        for (var _i = 0, yKeys_1 = yKeys; _i < yKeys_1.length; _i++) {\n            var stack = yKeys_1[_i];\n            var i = stack.indexOf(yKey);\n            if (i >= 0) {\n                yKeyIndex += i;\n                break;\n            }\n            yKeyIndex += stack.length;\n        }\n        var _b = this, xName = _b.xName, yNames = _b.yNames, fills = _b.fills, tooltip = _b.tooltip;\n        var _c = tooltip.renderer, tooltipRenderer = _c === void 0 ? this.tooltipRenderer : _c; // TODO: remove deprecated tooltipRenderer\n        var datum = nodeDatum.seriesDatum;\n        var yName = yNames[yKey];\n        var color = fills[yKeyIndex % fills.length];\n        var xValue = datum[xKey];\n        var yValue = datum[yKey];\n        var xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        var yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        var title = yName;\n        var content = xString + ': ' + yString;\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum: datum,\n                xKey: xKey,\n                xValue: xValue,\n                xName: xName,\n                yKey: yKey,\n                yValue: yValue,\n                yName: yName,\n                color: color\n            }), defaults);\n        }\n        return toTooltipHtml(defaults);\n    };\n    BarSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, id = _a.id, data = _a.data, xKey = _a.xKey, yKeys = _a.yKeys, yNames = _a.yNames, cumYKeyCount = _a.cumYKeyCount, seriesItemEnabled = _a.seriesItemEnabled, hideInLegend = _a.hideInLegend, fills = _a.fills, strokes = _a.strokes, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length && xKey && yKeys.length) {\n            this.yKeys.forEach(function (stack, stackIndex) {\n                stack.forEach(function (yKey, levelIndex) {\n                    if (hideInLegend.indexOf(yKey) < 0) {\n                        var colorIndex = cumYKeyCount[stackIndex] + levelIndex;\n                        legendData.push({\n                            id: id,\n                            itemId: yKey,\n                            enabled: seriesItemEnabled.get(yKey) || false,\n                            label: {\n                                text: yNames[yKey] || yKey\n                            },\n                            marker: {\n                                fill: fills[colorIndex % fills.length],\n                                stroke: strokes[colorIndex % strokes.length],\n                                fillOpacity: fillOpacity,\n                                strokeOpacity: strokeOpacity\n                            }\n                        });\n                    }\n                });\n            });\n        }\n    };\n    BarSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n        var seriesItemEnabled = this.seriesItemEnabled;\n        seriesItemEnabled.set(itemId, enabled);\n        var yKeys = this.yKeys.map(function (stack) { return stack.slice(); }); // deep clone\n        seriesItemEnabled.forEach(function (enabled, yKey) {\n            if (!enabled) {\n                yKeys.forEach(function (stack) {\n                    var index = stack.indexOf(yKey);\n                    if (index >= 0) {\n                        stack.splice(index, 1);\n                    }\n                });\n            }\n        });\n        var visibleStacks = [];\n        yKeys.forEach(function (stack, index) {\n            if (stack.length > 0) {\n                visibleStacks.push(String(index));\n            }\n        });\n        this.groupScale.domain = visibleStacks;\n        this.scheduleData();\n    };\n    BarSeries.className = 'BarSeries';\n    BarSeries.type = 'bar';\n    __decorate$N([\n        reactive('layoutChange')\n    ], BarSeries.prototype, \"flipXY\", void 0);\n    __decorate$N([\n        reactive('dataChange')\n    ], BarSeries.prototype, \"fills\", void 0);\n    __decorate$N([\n        reactive('dataChange')\n    ], BarSeries.prototype, \"strokes\", void 0);\n    __decorate$N([\n        reactive('layoutChange')\n    ], BarSeries.prototype, \"fillOpacity\", void 0);\n    __decorate$N([\n        reactive('layoutChange')\n    ], BarSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate$N([\n        reactive('update')\n    ], BarSeries.prototype, \"lineDash\", void 0);\n    __decorate$N([\n        reactive('update')\n    ], BarSeries.prototype, \"lineDashOffset\", void 0);\n    __decorate$N([\n        reactive('update')\n    ], BarSeries.prototype, \"formatter\", void 0);\n    __decorate$N([\n        reactive('layoutChange')\n    ], BarSeries.prototype, \"hideInLegend\", void 0);\n    return BarSeries;\n}(CartesianSeries));\n\nvar __extends$1n = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LineSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1n(LineSeriesTooltip, _super);\n    function LineSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$O([\n        reactive('change')\n    ], LineSeriesTooltip.prototype, \"renderer\", void 0);\n    __decorate$O([\n        reactive('change')\n    ], LineSeriesTooltip.prototype, \"format\", void 0);\n    return LineSeriesTooltip;\n}(SeriesTooltip));\nvar LineSeries = /** @class */ (function (_super) {\n    __extends$1n(LineSeries, _super);\n    function LineSeries() {\n        var _this = _super.call(this) || this;\n        _this.xDomain = [];\n        _this.yDomain = [];\n        _this.xData = [];\n        _this.yData = [];\n        _this.lineNode = new Path();\n        // We use groups for this selection even though each group only contains a marker ATM\n        // because in the future we might want to add label support as well.\n        _this.nodeSelection = Selection.select(_this.group).selectAll();\n        _this.nodeData = [];\n        _this.marker = new CartesianSeriesMarker();\n        _this.stroke = '#874349';\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        _this.strokeWidth = 2;\n        _this.strokeOpacity = 1;\n        _this.tooltip = new LineSeriesTooltip();\n        _this._xKey = '';\n        _this.xName = '';\n        _this._yKey = '';\n        _this.yName = '';\n        _this.highlightStyle = { fill: 'yellow' };\n        var lineNode = _this.lineNode;\n        lineNode.fill = undefined;\n        lineNode.lineJoin = 'round';\n        lineNode.pointerEvents = PointerEvents.None;\n        _this.group.append(lineNode);\n        _this.addEventListener('update', _this.update);\n        var marker = _this.marker;\n        marker.fill = '#c16068';\n        marker.stroke = '#874349';\n        marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n        marker.addPropertyListener('enabled', _this.onMarkerEnabledChange, _this);\n        marker.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    LineSeries.prototype.onMarkerShapeChange = function () {\n        this.nodeSelection = this.nodeSelection.setData([]);\n        this.nodeSelection.exit.remove();\n        this.update();\n        this.fireEvent({ type: 'legendChange' });\n    };\n    LineSeries.prototype.onMarkerEnabledChange = function (event) {\n        if (!event.value) {\n            this.nodeSelection = this.nodeSelection.setData([]);\n            this.nodeSelection.exit.remove();\n        }\n    };\n    LineSeries.prototype.setColors = function (fills, strokes) {\n        this.stroke = fills[0];\n        this.marker.stroke = strokes[0];\n        this.marker.fill = fills[0];\n    };\n    Object.defineProperty(LineSeries.prototype, \"xKey\", {\n        get: function () {\n            return this._xKey;\n        },\n        set: function (value) {\n            if (this._xKey !== value) {\n                this._xKey = value;\n                this.xData = [];\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LineSeries.prototype, \"yKey\", {\n        get: function () {\n            return this._yKey;\n        },\n        set: function (value) {\n            if (this._yKey !== value) {\n                this._yKey = value;\n                this.yData = [];\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LineSeries.prototype.processData = function () {\n        var _a = this, xAxis = _a.xAxis, yAxis = _a.yAxis, xKey = _a.xKey, yKey = _a.yKey, xData = _a.xData, yData = _a.yData;\n        var data = xKey && yKey && this.data ? this.data : [];\n        if (!xAxis) {\n            return false;\n        }\n        var isContinuousX = xAxis.scale instanceof ContinuousScale;\n        var isContinuousY = yAxis.scale instanceof ContinuousScale;\n        xData.length = 0;\n        yData.length = 0;\n        for (var i = 0, n = data.length; i < n; i++) {\n            var datum = data[i];\n            var x = datum[xKey];\n            var y = datum[yKey];\n            xData.push(x);\n            yData.push(y);\n        }\n        this.xDomain = isContinuousX ? this.fixNumericExtent(numericExtent(xData), 'x') : xData;\n        this.yDomain = isContinuousY ? this.fixNumericExtent(numericExtent(yData), 'y') : yData;\n        return true;\n    };\n    LineSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.xDomain;\n        }\n        return this.yDomain;\n    };\n    LineSeries.prototype.onHighlightChange = function () {\n        this.updateNodes();\n    };\n    LineSeries.prototype.update = function () {\n        this.group.visible = this.visible;\n        var _a = this, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis;\n        if (!chart || chart.layoutPending || chart.dataPending || !xAxis || !yAxis) {\n            return;\n        }\n        this.updateLinePath(); // this will generate node data too\n        this.updateNodeSelection();\n        this.updateNodes();\n    };\n    LineSeries.prototype.getXYDatums = function (i, xData, yData, xScale, yScale) {\n        var isContinuousX = xScale instanceof ContinuousScale;\n        var isContinuousY = yScale instanceof ContinuousScale;\n        var xDatum = xData[i];\n        var yDatum = yData[i];\n        var noDatum = yDatum == null || (isContinuousY && (isNaN(yDatum) || !isFinite(yDatum))) ||\n            xDatum == null || (isContinuousX && (isNaN(xDatum) || !isFinite(xDatum)));\n        return noDatum ? undefined : [xDatum, yDatum];\n    };\n    LineSeries.prototype.updateLinePath = function () {\n        if (!this.data) {\n            return;\n        }\n        var _a = this, xAxis = _a.xAxis, yAxis = _a.yAxis, data = _a.data, xData = _a.xData, yData = _a.yData, lineNode = _a.lineNode;\n        var xScale = xAxis.scale;\n        var yScale = yAxis.scale;\n        var xOffset = (xScale.bandwidth || 0) / 2;\n        var yOffset = (yScale.bandwidth || 0) / 2;\n        var linePath = lineNode.path;\n        var nodeData = [];\n        linePath.clear();\n        var moveTo = true;\n        var prevXInRange = undefined;\n        var nextXYDatums = undefined;\n        for (var i = 0; i < xData.length; i++) {\n            var xyDatums = nextXYDatums || this.getXYDatums(i, xData, yData, xScale, yScale);\n            if (!xyDatums) {\n                prevXInRange = undefined;\n                moveTo = true;\n            }\n            else {\n                var xDatum = xyDatums[0], yDatum = xyDatums[1];\n                var x = xScale.convert(xDatum) + xOffset;\n                var tolerance = (xScale.bandwidth || (this.marker.size * 0.5 + (this.marker.strokeWidth || 0))) + 1;\n                nextXYDatums = this.getXYDatums(i + 1, xData, yData, xScale, yScale);\n                var xInRange = xAxis.inRangeEx(x, 0, tolerance);\n                var nextXInRange = nextXYDatums && xAxis.inRangeEx(xScale.convert(nextXYDatums[0]) + xOffset, 0, tolerance);\n                if (xInRange === -1 && nextXInRange === -1) {\n                    moveTo = true;\n                    continue;\n                }\n                if (xInRange === 1 && prevXInRange === 1) {\n                    moveTo = true;\n                    continue;\n                }\n                prevXInRange = xInRange;\n                var y = yScale.convert(yDatum) + yOffset;\n                if (moveTo) {\n                    linePath.moveTo(x, y);\n                    moveTo = false;\n                }\n                else {\n                    linePath.lineTo(x, y);\n                }\n                nodeData.push({\n                    series: this,\n                    seriesDatum: data[i],\n                    point: { x: x, y: y }\n                });\n            }\n        }\n        lineNode.stroke = this.stroke;\n        lineNode.strokeWidth = this.strokeWidth;\n        lineNode.lineDash = this.lineDash;\n        lineNode.lineDashOffset = this.lineDashOffset;\n        lineNode.strokeOpacity = this.strokeOpacity;\n        // Used by marker nodes and for hit-testing even when not using markers\n        // when `chart.tooltipTracking` is true.\n        this.nodeData = nodeData;\n    };\n    LineSeries.prototype.updateNodeSelection = function () {\n        var marker = this.marker;\n        var nodeData = marker.shape ? this.nodeData : [];\n        var MarkerShape = getMarker(marker.shape);\n        var updateSelection = this.nodeSelection.setData(nodeData);\n        updateSelection.exit.remove();\n        var enterSelection = updateSelection.enter.append(Group);\n        enterSelection.append(MarkerShape);\n        this.nodeSelection = updateSelection.merge(enterSelection);\n    };\n    LineSeries.prototype.updateNodes = function () {\n        if (!this.chart) {\n            return;\n        }\n        var _a = this, marker = _a.marker, xKey = _a.xKey, yKey = _a.yKey, stroke = _a.stroke, strokeWidth = _a.strokeWidth;\n        var MarkerShape = getMarker(marker.shape);\n        var highlightedDatum = this.chart.highlightedDatum;\n        var _b = this.highlightStyle, highlightFill = _b.fill, highlightStroke = _b.stroke;\n        var markerFormatter = marker.formatter;\n        var markerSize = marker.size;\n        var markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : strokeWidth;\n        this.nodeSelection.selectByClass(MarkerShape)\n            .each(function (node, datum) {\n            var highlighted = datum === highlightedDatum;\n            var markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;\n            var markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || stroke;\n            var markerFormat = undefined;\n            if (markerFormatter) {\n                markerFormat = markerFormatter({\n                    datum: datum.seriesDatum,\n                    xKey: xKey,\n                    yKey: yKey,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted: highlighted\n                });\n            }\n            node.fill = markerFormat && markerFormat.fill || markerFill;\n            node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n            node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                ? markerFormat.strokeWidth\n                : markerStrokeWidth;\n            node.size = markerFormat && markerFormat.size !== undefined\n                ? markerFormat.size\n                : markerSize;\n            node.translationX = datum.point.x;\n            node.translationY = datum.point.y;\n            node.visible = marker.enabled && node.size > 0;\n        });\n    };\n    LineSeries.prototype.getNodeData = function () {\n        return this.nodeData;\n    };\n    LineSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: this.yKey\n        });\n    };\n    LineSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var _a = this, xKey = _a.xKey, yKey = _a.yKey;\n        if (!xKey || !yKey) {\n            return '';\n        }\n        var _b = this, xName = _b.xName, yName = _b.yName, color = _b.stroke, tooltip = _b.tooltip;\n        var _c = tooltip.renderer, tooltipRenderer = _c === void 0 ? this.tooltipRenderer : _c, tooltipFormat = tooltip.format;\n        var datum = nodeDatum.seriesDatum;\n        var xValue = datum[xKey];\n        var yValue = datum[yKey];\n        var xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        var yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        var title = this.title || yName;\n        var content = xString + ': ' + yString;\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipFormat || tooltipRenderer) {\n            var params = {\n                datum: datum,\n                xKey: xKey,\n                xValue: xValue,\n                xName: xName,\n                yKey: yKey,\n                yValue: yValue,\n                yName: yName,\n                title: title,\n                color: color\n            };\n            if (tooltipFormat) {\n                return toTooltipHtml({\n                    content: interpolate(tooltipFormat, params)\n                }, defaults);\n            }\n            if (tooltipRenderer) {\n                return toTooltipHtml(tooltipRenderer(params), defaults);\n            }\n        }\n        return toTooltipHtml(defaults);\n    };\n    LineSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, id = _a.id, data = _a.data, xKey = _a.xKey, yKey = _a.yKey, yName = _a.yName, visible = _a.visible, title = _a.title, marker = _a.marker, stroke = _a.stroke, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length && xKey && yKey) {\n            legendData.push({\n                id: id,\n                itemId: undefined,\n                enabled: visible,\n                label: {\n                    text: title || yName || yKey\n                },\n                marker: {\n                    shape: marker.shape,\n                    fill: marker.fill || 'rgba(0, 0, 0, 0)',\n                    stroke: marker.stroke || stroke || 'rgba(0, 0, 0, 0)',\n                    fillOpacity: 1,\n                    strokeOpacity: strokeOpacity\n                }\n            });\n        }\n    };\n    LineSeries.className = 'LineSeries';\n    LineSeries.type = 'line';\n    __decorate$O([\n        reactive('layoutChange')\n    ], LineSeries.prototype, \"title\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"stroke\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"lineDash\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"lineDashOffset\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"strokeWidth\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"xName\", void 0);\n    __decorate$O([\n        reactive('update')\n    ], LineSeries.prototype, \"yName\", void 0);\n    return LineSeries;\n}(CartesianSeries));\n\nvar __extends$1o = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ScatterSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1o(ScatterSeriesTooltip, _super);\n    function ScatterSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$P([\n        reactive('change')\n    ], ScatterSeriesTooltip.prototype, \"renderer\", void 0);\n    return ScatterSeriesTooltip;\n}(SeriesTooltip));\nvar ScatterSeries = /** @class */ (function (_super) {\n    __extends$1o(ScatterSeries, _super);\n    function ScatterSeries() {\n        var _this = _super.call(this) || this;\n        _this.xDomain = [];\n        _this.yDomain = [];\n        _this.xData = [];\n        _this.yData = [];\n        _this.sizeData = [];\n        _this.sizeScale = new LinearScale();\n        _this.nodeSelection = Selection.select(_this.group).selectAll();\n        _this.nodeData = [];\n        _this.marker = new CartesianSeriesMarker();\n        _this._fill = '#c16068';\n        _this._stroke = '#874349';\n        _this._strokeWidth = 2;\n        _this._fillOpacity = 1;\n        _this._strokeOpacity = 1;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.xKey = '';\n        _this.yKey = '';\n        _this.xName = '';\n        _this.yName = '';\n        _this.sizeName = 'Size';\n        _this.labelName = 'Label';\n        _this.tooltip = new ScatterSeriesTooltip();\n        var marker = _this.marker;\n        marker.addPropertyListener('shape', _this.onMarkerShapeChange, _this);\n        marker.addEventListener('change', _this.update, _this);\n        _this.addPropertyListener('xKey', function () { return _this.xData = []; });\n        _this.addPropertyListener('yKey', function () { return _this.yData = []; });\n        _this.addPropertyListener('sizeKey', function () { return _this.sizeData = []; });\n        return _this;\n    }\n    Object.defineProperty(ScatterSeries.prototype, \"fill\", {\n        get: function () {\n            return this._fill;\n        },\n        set: function (value) {\n            if (this._fill !== value) {\n                this._fill = value;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScatterSeries.prototype, \"stroke\", {\n        get: function () {\n            return this._stroke;\n        },\n        set: function (value) {\n            if (this._stroke !== value) {\n                this._stroke = value;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScatterSeries.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScatterSeries.prototype, \"fillOpacity\", {\n        get: function () {\n            return this._fillOpacity;\n        },\n        set: function (value) {\n            if (this._fillOpacity !== value) {\n                this._fillOpacity = value;\n                this.scheduleLayout();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScatterSeries.prototype, \"strokeOpacity\", {\n        get: function () {\n            return this._strokeOpacity;\n        },\n        set: function (value) {\n            if (this._strokeOpacity !== value) {\n                this._strokeOpacity = value;\n                this.scheduleLayout();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScatterSeries.prototype.onHighlightChange = function () {\n        this.updateNodes();\n    };\n    ScatterSeries.prototype.onMarkerShapeChange = function () {\n        this.nodeSelection = this.nodeSelection.setData([]);\n        this.nodeSelection.exit.remove();\n        this.update();\n        this.fireEvent({ type: 'legendChange' });\n    };\n    ScatterSeries.prototype.setColors = function (fills, strokes) {\n        this.fill = fills[0];\n        this.stroke = strokes[0];\n        this.marker.fill = fills[0];\n        this.marker.stroke = strokes[0];\n    };\n    ScatterSeries.prototype.processData = function () {\n        var _a = this, xKey = _a.xKey, yKey = _a.yKey, sizeKey = _a.sizeKey, xAxis = _a.xAxis, yAxis = _a.yAxis, marker = _a.marker;\n        var data = xKey && yKey && this.data ? this.data : [];\n        this.xData = data.map(function (d) { return d[xKey]; });\n        this.yData = data.map(function (d) { return d[yKey]; });\n        if (sizeKey) {\n            this.sizeData = data.map(function (d) { return d[sizeKey]; });\n        }\n        else {\n            this.sizeData = [];\n        }\n        this.sizeScale.domain = marker.domain ? marker.domain : finiteExtent(this.sizeData) || [1, 1];\n        if (xAxis.scale instanceof ContinuousScale) {\n            this.xDomain = this.fixNumericExtent(finiteExtent(this.xData), 'x');\n        }\n        else {\n            this.xDomain = this.xData;\n        }\n        if (yAxis.scale instanceof ContinuousScale) {\n            this.yDomain = this.fixNumericExtent(finiteExtent(this.yData), 'y');\n        }\n        else {\n            this.yDomain = this.yData;\n        }\n        return true;\n    };\n    ScatterSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.xDomain;\n        }\n        else {\n            return this.yDomain;\n        }\n    };\n    ScatterSeries.prototype.getNodeData = function () {\n        return this.nodeData;\n    };\n    ScatterSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: this.yKey,\n            sizeKey: this.sizeKey\n        });\n    };\n    ScatterSeries.prototype.generateNodeData = function () {\n        if (!this.data) {\n            return [];\n        }\n        var _a = this, xAxis = _a.xAxis, yAxis = _a.yAxis;\n        var xScale = xAxis.scale;\n        var yScale = yAxis.scale;\n        var isContinuousX = xScale instanceof ContinuousScale;\n        var isContinuousY = yScale instanceof ContinuousScale;\n        var xOffset = (xScale.bandwidth || 0) / 2;\n        var yOffset = (yScale.bandwidth || 0) / 2;\n        var _b = this, data = _b.data, xData = _b.xData, yData = _b.yData, sizeData = _b.sizeData, sizeScale = _b.sizeScale, marker = _b.marker;\n        sizeScale.range = [marker.size, marker.maxSize];\n        var nodeData = [];\n        for (var i = 0; i < xData.length; i++) {\n            var xDatum = xData[i];\n            var yDatum = yData[i];\n            var noDatum = yDatum == null || (isContinuousY && (isNaN(yDatum) || !isFinite(yDatum))) ||\n                xDatum == null || (isContinuousX && (isNaN(xDatum) || !isFinite(xDatum)));\n            if (noDatum) {\n                continue;\n            }\n            var x = xScale.convert(xDatum) + xOffset;\n            if (!xAxis.inRange(x)) {\n                continue;\n            }\n            nodeData.push({\n                series: this,\n                seriesDatum: data[i],\n                point: {\n                    x: x,\n                    y: yScale.convert(yData[i]) + yOffset\n                },\n                size: sizeData.length ? sizeScale.convert(sizeData[i]) : marker.size\n            });\n        }\n        return nodeData;\n    };\n    ScatterSeries.prototype.update = function () {\n        var _a = this, visible = _a.visible, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis;\n        this.group.visible = visible;\n        if (!visible || !chart || chart.layoutPending || chart.dataPending || !xAxis || !yAxis) {\n            return;\n        }\n        var nodeData = this.nodeData = this.generateNodeData();\n        this.updateNodeSelection(nodeData);\n        this.updateNodes();\n    };\n    ScatterSeries.prototype.updateNodeSelection = function (nodeData) {\n        var MarkerShape = getMarker(this.marker.shape);\n        var updateSelection = this.nodeSelection.setData(nodeData);\n        updateSelection.exit.remove();\n        var enterSelection = updateSelection.enter.append(Group);\n        enterSelection.append(MarkerShape);\n        this.nodeSelection = updateSelection.merge(enterSelection);\n    };\n    ScatterSeries.prototype.updateNodes = function () {\n        if (!this.chart) {\n            return;\n        }\n        var highlightedDatum = this.chart.highlightedDatum;\n        var _a = this, marker = _a.marker, xKey = _a.xKey, yKey = _a.yKey, fill = _a.fill, stroke = _a.stroke, strokeWidth = _a.strokeWidth, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        var _b = this.highlightStyle, highlightFill = _b.fill, highlightStroke = _b.stroke;\n        var markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : strokeWidth;\n        var MarkerShape = getMarker(marker.shape);\n        var markerFormatter = marker.formatter;\n        this.nodeSelection.selectByClass(MarkerShape)\n            .each(function (node, datum) {\n            var highlighted = datum === highlightedDatum;\n            var markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || fill;\n            var markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || stroke;\n            var markerFormat = undefined;\n            if (markerFormatter) {\n                markerFormat = markerFormatter({\n                    datum: datum.seriesDatum,\n                    xKey: xKey,\n                    yKey: yKey,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: datum.size,\n                    highlighted: highlighted\n                });\n            }\n            node.fill = markerFormat && markerFormat.fill || markerFill;\n            node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n            node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                ? markerFormat.strokeWidth\n                : markerStrokeWidth;\n            node.size = markerFormat && markerFormat.size !== undefined\n                ? markerFormat.size\n                : datum.size;\n            node.fillOpacity = fillOpacity;\n            node.strokeOpacity = strokeOpacity;\n            node.translationX = datum.point.x;\n            node.translationY = datum.point.y;\n            node.visible = marker.enabled && node.size > 0;\n        });\n    };\n    ScatterSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var _a = this, xKey = _a.xKey, yKey = _a.yKey;\n        if (!xKey || !yKey) {\n            return '';\n        }\n        var _b = this, tooltip = _b.tooltip, xName = _b.xName, yName = _b.yName, sizeKey = _b.sizeKey, sizeName = _b.sizeName, labelKey = _b.labelKey, labelName = _b.labelName, fill = _b.fill;\n        var _c = tooltip.renderer, tooltipRenderer = _c === void 0 ? this.tooltipRenderer : _c;\n        var color = fill || 'gray';\n        var title = this.title || yName;\n        var datum = nodeDatum.seriesDatum;\n        var xValue = datum[xKey];\n        var yValue = datum[yKey];\n        var content = \"<b>\" + (xName || xKey) + \"</b>: \" + (typeof xValue === 'number' ? toFixed(xValue) : xValue)\n            + (\"<br><b>\" + (yName || yKey) + \"</b>: \" + (typeof yValue === 'number' ? toFixed(yValue) : yValue));\n        if (sizeKey) {\n            content += \"<br><b>\" + sizeName + \"</b>: \" + datum[sizeKey];\n        }\n        if (labelKey) {\n            content = \"<b>\" + labelName + \"</b>: \" + datum[labelKey] + \"<br>\" + content;\n        }\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum: datum,\n                xKey: xKey,\n                xValue: xValue,\n                xName: xName,\n                yKey: yKey,\n                yValue: yValue,\n                yName: yName,\n                sizeKey: sizeKey,\n                sizeName: sizeName,\n                labelKey: labelKey,\n                labelName: labelName,\n                title: title,\n                color: color\n            }), defaults);\n        }\n        return toTooltipHtml(defaults);\n    };\n    ScatterSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, id = _a.id, data = _a.data, xKey = _a.xKey, yKey = _a.yKey, yName = _a.yName, title = _a.title, visible = _a.visible, marker = _a.marker, fill = _a.fill, stroke = _a.stroke, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length && xKey && yKey) {\n            legendData.push({\n                id: id,\n                itemId: undefined,\n                enabled: visible,\n                label: {\n                    text: title || yName || yKey\n                },\n                marker: {\n                    shape: marker.shape,\n                    fill: marker.fill || fill || 'rgba(0, 0, 0, 0)',\n                    stroke: marker.stroke || stroke || 'rgba(0, 0, 0, 0)',\n                    fillOpacity: fillOpacity,\n                    strokeOpacity: strokeOpacity\n                }\n            });\n        }\n    };\n    ScatterSeries.className = 'ScatterSeries';\n    ScatterSeries.type = 'scatter';\n    __decorate$P([\n        reactive('layoutChange')\n    ], ScatterSeries.prototype, \"title\", void 0);\n    __decorate$P([\n        reactive('dataChange')\n    ], ScatterSeries.prototype, \"xKey\", void 0);\n    __decorate$P([\n        reactive('dataChange')\n    ], ScatterSeries.prototype, \"yKey\", void 0);\n    __decorate$P([\n        reactive('dataChange')\n    ], ScatterSeries.prototype, \"sizeKey\", void 0);\n    __decorate$P([\n        reactive('dataChange')\n    ], ScatterSeries.prototype, \"labelKey\", void 0);\n    return ScatterSeries;\n}(CartesianSeries));\n\nvar __extends$1p = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays$4 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar HistogramSeriesNodeTag;\n(function (HistogramSeriesNodeTag) {\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Bin\"] = 0] = \"Bin\";\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Label\"] = 1] = \"Label\";\n})(HistogramSeriesNodeTag || (HistogramSeriesNodeTag = {}));\nvar HistogramSeriesLabel = /** @class */ (function (_super) {\n    __extends$1p(HistogramSeriesLabel, _super);\n    function HistogramSeriesLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$Q([\n        reactive('change')\n    ], HistogramSeriesLabel.prototype, \"formatter\", void 0);\n    return HistogramSeriesLabel;\n}(Label));\nvar defaultBinCount = 10;\nvar aggregationFunctions = {\n    count: function (bin) { return bin.data.length; },\n    sum: function (bin, yKey) { return bin.data.reduce(function (acc, datum) { return acc + datum[yKey]; }, 0); },\n    mean: function (bin, yKey) { return aggregationFunctions.sum(bin, yKey) / aggregationFunctions.count(bin, yKey); }\n};\nvar HistogramBin = /** @class */ (function () {\n    function HistogramBin(_a) {\n        var domainMin = _a[0], domainMax = _a[1];\n        this.data = [];\n        this.aggregatedValue = 0;\n        this.frequency = 0;\n        this.domain = [domainMin, domainMax];\n    }\n    HistogramBin.prototype.addDatum = function (datum) {\n        this.data.push(datum);\n        this.frequency++;\n    };\n    Object.defineProperty(HistogramBin.prototype, \"domainWidth\", {\n        get: function () {\n            var _a = this.domain, domainMin = _a[0], domainMax = _a[1];\n            return domainMax - domainMin;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramBin.prototype, \"relativeHeight\", {\n        get: function () {\n            return this.aggregatedValue / this.domainWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HistogramBin.prototype.calculateAggregatedValue = function (aggregationName, yKey) {\n        if (!yKey) {\n            // not having a yKey forces us into a frequency plot\n            aggregationName = 'count';\n        }\n        var aggregationFunction = aggregationFunctions[aggregationName];\n        this.aggregatedValue = aggregationFunction(this, yKey);\n    };\n    HistogramBin.prototype.getY = function (areaPlot) {\n        return areaPlot ? this.relativeHeight : this.aggregatedValue;\n    };\n    return HistogramBin;\n}());\nvar HistogramSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1p(HistogramSeriesTooltip, _super);\n    function HistogramSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$Q([\n        reactive('change')\n    ], HistogramSeriesTooltip.prototype, \"renderer\", void 0);\n    return HistogramSeriesTooltip;\n}(SeriesTooltip));\nvar HistogramSeries = /** @class */ (function (_super) {\n    __extends$1p(HistogramSeries, _super);\n    function HistogramSeries() {\n        var _a;\n        var _this = _super.call(this) || this;\n        // Need to put column and label nodes into separate groups, because even though label nodes are\n        // created after the column nodes, this only guarantees that labels will always be on top of columns\n        // on the first run. If on the next run more columns are added, they might clip the labels\n        // rendered during the previous run.\n        _this.rectGroup = _this.group.appendChild(new Group());\n        _this.textGroup = _this.group.appendChild(new Group());\n        _this.rectSelection = Selection.select(_this.rectGroup).selectAll();\n        _this.textSelection = Selection.select(_this.textGroup).selectAll();\n        _this.binnedData = [];\n        _this.xDomain = [];\n        _this.yDomain = [];\n        _this.label = new HistogramSeriesLabel();\n        _this.seriesItemEnabled = true;\n        _this.tooltip = new HistogramSeriesTooltip();\n        _this.fill = undefined;\n        _this.stroke = undefined;\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        _this.directionKeys = (_a = {},\n            _a[ChartAxisDirection.X] = ['xKey'],\n            _a[ChartAxisDirection.Y] = ['yKey'],\n            _a);\n        _this._xKey = '';\n        _this._areaPlot = false;\n        _this._bins = undefined;\n        _this._aggregation = 'count';\n        _this._binCount = undefined;\n        _this._xName = '';\n        _this._yKey = '';\n        _this._yName = '';\n        _this._strokeWidth = 1;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.label.enabled = false;\n        _this.label.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    HistogramSeries.prototype.getKeys = function (direction) {\n        var _this = this;\n        var directionKeys = this.directionKeys;\n        var keys = directionKeys && directionKeys[direction];\n        var values = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var value = _this[key];\n                if (value) {\n                    if (Array.isArray(value)) {\n                        values.push.apply(values, value);\n                    }\n                    else {\n                        values.push(value);\n                    }\n                }\n            });\n        }\n        return values;\n    };\n    Object.defineProperty(HistogramSeries.prototype, \"xKey\", {\n        get: function () {\n            return this._xKey;\n        },\n        set: function (value) {\n            if (this._xKey !== value) {\n                this._xKey = value;\n                this.scheduleData();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"areaPlot\", {\n        get: function () {\n            return this._areaPlot;\n        },\n        set: function (c) {\n            this._areaPlot = c;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"bins\", {\n        get: function () {\n            return this._bins;\n        },\n        set: function (bins) {\n            this._bins = bins;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"aggregation\", {\n        get: function () {\n            return this._aggregation;\n        },\n        set: function (aggregation) {\n            this._aggregation = aggregation;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"binCount\", {\n        get: function () {\n            return this._binCount;\n        },\n        set: function (binCount) {\n            this._binCount = binCount;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"xName\", {\n        get: function () {\n            return this._xName;\n        },\n        set: function (value) {\n            if (this._xName !== value) {\n                this._xName = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"yKey\", {\n        get: function () {\n            return this._yKey;\n        },\n        set: function (yKey) {\n            this._yKey = yKey;\n            this.seriesItemEnabled = true;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"yName\", {\n        get: function () {\n            return this._yName;\n        },\n        set: function (values) {\n            this._yName = values;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"strokeWidth\", {\n        get: function () {\n            return this._strokeWidth;\n        },\n        set: function (value) {\n            if (this._strokeWidth !== value) {\n                this._strokeWidth = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HistogramSeries.prototype, \"shadow\", {\n        get: function () {\n            return this._shadow;\n        },\n        set: function (value) {\n            if (this._shadow !== value) {\n                this._shadow = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HistogramSeries.prototype.onHighlightChange = function () {\n        this.updateRectNodes();\n    };\n    HistogramSeries.prototype.setColors = function (fills, strokes) {\n        this.fill = fills[0];\n        this.stroke = strokes[0];\n    };\n    // During processData phase, used to unify different ways of the user specifying\n    // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n    HistogramSeries.prototype.deriveBins = function () {\n        var _this = this;\n        var _a = this, bins = _a.bins, binCount = _a.binCount;\n        if (!this.data) {\n            return [];\n        }\n        if (bins && binCount) {\n            console.warn('bins and bitCount are mutually exclusive properties.');\n        }\n        if (bins) {\n            return bins;\n        }\n        var xData = this.data.map(function (datum) { return datum[_this.xKey]; });\n        var xDomain = this.fixNumericExtent(finiteExtent(xData), 'x');\n        var binStarts = ticks(xDomain[0], xDomain[1], this.binCount || defaultBinCount);\n        var binSize = tickStep(xDomain[0], xDomain[1], this.binCount || defaultBinCount);\n        var firstBinEnd = binStarts[0];\n        var expandStartToBin = function (n) { return [n, n + binSize]; };\n        return __spreadArrays$4([\n            [firstBinEnd - binSize, firstBinEnd]\n        ], binStarts.map(expandStartToBin));\n    };\n    HistogramSeries.prototype.placeDataInBins = function (data) {\n        var _this = this;\n        var xKey = this.xKey;\n        var derivedBins = this.deriveBins();\n        // creating a sorted copy allows binning in O(n) rather than O(n)\n        // but at the expense of more temporary memory\n        var sortedData = data.slice().sort(function (a, b) {\n            if (a[xKey] < b[xKey]) {\n                return -1;\n            }\n            if (a[xKey] > b[xKey]) {\n                return 1;\n            }\n            return 0;\n        });\n        var currentBin = 0;\n        var bins = [new HistogramBin(derivedBins[0])];\n        loop: for (var i = 0, ln = sortedData.length; i < ln; i++) {\n            var datum = sortedData[i];\n            while (datum[xKey] > derivedBins[currentBin][1]) {\n                currentBin++;\n                var bin = derivedBins[currentBin];\n                if (!bin) {\n                    break loop;\n                }\n                bins.push(new HistogramBin(bin));\n            }\n            bins[currentBin].addDatum(datum);\n        }\n        bins.forEach(function (b) { return b.calculateAggregatedValue(_this._aggregation, _this.yKey); });\n        return bins;\n    };\n    Object.defineProperty(HistogramSeries.prototype, \"xMax\", {\n        get: function () {\n            var _this = this;\n            return this.data && this.data.reduce(function (acc, datum) {\n                return Math.max(acc, datum[_this.xKey]);\n            }, Number.NEGATIVE_INFINITY);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HistogramSeries.prototype.processData = function () {\n        var _this = this;\n        var _a = this, xKey = _a.xKey, data = _a.data;\n        this.binnedData = this.placeDataInBins(xKey && data ? data : []);\n        var yData = this.binnedData.map(function (b) { return b.getY(_this.areaPlot); });\n        var yMinMax = numericExtent(yData);\n        this.yDomain = this.fixNumericExtent([0, yMinMax ? yMinMax[1] : 1], 'y');\n        var firstBin = this.binnedData[0];\n        var lastBin = this.binnedData[this.binnedData.length - 1];\n        var xMin = firstBin.domain[0];\n        var xMax = lastBin.domain[1];\n        this.xDomain = [xMin, xMax];\n        this.fireEvent({ type: 'dataProcessed' });\n        return true;\n    };\n    HistogramSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.xDomain;\n        }\n        else {\n            return this.yDomain;\n        }\n    };\n    HistogramSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey\n        });\n    };\n    HistogramSeries.prototype.update = function () {\n        var _a = this, visible = _a.visible, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis;\n        this.group.visible = visible;\n        if (!xAxis || !yAxis || !visible || !chart || chart.layoutPending || chart.dataPending) {\n            return;\n        }\n        var nodeData = this.generateNodeData();\n        this.updateRectSelection(nodeData);\n        this.updateRectNodes();\n        this.updateTextSelection(nodeData);\n        this.updateTextNodes();\n    };\n    HistogramSeries.prototype.generateNodeData = function () {\n        var _this = this;\n        if (!this.seriesItemEnabled) {\n            return [];\n        }\n        var _a = this, xScale = _a.xAxis.scale, yScale = _a.yAxis.scale, fill = _a.fill, stroke = _a.stroke, strokeWidth = _a.strokeWidth;\n        var nodeData = [];\n        var defaultLabelFormatter = function (params) { return String(params.value); };\n        var _b = this.label, _c = _b.formatter, labelFormatter = _c === void 0 ? defaultLabelFormatter : _c, labelFontStyle = _b.fontStyle, labelFontWeight = _b.fontWeight, labelFontSize = _b.fontSize, labelFontFamily = _b.fontFamily, labelColor = _b.color;\n        this.binnedData.forEach(function (binOfData) {\n            var total = binOfData.aggregatedValue, frequency = binOfData.frequency, _a = binOfData.domain, xDomainMin = _a[0], xDomainMax = _a[1], relativeHeight = binOfData.relativeHeight;\n            var xMinPx = xScale.convert(xDomainMin), xMaxPx = xScale.convert(xDomainMax), \n            // note: assuming can't be negative:\n            y = _this.areaPlot ? relativeHeight : (_this.yKey ? total : frequency), yZeroPx = yScale.convert(0), yMaxPx = yScale.convert(y), w = xMaxPx - xMinPx, h = Math.abs(yMaxPx - yZeroPx);\n            var selectionDatumLabel = y !== 0 ? {\n                text: labelFormatter({ value: binOfData.aggregatedValue }),\n                fontStyle: labelFontStyle,\n                fontWeight: labelFontWeight,\n                fontSize: labelFontSize,\n                fontFamily: labelFontFamily,\n                fill: labelColor,\n                x: xMinPx + w / 2,\n                y: yMaxPx + h / 2\n            } : undefined;\n            nodeData.push({\n                series: _this,\n                seriesDatum: binOfData,\n                // since each selection is an aggregation of multiple data.\n                x: xMinPx,\n                y: yMaxPx,\n                width: w,\n                height: h,\n                fill: fill,\n                stroke: stroke,\n                strokeWidth: strokeWidth,\n                label: selectionDatumLabel,\n            });\n        });\n        return nodeData;\n    };\n    HistogramSeries.prototype.updateRectSelection = function (nodeData) {\n        var updateRects = this.rectSelection.setData(nodeData);\n        updateRects.exit.remove();\n        var enterRects = updateRects.enter.append(Rect).each(function (rect) {\n            rect.tag = HistogramSeriesNodeTag.Bin;\n            rect.crisp = true;\n        });\n        this.rectSelection = updateRects.merge(enterRects);\n    };\n    HistogramSeries.prototype.updateRectNodes = function () {\n        var _this = this;\n        if (!this.chart) {\n            return;\n        }\n        var highlightedDatum = this.chart.highlightedDatum;\n        var _a = this, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, shadow = _a.shadow, _b = _a.highlightStyle, fill = _b.fill, stroke = _b.stroke;\n        this.rectSelection.each(function (rect, datum) {\n            var highlighted = datum === highlightedDatum;\n            rect.x = datum.x;\n            rect.y = datum.y;\n            rect.width = datum.width;\n            rect.height = datum.height;\n            rect.fill = highlighted && fill !== undefined ? fill : datum.fill;\n            rect.stroke = highlighted && stroke !== undefined ? stroke : datum.stroke;\n            rect.fillOpacity = fillOpacity;\n            rect.strokeOpacity = strokeOpacity;\n            rect.strokeWidth = datum.strokeWidth;\n            rect.lineDash = _this.lineDash;\n            rect.lineDashOffset = _this.lineDashOffset;\n            rect.fillShadow = shadow;\n            rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns\n        });\n    };\n    HistogramSeries.prototype.updateTextSelection = function (nodeData) {\n        var updateTexts = this.textSelection.setData(nodeData);\n        updateTexts.exit.remove();\n        var enterTexts = updateTexts.enter.append(Text).each(function (text) {\n            text.tag = HistogramSeriesNodeTag.Label;\n            text.pointerEvents = PointerEvents.None;\n            text.textAlign = 'center';\n            text.textBaseline = 'middle';\n        });\n        this.textSelection = updateTexts.merge(enterTexts);\n    };\n    HistogramSeries.prototype.updateTextNodes = function () {\n        var labelEnabled = this.label.enabled;\n        this.textSelection.each(function (text, datum) {\n            var label = datum.label;\n            if (label && labelEnabled) {\n                text.text = label.text;\n                text.x = label.x;\n                text.y = label.y;\n                text.fontStyle = label.fontStyle;\n                text.fontWeight = label.fontWeight;\n                text.fontSize = label.fontSize;\n                text.fontFamily = label.fontFamily;\n                text.fill = label.fill;\n                text.visible = true;\n            }\n            else {\n                text.visible = false;\n            }\n        });\n    };\n    HistogramSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var _a = this, xKey = _a.xKey, yKey = _a.yKey;\n        if (!xKey) {\n            return '';\n        }\n        var _b = this, xName = _b.xName, yName = _b.yName, color = _b.fill, tooltip = _b.tooltip, aggregation = _b.aggregation;\n        var _c = tooltip.renderer, tooltipRenderer = _c === void 0 ? this.tooltipRenderer : _c;\n        var bin = nodeDatum.seriesDatum;\n        var aggregatedValue = bin.aggregatedValue, frequency = bin.frequency, _d = bin.domain, rangeMin = _d[0], rangeMax = _d[1];\n        var title = (xName || xKey) + \": \" + toFixed(rangeMin) + \" - \" + toFixed(rangeMax);\n        var content = yKey ?\n            \"<b>\" + (yName || yKey) + \" (\" + aggregation + \")</b>: \" + toFixed(aggregatedValue) + \"<br>\" :\n            '';\n        content += \"<b>Frequency</b>: \" + frequency;\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum: bin,\n                xKey: xKey,\n                xValue: bin.domain,\n                xName: xName,\n                yKey: yKey,\n                yValue: bin.aggregatedValue,\n                yName: yName,\n                color: color\n            }), defaults);\n        }\n        return toTooltipHtml(defaults);\n    };\n    HistogramSeries.prototype.listSeriesItems = function (legendData) {\n        var _a = this, id = _a.id, data = _a.data, yKey = _a.yKey, yName = _a.yName, seriesItemEnabled = _a.seriesItemEnabled, fill = _a.fill, stroke = _a.stroke, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity;\n        if (data && data.length) {\n            legendData.push({\n                id: id,\n                itemId: yKey,\n                enabled: seriesItemEnabled,\n                label: {\n                    text: yName || yKey || 'Frequency'\n                },\n                marker: {\n                    fill: fill || 'rgba(0, 0, 0, 0)',\n                    stroke: stroke || 'rgba(0, 0, 0, 0)',\n                    fillOpacity: fillOpacity,\n                    strokeOpacity: strokeOpacity\n                }\n            });\n        }\n    };\n    HistogramSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n        if (itemId === this.yKey) {\n            this.seriesItemEnabled = enabled;\n        }\n        this.scheduleData();\n    };\n    HistogramSeries.className = 'HistogramSeries';\n    HistogramSeries.type = 'histogram';\n    __decorate$Q([\n        reactive('dataChange')\n    ], HistogramSeries.prototype, \"fill\", void 0);\n    __decorate$Q([\n        reactive('dataChange')\n    ], HistogramSeries.prototype, \"stroke\", void 0);\n    __decorate$Q([\n        reactive('layoutChange')\n    ], HistogramSeries.prototype, \"fillOpacity\", void 0);\n    __decorate$Q([\n        reactive('layoutChange')\n    ], HistogramSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate$Q([\n        reactive('update')\n    ], HistogramSeries.prototype, \"lineDash\", void 0);\n    __decorate$Q([\n        reactive('update')\n    ], HistogramSeries.prototype, \"lineDashOffset\", void 0);\n    return HistogramSeries;\n}(CartesianSeries));\n\nvar __extends$1q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar HierarchySeries = /** @class */ (function (_super) {\n    __extends$1q(HierarchySeries, _super);\n    function HierarchySeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.data = undefined;\n        return _this;\n    }\n    __decorate$R([\n        reactive('dataChange')\n    ], HierarchySeries.prototype, \"data\", void 0);\n    return HierarchySeries;\n}(Series));\n\nvar __extends$1r = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DropShadow = /** @class */ (function (_super) {\n    __extends$1r(DropShadow, _super);\n    function DropShadow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.enabled = true;\n        _this.color = 'rgba(0, 0, 0, 0.5)';\n        _this.xOffset = 0;\n        _this.yOffset = 0;\n        _this.blur = 5;\n        return _this;\n    }\n    __decorate$S([\n        reactive('change')\n    ], DropShadow.prototype, \"enabled\", void 0);\n    __decorate$S([\n        reactive('change')\n    ], DropShadow.prototype, \"color\", void 0);\n    __decorate$S([\n        reactive('change')\n    ], DropShadow.prototype, \"xOffset\", void 0);\n    __decorate$S([\n        reactive('change')\n    ], DropShadow.prototype, \"yOffset\", void 0);\n    __decorate$S([\n        reactive('change')\n    ], DropShadow.prototype, \"blur\", void 0);\n    return DropShadow;\n}(Observable));\n\nfunction slice(parent, x0, y0, x1, y1) {\n    var nodes = parent.children;\n    var k = parent.value && (y1 - y0) / parent.value;\n    nodes.forEach(function (node) {\n        node.x0 = x0;\n        node.x1 = x1;\n        node.y0 = y0;\n        node.y1 = y0 += node.value * k;\n    });\n}\nfunction dice(parent, x0, y0, x1, y1) {\n    var nodes = parent.children;\n    var k = parent.value && (x1 - x0) / parent.value;\n    nodes.forEach(function (node) {\n        node.x0 = x0;\n        node.x1 = x0 += node.value * k;\n        node.y0 = y0;\n        node.y1 = y1;\n    });\n}\nfunction roundNode(node) {\n    node.x0 = Math.round(node.x0);\n    node.y0 = Math.round(node.y0);\n    node.x1 = Math.round(node.x1);\n    node.y1 = Math.round(node.y1);\n}\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n    var rows = [];\n    var nodes = parent.children;\n    var n = nodes.length;\n    var value = parent.value;\n    var i0 = 0;\n    var i1 = 0;\n    var dx;\n    var dy;\n    var nodeValue;\n    var sumValue;\n    var minValue;\n    var maxValue;\n    var newRatio;\n    var minRatio;\n    var alpha;\n    var beta;\n    while (i0 < n) {\n        dx = x1 - x0;\n        dy = y1 - y0;\n        // Find the next non-empty node.\n        do {\n            sumValue = nodes[i1++].value;\n        } while (!sumValue && i1 < n);\n        minValue = maxValue = sumValue;\n        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n        beta = sumValue * sumValue * alpha;\n        minRatio = Math.max(maxValue / beta, beta / minValue);\n        // Keep adding nodes while the aspect ratio maintains or improves.\n        for (; i1 < n; ++i1) {\n            nodeValue = nodes[i1].value;\n            sumValue += nodeValue;\n            if (nodeValue < minValue) {\n                minValue = nodeValue;\n            }\n            if (nodeValue > maxValue) {\n                maxValue = nodeValue;\n            }\n            beta = sumValue * sumValue * alpha;\n            newRatio = Math.max(maxValue / beta, beta / minValue);\n            if (newRatio > minRatio) {\n                sumValue -= nodeValue;\n                break;\n            }\n            minRatio = newRatio;\n        }\n        // Position and record the row orientation.\n        var row = {\n            value: sumValue,\n            dice: dx < dy,\n            children: nodes.slice(i0, i1)\n        };\n        rows.push(row);\n        if (row.dice) {\n            dice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n        }\n        else {\n            slice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n        }\n        value -= sumValue;\n        i0 = i1;\n    }\n    return rows;\n}\nvar phi = (1 + Math.sqrt(5)) / 2;\nvar squarify = (function custom(ratio) {\n    function squarify(parent, x0, y0, x1, y1) {\n        squarifyRatio(ratio, parent, x0, y0, x1, y1);\n    }\n    squarify.ratio = function (x) { return custom((x = +x) > 1 ? x : 1); };\n    return squarify;\n})(phi);\nvar Treemap = /** @class */ (function () {\n    function Treemap() {\n        this.paddingStack = [0];\n        this.dx = 1;\n        this.dy = 1;\n        this.round = true;\n        this.tile = squarify;\n        this.paddingInner = function (_) { return 0; };\n        this.paddingTop = function (_) { return 0; };\n        this.paddingRight = function (_) { return 0; };\n        this.paddingBottom = function (_) { return 0; };\n        this.paddingLeft = function (_) { return 0; };\n    }\n    Object.defineProperty(Treemap.prototype, \"size\", {\n        get: function () {\n            return [this.dx, this.dy];\n        },\n        set: function (size) {\n            this.dx = size[0];\n            this.dy = size[1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Treemap.prototype.processData = function (root) {\n        root.x0 = 0;\n        root.y0 = 0;\n        root.x1 = this.dx;\n        root.y1 = this.dy;\n        root.eachBefore(this.positionNode.bind(this));\n        this.paddingStack = [0];\n        if (this.round) {\n            root.eachBefore(roundNode);\n        }\n        return root;\n    };\n    Treemap.prototype.positionNode = function (node) {\n        var p = this.paddingStack[node.depth];\n        var x0 = node.x0 + p;\n        var y0 = node.y0 + p;\n        var x1 = node.x1 - p;\n        var y1 = node.y1 - p;\n        if (x1 < x0) {\n            x0 = x1 = (x0 + x1) / 2;\n        }\n        if (y1 < y0) {\n            y0 = y1 = (y0 + y1) / 2;\n        }\n        node.x0 = x0;\n        node.y0 = y0;\n        node.x1 = x1;\n        node.y1 = y1;\n        if (node.children) {\n            p = this.paddingStack[node.depth + 1] = this.paddingInner(node) / 2;\n            x0 += this.paddingLeft(node) - p;\n            y0 += this.paddingTop(node) - p;\n            x1 -= this.paddingRight(node) - p;\n            y1 -= this.paddingBottom(node) - p;\n            if (x1 < x0) {\n                x0 = x1 = (x0 + x1) / 2;\n            }\n            if (y1 < y0) {\n                y0 = y1 = (y0 + y1) / 2;\n            }\n            this.tile(node, x0, y0, x1, y1);\n        }\n    };\n    return Treemap;\n}());\n\nvar HierarchyNode = /** @class */ (function () {\n    function HierarchyNode(data) {\n        this.value = 0;\n        this.depth = 0;\n        this.height = 0;\n        this.parent = undefined;\n        this.children = undefined;\n        this.data = data;\n    }\n    HierarchyNode.prototype.countFn = function (node) {\n        var sum = 0, children = node.children;\n        if (!children || !children.length) {\n            sum = 1;\n        }\n        else {\n            var i = children.length;\n            while (--i >= 0) {\n                sum += children[i].value;\n            }\n        }\n        node.value = sum;\n    };\n    HierarchyNode.prototype.count = function () {\n        return this.eachAfter(this.countFn);\n    };\n    HierarchyNode.prototype.each = function (callback, scope) {\n        var _this = this;\n        var index = -1;\n        this.iterator(function (node) {\n            callback.call(scope, node, ++index, _this);\n        });\n        return this;\n    };\n    /**\n     * Invokes the given callback for each node in post-order traversal.\n     * @param callback\n     * @param scope\n     */\n    HierarchyNode.prototype.eachAfter = function (callback, scope) {\n        var node = this;\n        var nodes = [node];\n        var next = [];\n        while (node = nodes.pop()) {\n            next.push(node);\n            var children = node.children;\n            if (children) {\n                for (var i = 0, n = children.length; i < n; ++i) {\n                    nodes.push(children[i]);\n                }\n            }\n        }\n        var index = -1;\n        while (node = next.pop()) {\n            callback.call(scope, node, ++index, this);\n        }\n        return this;\n    };\n    /**\n     * Invokes the given callback for each node in pre-order traversal.\n     * @param callback\n     * @param scope\n     */\n    HierarchyNode.prototype.eachBefore = function (callback, scope) {\n        var node = this;\n        var nodes = [node];\n        var index = -1;\n        while (node = nodes.pop()) {\n            callback.call(scope, node, ++index, this);\n            var children = node.children;\n            if (children) {\n                for (var i = children.length - 1; i >= 0; --i) {\n                    var child = children[i];\n                    nodes.push(child);\n                }\n            }\n        }\n        return this;\n    };\n    HierarchyNode.prototype.find = function (callback, scope) {\n        var _this = this;\n        var index = -1;\n        var result;\n        this.iterator(function (node) {\n            if (callback.call(scope, node, ++index, _this)) {\n                result = node;\n                return false;\n            }\n        });\n        return result;\n    };\n    HierarchyNode.prototype.sum = function (value) {\n        return this.eachAfter(function (node) {\n            var sum = +value(node.data) || 0;\n            var children = node.children;\n            if (children) {\n                var i = children.length;\n                while (--i >= 0) {\n                    sum += children[i].value;\n                }\n            }\n            node.value = sum;\n        });\n    };\n    HierarchyNode.prototype.sort = function (compare) {\n        return this.eachBefore(function (node) {\n            if (node.children) {\n                node.children.sort(compare);\n            }\n        });\n    };\n    HierarchyNode.prototype.path = function (end) {\n        var start = this;\n        var ancestor = leastCommonAncestor(start, end);\n        var nodes = [start];\n        while (start !== ancestor) {\n            start = start.parent;\n            nodes.push(start);\n        }\n        var k = nodes.length;\n        while (end !== ancestor) {\n            nodes.splice(k, 0, end);\n            end = end.parent;\n        }\n        // const otherBranch = [];\n        // while (end !== ancestor) {\n        //     otherBranch.push(end);\n        //     end = end.parent;\n        // }\n        // nodes.concat(otherBranch.reverse());\n        return nodes;\n    };\n    HierarchyNode.prototype.ancestors = function () {\n        var node = this;\n        var nodes = [node];\n        while (node = node.parent) {\n            nodes.push(node);\n        }\n        return nodes;\n    };\n    HierarchyNode.prototype.descendants = function () {\n        var nodes = [];\n        this.iterator(function (node) { return nodes.push(node); });\n        return nodes;\n    };\n    HierarchyNode.prototype.leaves = function () {\n        var leaves = [];\n        this.eachBefore(function (node) {\n            if (!node.children) {\n                leaves.push(node);\n            }\n        });\n        return leaves;\n    };\n    HierarchyNode.prototype.links = function () {\n        var root = this;\n        var links = [];\n        root.each(function (node) {\n            if (node !== root) { // Dont include the roots parent, if any.\n                links.push({ source: node.parent, target: node });\n            }\n        });\n        return links;\n    };\n    HierarchyNode.prototype.copy = function () {\n        // TODO\n    };\n    HierarchyNode.prototype.iterator = function (callback) {\n        var node = this;\n        var next = [node];\n        var current;\n        doLoop: do {\n            current = next.reverse();\n            next = [];\n            while (node = current.pop()) {\n                if (callback(node) === false) {\n                    break doLoop;\n                }\n                var children = node.children;\n                if (children) {\n                    for (var i = 0, n = children.length; i < n; ++i) {\n                        next.push(children[i]);\n                    }\n                }\n            }\n        } while (next.length);\n    };\n    return HierarchyNode;\n}());\nfunction hierarchy(data, children) {\n    if (data instanceof Map) {\n        data = [undefined, data];\n        if (children === undefined) {\n            children = mapChildren;\n        }\n    }\n    else if (children === undefined) {\n        children = objectChildren;\n    }\n    var root = new HierarchyNode(data);\n    var nodes = [root];\n    var node;\n    var child, childs, i, n;\n    while (node = nodes.pop()) {\n        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {\n            node.children = childs;\n            for (i = n - 1; i >= 0; --i) {\n                nodes.push(child = childs[i] = new HierarchyNode(childs[i]));\n                child.parent = node;\n                child.depth = node.depth + 1;\n            }\n        }\n    }\n    return root.eachBefore(computeHeight);\n}\nfunction computeHeight(node) {\n    var height = 0;\n    do {\n        node.height = height;\n    } while ((node = node.parent) && (node.height < ++height));\n}\nfunction mapChildren(d) {\n    return Array.isArray(d) ? d[1] : undefined;\n}\nfunction objectChildren(d) {\n    return d.children;\n}\nfunction leastCommonAncestor(a, b) {\n    if (!(a && b)) {\n        return undefined;\n    }\n    if (a === b) {\n        return a;\n    }\n    var aNodes = a.ancestors();\n    var bNodes = b.ancestors();\n    var c = undefined;\n    a = aNodes.pop();\n    b = bNodes.pop();\n    while (a === b) {\n        c = a;\n        a = aNodes.pop();\n        b = bNodes.pop();\n    }\n    return c;\n}\n\nvar __extends$1s = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TreemapSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1s(TreemapSeriesTooltip, _super);\n    function TreemapSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$T([\n        reactive('change')\n    ], TreemapSeriesTooltip.prototype, \"renderer\", void 0);\n    return TreemapSeriesTooltip;\n}(SeriesTooltip));\nvar TreemapSeriesLabel = /** @class */ (function (_super) {\n    __extends$1s(TreemapSeriesLabel, _super);\n    function TreemapSeriesLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.padding = 10;\n        return _this;\n    }\n    __decorate$T([\n        reactive('change')\n    ], TreemapSeriesLabel.prototype, \"padding\", void 0);\n    return TreemapSeriesLabel;\n}(Label));\nvar TextNodeTag;\n(function (TextNodeTag) {\n    TextNodeTag[TextNodeTag[\"Name\"] = 0] = \"Name\";\n    TextNodeTag[TextNodeTag[\"Value\"] = 1] = \"Value\";\n})(TextNodeTag || (TextNodeTag = {}));\nvar TreemapSeries = /** @class */ (function (_super) {\n    __extends$1s(TreemapSeries, _super);\n    function TreemapSeries() {\n        var _this = _super.call(this) || this;\n        _this.groupSelection = Selection.select(_this.group).selectAll();\n        _this.labelMap = new Map();\n        _this.layout = new Treemap();\n        _this.title = (function () {\n            var label = new TreemapSeriesLabel();\n            label.fontWeight = 'bold';\n            label.fontSize = 12;\n            label.fontFamily = 'Verdana, sans-serif';\n            label.padding = 15;\n            return label;\n        })();\n        _this.subtitle = (function () {\n            var label = new TreemapSeriesLabel();\n            label.fontSize = 9;\n            label.fontFamily = 'Verdana, sans-serif';\n            label.padding = 13;\n            return label;\n        })();\n        _this.labels = {\n            large: (function () {\n                var label = new Label();\n                label.fontWeight = 'bold';\n                label.fontSize = 18;\n                return label;\n            })(),\n            medium: (function () {\n                var label = new Label();\n                label.fontWeight = 'bold';\n                label.fontSize = 14;\n                return label;\n            })(),\n            small: (function () {\n                var label = new Label();\n                label.fontWeight = 'bold';\n                label.fontSize = 10;\n                return label;\n            })(),\n            color: (function () {\n                var label = new Label();\n                label.color = 'white';\n                return label;\n            })()\n        };\n        _this._nodePadding = 2;\n        _this.labelKey = 'label';\n        _this.sizeKey = 'size';\n        _this.colorKey = 'color';\n        _this.colorDomain = [-5, 5];\n        _this.colorRange = ['#cb4b3f', '#6acb64'];\n        _this.colorParents = false;\n        _this.gradient = true;\n        _this.colorName = 'Change';\n        _this.rootName = 'Root';\n        _this._shadow = (function () {\n            var shadow = new DropShadow();\n            shadow.color = 'rgba(0, 0, 0, 0.4)';\n            shadow.xOffset = 1.5;\n            shadow.yOffset = 1.5;\n            return shadow;\n        })();\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.tooltip = new TreemapSeriesTooltip();\n        _this.shadow.addEventListener('change', _this.update, _this);\n        _this.title.addEventListener('change', _this.update, _this);\n        _this.subtitle.addEventListener('change', _this.update, _this);\n        _this.labels.small.addEventListener('change', _this.update, _this);\n        _this.labels.medium.addEventListener('change', _this.update, _this);\n        _this.labels.large.addEventListener('change', _this.update, _this);\n        _this.labels.color.addEventListener('change', _this.update, _this);\n        return _this;\n    }\n    Object.defineProperty(TreemapSeries.prototype, \"nodePadding\", {\n        get: function () {\n            return this._nodePadding;\n        },\n        set: function (value) {\n            if (this._nodePadding !== value) {\n                this._nodePadding = value;\n                this.updateLayoutPadding();\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TreemapSeries.prototype, \"shadow\", {\n        get: function () {\n            return this._shadow;\n        },\n        set: function (value) {\n            if (this._shadow !== value) {\n                this._shadow = value;\n                this.update();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TreemapSeries.prototype.onHighlightChange = function () {\n        this.updateNodes();\n    };\n    TreemapSeries.prototype.updateLayoutPadding = function () {\n        var _a = this, title = _a.title, subtitle = _a.subtitle, nodePadding = _a.nodePadding, labelKey = _a.labelKey;\n        this.layout.paddingRight = function (_) { return nodePadding; };\n        this.layout.paddingBottom = function (_) { return nodePadding; };\n        this.layout.paddingLeft = function (_) { return nodePadding; };\n        this.layout.paddingTop = function (node) {\n            var name = node.data[labelKey] || '';\n            if (node.children) {\n                name = name.toUpperCase();\n            }\n            var font = node.depth > 1 ? subtitle : title;\n            var textSize = HdpiCanvas.getTextSize(name, [font.fontWeight, font.fontSize + 'px', font.fontFamily].join(' ').trim());\n            var innerNodeWidth = node.x1 - node.x0 - nodePadding * 2;\n            var hasTitle = node.depth > 0 && node.children && textSize.width <= innerNodeWidth;\n            node.hasTitle = hasTitle;\n            return hasTitle ? textSize.height + nodePadding * 2 : nodePadding;\n        };\n    };\n    TreemapSeries.prototype.processData = function () {\n        if (!this.data) {\n            return false;\n        }\n        var _a = this, data = _a.data, sizeKey = _a.sizeKey, labelKey = _a.labelKey, colorKey = _a.colorKey, colorDomain = _a.colorDomain, colorRange = _a.colorRange, colorParents = _a.colorParents;\n        var dataRoot;\n        if (sizeKey) {\n            dataRoot = hierarchy(data).sum(function (datum) { return datum.children ? 1 : datum[sizeKey]; });\n        }\n        else {\n            dataRoot = hierarchy(data).sum(function (datum) { return datum.children ? 0 : 1; });\n        }\n        this.dataRoot = dataRoot;\n        var colorScale = new LinearScale();\n        colorScale.domain = colorDomain;\n        colorScale.range = colorRange;\n        var series = this;\n        function traverse(root, depth) {\n            if (depth === void 0) { depth = 0; }\n            var children = root.children, data = root.data;\n            var label = data[labelKey];\n            var colorValue = colorKey ? data[colorKey] : depth;\n            root.series = series;\n            root.fill = !children || colorParents ? colorScale.convert(colorValue) : '#272931';\n            root.colorValue = colorValue;\n            if (label) {\n                root.label = children ? label.toUpperCase() : label;\n            }\n            else {\n                root.label = '';\n            }\n            if (children) {\n                children.forEach(function (child) { return traverse(child, depth + 1); });\n            }\n        }\n        traverse(this.dataRoot);\n        return true;\n    };\n    TreemapSeries.prototype.getLabelCenterX = function (datum) {\n        return (datum.x0 + datum.x1) / 2;\n    };\n    TreemapSeries.prototype.getLabelCenterY = function (datum) {\n        return (datum.y0 + datum.y1) / 2 + 2;\n    };\n    TreemapSeries.prototype.update = function () {\n        var _a = this, chart = _a.chart, dataRoot = _a.dataRoot;\n        if (!chart || !dataRoot) {\n            return;\n        }\n        var seriesRect = chart.getSeriesRect();\n        if (!seriesRect) {\n            return;\n        }\n        this.layout.size = [seriesRect.width, seriesRect.height];\n        this.updateLayoutPadding();\n        var descendants = this.layout.processData(dataRoot).descendants();\n        var updateGroups = this.groupSelection.setData(descendants);\n        updateGroups.exit.remove();\n        var enterGroups = updateGroups.enter.append(Group);\n        enterGroups.append(Rect);\n        enterGroups.append(Text).each(function (node) { return node.tag = TextNodeTag.Name; });\n        enterGroups.append(Text).each(function (node) { return node.tag = TextNodeTag.Value; });\n        this.groupSelection = updateGroups.merge(enterGroups);\n        this.updateNodes();\n    };\n    TreemapSeries.prototype.updateNodes = function () {\n        var _this = this;\n        var chart = this.chart;\n        if (!chart) {\n            return;\n        }\n        var highlightedDatum = chart.highlightedDatum;\n        var _a = this.highlightStyle, highlightFill = _a.fill, highlightStroke = _a.stroke;\n        var _b = this, colorKey = _b.colorKey, labelMap = _b.labelMap, nodePadding = _b.nodePadding, title = _b.title, subtitle = _b.subtitle, labels = _b.labels, shadow = _b.shadow, gradient = _b.gradient;\n        this.groupSelection.selectByClass(Rect).each(function (rect, datum) {\n            var highlighted = datum === highlightedDatum;\n            var fill = highlighted && highlightFill !== undefined\n                ? highlightFill\n                : datum.fill;\n            var stroke = highlighted && highlightStroke !== undefined\n                ? highlightStroke\n                : datum.depth < 2 ? undefined : 'black';\n            rect.fill = fill;\n            rect.stroke = stroke;\n            rect.strokeWidth = 1;\n            rect.crisp = true;\n            rect.gradient = gradient;\n            rect.x = datum.x0;\n            rect.y = datum.y0;\n            rect.width = datum.x1 - datum.x0;\n            rect.height = datum.y1 - datum.y0;\n        });\n        this.groupSelection.selectByTag(TextNodeTag.Name).each(function (text, datum, index) {\n            var isLeaf = !datum.children;\n            var innerNodeWidth = datum.x1 - datum.x0 - nodePadding * 2;\n            var innerNodeHeight = datum.y1 - datum.y0 - nodePadding * 2;\n            var hasTitle = datum.hasTitle;\n            var highlighted = datum === highlightedDatum;\n            var label;\n            if (isLeaf) {\n                if (innerNodeWidth > 40 && innerNodeWidth > 40) {\n                    label = labels.large;\n                }\n                else if (innerNodeWidth > 20 && innerNodeHeight > 20) {\n                    label = labels.medium;\n                }\n                else {\n                    label = labels.small;\n                }\n            }\n            else {\n                if (datum.depth > 1) {\n                    label = subtitle;\n                }\n                else {\n                    label = title;\n                }\n            }\n            text.fontWeight = label.fontWeight;\n            text.fontSize = label.fontSize;\n            text.fontFamily = label.fontFamily;\n            text.textBaseline = isLeaf ? 'bottom' : (hasTitle ? 'top' : 'middle');\n            text.textAlign = hasTitle ? 'left' : 'center';\n            text.text = datum.label;\n            var textBBox = text.computeBBox();\n            var hasLabel = isLeaf && !!textBBox\n                && textBBox.width <= innerNodeWidth\n                && textBBox.height * 2 + 8 <= innerNodeHeight;\n            labelMap.set(index, text);\n            text.fill = highlighted ? 'black' : 'white';\n            text.fillShadow = hasLabel && !highlighted ? shadow : undefined;\n            text.visible = hasTitle || hasLabel;\n            if (hasTitle) {\n                text.x = datum.x0 + nodePadding;\n                text.y = datum.y0 + nodePadding;\n            }\n            else {\n                text.x = _this.getLabelCenterX(datum);\n                text.y = _this.getLabelCenterY(datum);\n            }\n        });\n        this.groupSelection.selectByTag(TextNodeTag.Value).each(function (text, datum, index) {\n            var innerNodeWidth = datum.x1 - datum.x0 - nodePadding * 2;\n            var highlighted = datum === highlightedDatum;\n            var value = datum.colorValue;\n            var label = labels.color;\n            text.fontSize = label.fontSize;\n            text.fontFamily = label.fontFamily;\n            text.fontStyle = label.fontStyle;\n            text.fontWeight = label.fontWeight;\n            text.textBaseline = 'top';\n            text.textAlign = 'center';\n            text.text = typeof value === 'number' && isFinite(value)\n                ? String(toFixed(datum.colorValue)) + '%'\n                : '';\n            var textBBox = text.computeBBox();\n            var nameNode = labelMap.get(index);\n            var hasLabel = !!nameNode && nameNode.visible;\n            var isVisible = !!colorKey && hasLabel && !!textBBox && textBBox.width < innerNodeWidth;\n            text.fill = highlighted ? 'black' : label.color;\n            text.fillShadow = highlighted ? undefined : shadow;\n            text.visible = isVisible;\n            if (isVisible) {\n                text.x = _this.getLabelCenterX(datum);\n                text.y = _this.getLabelCenterY(datum);\n            }\n            else {\n                if (nameNode && !(datum.children && datum.children.length)) {\n                    nameNode.textBaseline = 'middle';\n                    nameNode.y = _this.getLabelCenterY(datum);\n                }\n            }\n        });\n    };\n    TreemapSeries.prototype.getDomain = function (direction) {\n        return [0, 1];\n    };\n    TreemapSeries.prototype.getTooltipHtml = function (datum) {\n        var _a = this, tooltip = _a.tooltip, sizeKey = _a.sizeKey, labelKey = _a.labelKey, colorKey = _a.colorKey, colorName = _a.colorName, rootName = _a.rootName;\n        var data = datum.data;\n        var tooltipRenderer = tooltip.renderer;\n        var title = datum.depth ? data[labelKey] : (rootName || data[labelKey]);\n        var content = undefined;\n        var color = datum.fill || 'gray';\n        if (colorKey && colorName) {\n            var colorValue = data[colorKey];\n            if (typeof colorValue === 'number' && isFinite(colorValue)) {\n                content = \"<b>\" + colorName + \"</b>: \" + toFixed(data[colorKey]);\n            }\n        }\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum: datum,\n                sizeKey: sizeKey,\n                labelKey: labelKey,\n                colorKey: colorKey,\n                title: title,\n                color: color\n            }), defaults);\n        }\n        return toTooltipHtml(defaults);\n    };\n    TreemapSeries.prototype.listSeriesItems = function (legendData) {\n    };\n    TreemapSeries.className = 'TreemapSeries';\n    TreemapSeries.type = 'treemap';\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"labelKey\", void 0);\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"sizeKey\", void 0);\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"colorKey\", void 0);\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"colorDomain\", void 0);\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"colorRange\", void 0);\n    __decorate$T([\n        reactive('dataChange')\n    ], TreemapSeries.prototype, \"colorParents\", void 0);\n    __decorate$T([\n        reactive('update')\n    ], TreemapSeries.prototype, \"gradient\", void 0);\n    return TreemapSeries;\n}(HierarchySeries));\n\nvar __extends$1t = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Sector = /** @class */ (function (_super) {\n    __extends$1t(Sector, _super);\n    function Sector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.path = new Path2D();\n        _this._dirtyPath = true;\n        _this._centerX = 0;\n        _this._centerY = 0;\n        _this._centerOffset = 0;\n        _this._innerRadius = 10;\n        _this._outerRadius = 20;\n        _this._startAngle = 0;\n        _this._endAngle = Math.PI * 2;\n        _this._angleOffset = 0;\n        return _this;\n    }\n    Object.defineProperty(Sector.prototype, \"dirtyPath\", {\n        get: function () {\n            return this._dirtyPath;\n        },\n        set: function (value) {\n            if (this._dirtyPath !== value) {\n                this._dirtyPath = value;\n                if (value) {\n                    this.dirty = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"centerX\", {\n        get: function () {\n            return this._centerX;\n        },\n        set: function (value) {\n            if (this._centerX !== value) {\n                this._centerX = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"centerY\", {\n        get: function () {\n            return this._centerY;\n        },\n        set: function (value) {\n            if (this._centerY !== value) {\n                this._centerY = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"centerOffset\", {\n        get: function () {\n            return this._centerOffset;\n        },\n        set: function (value) {\n            if (this._centerOffset !== value) {\n                this._centerOffset = Math.max(0, value);\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"innerRadius\", {\n        get: function () {\n            return this._innerRadius;\n        },\n        set: function (value) {\n            if (this._innerRadius !== value) {\n                this._innerRadius = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"outerRadius\", {\n        get: function () {\n            return this._outerRadius;\n        },\n        set: function (value) {\n            if (this._outerRadius !== value) {\n                this._outerRadius = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"startAngle\", {\n        get: function () {\n            return this._startAngle;\n        },\n        set: function (value) {\n            if (this._startAngle !== value) {\n                this._startAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"endAngle\", {\n        get: function () {\n            return this._endAngle;\n        },\n        set: function (value) {\n            if (this._endAngle !== value) {\n                this._endAngle = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sector.prototype, \"angleOffset\", {\n        get: function () {\n            return this._angleOffset;\n        },\n        set: function (value) {\n            if (this._angleOffset !== value) {\n                this._angleOffset = value;\n                this.dirtyPath = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Sector.prototype.computeBBox = function () {\n        var radius = this.outerRadius;\n        return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);\n    };\n    Sector.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        return this.path.isPointInPath(point.x, point.y);\n    };\n    Sector.prototype.isPointInStroke = function (x, y) {\n        return false;\n    };\n    Object.defineProperty(Sector.prototype, \"fullPie\", {\n        get: function () {\n            return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Sector.prototype.updatePath = function () {\n        if (!this.dirtyPath) {\n            return;\n        }\n        var path = this.path;\n        var angleOffset = this.angleOffset;\n        var startAngle = Math.min(this.startAngle, this.endAngle) + angleOffset;\n        var endAngle = Math.max(this.startAngle, this.endAngle) + angleOffset;\n        var midAngle = (startAngle + endAngle) * 0.5;\n        var innerRadius = Math.min(this.innerRadius, this.outerRadius);\n        var outerRadius = Math.max(this.innerRadius, this.outerRadius);\n        var centerOffset = this.centerOffset;\n        var fullPie = this.fullPie;\n        var centerX = this.centerX;\n        var centerY = this.centerY;\n        path.clear();\n        if (centerOffset) {\n            centerX += centerOffset * Math.cos(midAngle);\n            centerY += centerOffset * Math.sin(midAngle);\n        }\n        if (!fullPie) {\n            path.moveTo(centerX + innerRadius * Math.cos(startAngle), centerY + innerRadius * Math.sin(startAngle));\n            // if (showTip) {\n            //     path.lineTo(\n            //         centerX + 0.5 * (innerRadius + outerRadius) * Math.cos(startAngle) + tipOffset * Math.cos(startAngle + Math.PI / 2),\n            //         centerY + 0.5 * (innerRadius + outerRadius) * Math.sin(startAngle) + tipOffset * Math.sin(startAngle + Math.PI / 2)\n            //     );\n            // }\n            path.lineTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n        }\n        path.cubicArc(centerX, centerY, outerRadius, outerRadius, 0, startAngle, endAngle, 0);\n        // path[fullPie ? 'moveTo' : 'lineTo'](\n        //     centerX + innerRadius * Math.cos(endAngle),\n        //     centerY + innerRadius * Math.sin(endAngle)\n        // );\n        if (fullPie) {\n            path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        }\n        else {\n            // if (showTip) {\n            //     path.lineTo(\n            //         centerX + 0.5 * (innerRadius + outerRadius) * Math.cos(endAngle) + tipOffset * Math.cos(endAngle + Math.PI / 2),\n            //         centerY + 0.5 * (innerRadius + outerRadius) * Math.sin(endAngle) + tipOffset * Math.sin(endAngle + Math.PI / 2)\n            //     );\n            // }\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var x = centerX + innerRadius * Math.cos(endAngle);\n            path.lineTo(Math.abs(x) < 1e-8 ? 0 : x, centerY + innerRadius * Math.sin(endAngle));\n        }\n        path.cubicArc(centerX, centerY, innerRadius, innerRadius, 0, endAngle, startAngle, 1);\n        path.closePath();\n        this.dirtyPath = false;\n    };\n    Sector.prototype.render = function (ctx) {\n        if (this.dirtyTransform) {\n            this.computeTransformMatrix();\n        }\n        this.matrix.toContext(ctx);\n        this.updatePath();\n        this.scene.appendPath(this.path);\n        this.fillStroke(ctx);\n        this.dirty = false;\n    };\n    Sector.className = 'Sector';\n    return Sector;\n}(Shape));\n\nvar __extends$1u = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PieNodeTag;\n(function (PieNodeTag) {\n    PieNodeTag[PieNodeTag[\"Sector\"] = 0] = \"Sector\";\n    PieNodeTag[PieNodeTag[\"Callout\"] = 1] = \"Callout\";\n    PieNodeTag[PieNodeTag[\"Label\"] = 2] = \"Label\";\n})(PieNodeTag || (PieNodeTag = {}));\nvar PieSeriesLabel = /** @class */ (function (_super) {\n    __extends$1u(PieSeriesLabel, _super);\n    function PieSeriesLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.offset = 3; // from the callout line\n        _this.minAngle = 20; // in degrees\n        return _this;\n    }\n    __decorate$U([\n        reactive('change')\n    ], PieSeriesLabel.prototype, \"offset\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeriesLabel.prototype, \"minAngle\", void 0);\n    return PieSeriesLabel;\n}(Label));\nvar PieSeriesCallout = /** @class */ (function (_super) {\n    __extends$1u(PieSeriesCallout, _super);\n    function PieSeriesCallout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.colors = [];\n        _this.length = 10;\n        _this.strokeWidth = 1;\n        return _this;\n    }\n    __decorate$U([\n        reactive('change')\n    ], PieSeriesCallout.prototype, \"colors\", void 0);\n    __decorate$U([\n        reactive('change')\n    ], PieSeriesCallout.prototype, \"length\", void 0);\n    __decorate$U([\n        reactive('change')\n    ], PieSeriesCallout.prototype, \"strokeWidth\", void 0);\n    return PieSeriesCallout;\n}(Observable));\nvar PieSeriesTooltip = /** @class */ (function (_super) {\n    __extends$1u(PieSeriesTooltip, _super);\n    function PieSeriesTooltip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate$U([\n        reactive('change')\n    ], PieSeriesTooltip.prototype, \"renderer\", void 0);\n    return PieSeriesTooltip;\n}(SeriesTooltip));\nvar PieSeries = /** @class */ (function (_super) {\n    __extends$1u(PieSeries, _super);\n    function PieSeries() {\n        var _this = _super.call(this) || this;\n        _this.radiusScale = new LinearScale();\n        _this.groupSelection = Selection.select(_this.group).selectAll();\n        /**\n         * The processed data that gets visualized.\n         */\n        _this.groupSelectionData = [];\n        _this.angleScale = (function () {\n            var scale = new LinearScale();\n            // Each slice is a ratio of the whole, where all ratios add up to 1.\n            scale.domain = [0, 1];\n            // Add 90 deg to start the first pie at 12 o'clock.\n            scale.range = [-Math.PI, Math.PI].map(function (angle) { return angle + Math.PI / 2; });\n            return scale;\n        })();\n        // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n        _this.seriesItemEnabled = [];\n        _this.label = new PieSeriesLabel();\n        _this.callout = new PieSeriesCallout();\n        _this.tooltip = new PieSeriesTooltip();\n        /**\n         * The key of the numeric field to use to determine the angle (for example,\n         * a pie slice angle).\n         */\n        _this.angleKey = '';\n        _this.angleName = '';\n        _this._fills = [\n            '#c16068',\n            '#a2bf8a',\n            '#ebcc87',\n            '#80a0c3',\n            '#b58dae',\n            '#85c0d1'\n        ];\n        _this._strokes = [\n            '#874349',\n            '#718661',\n            '#a48f5f',\n            '#5a7088',\n            '#7f637a',\n            '#5d8692'\n        ];\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.lineDash = undefined;\n        _this.lineDashOffset = 0;\n        /**\n         * The series rotation in degrees.\n         */\n        _this.rotation = 0;\n        _this.outerRadiusOffset = 0;\n        _this.innerRadiusOffset = 0;\n        _this.strokeWidth = 1;\n        _this.highlightStyle = { fill: 'yellow' };\n        _this.addEventListener('update', _this.update, _this);\n        _this.label.addEventListener('change', _this.scheduleLayout, _this);\n        _this.label.addEventListener('dataChange', _this.scheduleData, _this);\n        _this.callout.addEventListener('change', _this.scheduleLayout, _this);\n        _this.callout.colors = _this.strokes;\n        _this.addPropertyListener('data', function (event) {\n            if (event.value) {\n                event.source.seriesItemEnabled = event.value.map(function () { return true; });\n            }\n        });\n        return _this;\n    }\n    Object.defineProperty(PieSeries.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    oldTitle.removeEventListener('change', this.scheduleLayout);\n                    this.group.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.textBaseline = 'bottom';\n                    value.addEventListener('change', this.scheduleLayout);\n                    this.group.appendChild(value.node);\n                }\n                this._title = value;\n                this.scheduleLayout();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PieSeries.prototype, \"fills\", {\n        get: function () {\n            return this._fills;\n        },\n        set: function (values) {\n            this._fills = values;\n            this.strokes = values.map(function (color) { return Color.fromString(color).darker().toHexString(); });\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PieSeries.prototype, \"strokes\", {\n        get: function () {\n            return this._strokes;\n        },\n        set: function (values) {\n            this._strokes = values;\n            this.callout.colors = values;\n            this.scheduleData();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PieSeries.prototype.onHighlightChange = function () {\n        this.updateNodes();\n    };\n    PieSeries.prototype.setColors = function (fills, strokes) {\n        this.fills = fills;\n        this.strokes = strokes;\n        this.callout.colors = strokes;\n    };\n    PieSeries.prototype.getDomain = function (direction) {\n        if (direction === ChartAxisDirection.X) {\n            return this.angleScale.domain;\n        }\n        else {\n            return this.radiusScale.domain;\n        }\n    };\n    PieSeries.prototype.processData = function () {\n        var _this = this;\n        var _a = this, angleKey = _a.angleKey, radiusKey = _a.radiusKey, seriesItemEnabled = _a.seriesItemEnabled, angleScale = _a.angleScale, groupSelectionData = _a.groupSelectionData;\n        var data = angleKey && this.data ? this.data : [];\n        var angleData = data.map(function (datum, index) { return seriesItemEnabled[index] && Math.abs(+datum[angleKey]) || 0; });\n        var angleDataTotal = angleData.reduce(function (a, b) { return a + b; }, 0);\n        // The ratios (in [0, 1] interval) used to calculate the end angle value for every pie slice.\n        // Each slice starts where the previous one ends, so we only keep the ratios for end angles.\n        var angleDataRatios = (function () {\n            var sum = 0;\n            return angleData.map(function (datum) { return sum += datum / angleDataTotal; });\n        })();\n        var labelKey = this.label.enabled && this.labelKey;\n        var labelData = labelKey ? data.map(function (datum) { return String(datum[labelKey]); }) : [];\n        var radiusData = [];\n        if (radiusKey) {\n            var _b = this, radiusMin = _b.radiusMin, radiusMax = _b.radiusMax;\n            var radii = data.map(function (datum) { return Math.abs(datum[radiusKey]); });\n            var min_1 = radiusMin !== undefined ? radiusMin : Math.min.apply(Math, radii);\n            var max = radiusMax !== undefined ? radiusMax : Math.max.apply(Math, radii);\n            var delta_1 = max - min_1;\n            radiusData = radii.map(function (value) { return delta_1 ? (value - min_1) / delta_1 : 1; });\n        }\n        groupSelectionData.length = 0;\n        var rotation = toRadians(this.rotation);\n        var halfPi = Math.PI / 2;\n        var datumIndex = 0;\n        // Simply use reduce here to pair up adjacent ratios.\n        angleDataRatios.reduce(function (start, end) {\n            var radius = radiusKey ? radiusData[datumIndex] : 1;\n            var startAngle = angleScale.convert(start) + rotation;\n            var endAngle = angleScale.convert(end) + rotation;\n            var midAngle = (startAngle + endAngle) / 2;\n            var span = Math.abs(endAngle - startAngle);\n            var midCos = Math.cos(midAngle);\n            var midSin = Math.sin(midAngle);\n            var labelMinAngle = toRadians(_this.label.minAngle);\n            var labelVisible = labelKey && span > labelMinAngle;\n            var midAngle180 = normalizeAngle180(midAngle);\n            // Split the circle into quadrants like so: \n            var quadrantStart = -3 * Math.PI / 4; // same as `normalizeAngle180(toRadians(-135))`\n            var textAlign;\n            var textBaseline;\n            if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'center';\n                textBaseline = 'bottom';\n            }\n            else if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'left';\n                textBaseline = 'middle';\n            }\n            else if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'center';\n                textBaseline = 'hanging';\n            }\n            else {\n                textAlign = 'right';\n                textBaseline = 'middle';\n            }\n            groupSelectionData.push({\n                series: _this,\n                seriesDatum: data[datumIndex],\n                index: datumIndex,\n                radius: radius,\n                startAngle: startAngle,\n                endAngle: endAngle,\n                midAngle: midAngle,\n                midCos: midCos,\n                midSin: midSin,\n                label: labelVisible ? {\n                    text: labelData[datumIndex],\n                    textAlign: textAlign,\n                    textBaseline: textBaseline\n                } : undefined\n            });\n            datumIndex++;\n            return end;\n        }, 0);\n        return true;\n    };\n    PieSeries.prototype.update = function () {\n        var chart = this.chart;\n        var visible = this.group.visible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n        if (!visible || !chart || chart.dataPending || chart.layoutPending) {\n            return;\n        }\n        var _a = this, radius = _a.radius, innerRadiusOffset = _a.innerRadiusOffset, outerRadiusOffset = _a.outerRadiusOffset, title = _a.title;\n        this.radiusScale.range = [\n            innerRadiusOffset ? radius + innerRadiusOffset : 0,\n            radius + (outerRadiusOffset || 0)\n        ];\n        this.group.translationX = this.centerX;\n        this.group.translationY = this.centerY;\n        if (title) {\n            title.node.translationY = -radius - outerRadiusOffset - 2;\n            title.node.visible = title.enabled;\n        }\n        this.updateGroupSelection();\n        this.updateNodes();\n    };\n    PieSeries.prototype.updateGroupSelection = function () {\n        var updateGroups = this.groupSelection.setData(this.groupSelectionData);\n        updateGroups.exit.remove();\n        var enterGroups = updateGroups.enter.append(Group);\n        enterGroups.append(Sector).each(function (node) { return node.tag = PieNodeTag.Sector; });\n        enterGroups.append(Line).each(function (node) {\n            node.tag = PieNodeTag.Callout;\n            node.pointerEvents = PointerEvents.None;\n        });\n        enterGroups.append(Text).each(function (node) {\n            node.tag = PieNodeTag.Label;\n            node.pointerEvents = PointerEvents.None;\n        });\n        this.groupSelection = updateGroups.merge(enterGroups);\n    };\n    PieSeries.prototype.updateNodes = function () {\n        var _this = this;\n        if (!this.chart) {\n            return;\n        }\n        var _a = this, fills = _a.fills, strokes = _a.strokes, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, strokeWidth = _a.strokeWidth, outerRadiusOffset = _a.outerRadiusOffset, radiusScale = _a.radiusScale, callout = _a.callout, shadow = _a.shadow, _b = _a.highlightStyle, fill = _b.fill, stroke = _b.stroke, centerOffset = _b.centerOffset, angleKey = _a.angleKey, radiusKey = _a.radiusKey, formatter = _a.formatter;\n        var highlightedDatum = this.chart.highlightedDatum;\n        var centerOffsets = [];\n        var innerRadius = radiusScale.convert(0);\n        this.groupSelection.selectByTag(PieNodeTag.Sector).each(function (sector, datum, index) {\n            var radius = radiusScale.convert(datum.radius);\n            var highlighted = datum === highlightedDatum;\n            var sectorFill = highlighted && fill !== undefined ? fill : fills[index % fills.length];\n            var sectorStroke = highlighted && stroke !== undefined ? stroke : strokes[index % strokes.length];\n            var format = undefined;\n            if (formatter) {\n                format = formatter({\n                    datum: datum.seriesDatum,\n                    fill: sectorFill,\n                    stroke: sectorStroke,\n                    strokeWidth: strokeWidth,\n                    highlighted: highlighted,\n                    angleKey: angleKey,\n                    radiusKey: radiusKey\n                });\n            }\n            sector.innerRadius = innerRadius;\n            sector.outerRadius = radius;\n            sector.startAngle = datum.startAngle;\n            sector.endAngle = datum.endAngle;\n            sector.fill = format && format.fill || sectorFill;\n            sector.stroke = format && format.stroke || sectorStroke;\n            sector.strokeWidth = format && format.strokeWidth !== undefined ? format.strokeWidth : strokeWidth;\n            sector.fillOpacity = fillOpacity;\n            sector.strokeOpacity = strokeOpacity;\n            sector.lineDash = _this.lineDash;\n            sector.lineDashOffset = _this.lineDashOffset;\n            sector.centerOffset = highlighted && centerOffset !== undefined ? centerOffset : 0;\n            sector.fillShadow = shadow;\n            sector.lineJoin = 'round';\n            centerOffsets.push(sector.centerOffset);\n        });\n        var calloutColors = callout.colors, calloutLength = callout.length, calloutStrokeWidth = callout.strokeWidth;\n        this.groupSelection.selectByTag(PieNodeTag.Callout).each(function (line, datum, index) {\n            if (datum.label) {\n                var radius = radiusScale.convert(datum.radius);\n                line.strokeWidth = calloutStrokeWidth;\n                line.stroke = calloutColors[index % calloutColors.length];\n                line.x1 = datum.midCos * radius;\n                line.y1 = datum.midSin * radius;\n                line.x2 = datum.midCos * (radius + calloutLength);\n                line.y2 = datum.midSin * (radius + calloutLength);\n            }\n            else {\n                line.stroke = undefined;\n            }\n        });\n        {\n            var _c = this.label, offset_1 = _c.offset, fontStyle_1 = _c.fontStyle, fontWeight_1 = _c.fontWeight, fontSize_1 = _c.fontSize, fontFamily_1 = _c.fontFamily, color_1 = _c.color;\n            this.groupSelection.selectByTag(PieNodeTag.Label).each(function (text, datum, index) {\n                var label = datum.label;\n                if (label) {\n                    var radius = radiusScale.convert(datum.radius);\n                    var labelRadius = centerOffsets[index] + radius + calloutLength + offset_1;\n                    text.fontStyle = fontStyle_1;\n                    text.fontWeight = fontWeight_1;\n                    text.fontSize = fontSize_1;\n                    text.fontFamily = fontFamily_1;\n                    text.text = label.text;\n                    text.x = datum.midCos * labelRadius;\n                    text.y = datum.midSin * labelRadius;\n                    text.fill = color_1;\n                    text.textAlign = label.textAlign;\n                    text.textBaseline = label.textBaseline;\n                }\n                else {\n                    text.fill = undefined;\n                }\n            });\n        }\n    };\n    PieSeries.prototype.fireNodeClickEvent = function (event, datum) {\n        this.fireEvent({\n            type: 'nodeClick',\n            event: event,\n            series: this,\n            datum: datum.seriesDatum,\n            angleKey: this.angleKey,\n            labelKey: this.labelKey,\n            radiusKey: this.radiusKey\n        });\n    };\n    PieSeries.prototype.getTooltipHtml = function (nodeDatum) {\n        var angleKey = this.angleKey;\n        if (!angleKey) {\n            return '';\n        }\n        var _a = this, fills = _a.fills, tooltip = _a.tooltip, angleName = _a.angleName, radiusKey = _a.radiusKey, radiusName = _a.radiusName, labelKey = _a.labelKey, labelName = _a.labelName;\n        var _b = tooltip.renderer, tooltipRenderer = _b === void 0 ? this.tooltipRenderer : _b;\n        var color = fills[nodeDatum.index % fills.length];\n        var datum = nodeDatum.seriesDatum;\n        var label = labelKey ? datum[labelKey] + \": \" : '';\n        var angleValue = datum[angleKey];\n        var formattedAngleValue = typeof angleValue === 'number' ? toFixed(angleValue) : angleValue.toString();\n        var title = this.title ? this.title.text : undefined;\n        var content = label + formattedAngleValue;\n        var defaults = {\n            title: title,\n            backgroundColor: color,\n            content: content\n        };\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum: datum,\n                angleKey: angleKey,\n                angleValue: angleValue,\n                angleName: angleName,\n                radiusKey: radiusKey,\n                radiusValue: radiusKey ? datum[radiusKey] : undefined,\n                radiusName: radiusName,\n                labelKey: labelKey,\n                labelName: labelName,\n                title: title,\n                color: color,\n            }), defaults);\n        }\n        return toTooltipHtml(defaults);\n    };\n    PieSeries.prototype.listSeriesItems = function (legendData) {\n        var _this = this;\n        var _a = this, labelKey = _a.labelKey, data = _a.data;\n        if (data && data.length && labelKey) {\n            var _b = this, fills_1 = _b.fills, strokes_1 = _b.strokes, id_1 = _b.id;\n            data.forEach(function (datum, index) {\n                legendData.push({\n                    id: id_1,\n                    itemId: index,\n                    enabled: _this.seriesItemEnabled[index],\n                    label: {\n                        text: String(datum[labelKey])\n                    },\n                    marker: {\n                        fill: fills_1[index % fills_1.length],\n                        stroke: strokes_1[index % strokes_1.length],\n                        fillOpacity: _this.fillOpacity,\n                        strokeOpacity: _this.strokeOpacity\n                    }\n                });\n            });\n        }\n    };\n    PieSeries.prototype.toggleSeriesItem = function (itemId, enabled) {\n        this.seriesItemEnabled[itemId] = enabled;\n        this.scheduleData();\n    };\n    PieSeries.className = 'PieSeries';\n    PieSeries.type = 'pie';\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"angleKey\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"angleName\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"radiusKey\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"radiusName\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"radiusMin\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"radiusMax\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"labelKey\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"labelName\", void 0);\n    __decorate$U([\n        reactive('layoutChange')\n    ], PieSeries.prototype, \"fillOpacity\", void 0);\n    __decorate$U([\n        reactive('layoutChange')\n    ], PieSeries.prototype, \"strokeOpacity\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"lineDash\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"lineDashOffset\", void 0);\n    __decorate$U([\n        reactive('update')\n    ], PieSeries.prototype, \"formatter\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"rotation\", void 0);\n    __decorate$U([\n        reactive('layoutChange')\n    ], PieSeries.prototype, \"outerRadiusOffset\", void 0);\n    __decorate$U([\n        reactive('dataChange')\n    ], PieSeries.prototype, \"innerRadiusOffset\", void 0);\n    __decorate$U([\n        reactive('layoutChange')\n    ], PieSeries.prototype, \"strokeWidth\", void 0);\n    __decorate$U([\n        reactive('layoutChange')\n    ], PieSeries.prototype, \"shadow\", void 0);\n    return PieSeries;\n}(PolarSeries));\n\nfunction floor$9(date) {\n    date.setUTCSeconds(0, 0);\n}\nfunction offset$9(date, minutes) {\n    date.setTime(date.getTime() + minutes * durationMinute);\n}\nfunction count$9(start, end) {\n    return (end.getTime() - start.getTime()) / durationMinute;\n}\nfunction field$7(date) {\n    return date.getUTCMinutes();\n}\nvar utcMinute = new CountableTimeInterval(floor$9, offset$9, count$9, field$7);\n\nfunction floor$a(date) {\n    date.setUTCMinutes(0, 0, 0);\n}\nfunction offset$a(date, hours) {\n    date.setTime(date.getTime() + hours * durationHour);\n}\nfunction count$a(start, end) {\n    return (end.getTime() - start.getTime()) / durationHour;\n}\nfunction field$8(date) {\n    return date.getUTCHours();\n}\nvar utcHour = new CountableTimeInterval(floor$a, offset$a, count$a, field$8);\n\nfunction floor$b(date) {\n    date.setUTCDate(1);\n    date.setUTCHours(0, 0, 0, 0);\n}\nfunction offset$b(date, months) {\n    date.setUTCMonth(date.getUTCMonth() + months);\n}\nfunction count$b(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}\nfunction field$9(date) {\n    return date.getUTCMonth();\n}\nvar utcMonth = new CountableTimeInterval(floor$b, offset$b, count$b, field$9);\n\nvar __assign$3 = (undefined && undefined.__assign) || function () {\n    __assign$3 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$3.apply(this, arguments);\n};\nvar palette = {\n    fills: [\n        '#f3622d',\n        '#fba71b',\n        '#57b757',\n        '#41a9c9',\n        '#4258c9',\n        '#9a42c8',\n        '#c84164',\n        '#888888'\n    ],\n    strokes: [\n        '#aa4520',\n        '#b07513',\n        '#3d803d',\n        '#2d768d',\n        '#2e3e8d',\n        '#6c2e8c',\n        '#8c2d46',\n        '#5f5f5f'\n    ]\n};\nvar ChartTheme = /** @class */ (function () {\n    function ChartTheme(options) {\n        var defaults = this.createChartConfigPerSeries(this.getDefaults());\n        if (isObject(options)) {\n            var mergeOptions_1 = { arrayMerge: arrayMerge };\n            options = deepMerge({}, options, mergeOptions_1);\n            var overrides_1 = options.overrides;\n            if (overrides_1) {\n                if (isObject(overrides_1.common)) {\n                    ChartTheme.seriesTypes.concat(['cartesian', 'polar']).forEach(function (seriesType) {\n                        defaults[seriesType] = deepMerge(defaults[seriesType], overrides_1.common, mergeOptions_1);\n                    });\n                }\n                if (overrides_1.cartesian) {\n                    defaults.cartesian = deepMerge(defaults.cartesian, overrides_1.cartesian, mergeOptions_1);\n                    ChartTheme.cartesianSeriesTypes.forEach(function (seriesType) {\n                        defaults[seriesType] = deepMerge(defaults[seriesType], overrides_1.cartesian, mergeOptions_1);\n                    });\n                }\n                if (overrides_1.polar) {\n                    defaults.polar = deepMerge(defaults.polar, overrides_1.polar, mergeOptions_1);\n                    ChartTheme.polarSeriesTypes.forEach(function (seriesType) {\n                        defaults[seriesType] = deepMerge(defaults[seriesType], overrides_1.polar, mergeOptions_1);\n                    });\n                }\n                ChartTheme.seriesTypes.forEach(function (seriesType) {\n                    var _a;\n                    var chartConfig = overrides_1[seriesType];\n                    if (chartConfig) {\n                        if (chartConfig.series) {\n                            chartConfig.series = (_a = {}, _a[seriesType] = chartConfig.series, _a);\n                        }\n                        defaults[seriesType] = deepMerge(defaults[seriesType], chartConfig, mergeOptions_1);\n                    }\n                });\n            }\n        }\n        this.palette = options && options.palette ? options.palette : this.getPalette();\n        this.config = Object.freeze(defaults);\n    }\n    ChartTheme.prototype.getPalette = function () {\n        return palette;\n    };\n    ChartTheme.getAxisDefaults = function () {\n        return {\n            top: {},\n            right: {},\n            bottom: {},\n            left: {},\n            title: {\n                padding: {\n                    top: 10,\n                    right: 10,\n                    bottom: 10,\n                    left: 10\n                },\n                text: 'Axis Title',\n                fontStyle: undefined,\n                fontWeight: 'bold',\n                fontSize: 12,\n                fontFamily: this.fontFamily,\n                color: 'rgb(70, 70, 70)'\n            },\n            label: {\n                fontStyle: undefined,\n                fontWeight: undefined,\n                fontSize: 12,\n                fontFamily: this.fontFamily,\n                padding: 5,\n                rotation: 0,\n                color: 'rgb(87, 87, 87)',\n                formatter: undefined\n            },\n            line: {\n                width: 1,\n                color: 'rgb(195, 195, 195)'\n            },\n            tick: {\n                width: 1,\n                size: 6,\n                color: 'rgb(195, 195, 195)',\n                count: 10\n            },\n            gridStyle: [{\n                    stroke: 'rgb(219, 219, 219)',\n                    lineDash: [4, 2]\n                }]\n        };\n    };\n    ChartTheme.getSeriesDefaults = function () {\n        return {\n            tooltip: {\n                enabled: true,\n                renderer: undefined,\n                format: undefined\n            },\n            visible: true,\n            showInLegend: true\n        };\n    };\n    ChartTheme.getBarSeriesDefaults = function () {\n        return __assign$3(__assign$3({}, this.getSeriesDefaults()), { flipXY: false, fillOpacity: 1, strokeOpacity: 1, xKey: '', xName: '', yKeys: [], yNames: [], grouped: false, normalizedTo: undefined, strokeWidth: 1, lineDash: undefined, lineDashOffset: 0, tooltipRenderer: undefined, highlightStyle: {\n                fill: 'yellow'\n            }, label: {\n                enabled: false,\n                fontStyle: undefined,\n                fontWeight: undefined,\n                fontSize: 12,\n                fontFamily: this.fontFamily,\n                color: 'rgb(70, 70, 70)',\n                formatter: undefined\n            }, shadow: {\n                enabled: false,\n                color: 'rgba(0, 0, 0, 0.5)',\n                xOffset: 3,\n                yOffset: 3,\n                blur: 5\n            } });\n    };\n    ChartTheme.getCartesianSeriesMarkerDefaults = function () {\n        return {\n            enabled: true,\n            shape: 'circle',\n            size: 6,\n            maxSize: 30,\n            strokeWidth: 1,\n            formatter: undefined\n        };\n    };\n    ChartTheme.getChartDefaults = function () {\n        return {\n            width: 600,\n            height: 300,\n            autoSize: true,\n            background: {\n                visible: true,\n                fill: 'white'\n            },\n            padding: {\n                top: 20,\n                right: 20,\n                bottom: 20,\n                left: 20\n            },\n            title: {\n                enabled: false,\n                padding: {\n                    top: 10,\n                    right: 10,\n                    bottom: 10,\n                    left: 10\n                },\n                text: 'Title',\n                fontStyle: undefined,\n                fontWeight: 'bold',\n                fontSize: 16,\n                fontFamily: this.fontFamily,\n                color: 'rgb(70, 70, 70)'\n            },\n            subtitle: {\n                enabled: false,\n                padding: {\n                    top: 10,\n                    right: 10,\n                    bottom: 10,\n                    left: 10\n                },\n                text: 'Subtitle',\n                fontStyle: undefined,\n                fontWeight: undefined,\n                fontSize: 12,\n                fontFamily: this.fontFamily,\n                color: 'rgb(140, 140, 140)'\n            },\n            legend: {\n                enabled: true,\n                position: 'right',\n                spacing: 20,\n                item: {\n                    paddingX: 16,\n                    paddingY: 8,\n                    marker: {\n                        shape: undefined,\n                        size: 15,\n                        strokeWidth: 1,\n                        padding: 8\n                    },\n                    label: {\n                        color: 'black',\n                        fontStyle: undefined,\n                        fontWeight: undefined,\n                        fontSize: 12,\n                        fontFamily: this.fontFamily\n                    }\n                }\n            },\n            tooltip: {\n                enabled: true,\n                tracking: true,\n                delay: 0,\n                class: Chart.defaultTooltipClass\n            }\n        };\n    };\n    ChartTheme.prototype.createChartConfigPerSeries = function (config) {\n        var typeToAliases = {\n            cartesian: ChartTheme.cartesianSeriesTypes,\n            polar: ChartTheme.polarSeriesTypes\n        };\n        var _loop_1 = function (type) {\n            typeToAliases[type].forEach(function (alias) {\n                if (!config[alias]) {\n                    config[alias] = deepMerge({}, config[type], { arrayMerge: arrayMerge });\n                }\n            });\n        };\n        for (var type in typeToAliases) {\n            _loop_1(type);\n        }\n        return config;\n    };\n    ChartTheme.prototype.getConfig = function (path) {\n        return getValue(this.config, path);\n    };\n    /**\n     * Meant to be overridden in subclasses. For example:\n     * ```\n     *     getDefaults() {\n     *         const subclassDefaults = { ... };\n     *         return this.mergeWithParentDefaults(subclassDefaults);\n     *     }\n     * ```\n     */\n    ChartTheme.prototype.getDefaults = function () {\n        return deepMerge({}, ChartTheme.defaults, { arrayMerge: arrayMerge });\n    };\n    ChartTheme.prototype.mergeWithParentDefaults = function (defaults) {\n        var mergeOptions = { arrayMerge: arrayMerge };\n        var proto = Object.getPrototypeOf(Object.getPrototypeOf(this));\n        if (proto === Object.prototype) {\n            var config = deepMerge({}, ChartTheme.defaults, mergeOptions);\n            config = deepMerge(config, defaults, mergeOptions);\n            return config;\n        }\n        var parentDefaults = proto.getDefaults();\n        return deepMerge(parentDefaults, defaults, mergeOptions);\n    };\n    ChartTheme.prototype.setSeriesColors = function (series, seriesOptions, firstColorIndex) {\n        var palette = this.palette;\n        var colorCount = this.getSeriesColorCount(seriesOptions);\n        if (colorCount === Infinity) {\n            series.setColors(palette.fills, palette.strokes);\n        }\n        else {\n            var fills = copy(palette.fills, firstColorIndex, colorCount);\n            var strokes = copy(palette.strokes, firstColorIndex, colorCount);\n            series.setColors(fills, strokes);\n            firstColorIndex += colorCount;\n        }\n        return firstColorIndex;\n    };\n    /**\n     * This would typically correspond to the number of dependent variables the series plots.\n     * If the color count is not fixed, for example it's data-dependent with one color per data point,\n     * return Infinity to fetch all unique colors and manage them in the series.\n     */\n    ChartTheme.prototype.getSeriesColorCount = function (seriesOptions) {\n        var type = seriesOptions.type;\n        switch (type) {\n            case 'bar':\n            case 'column':\n            case 'area':\n                return seriesOptions.yKeys ? seriesOptions.yKeys.length : 0;\n            case 'pie':\n                return Infinity;\n            default:\n                return 1;\n        }\n    };\n    ChartTheme.fontFamily = 'Verdana, sans-serif';\n    ChartTheme.cartesianDefaults = __assign$3(__assign$3({}, ChartTheme.getChartDefaults()), { axes: {\n            number: __assign$3({}, ChartTheme.getAxisDefaults()),\n            category: __assign$3({}, ChartTheme.getAxisDefaults()),\n            groupedCategory: __assign$3({}, ChartTheme.getAxisDefaults()),\n            time: __assign$3({}, ChartTheme.getAxisDefaults())\n        }, series: {\n            column: __assign$3(__assign$3({}, ChartTheme.getBarSeriesDefaults()), { flipXY: false }),\n            bar: __assign$3(__assign$3({}, ChartTheme.getBarSeriesDefaults()), { flipXY: true }),\n            line: __assign$3(__assign$3({}, ChartTheme.getSeriesDefaults()), { title: undefined, xKey: '', xName: '', yKey: '', yName: '', strokeWidth: 2, strokeOpacity: 1, lineDash: undefined, lineDashOffset: 0, tooltipRenderer: undefined, highlightStyle: {\n                    fill: 'yellow'\n                }, marker: __assign$3({}, ChartTheme.getCartesianSeriesMarkerDefaults()) }),\n            scatter: __assign$3(__assign$3({}, ChartTheme.getSeriesDefaults()), { title: undefined, xKey: '', yKey: '', sizeKey: undefined, labelKey: undefined, xName: '', yName: '', sizeName: 'Size', labelName: 'Label', strokeWidth: 2, fillOpacity: 1, strokeOpacity: 1, tooltipRenderer: undefined, highlightStyle: {\n                    fill: 'yellow'\n                }, marker: __assign$3({}, ChartTheme.getCartesianSeriesMarkerDefaults()) }),\n            area: __assign$3(__assign$3({}, ChartTheme.getSeriesDefaults()), { title: undefined, xKey: '', xName: '', yKeys: [], yNames: [], normalizedTo: undefined, fillOpacity: 0.8, strokeOpacity: 1, strokeWidth: 2, lineDash: undefined, lineDashOffset: 0, shadow: {\n                    enabled: false,\n                    color: 'rgba(0, 0, 0, 0.5)',\n                    xOffset: 3,\n                    yOffset: 3,\n                    blur: 5\n                }, tooltipRenderer: undefined, highlightStyle: {\n                    fill: 'yellow'\n                }, marker: __assign$3(__assign$3({}, ChartTheme.getCartesianSeriesMarkerDefaults()), { enabled: false }) }),\n            histogram: __assign$3(__assign$3({}, ChartTheme.getSeriesDefaults()), { title: undefined, xKey: '', yKey: '', xName: '', yName: '', strokeWidth: 1, fillOpacity: 1, strokeOpacity: 1, lineDash: undefined, lineDashOffset: 0, areaPlot: false, binCount: undefined, bins: undefined, aggregation: 'sum', tooltipRenderer: undefined, highlightStyle: {\n                    fill: 'yellow'\n                }, label: {\n                    enabled: false,\n                    fontStyle: undefined,\n                    fontWeight: undefined,\n                    fontSize: 12,\n                    fontFamily: ChartTheme.fontFamily,\n                    color: 'rgb(70, 70, 70)',\n                    formatter: undefined\n                } })\n        }, navigator: {\n            enabled: false,\n            height: 30,\n            min: 0,\n            max: 1,\n            mask: {\n                fill: '#999999',\n                stroke: '#999999',\n                strokeWidth: 1,\n                fillOpacity: 0.2\n            },\n            minHandle: {\n                fill: '#f2f2f2',\n                stroke: '#999999',\n                strokeWidth: 1,\n                width: 8,\n                height: 16,\n                gripLineGap: 2,\n                gripLineLength: 8\n            },\n            maxHandle: {\n                fill: '#f2f2f2',\n                stroke: '#999999',\n                strokeWidth: 1,\n                width: 8,\n                height: 16,\n                gripLineGap: 2,\n                gripLineLength: 8\n            }\n        } });\n    ChartTheme.defaults = {\n        cartesian: ChartTheme.cartesianDefaults,\n        groupedCategory: ChartTheme.cartesianDefaults,\n        polar: __assign$3(__assign$3({}, ChartTheme.getChartDefaults()), { series: {\n                pie: __assign$3(__assign$3({}, ChartTheme.getSeriesDefaults()), { title: {\n                        enabled: true,\n                        padding: new Padding(0),\n                        text: '',\n                        fontStyle: undefined,\n                        fontWeight: undefined,\n                        fontSize: 12,\n                        fontFamily: ChartTheme.fontFamily,\n                        color: 'rgb(70, 70, 70)'\n                    }, angleKey: '', angleName: '', radiusKey: undefined, radiusName: undefined, labelKey: undefined, labelName: undefined, label: {\n                        enabled: true,\n                        fontStyle: undefined,\n                        fontWeight: undefined,\n                        fontSize: 12,\n                        fontFamily: ChartTheme.fontFamily,\n                        color: 'rgb(70, 70, 70)',\n                        offset: 3,\n                        minAngle: 20\n                    }, callout: {\n                        length: 10,\n                        strokeWidth: 2\n                    }, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, lineDash: undefined, lineDashOffset: 0, rotation: 0, outerRadiusOffset: 0, innerRadiusOffset: 0, highlightStyle: {\n                        fill: 'yellow'\n                    }, shadow: {\n                        enabled: false,\n                        color: 'rgba(0, 0, 0, 0.5)',\n                        xOffset: 3,\n                        yOffset: 3,\n                        blur: 5\n                    } })\n            } }),\n        hierarchy: __assign$3(__assign$3({}, ChartTheme.getChartDefaults()), { series: {\n                treemap: __assign$3({}, ChartTheme.getSeriesDefaults())\n            } })\n    };\n    ChartTheme.cartesianSeriesTypes = ['line', 'area', 'bar', 'column', 'scatter', 'histogram'];\n    ChartTheme.polarSeriesTypes = ['pie'];\n    ChartTheme.seriesTypes = ChartTheme.cartesianSeriesTypes.concat(ChartTheme.polarSeriesTypes);\n    return ChartTheme;\n}());\nfunction arrayMerge(target, source, options) {\n    return source;\n}\n\nvar __extends$1v = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$4 = (undefined && undefined.__assign) || function () {\n    __assign$4 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$4.apply(this, arguments);\n};\nvar DarkTheme = /** @class */ (function (_super) {\n    __extends$1v(DarkTheme, _super);\n    function DarkTheme(options) {\n        return _super.call(this, options) || this;\n    }\n    DarkTheme.prototype.getDefaults = function () {\n        var fontColor = 'rgb(200, 200, 200)';\n        var mutedFontColor = 'rgb(150, 150, 150)';\n        var axisDefaults = {\n            title: {\n                color: fontColor\n            },\n            label: {\n                color: fontColor\n            },\n            gridStyle: [{\n                    stroke: 'rgb(88, 88, 88)',\n                    lineDash: [4, 2]\n                }]\n        };\n        var seriesLabelDefaults = {\n            label: {\n                color: fontColor\n            }\n        };\n        var chartDefaults = {\n            background: {\n                fill: 'rgb(34, 38, 41)'\n            },\n            title: {\n                color: fontColor\n            },\n            subtitle: {\n                color: mutedFontColor\n            },\n            axes: {\n                number: __assign$4({}, axisDefaults),\n                category: __assign$4({}, axisDefaults),\n                time: __assign$4({}, axisDefaults)\n            },\n            legend: {\n                item: {\n                    label: {\n                        color: fontColor\n                    }\n                }\n            }\n        };\n        return this.mergeWithParentDefaults({\n            cartesian: __assign$4(__assign$4({}, chartDefaults), { series: {\n                    bar: __assign$4({}, seriesLabelDefaults),\n                    column: __assign$4({}, seriesLabelDefaults),\n                    histogram: __assign$4({}, seriesLabelDefaults)\n                } }),\n            polar: __assign$4(__assign$4({}, chartDefaults), { series: {\n                    pie: __assign$4(__assign$4({}, seriesLabelDefaults), { title: {\n                            color: fontColor\n                        } })\n                } })\n        });\n    };\n    return DarkTheme;\n}(ChartTheme));\n\nvar __extends$1w = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$1 = {\n    fills: [\n        '#f44336',\n        '#e91e63',\n        '#9c27b0',\n        '#673ab7',\n        '#3f51b5',\n        '#2196f3',\n        '#03a9f4',\n        '#00bcd4',\n        '#009688',\n        '#4caf50',\n        '#8bc34a',\n        '#cddc39',\n        '#ffeb3b',\n        '#ffc107',\n        '#ff9800',\n        '#ff5722'\n    ],\n    strokes: [\n        '#ab2f26',\n        '#a31545',\n        '#6d1b7b',\n        '#482980',\n        '#2c397f',\n        '#1769aa',\n        '#0276ab',\n        '#008494',\n        '#00695f',\n        '#357a38',\n        '#618834',\n        '#909a28',\n        '#b3a429',\n        '#b38705',\n        '#b36a00',\n        '#b33d18'\n    ]\n};\nvar MaterialLight = /** @class */ (function (_super) {\n    __extends$1w(MaterialLight, _super);\n    function MaterialLight() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MaterialLight.prototype.getPalette = function () {\n        return palette$1;\n    };\n    return MaterialLight;\n}(ChartTheme));\n\nvar __extends$1x = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$2 = {\n    fills: [\n        '#f44336',\n        '#e91e63',\n        '#9c27b0',\n        '#673ab7',\n        '#3f51b5',\n        '#2196f3',\n        '#03a9f4',\n        '#00bcd4',\n        '#009688',\n        '#4caf50',\n        '#8bc34a',\n        '#cddc39',\n        '#ffeb3b',\n        '#ffc107',\n        '#ff9800',\n        '#ff5722'\n    ],\n    strokes: [\n        '#ab2f26',\n        '#a31545',\n        '#6d1b7b',\n        '#482980',\n        '#2c397f',\n        '#1769aa',\n        '#0276ab',\n        '#008494',\n        '#00695f',\n        '#357a38',\n        '#618834',\n        '#909a28',\n        '#b3a429',\n        '#b38705',\n        '#b36a00',\n        '#b33d18'\n    ]\n};\nvar MaterialDark = /** @class */ (function (_super) {\n    __extends$1x(MaterialDark, _super);\n    function MaterialDark() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MaterialDark.prototype.getPalette = function () {\n        return palette$2;\n    };\n    return MaterialDark;\n}(DarkTheme));\n\nvar __extends$1y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$3 = {\n    fills: [\n        '#c16068',\n        '#a2bf8a',\n        '#ebcc87',\n        '#80a0c3',\n        '#b58dae',\n        '#85c0d1'\n    ],\n    strokes: [\n        '#874349',\n        '#718661',\n        '#a48f5f',\n        '#5a7088',\n        '#7f637a',\n        '#5d8692'\n    ]\n};\nvar PastelLight = /** @class */ (function (_super) {\n    __extends$1y(PastelLight, _super);\n    function PastelLight() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PastelLight.prototype.getPalette = function () {\n        return palette$3;\n    };\n    return PastelLight;\n}(ChartTheme));\n\nvar __extends$1z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$4 = {\n    fills: [\n        '#c16068',\n        '#a2bf8a',\n        '#ebcc87',\n        '#80a0c3',\n        '#b58dae',\n        '#85c0d1'\n    ],\n    strokes: [\n        '#874349',\n        '#718661',\n        '#a48f5f',\n        '#5a7088',\n        '#7f637a',\n        '#5d8692'\n    ]\n};\nvar PastelDark = /** @class */ (function (_super) {\n    __extends$1z(PastelDark, _super);\n    function PastelDark() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PastelDark.prototype.getPalette = function () {\n        return palette$4;\n    };\n    return PastelDark;\n}(DarkTheme));\n\nvar __extends$1A = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$5 = {\n    fills: [\n        '#febe76',\n        '#ff7979',\n        '#badc58',\n        '#f9ca23',\n        '#f0932b',\n        '#eb4c4b',\n        '#6ab04c',\n        '#7ed6df',\n        '#e056fd',\n        '#686de0'\n    ],\n    strokes: [\n        '#b28553',\n        '#b35555',\n        '#829a3e',\n        '#ae8d19',\n        '#a8671e',\n        '#a43535',\n        '#4a7b35',\n        '#58969c',\n        '#9d3cb1',\n        '#494c9d'\n    ]\n};\nvar SolarLight = /** @class */ (function (_super) {\n    __extends$1A(SolarLight, _super);\n    function SolarLight() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SolarLight.prototype.getPalette = function () {\n        return palette$5;\n    };\n    return SolarLight;\n}(ChartTheme));\n\nvar __extends$1B = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$6 = {\n    fills: [\n        '#febe76',\n        '#ff7979',\n        '#badc58',\n        '#f9ca23',\n        '#f0932b',\n        '#eb4c4b',\n        '#6ab04c',\n        '#7ed6df',\n        '#e056fd',\n        '#686de0'\n    ],\n    strokes: [\n        '#b28553',\n        '#b35555',\n        '#829a3e',\n        '#ae8d19',\n        '#a8671e',\n        '#a43535',\n        '#4a7b35',\n        '#58969c',\n        '#9d3cb1',\n        '#494c9d'\n    ]\n};\nvar SolarDark = /** @class */ (function (_super) {\n    __extends$1B(SolarDark, _super);\n    function SolarDark() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SolarDark.prototype.getPalette = function () {\n        return palette$6;\n    };\n    return SolarDark;\n}(DarkTheme));\n\nvar __extends$1C = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$7 = {\n    fills: [\n        '#5BC0EB',\n        '#FDE74C',\n        '#9BC53D',\n        '#E55934',\n        '#FA7921',\n        '#fa3081'\n    ],\n    strokes: [\n        '#4086a4',\n        '#b1a235',\n        '#6c8a2b',\n        '#a03e24',\n        '#af5517',\n        '#af225a'\n    ]\n};\nvar VividLight = /** @class */ (function (_super) {\n    __extends$1C(VividLight, _super);\n    function VividLight() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    VividLight.prototype.getPalette = function () {\n        return palette$7;\n    };\n    return VividLight;\n}(ChartTheme));\n\nvar __extends$1D = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar palette$8 = {\n    fills: [\n        '#5BC0EB',\n        '#FDE74C',\n        '#9BC53D',\n        '#E55934',\n        '#FA7921',\n        '#fa3081'\n    ],\n    strokes: [\n        '#4086a4',\n        '#b1a235',\n        '#6c8a2b',\n        '#a03e24',\n        '#af5517',\n        '#af225a'\n    ]\n};\nvar VividDark = /** @class */ (function (_super) {\n    __extends$1D(VividDark, _super);\n    function VividDark() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    VividDark.prototype.getPalette = function () {\n        return palette$8;\n    };\n    return VividDark;\n}(DarkTheme));\n\nvar __assign$5 = (undefined && undefined.__assign) || function () {\n    __assign$5 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$5.apply(this, arguments);\n};\nvar _a, _b, _c, _d, _e;\n/*\n    This file defines the specs for creating different kinds of charts, but\n    contains no code that uses the specs to actually create charts\n*/\nvar chartPadding = 20;\nvar commonChartMappings = {\n    background: {\n        meta: {\n            defaults: {\n                visible: true,\n                fill: 'white'\n            }\n        }\n    },\n    padding: {\n        meta: {\n            constructor: Padding,\n            defaults: {\n                top: chartPadding,\n                right: chartPadding,\n                bottom: chartPadding,\n                left: chartPadding\n            }\n        }\n    },\n    tooltip: {\n        meta: {\n            defaults: {\n                enabled: true,\n                tracking: true,\n                delay: 0,\n                class: Chart.defaultTooltipClass\n            }\n        }\n    },\n    title: {\n        meta: {\n            constructor: Caption,\n            defaults: {\n                enabled: false,\n                padding: {\n                    meta: {\n                        constructor: Padding,\n                        defaults: {\n                            top: 10,\n                            right: 10,\n                            bottom: 10,\n                            left: 10\n                        }\n                    }\n                },\n                text: 'Title',\n                fontStyle: undefined,\n                fontWeight: 'bold',\n                fontSize: 14,\n                fontFamily: 'Verdana, sans-serif',\n                color: 'rgb(70, 70, 70)'\n            }\n        }\n    },\n    subtitle: {\n        meta: {\n            constructor: Caption,\n            defaults: {\n                enabled: false,\n                padding: {\n                    meta: {\n                        constructor: Padding,\n                        defaults: {\n                            top: 10,\n                            right: 10,\n                            bottom: 10,\n                            left: 10\n                        }\n                    }\n                },\n                text: 'Subtitle',\n                fontStyle: undefined,\n                fontWeight: undefined,\n                fontSize: 12,\n                fontFamily: 'Verdana, sans-serif',\n                color: 'rgb(140, 140, 140)'\n            }\n        }\n    },\n    legend: {\n        meta: {\n            constructor: Legend,\n            defaults: {\n                enabled: true,\n                position: LegendPosition.Right,\n                spacing: 20\n            }\n        },\n        item: {\n            meta: {\n                constructor: LegendItem,\n                defaults: {\n                    paddingX: 16,\n                    paddingY: 8\n                }\n            },\n            marker: {\n                meta: {\n                    constructor: LegendMarker,\n                    defaults: {\n                        shape: undefined,\n                        size: 15,\n                        strokeWidth: 1,\n                        padding: 8\n                    }\n                }\n            },\n            label: {\n                meta: {\n                    constructor: LegendLabel,\n                    defaults: {\n                        color: 'black',\n                        fontStyle: undefined,\n                        fontWeight: undefined,\n                        fontSize: 12,\n                        fontFamily: 'Verdana, sans-serif'\n                    }\n                }\n            }\n        }\n    }\n};\nvar chartDefaults = {\n    container: undefined,\n    autoSize: true,\n    width: 600,\n    height: 300,\n    data: [],\n    title: undefined,\n    subtitle: undefined,\n    padding: {},\n    background: {},\n    legend: {\n        item: {\n            marker: {},\n            label: {}\n        }\n    },\n    navigator: {\n        mask: {},\n        minHandle: {},\n        maxHandle: {}\n    },\n    listeners: undefined\n};\nvar chartMeta = {\n    // Charts components' constructors normally don't take any parameters (which makes things consistent -- everything\n    // is configured the same way, via the properties, and makes the factory pattern work well) but the charts\n    // themselves are the exceptions.\n    // If a chart config has the (optional) `document` property, it will be passed to the constructor.\n    // There is no actual `document` property on the chart, it can only be supplied during instantiation.\n    constructorParams: ['document'],\n    setAsIs: ['container', 'data', 'tooltipOffset'],\n    nonSerializable: ['container', 'data']\n};\nvar axisDefaults = {\n    defaults: {\n        visibleRange: [0, 1],\n        label: {},\n        tick: {},\n        title: {},\n        line: {},\n        gridStyle: [{\n                stroke: 'rgb(219, 219, 219)',\n                lineDash: [4, 2]\n            }]\n    }\n};\nvar seriesDefaults = {\n    visible: true,\n    showInLegend: true,\n    listeners: undefined\n};\nvar columnSeriesDefaults = {\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    xKey: '',\n    xName: '',\n    yKeys: [],\n    yNames: [],\n    grouped: false,\n    normalizedTo: undefined,\n    strokeWidth: 1,\n    lineDash: undefined,\n    lineDashOffset: 0,\n    shadow: undefined,\n    highlightStyle: {\n        fill: 'yellow'\n    }\n};\nvar shadowMapping = {\n    shadow: {\n        meta: {\n            constructor: DropShadow,\n            defaults: {\n                enabled: true,\n                color: 'rgba(0, 0, 0, 0.5)',\n                xOffset: 0,\n                yOffset: 0,\n                blur: 5\n            }\n        }\n    }\n};\nvar labelDefaults = {\n    enabled: true,\n    fontStyle: undefined,\n    fontWeight: undefined,\n    fontSize: 12,\n    fontFamily: 'Verdana, sans-serif',\n    color: 'rgb(70, 70, 70)'\n};\nvar barLabelMapping = {\n    label: {\n        meta: {\n            defaults: __assign$5(__assign$5({}, labelDefaults), { formatter: undefined })\n        }\n    }\n};\nvar tooltipMapping = {\n    tooltip: {\n        meta: {\n            defaults: {\n                enabled: true,\n                renderer: undefined,\n                format: undefined\n            }\n        }\n    }\n};\nvar axisMappings = {\n    line: {\n        meta: {\n            defaults: {\n                width: 1,\n                color: 'rgb(195, 195, 195)'\n            }\n        }\n    },\n    title: {\n        meta: {\n            constructor: Caption,\n            defaults: {\n                padding: {\n                    meta: {\n                        constructor: Padding,\n                        defaults: {\n                            top: 10,\n                            right: 10,\n                            bottom: 10,\n                            left: 10\n                        }\n                    }\n                },\n                text: 'Axis Title',\n                fontStyle: undefined,\n                fontWeight: 'bold',\n                fontSize: 12,\n                fontFamily: 'Verdana, sans-serif',\n                color: 'rgb(70, 70, 70)'\n            }\n        }\n    },\n    label: {\n        meta: {\n            constructor: AxisLabel,\n            defaults: {\n                fontStyle: undefined,\n                fontWeight: undefined,\n                fontSize: 12,\n                fontFamily: 'Verdana, sans-serif',\n                padding: 5,\n                rotation: 0,\n                color: 'rgb(87, 87, 87)',\n                formatter: undefined\n            }\n        }\n    },\n    tick: {\n        meta: {\n            constructor: AxisTick,\n            defaults: {\n                width: 1,\n                size: 6,\n                color: 'rgb(195, 195, 195)',\n                count: 10\n            }\n        }\n    }\n};\nvar mappings = (_a = {},\n    _a[CartesianChart.type] = __assign$5(__assign$5({ meta: __assign$5(__assign$5({ constructor: CartesianChart }, chartMeta), { defaults: __assign$5(__assign$5({}, chartDefaults), { axes: [{\n                        type: NumberAxis.type,\n                        position: 'left'\n                    }, {\n                        type: CategoryAxis.type,\n                        position: 'bottom'\n                    }] }) }) }, commonChartMappings), { axes: (_b = {},\n            _b[NumberAxis.type] = __assign$5({ meta: __assign$5({ constructor: NumberAxis, setAsIs: ['gridStyle', 'visibleRange'] }, axisDefaults) }, axisMappings),\n            _b[CategoryAxis.type] = __assign$5({ meta: __assign$5({ constructor: CategoryAxis, setAsIs: ['gridStyle', 'visibleRange'] }, axisDefaults) }, axisMappings),\n            _b[GroupedCategoryAxis.type] = __assign$5({ meta: __assign$5({ constructor: GroupedCategoryAxis, setAsIs: ['gridStyle', 'visibleRange'] }, axisDefaults) }, axisMappings),\n            _b[TimeAxis.type] = __assign$5({ meta: __assign$5({ constructor: TimeAxis, setAsIs: ['gridStyle', 'visibleRange'] }, axisDefaults) }, axisMappings),\n            _b), series: (_c = {\n                column: __assign$5(__assign$5(__assign$5({ meta: {\n                        constructor: BarSeries,\n                        setAsIs: ['lineDash'],\n                        defaults: __assign$5(__assign$5({ flipXY: false }, seriesDefaults), columnSeriesDefaults)\n                    }, highlightStyle: {} }, tooltipMapping), barLabelMapping), shadowMapping)\n            },\n            _c[BarSeries.type] = __assign$5(__assign$5(__assign$5({ meta: {\n                    constructor: BarSeries,\n                    setAsIs: ['lineDash'],\n                    defaults: __assign$5(__assign$5({ flipXY: true }, seriesDefaults), columnSeriesDefaults)\n                }, highlightStyle: {} }, tooltipMapping), barLabelMapping), shadowMapping),\n            _c[LineSeries.type] = __assign$5(__assign$5({ meta: {\n                    constructor: LineSeries,\n                    setAsIs: ['lineDash'],\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { title: undefined, xKey: '', xName: '', yKey: '', yName: '', strokeWidth: 2, strokeOpacity: 1, lineDash: undefined, lineDashOffset: 0, highlightStyle: {\n                            fill: 'yellow'\n                        } })\n                } }, tooltipMapping), { highlightStyle: {}, marker: {\n                    meta: {\n                        constructor: CartesianSeriesMarker,\n                        defaults: {\n                            enabled: true,\n                            shape: 'circle',\n                            size: 6,\n                            maxSize: 30,\n                            strokeWidth: 1,\n                            formatter: undefined\n                        }\n                    }\n                } }),\n            _c[ScatterSeries.type] = __assign$5(__assign$5({ meta: {\n                    constructor: ScatterSeries,\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { title: undefined, xKey: '', yKey: '', sizeKey: undefined, labelKey: undefined, xName: '', yName: '', sizeName: 'Size', labelName: 'Label', strokeWidth: 2, fillOpacity: 1, strokeOpacity: 1, highlightStyle: {\n                            fill: 'yellow'\n                        } })\n                } }, tooltipMapping), { highlightStyle: {}, marker: {\n                    meta: {\n                        constructor: CartesianSeriesMarker,\n                        defaults: {\n                            enabled: true,\n                            shape: 'circle',\n                            size: 6,\n                            maxSize: 30,\n                            strokeWidth: 1,\n                            formatter: undefined\n                        }\n                    }\n                } }),\n            _c[AreaSeries.type] = __assign$5(__assign$5(__assign$5({ meta: {\n                    constructor: AreaSeries,\n                    setAsIs: ['lineDash'],\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { xKey: '', xName: '', yKeys: [], yNames: [], normalizedTo: undefined, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 2, lineDash: undefined, lineDashOffset: 0, shadow: undefined, highlightStyle: {\n                            fill: 'yellow'\n                        } })\n                } }, tooltipMapping), { highlightStyle: {}, marker: {\n                    meta: {\n                        constructor: CartesianSeriesMarker,\n                        defaults: {\n                            enabled: true,\n                            shape: 'circle',\n                            size: 6,\n                            maxSize: 30,\n                            strokeWidth: 1,\n                            formatter: undefined\n                        }\n                    }\n                } }), shadowMapping),\n            _c[HistogramSeries.type] = __assign$5(__assign$5(__assign$5({ meta: {\n                    constructor: HistogramSeries,\n                    setAsIs: ['lineDash'],\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { title: undefined, xKey: '', yKey: '', xName: '', yName: '', strokeWidth: 1, fillOpacity: 1, strokeOpacity: 1, lineDash: undefined, lineDashOffset: 0, areaPlot: false, binCount: undefined, bins: undefined, aggregation: 'sum', highlightStyle: {\n                            fill: 'yellow'\n                        } })\n                } }, tooltipMapping), { highlightStyle: {}, label: {\n                    meta: {\n                        defaults: __assign$5(__assign$5({}, labelDefaults), { formatter: undefined })\n                    }\n                } }), shadowMapping),\n            _c), navigator: {\n            meta: {\n                constructor: Navigator,\n                defaults: {\n                    enabled: false,\n                    height: 30,\n                    min: 0,\n                    max: 1\n                }\n            },\n            mask: {\n                meta: {\n                    constructor: NavigatorMask,\n                    defaults: {\n                        fill: '#999999',\n                        stroke: '#999999',\n                        strokeWidth: 1,\n                        fillOpacity: 0.2\n                    }\n                }\n            },\n            minHandle: {\n                meta: {\n                    constructor: NavigatorHandle,\n                    defaults: {\n                        fill: '#f2f2f2',\n                        stroke: '#999999',\n                        strokeWidth: 1,\n                        width: 8,\n                        height: 16,\n                        gripLineGap: 2,\n                        gripLineLength: 8\n                    }\n                }\n            },\n            maxHandle: {\n                meta: {\n                    constructor: NavigatorHandle,\n                    defaults: {\n                        fill: '#f2f2f2',\n                        stroke: '#999999',\n                        strokeWidth: 1,\n                        width: 8,\n                        height: 16,\n                        gripLineGap: 2,\n                        gripLineLength: 8\n                    }\n                }\n            }\n        } }),\n    _a[PolarChart.type] = __assign$5(__assign$5({ meta: __assign$5(__assign$5({ constructor: PolarChart }, chartMeta), { defaults: __assign$5(__assign$5({}, chartDefaults), { padding: {\n                    meta: {\n                        constructor: Padding,\n                        defaults: {\n                            top: 40,\n                            right: 40,\n                            bottom: 40,\n                            left: 40\n                        }\n                    }\n                } }) }) }, commonChartMappings), { series: (_d = {},\n            _d[PieSeries.type] = __assign$5(__assign$5(__assign$5({ meta: {\n                    constructor: PieSeries,\n                    setAsIs: ['lineDash'],\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { title: undefined, angleKey: '', angleName: '', radiusKey: undefined, radiusName: undefined, labelKey: undefined, labelName: undefined, callout: {}, fillOpacity: 1, strokeOpacity: 1, rotation: 0, outerRadiusOffset: 0, innerRadiusOffset: 0, strokeWidth: 1, lineDash: undefined, lineDashOffset: 0, shadow: undefined })\n                } }, tooltipMapping), { highlightStyle: {}, title: {\n                    meta: {\n                        constructor: Caption,\n                        defaults: {\n                            enabled: true,\n                            padding: {\n                                meta: {\n                                    constructor: Padding,\n                                    defaults: {\n                                        top: 10,\n                                        right: 10,\n                                        bottom: 10,\n                                        left: 10\n                                    }\n                                }\n                            },\n                            text: 'Series Title',\n                            fontStyle: undefined,\n                            fontWeight: 'bold',\n                            fontSize: 14,\n                            fontFamily: 'Verdana, sans-serif',\n                            color: 'black'\n                        }\n                    }\n                }, label: {\n                    meta: {\n                        defaults: __assign$5(__assign$5({}, labelDefaults), { offset: 3, minAngle: 20 })\n                    }\n                }, callout: {\n                    meta: {\n                        defaults: {\n                            length: 10,\n                            strokeWidth: 1\n                        }\n                    }\n                } }), shadowMapping),\n            _d) }),\n    _a[HierarchyChart.type] = __assign$5(__assign$5({ meta: __assign$5(__assign$5({ constructor: HierarchyChart }, chartMeta), { defaults: __assign$5({}, chartDefaults) }) }, commonChartMappings), { series: (_e = {},\n            _e[TreemapSeries.type] = __assign$5({ meta: {\n                    constructor: TreemapSeries,\n                    defaults: __assign$5(__assign$5({}, seriesDefaults), { showInLegend: false })\n                } }, tooltipMapping),\n            _e) }),\n    _a);\n// Amend the `mappings` object with aliases for different chart types.\n{\n    var typeToAliases = {\n        cartesian: ['line', 'area', 'bar', 'column'],\n        polar: ['pie'],\n        hierarchy: ['treemap']\n    };\n    var _loop_1 = function (type) {\n        typeToAliases[type].forEach(function (alias) {\n            mappings[alias] = mappings[type];\n        });\n    };\n    for (var type in typeToAliases) {\n        _loop_1(type);\n    }\n}\n// Special handling for scatter and histogram charts, for which both axes should default to type `number`.\nmappings['scatter'] =\n    mappings['histogram'] = __assign$5(__assign$5({}, mappings.cartesian), { meta: __assign$5(__assign$5({}, mappings.cartesian.meta), { defaults: __assign$5(__assign$5({}, chartDefaults), { axes: [{\n                        type: 'number',\n                        position: 'bottom'\n                    }, {\n                        type: 'number',\n                        position: 'left'\n                    }] }) }) });\nvar groupedCategoryChartMapping = Object.create(mappings[CartesianChart.type]);\nvar groupedCategoryChartMeta = Object.create(groupedCategoryChartMapping.meta);\ngroupedCategoryChartMeta.constructor = GroupedCategoryChart;\ngroupedCategoryChartMapping.meta = groupedCategoryChartMeta;\nmappings[GroupedCategoryChart.type] = groupedCategoryChartMapping;\n\nvar __assign$6 = (undefined && undefined.__assign) || function () {\n    __assign$6 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$6.apply(this, arguments);\n};\nvar __spreadArrays$5 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar lightTheme = new ChartTheme();\nvar darkTheme = new DarkTheme();\nvar lightThemes = {\n    'undefined': lightTheme,\n    'null': lightTheme,\n    'ag-default': lightTheme,\n    'ag-material': new MaterialLight(),\n    'ag-pastel': new PastelLight(),\n    'ag-solar': new SolarLight(),\n    'ag-vivid': new VividLight(),\n};\nvar darkThemes = {\n    'undefined': darkTheme,\n    'null': darkTheme,\n    'ag-default-dark': darkTheme,\n    'ag-material-dark': new MaterialDark(),\n    'ag-pastel-dark': new PastelDark(),\n    'ag-solar-dark': new SolarDark(),\n    'ag-vivid-dark': new VividDark(),\n};\nvar themes = __assign$6(__assign$6({}, darkThemes), lightThemes);\nfunction getChartTheme(value) {\n    if (value instanceof ChartTheme) {\n        return value;\n    }\n    var stockTheme = themes[value];\n    if (stockTheme) {\n        return stockTheme;\n    }\n    value = value;\n    if (value.baseTheme || value.overrides || value.palette) {\n        var baseTheme = getChartTheme(value.baseTheme);\n        return new baseTheme.constructor(value);\n    }\n    return lightTheme;\n}\nvar firstColorIndex = 0;\nvar AgChart = /** @class */ (function () {\n    function AgChart() {\n    }\n    AgChart.create = function (options, container, data) {\n        options = Object.create(options); // avoid mutating user provided options\n        if (container) {\n            options.container = container;\n        }\n        if (data) {\n            options.data = data;\n        }\n        // special handling when both `autoSize` and `width` / `height` are present in the options\n        var autoSize = options && options.autoSize !== false;\n        var theme = getChartTheme(options.theme);\n        firstColorIndex = 0;\n        var chart = create(options, undefined, undefined, theme);\n        if (chart) {\n            if (autoSize) { // `autoSize` takes precedence over `width` / `height`\n                chart.autoSize = true;\n            }\n        }\n        return chart;\n    };\n    AgChart.update = function (chart, options, container, data) {\n        if (!(chart && options)) {\n            return;\n        }\n        options = Object.create(options);\n        if (container) {\n            options.container = container;\n        }\n        if (data) {\n            options.data = data;\n        }\n        var autoSize = options && options.autoSize !== false;\n        var theme = getChartTheme(options.theme);\n        firstColorIndex = 0;\n        update(chart, options, undefined, theme);\n        if (autoSize) {\n            chart.autoSize = true;\n        }\n    };\n    AgChart.save = function (component) {\n        var target = {};\n        save(component, target);\n        return target;\n    };\n    AgChart.createComponent = create;\n    return AgChart;\n}());\nvar pathToSeriesTypeMap = {\n    'cartesian.series': 'line',\n    'line.series': 'line',\n    'area.series': 'area',\n    'bar.series': 'bar',\n    'column.series': 'column',\n    'histogram.series': 'histogram',\n    'scatter.series': 'scatter',\n    'polar.series': 'pie',\n    'pie.series': 'pie'\n};\nvar actualSeriesTypeMap = (function () {\n    var map = {};\n    var actualSeries = ['area', 'bar', 'histogram', 'line', 'pie', 'scatter'];\n    actualSeries.forEach(function (series) { return map[series] = series; });\n    // Aliases:\n    map['column'] = 'bar';\n    return map;\n})();\nfunction save(component, target, mapping) {\n    if (target === void 0) { target = {}; }\n    if (mapping === void 0) { mapping = mappings; }\n    if (component.constructor && component.constructor.type && !mapping.meta) {\n        mapping = mapping[component.constructor.type];\n    }\n    var defaults = mapping && mapping.meta && mapping.meta.defaults;\n    var keys = Object.keys(defaults);\n    keys.forEach(function (key) {\n        var value = component[key];\n        if (isObject(value) && (!mapping.meta.nonSerializable || mapping.meta.nonSerializable.indexOf(key) < 0)) {\n            target[key] = {};\n            // save(value, target[key], mapping[key]);\n        }\n        else if (Array.isArray(value)) ;\n        else {\n            target[key] = component[key];\n        }\n    });\n}\nfunction create(options, path, component, theme) {\n    var _a;\n    // Deprecate `chart.legend.item.marker.type` in integrated chart options.\n    options = Object.create(options);\n    if (component instanceof LegendMarker) {\n        if (options.type) {\n            options.shape = options.type;\n        }\n    }\n    else {\n        options = provideDefaultType(options, path);\n        if (path) {\n            if (options.type) {\n                path = path + '.' + options.type;\n            }\n        }\n        else {\n            path = options.type;\n        }\n    }\n    if (!path) {\n        return;\n    }\n    var mapping = getValue(mappings, path);\n    if (mapping) {\n        options = provideDefaultOptions(path, options, mapping, theme);\n        var meta = mapping.meta || {};\n        var constructorParams = meta.constructorParams || [];\n        var skipKeys = ['type', 'listeners'].concat(constructorParams);\n        // TODO: Constructor params processing could be improved, but it's good enough for current params.\n        var constructorParamValues = constructorParams\n            .map(function (param) { return options[param]; })\n            .filter(function (value) { return value !== undefined; });\n        if (!component) {\n            component = new ((_a = meta.constructor).bind.apply(_a, __spreadArrays$5([void 0], constructorParamValues)))();\n            if (theme && component instanceof Series) {\n                firstColorIndex = theme.setSeriesColors(component, options, firstColorIndex);\n            }\n        }\n        var _loop_1 = function (key) {\n            // Process every non-special key in the config object.\n            if (skipKeys.indexOf(key) < 0) {\n                var value = options[key];\n                if (value && key in mapping && !(meta.setAsIs && meta.setAsIs.indexOf(key) >= 0)) {\n                    if (Array.isArray(value)) {\n                        var subComponents = value\n                            .map(function (config) {\n                            var axis = create(config, path + '.' + key, undefined, theme);\n                            if (theme && key === 'axes') {\n                                var fakeTheme = {\n                                    getConfig: function (path) {\n                                        var parts = path.split('.');\n                                        var modifiedPath = parts.slice(0, 3).join('.') + '.' + axis.position;\n                                        var after = parts.slice(3);\n                                        if (after.length) {\n                                            modifiedPath += '.' + after.join('.');\n                                        }\n                                        var config = theme.getConfig(path);\n                                        var modifiedConfig = theme.getConfig(modifiedPath);\n                                        isObject(theme.getConfig(modifiedPath));\n                                        if (isObject(config) && isObject(modifiedConfig)) {\n                                            return deepMerge(config, modifiedConfig);\n                                        }\n                                        return modifiedConfig;\n                                    }\n                                };\n                                update(axis, config, path + '.' + key, fakeTheme);\n                            }\n                            return axis;\n                        })\n                            .filter(function (instance) { return !!instance; });\n                        component[key] = subComponents;\n                    }\n                    else {\n                        if (mapping[key] && component[key]) {\n                            // The instance property already exists on the component (e.g. chart.legend).\n                            // Simply configure the existing instance, without creating a new one.\n                            create(value, path + '.' + key, component[key], theme);\n                        }\n                        else {\n                            var subComponent = create(value, value.type ? path : path + '.' + key, undefined, theme);\n                            if (subComponent) {\n                                component[key] = subComponent;\n                            }\n                        }\n                    }\n                }\n                else { // if (key in meta.constructor.defaults) { // prevent users from creating custom properties\n                    component[key] = value;\n                }\n            }\n        };\n        for (var key in options) {\n            _loop_1(key);\n        }\n        var listeners = options.listeners;\n        if (component && component.addEventListener && listeners) {\n            for (var key in listeners) {\n                if (listeners.hasOwnProperty(key)) {\n                    var listener = listeners[key];\n                    if (typeof listener === 'function') {\n                        component.addEventListener(key, listener);\n                    }\n                }\n            }\n        }\n        return component;\n    }\n}\nfunction update(component, options, path, theme) {\n    if (!(options && isObject(options))) {\n        return;\n    }\n    // Deprecate `chart.legend.item.marker.type` in integrated chart options.\n    if (component instanceof LegendMarker) {\n        if (options.type) {\n            options.shape = options.type;\n        }\n    }\n    else {\n        options = provideDefaultType(options, path);\n        if (path) {\n            if (options.type) {\n                path = path + '.' + options.type;\n            }\n        }\n        else {\n            path = options.type;\n        }\n    }\n    if (!path) {\n        return;\n    }\n    var chart = path in mappings ? component : undefined;\n    var mapping = getValue(mappings, path);\n    if (mapping) {\n        options = provideDefaultOptions(path, options, mapping, theme);\n        var meta = mapping.meta || {};\n        var constructorParams = meta && meta.constructorParams || [];\n        var skipKeys = ['type'].concat(constructorParams);\n        for (var key in options) {\n            if (skipKeys.indexOf(key) < 0) {\n                var value = options[key];\n                var keyPath = path + '.' + key;\n                if (meta.setAsIs && meta.setAsIs.indexOf(key) >= 0) {\n                    component[key] = value;\n                }\n                else {\n                    var oldValue = component[key];\n                    if (Array.isArray(oldValue) && Array.isArray(value)) {\n                        if (chart) {\n                            if (key === 'series') {\n                                updateSeries(component, value, keyPath, theme);\n                            }\n                            else if (key === 'axes') {\n                                updateAxes(component, value, keyPath, theme);\n                            }\n                        }\n                        else {\n                            component[key] = value;\n                        }\n                    }\n                    else if (isObject(oldValue)) {\n                        if (value) {\n                            update(oldValue, value, value.type ? path : keyPath, theme);\n                        }\n                        else if (key in options) {\n                            component[key] = value;\n                        }\n                    }\n                    else {\n                        var subComponent = isObject(value) && create(value, value.type ? path : keyPath, undefined, theme);\n                        if (subComponent) {\n                            component[key] = subComponent;\n                        }\n                        else {\n                            if (chart && options.autoSize && (key === 'width' || key === 'height')) {\n                                continue;\n                            }\n                            component[key] = value;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (chart) {\n        chart.layoutPending = true;\n    }\n}\nfunction updateSeries(chart, configs, keyPath, theme) {\n    var allSeries = chart.series.slice();\n    var prevSeries;\n    var i = 0;\n    for (; i < configs.length; i++) {\n        var config = configs[i];\n        var series = allSeries[i];\n        if (series) {\n            config = provideDefaultType(config, keyPath);\n            var type = actualSeriesTypeMap[config.type];\n            if (series.type === type) {\n                if (theme) {\n                    firstColorIndex = theme.setSeriesColors(series, config, firstColorIndex);\n                }\n                update(series, config, keyPath, theme);\n            }\n            else {\n                var newSeries = create(config, keyPath, undefined, theme);\n                chart.removeSeries(series);\n                chart.addSeriesAfter(newSeries, prevSeries);\n                series = newSeries;\n            }\n        }\n        else { // more new configs than existing series\n            var newSeries = create(config, keyPath, undefined, theme);\n            chart.addSeries(newSeries);\n        }\n        prevSeries = series;\n    }\n    // more existing series than new configs\n    for (; i < allSeries.length; i++) {\n        var series = allSeries[i];\n        if (series) {\n            chart.removeSeries(series);\n        }\n    }\n}\nfunction updateAxes(chart, configs, keyPath, theme) {\n    var axes = chart.axes;\n    var axesToAdd = [];\n    var axesToUpdate = [];\n    var _loop_2 = function (config) {\n        var axisToUpdate = find(axes, function (axis) {\n            return axis.type === config.type && axis.position === config.position;\n        });\n        if (axisToUpdate) {\n            axesToUpdate.push(axisToUpdate);\n            update(axisToUpdate, config, keyPath, theme);\n        }\n        else {\n            var axisToAdd = create(config, keyPath, undefined, theme);\n            if (axisToAdd) {\n                axesToAdd.push(axisToAdd);\n            }\n        }\n    };\n    for (var _i = 0, configs_1 = configs; _i < configs_1.length; _i++) {\n        var config = configs_1[_i];\n        _loop_2(config);\n    }\n    chart.axes = axesToUpdate.concat(axesToAdd);\n}\nfunction provideDefaultChartType(options) {\n    if (options.type) {\n        return options;\n    }\n    // If chart type is not specified, try to infer it from the type of first series.\n    var series = options.series && options.series[0];\n    if (series && series.type) {\n        outerLoop: for (var chartType in mappings) {\n            for (var seriesType in mappings[chartType].series) {\n                if (series.type === seriesType) {\n                    options = Object.create(options);\n                    options.type = chartType;\n                    break outerLoop;\n                }\n            }\n        }\n    }\n    if (!options.type) {\n        options = Object.create(options);\n        options.type = 'cartesian';\n    }\n    return options;\n}\nfunction provideDefaultType(options, path) {\n    if (!path) { // if `path` is undefined, `options` is a top-level (chart) config\n        path = '';\n        options = provideDefaultChartType(options);\n    }\n    if (!options.type) {\n        var seriesType = pathToSeriesTypeMap[path];\n        if (seriesType) {\n            options = Object.create(options);\n            options.type = seriesType;\n        }\n    }\n    return options;\n}\nfunction skipThemeKey(key) {\n    return ['axes', 'series'].indexOf(key) >= 0;\n}\nvar enabledKey = 'enabled';\n/**\n * If certain options were not provided by the user, use the defaults from the theme and the mapping.\n * All three objects are provided for the current path in the config tree, not necessarily top-level.\n */\nfunction provideDefaultOptions(path, options, mapping, theme) {\n    var isChartConfig = path.indexOf('.') < 0;\n    var themeDefaults = theme && theme.getConfig(path);\n    var defaults = mapping && mapping.meta && mapping.meta.defaults;\n    var isExplicitlyDisabled = options.enabled === false; // by the user\n    if (defaults || themeDefaults) {\n        options = Object.create(options);\n    }\n    // Fill in the gaps for properties not configured by the user using theme provided values.\n    for (var key in themeDefaults) {\n        // The default values for these special chart configs always come from the mappings, not theme.\n        if (isChartConfig && skipThemeKey(key)) {\n            continue;\n        }\n        if (!(key in options)) {\n            options[key] = themeDefaults[key];\n        }\n    }\n    // Fill in the gaps for properties not configured by the user, nor theme using chart mappings.\n    for (var key in defaults) {\n        if ((!themeDefaults || !(key in themeDefaults) || skipThemeKey(key)) && !(key in options)) {\n            options[key] = defaults[key];\n        }\n    }\n    // Special handling for the 'enabled' property. For example:\n    // title: { text: 'Quarterly Revenue' } // means title is enabled\n    // legend: {} // means legend is enabled\n    var hasEnabledKey = (themeDefaults && enabledKey in themeDefaults) ||\n        (defaults && enabledKey in defaults);\n    if (hasEnabledKey && !isExplicitlyDisabled) {\n        options[enabledKey] = true;\n    }\n    return options;\n}\n\nvar __extends$1E = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartController = /** @class */ (function (_super) {\n    __extends$1E(ChartController, _super);\n    function ChartController(model) {\n        var _this = _super.call(this) || this;\n        _this.model = model;\n        return _this;\n    }\n    ChartController.prototype.init = function () {\n        var _this = this;\n        this.setChartRange();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_RANGE_SELECTION_CHANGED, function (event) {\n            if (event.id && event.id === _this.model.getChartId()) {\n                _this.updateForRangeChange();\n            }\n        });\n        if (this.model.isUnlinked()) {\n            if (this.rangeController) {\n                this.rangeController.setCellRanges([]);\n            }\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_MOVED, this.updateForGridChange.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PINNED, this.updateForGridChange.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_VISIBLE, this.updateForGridChange.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.updateForGridChange.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, this.updateForGridChange.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_CELL_VALUE_CHANGED, this.updateForDataChange.bind(this));\n    };\n    ChartController.prototype.updateForGridChange = function () {\n        if (this.model.isUnlinked()) {\n            return;\n        }\n        this.model.updateCellRanges();\n        this.setChartRange();\n    };\n    ChartController.prototype.updateForDataChange = function () {\n        if (this.model.isUnlinked()) {\n            return;\n        }\n        this.model.updateData();\n        this.raiseChartUpdatedEvent();\n    };\n    ChartController.prototype.updateForRangeChange = function () {\n        this.updateForGridChange();\n        this.raiseChartRangeSelectionChangedEvent();\n    };\n    ChartController.prototype.updateForPanelChange = function (updatedCol) {\n        this.model.updateCellRanges(updatedCol);\n        this.setChartRange();\n        this.raiseChartRangeSelectionChangedEvent();\n    };\n    ChartController.prototype.getChartModel = function () {\n        var _this = this;\n        var modelType = this.model.isPivotChart() ? 'pivot' : 'range';\n        return {\n            modelType: modelType,\n            chartId: this.model.getChartId(),\n            chartType: this.model.getChartType(),\n            chartThemeName: this.getThemeName(),\n            chartOptions: this.chartProxy.getChartOptions(),\n            cellRange: this.model.getCellRangeParams(),\n            chart: this.chartProxy.getChart(),\n            getChartImageDataURL: function (params) {\n                return _this.chartProxy.getChartImageDataURL(params.type);\n            },\n            suppressChartRanges: this.model.isSuppressChartRanges(),\n            aggFunc: this.model.getAggFunc(),\n            unlinkChart: this.model.isUnlinked(),\n        };\n    };\n    ChartController.prototype.getChartType = function () {\n        return this.model.getChartType();\n    };\n    ChartController.prototype.isPivotChart = function () {\n        return this.model.isPivotChart();\n    };\n    ChartController.prototype.isGrouping = function () {\n        return this.model.isGrouping();\n    };\n    ChartController.prototype.getThemeName = function () {\n        return this.model.getChartThemeName();\n    };\n    ChartController.prototype.getThemes = function () {\n        return this.gridOptionsWrapper.getChartThemes();\n    };\n    ChartController.prototype.getPalettes = function () {\n        var _this = this;\n        var customPalette = this.chartProxy.getCustomPalette();\n        if (customPalette) {\n            return [customPalette];\n        }\n        var themeNames = this.gridOptionsWrapper.getChartThemes();\n        return themeNames.map(function (themeName) {\n            var theme = _this.chartProxy.isStockTheme(themeName) ?\n                themeName : _this.chartProxy.lookupCustomChartTheme(themeName);\n            return getChartTheme(theme).palette;\n        });\n    };\n    ChartController.prototype.setChartType = function (chartType) {\n        this.model.setChartType(chartType);\n        this.raiseChartUpdatedEvent();\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartController.prototype.setChartThemeName = function (chartThemeName) {\n        this.model.setChartThemeName(chartThemeName);\n        this.raiseChartUpdatedEvent();\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartController.prototype.getColStateForMenu = function () {\n        return { dimensionCols: this.model.getDimensionColState(), valueCols: this.model.getValueColState() };\n    };\n    ChartController.prototype.isDefaultCategorySelected = function () {\n        return this.model.getSelectedDimension().colId === ChartDataModel.DEFAULT_CATEGORY;\n    };\n    ChartController.prototype.setChartRange = function (silent) {\n        if (silent === void 0) { silent = false; }\n        if (this.rangeController && !this.model.isSuppressChartRanges() && !this.model.isUnlinked()) {\n            this.rangeController.setCellRanges(this.model.getCellRanges());\n        }\n        if (!silent) {\n            this.raiseChartUpdatedEvent();\n        }\n    };\n    ChartController.prototype.detachChartRange = function () {\n        // when chart is detached it won't listen to changes from the grid\n        this.model.toggleUnlinked();\n        if (this.model.isUnlinked()) {\n            // remove range from grid\n            if (this.rangeController) {\n                this.rangeController.setCellRanges([]);\n            }\n        }\n        else {\n            // update chart data may have changed\n            this.updateForGridChange();\n        }\n    };\n    ChartController.prototype.setChartProxy = function (chartProxy) {\n        this.chartProxy = chartProxy;\n    };\n    ChartController.prototype.getChartProxy = function () {\n        return this.chartProxy;\n    };\n    ChartController.prototype.isActiveXYChart = function () {\n        return agGridCommunity._.includes([agGridCommunity.ChartType.Scatter, agGridCommunity.ChartType.Bubble], this.getChartType());\n    };\n    ChartController.prototype.isChartLinked = function () {\n        return !this.model.isUnlinked();\n    };\n    ChartController.prototype.raiseChartUpdatedEvent = function () {\n        var event = Object.freeze({\n            type: ChartController.EVENT_CHART_UPDATED\n        });\n        this.dispatchEvent(event);\n    };\n    ChartController.prototype.raiseChartOptionsChangedEvent = function () {\n        this.chartProxy.raiseChartOptionsChangedEvent();\n    };\n    ChartController.prototype.raiseChartRangeSelectionChangedEvent = function () {\n        var event = Object.freeze({\n            type: agGridCommunity.Events.EVENT_CHART_RANGE_SELECTION_CHANGED,\n            id: this.model.getChartId(),\n            chartId: this.model.getChartId(),\n            cellRange: this.model.getCellRangeParams(),\n            api: this.gridApi,\n            columnApi: this.columnApi,\n        });\n        this.eventService.dispatchEvent(event);\n    };\n    ChartController.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.rangeController) {\n            this.rangeController.setCellRanges([]);\n        }\n    };\n    ChartController.EVENT_CHART_UPDATED = 'chartUpdated';\n    __decorate$V([\n        agGridCommunity.Autowired('rangeController')\n    ], ChartController.prototype, \"rangeController\", void 0);\n    __decorate$V([\n        agGridCommunity.Autowired('gridApi')\n    ], ChartController.prototype, \"gridApi\", void 0);\n    __decorate$V([\n        agGridCommunity.Autowired('columnApi')\n    ], ChartController.prototype, \"columnApi\", void 0);\n    __decorate$V([\n        agGridCommunity.PostConstruct\n    ], ChartController.prototype, \"init\", null);\n    return ChartController;\n}(agGridCommunity.BeanStub));\n\nvar __extends$1F = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays$6 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar ChartDataPanel = /** @class */ (function (_super) {\n    __extends$1F(ChartDataPanel, _super);\n    function ChartDataPanel(chartController) {\n        var _this = _super.call(this, ChartDataPanel.TEMPLATE) || this;\n        _this.columnComps = new Map();\n        _this.chartController = chartController;\n        return _this;\n    }\n    ChartDataPanel.prototype.init = function () {\n        this.updatePanels();\n        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, this.updatePanels.bind(this));\n    };\n    ChartDataPanel.prototype.destroy = function () {\n        this.clearComponents();\n        _super.prototype.destroy.call(this);\n    };\n    ChartDataPanel.prototype.updatePanels = function () {\n        var _this = this;\n        var currentChartType = this.chartType;\n        var _a = this.chartController.getColStateForMenu(), dimensionCols = _a.dimensionCols, valueCols = _a.valueCols;\n        var colIds = dimensionCols.map(function (c) { return c.colId; }).concat(valueCols.map(function (c) { return c.colId; }));\n        this.chartType = this.chartController.getChartType();\n        if (agGridCommunity._.areEqual(agGridCommunity._.keys(this.columnComps), colIds) && this.chartType === currentChartType) {\n            // if possible, we just update existing components\n            __spreadArrays$6(dimensionCols, valueCols).forEach(function (col) {\n                _this.columnComps.get(col.colId).setValue(col.selected, true);\n            });\n            if (this.chartController.isActiveXYChart()) {\n                var getSeriesLabel_1 = this.generateGetSeriesLabel();\n                valueCols.forEach(function (col) {\n                    _this.columnComps.get(col.colId).setLabel(getSeriesLabel_1(col));\n                });\n            }\n        }\n        else {\n            // otherwise we re-create everything\n            this.clearComponents();\n            this.createCategoriesGroupComponent(dimensionCols);\n            this.createSeriesGroupComponent(valueCols);\n        }\n    };\n    ChartDataPanel.prototype.addComponent = function (parent, component) {\n        var eDiv = document.createElement('div');\n        eDiv.className = 'ag-chart-data-section';\n        eDiv.appendChild(component.getGui());\n        parent.appendChild(eDiv);\n    };\n    ChartDataPanel.prototype.addChangeListener = function (component, columnState) {\n        var _this = this;\n        this.addManagedListener(component, agGridCommunity.AgAbstractField.EVENT_CHANGED, function () {\n            columnState.selected = component.getValue();\n            _this.chartController.updateForPanelChange(columnState);\n        });\n    };\n    ChartDataPanel.prototype.createCategoriesGroupComponent = function (columns) {\n        var _this = this;\n        this.categoriesGroupComp = this.createBean(new agGridCommunity.AgGroupComponent({\n            title: this.getCategoryGroupTitle(),\n            enabled: true,\n            suppressEnabledCheckbox: true,\n            suppressOpenCloseIcons: false,\n            cssIdentifier: 'charts-data'\n        }));\n        var inputName = \"chartDimension\" + this.getCompId();\n        columns.forEach(function (col) {\n            var comp = _this.categoriesGroupComp.createManagedBean(new agGridCommunity.AgRadioButton());\n            comp.setLabel(agGridCommunity._.escapeString(col.displayName));\n            comp.setValue(col.selected);\n            comp.setInputName(inputName);\n            _this.addChangeListener(comp, col);\n            _this.categoriesGroupComp.addItem(comp);\n            _this.columnComps.set(col.colId, comp);\n        });\n        this.addComponent(this.getGui(), this.categoriesGroupComp);\n    };\n    ChartDataPanel.prototype.createSeriesGroupComponent = function (columns) {\n        var _this = this;\n        this.seriesGroupComp = this.createManagedBean(new agGridCommunity.AgGroupComponent({\n            title: this.getSeriesGroupTitle(),\n            enabled: true,\n            suppressEnabledCheckbox: true,\n            suppressOpenCloseIcons: false,\n            cssIdentifier: 'charts-data'\n        }));\n        if (this.chartController.isActiveXYChart()) {\n            var pairedModeToggle = this.seriesGroupComp.createManagedBean(new agGridCommunity.AgToggleButton());\n            var chartProxy_1 = this.chartController.getChartProxy();\n            pairedModeToggle\n                .setLabel(this.chartTranslator.translate('paired'))\n                .setLabelAlignment('left')\n                .setLabelWidth('flex')\n                .setInputWidth(45)\n                .setValue(chartProxy_1.getSeriesOption('paired') || false)\n                .onValueChange(function (newValue) {\n                chartProxy_1.setSeriesOption('paired', newValue);\n                _this.chartController.updateForGridChange();\n            });\n            this.seriesGroupComp.addItem(pairedModeToggle);\n        }\n        var getSeriesLabel = this.generateGetSeriesLabel();\n        columns.forEach(function (col) {\n            var comp = _this.seriesGroupComp.createManagedBean(new agGridCommunity.AgCheckbox());\n            comp.addCssClass('ag-data-select-checkbox');\n            var label = getSeriesLabel(col);\n            comp.setLabel(label);\n            comp.setValue(col.selected);\n            _this.addChangeListener(comp, col);\n            _this.seriesGroupComp.addItem(comp);\n            _this.columnComps.set(col.colId, comp);\n            _this.addDragHandle(comp, col);\n        });\n        this.addComponent(this.getGui(), this.seriesGroupComp);\n        var dropTarget = {\n            getContainer: this.getGui.bind(this),\n            onDragging: this.onDragging.bind(this),\n            isInterestedIn: this.isInterestedIn.bind(this),\n        };\n        this.dragAndDropService.addDropTarget(dropTarget);\n    };\n    ChartDataPanel.prototype.addDragHandle = function (comp, col) {\n        var _this = this;\n        var eDragHandle = agGridCommunity._.createIconNoSpan('columnDrag', this.gridOptionsWrapper);\n        agGridCommunity._.addCssClass(eDragHandle, 'ag-drag-handle');\n        agGridCommunity._.addCssClass(eDragHandle, 'ag-chart-data-column-drag-handle');\n        comp.getGui().insertAdjacentElement('beforeend', eDragHandle);\n        var dragSource = {\n            type: agGridCommunity.DragSourceType.ChartPanel,\n            eElement: eDragHandle,\n            dragItemName: col.displayName,\n            defaultIconName: agGridCommunity.DragAndDropService.ICON_MOVE,\n            getDragItem: function () { return ({ columns: [col.column] }); },\n            onDragStopped: function () { _this.insertIndex = undefined; }\n        };\n        this.dragAndDropService.addDragSource(dragSource, true);\n        this.addDestroyFunc(function () { return _this.dragAndDropService.removeDragSource(dragSource); });\n    };\n    ChartDataPanel.prototype.generateGetSeriesLabel = function () {\n        if (!this.chartController.isActiveXYChart()) {\n            return function (col) { return agGridCommunity._.escapeString(col.displayName); };\n        }\n        var isBubble = this.chartType === agGridCommunity.ChartType.Bubble;\n        var isInPairedMode = this.isInPairedMode();\n        var selectedValuesCount = 0;\n        var indexToAxisLabel = new Map();\n        indexToAxisLabel.set(0, 'X');\n        indexToAxisLabel.set(1, 'Y');\n        indexToAxisLabel.set(2, 'size');\n        return function (col) {\n            var escapedLabel = agGridCommunity._.escapeString(col.displayName);\n            if (!col.selected) {\n                return escapedLabel;\n            }\n            var axisLabel;\n            if (isInPairedMode) {\n                axisLabel = indexToAxisLabel.get(selectedValuesCount % (isBubble ? 3 : 2));\n            }\n            else {\n                if (selectedValuesCount === 0) {\n                    axisLabel = 'X';\n                }\n                else {\n                    axisLabel = isBubble && selectedValuesCount % 2 === 0 ? 'size' : 'Y';\n                }\n            }\n            selectedValuesCount++;\n            return escapedLabel + \" (\" + axisLabel + \")\";\n        };\n    };\n    ChartDataPanel.prototype.getCategoryGroupTitle = function () {\n        return this.chartTranslator.translate(this.chartController.isActiveXYChart() ? 'labels' : 'categories');\n    };\n    ChartDataPanel.prototype.getSeriesGroupTitle = function () {\n        return this.chartTranslator.translate(this.chartController.isActiveXYChart() ? 'xyValues' : 'series');\n    };\n    ChartDataPanel.prototype.isInPairedMode = function () {\n        return this.chartController.isActiveXYChart() && this.chartController.getChartProxy().getSeriesOption('paired');\n    };\n    ChartDataPanel.prototype.clearComponents = function () {\n        agGridCommunity._.clearElement(this.getGui());\n        this.categoriesGroupComp = this.destroyBean(this.categoriesGroupComp);\n        this.seriesGroupComp = this.destroyBean(this.seriesGroupComp);\n        this.columnComps.clear();\n    };\n    ChartDataPanel.prototype.onDragging = function (draggingEvent) {\n        var _this = this;\n        if (this.checkInsertIndex(draggingEvent)) {\n            var column_1 = draggingEvent.dragItem.columns[0];\n            var _a = this.chartController.getColStateForMenu(), dimensionCols = _a.dimensionCols, valueCols = _a.valueCols;\n            __spreadArrays$6(dimensionCols, valueCols).filter(function (state) { return state.column === column_1; })\n                .forEach(function (state) {\n                state.order = _this.insertIndex;\n                _this.chartController.updateForPanelChange(state);\n            });\n        }\n    };\n    ChartDataPanel.prototype.checkInsertIndex = function (draggingEvent) {\n        if (agGridCommunity._.missing(draggingEvent.vDirection)) {\n            return false;\n        }\n        var newIndex = 0;\n        var mouseEvent = draggingEvent.event;\n        this.columnComps.forEach(function (comp) {\n            var rect = comp.getGui().getBoundingClientRect();\n            var verticalFit = mouseEvent.clientY >= (draggingEvent.vDirection === agGridCommunity.VerticalDirection.Down ? rect.top : rect.bottom);\n            if (verticalFit) {\n                newIndex++;\n            }\n        });\n        var changed = this.insertIndex !== undefined && newIndex !== this.insertIndex;\n        this.insertIndex = newIndex;\n        return changed;\n    };\n    ChartDataPanel.prototype.isInterestedIn = function (type) {\n        return type === agGridCommunity.DragSourceType.ChartPanel;\n    };\n    ChartDataPanel.TEMPLATE = \"<div class=\\\"ag-chart-data-wrapper\\\"></div>\";\n    __decorate$W([\n        agGridCommunity.Autowired('dragAndDropService')\n    ], ChartDataPanel.prototype, \"dragAndDropService\", void 0);\n    __decorate$W([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ChartDataPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$W([\n        agGridCommunity.PostConstruct\n    ], ChartDataPanel.prototype, \"init\", null);\n    return ChartDataPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1G = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FontPanel = /** @class */ (function (_super) {\n    __extends$1G(FontPanel, _super);\n    function FontPanel(params) {\n        var _this = _super.call(this) || this;\n        _this.activeComps = [];\n        _this.params = params;\n        return _this;\n    }\n    FontPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical',\n            suppressOpenCloseIcons: true\n        };\n        this.setTemplate(FontPanel.TEMPLATE, { fontGroup: groupParams });\n        this.initGroup();\n        this.initFontFamilySelect();\n        this.initFontWeightStyleSelect();\n        this.initFontSizeSelect();\n        this.initFontColorPicker();\n    };\n    FontPanel.prototype.addCompToPanel = function (comp) {\n        this.fontGroup.addItem(comp);\n        this.activeComps.push(comp);\n    };\n    FontPanel.prototype.setEnabled = function (enabled) {\n        this.fontGroup.setEnabled(enabled);\n    };\n    FontPanel.prototype.initGroup = function () {\n        var _this = this;\n        this.fontGroup\n            .setTitle(this.params.name || this.chartTranslator.translate('font'))\n            .setEnabled(this.params.enabled)\n            .hideEnabledCheckbox(!!this.params.suppressEnabledCheckbox)\n            .hideOpenCloseIcons(true)\n            .onEnableChange(function (enabled) {\n            if (_this.params.setEnabled) {\n                _this.params.setEnabled(enabled);\n            }\n        });\n    };\n    FontPanel.prototype.initFontFamilySelect = function () {\n        var _this = this;\n        var families = [\n            'Arial, sans-serif',\n            'Aria Black, sans-serif',\n            'Book Antiqua,  serif',\n            'Charcoal, sans-serif',\n            'Comic Sans MS, cursive',\n            'Courier, monospace',\n            'Courier New, monospace',\n            'Gadget, sans-serif',\n            'Geneva, sans-serif',\n            'Helvetica, sans-serif',\n            'Impact, sans-serif',\n            'Lucida Console, monospace',\n            'Lucida Grande, sans-serif',\n            'Lucida Sans Unicode,  sans-serif',\n            'Monaco, monospace',\n            'Palatino Linotype, serif',\n            'Palatino, serif',\n            'Times New Roman, serif',\n            'Times, serif',\n            'Verdana, sans-serif'\n        ];\n        var family = this.params.initialFont.family;\n        var initialValue = families[0];\n        if (family) {\n            // check for known values using lowercase\n            var lowerCaseValues = families.map(function (f) { return f.toLowerCase(); });\n            var valueIndex = lowerCaseValues.indexOf(family.toLowerCase());\n            if (valueIndex >= 0) {\n                initialValue = families[valueIndex];\n            }\n            else {\n                // add user provided value to list\n                var capitalisedFontValue = agGridCommunity._.capitalise(family);\n                families.push(capitalisedFontValue);\n                initialValue = capitalisedFontValue;\n            }\n        }\n        var options = families.sort().map(function (value) { return ({ value: value, text: value }); });\n        this.familySelect.addOptions(options)\n            .setInputWidth('flex')\n            .setValue(\"\" + initialValue)\n            .onValueChange(function (newValue) { return _this.params.setFont({ family: newValue }); });\n    };\n    FontPanel.prototype.initFontSizeSelect = function () {\n        var _this = this;\n        var sizes = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36];\n        var size = this.params.initialFont.size;\n        if (!agGridCommunity._.includes(sizes, size)) {\n            sizes.push(size);\n        }\n        var options = sizes.sort(function (a, b) { return a - b; }).map(function (value) { return ({ value: \"\" + value, text: \"\" + value }); });\n        this.sizeSelect.addOptions(options)\n            .setInputWidth('flex')\n            .setValue(\"\" + size)\n            .onValueChange(function (newValue) { return _this.params.setFont({ size: parseInt(newValue, 10) }); });\n        this.sizeSelect.setLabel(this.chartTranslator.translate('size'));\n    };\n    FontPanel.prototype.initFontWeightStyleSelect = function () {\n        var _this = this;\n        var _a = this.params.initialFont, _b = _a.weight, weight = _b === void 0 ? 'normal' : _b, _c = _a.style, style = _c === void 0 ? 'normal' : _c;\n        var weightStyles = [\n            { name: 'normal', weight: 'normal', style: 'normal' },\n            { name: 'bold', weight: 'bold', style: 'normal' },\n            { name: 'italic', weight: 'normal', style: 'italic' },\n            { name: 'boldItalic', weight: 'bold', style: 'italic' }\n        ];\n        var selectedOption = agGridCommunity._.find(weightStyles, function (x) { return x.weight === weight && x.style === style; });\n        if (!selectedOption) {\n            selectedOption = { name: 'predefined', weight: weight, style: style };\n            weightStyles.unshift(selectedOption);\n        }\n        var options = weightStyles.map(function (ws) { return ({\n            value: ws.name,\n            text: _this.chartTranslator.translate(ws.name),\n        }); });\n        this.weightStyleSelect.addOptions(options)\n            .setInputWidth('flex')\n            .setValue(selectedOption.name)\n            .onValueChange(function (newValue) {\n            var selectedWeightStyle = agGridCommunity._.find(weightStyles, function (x) { return x.name === newValue; });\n            _this.params.setFont({ weight: selectedWeightStyle.weight, style: selectedWeightStyle.style });\n        });\n    };\n    FontPanel.prototype.initFontColorPicker = function () {\n        var _this = this;\n        this.colorPicker\n            .setLabel(this.chartTranslator.translate('color'))\n            .setInputWidth(45)\n            .setValue(\"\" + this.params.initialFont.color)\n            .onValueChange(function (newColor) { return _this.params.setFont({ color: newColor }); });\n    };\n    FontPanel.prototype.destroyActiveComps = function () {\n        var _this = this;\n        this.activeComps.forEach(function (comp) {\n            agGridCommunity._.removeFromParent(comp.getGui());\n            _this.destroyBean(comp);\n        });\n    };\n    FontPanel.prototype.destroy = function () {\n        this.destroyActiveComps();\n        _super.prototype.destroy.call(this);\n    };\n    FontPanel.TEMPLATE = \"<div class=\\\"ag-font-panel\\\">\\n            <ag-group-component ref=\\\"fontGroup\\\">\\n                <ag-select ref=\\\"familySelect\\\"></ag-select>\\n                <ag-select ref=\\\"weightStyleSelect\\\"></ag-select>\\n                <div class=\\\"ag-charts-font-size-color\\\">\\n                    <ag-select ref=\\\"sizeSelect\\\"></ag-select>\\n                    <ag-color-picker ref=\\\"colorPicker\\\"></ag-color-picker>\\n                </div>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$X([\n        agGridCommunity.RefSelector('fontGroup')\n    ], FontPanel.prototype, \"fontGroup\", void 0);\n    __decorate$X([\n        agGridCommunity.RefSelector('familySelect')\n    ], FontPanel.prototype, \"familySelect\", void 0);\n    __decorate$X([\n        agGridCommunity.RefSelector('weightStyleSelect')\n    ], FontPanel.prototype, \"weightStyleSelect\", void 0);\n    __decorate$X([\n        agGridCommunity.RefSelector('sizeSelect')\n    ], FontPanel.prototype, \"sizeSelect\", void 0);\n    __decorate$X([\n        agGridCommunity.RefSelector('colorPicker')\n    ], FontPanel.prototype, \"colorPicker\", void 0);\n    __decorate$X([\n        agGridCommunity.Autowired('chartTranslator')\n    ], FontPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$X([\n        agGridCommunity.PostConstruct\n    ], FontPanel.prototype, \"init\", null);\n    return FontPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1H = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LegendPanel = /** @class */ (function (_super) {\n    __extends$1H(LegendPanel, _super);\n    function LegendPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    LegendPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(LegendPanel.TEMPLATE, { legendGroup: groupParams });\n        this.initLegendGroup();\n        this.initLegendPosition();\n        this.initLegendPadding();\n        this.initLegendItems();\n        this.initLabelPanel();\n    };\n    LegendPanel.prototype.initLegendGroup = function () {\n        var _this = this;\n        this.legendGroup\n            .setTitle(this.chartTranslator.translate(\"legend\"))\n            .hideEnabledCheckbox(false)\n            .setEnabled(this.chartController.getChartProxy().getChartOption(\"legend.enabled\") || false)\n            .toggleGroupExpand(false)\n            .onEnableChange(function (enabled) {\n            _this.chartController.getChartProxy().setChartOption(\"legend.enabled\", enabled);\n            _this.legendGroup.toggleGroupExpand(true);\n        });\n    };\n    LegendPanel.prototype.initLegendPosition = function () {\n        var _this = this;\n        var positions = [agGridCommunity.LegendPosition.Top, agGridCommunity.LegendPosition.Right, agGridCommunity.LegendPosition.Bottom, agGridCommunity.LegendPosition.Left];\n        this.legendPositionSelect\n            .setLabel(this.chartTranslator.translate(\"position\"))\n            .setLabelWidth(\"flex\")\n            .setInputWidth(80)\n            .addOptions(positions.map(function (position) { return ({\n            value: position,\n            text: _this.chartTranslator.translate(position)\n        }); }))\n            .setValue(this.chartController.getChartProxy().getChartOption(\"legend.position\"))\n            .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setChartOption(\"legend.position\", newValue); });\n    };\n    LegendPanel.prototype.initLegendPadding = function () {\n        var _this = this;\n        this.legendPaddingSlider\n            .setLabel(this.chartTranslator.translate(\"spacing\"))\n            .setValue(this.chartController.getChartProxy().getChartOption(\"legend.spacing\"))\n            .setTextFieldWidth(45)\n            .setMaxValue(200)\n            .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setChartOption(\"legend.spacing\", newValue); });\n    };\n    LegendPanel.prototype.initLegendItems = function () {\n        var _this = this;\n        var initSlider = function (expression, labelKey, input, maxValue) {\n            input.setLabel(_this.chartTranslator.translate(labelKey))\n                .setValue(_this.chartController.getChartProxy().getChartOption(\"legend.\" + expression))\n                .setMaxValue(maxValue)\n                .setTextFieldWidth(45)\n                .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setChartOption(\"legend.\" + expression, newValue); });\n        };\n        initSlider(\"item.marker.size\", \"markerSize\", this.markerSizeSlider, 40);\n        initSlider(\"item.marker.strokeWidth\", \"markerStroke\", this.markerStrokeSlider, 10);\n        initSlider(\"item.marker.padding\", \"itemSpacing\", this.markerPaddingSlider, 20);\n        initSlider(\"item.paddingX\", \"layoutHorizontalSpacing\", this.itemPaddingXSlider, 50);\n        initSlider(\"item.paddingY\", \"layoutVerticalSpacing\", this.itemPaddingYSlider, 50);\n    };\n    LegendPanel.prototype.initLabelPanel = function () {\n        var _this = this;\n        var chartProxy = this.chartController.getChartProxy();\n        var initialFont = {\n            family: chartProxy.getChartOption(\"legend.item.label.fontFamily\"),\n            style: chartProxy.getChartOption(\"legend.item.label.fontStyle\"),\n            weight: chartProxy.getChartOption(\"legend.item.label.fontWeight\"),\n            size: chartProxy.getChartOption(\"legend.item.label.fontSize\"),\n            color: chartProxy.getChartOption(\"legend.item.label.color\")\n        };\n        var setFont = function (font) {\n            var proxy = _this.chartController.getChartProxy();\n            if (font.family) {\n                proxy.setChartOption(\"legend.item.label.fontFamily\", font.family);\n            }\n            if (font.weight) {\n                proxy.setChartOption(\"legend.item.label.fontWeight\", font.weight);\n            }\n            if (font.style) {\n                proxy.setChartOption(\"legend.item.label.fontStyle\", font.style);\n            }\n            if (font.size) {\n                proxy.setChartOption(\"legend.item.label.fontSize\", font.size);\n            }\n            if (font.color) {\n                proxy.setChartOption(\"legend.item.label.color\", font.color);\n            }\n        };\n        var params = {\n            enabled: true,\n            suppressEnabledCheckbox: true,\n            initialFont: initialFont,\n            setFont: setFont\n        };\n        var fontPanelComp = this.createBean(new FontPanel(params));\n        this.legendGroup.addItem(fontPanelComp);\n        this.activePanels.push(fontPanelComp);\n    };\n    LegendPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    LegendPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    LegendPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"legendGroup\\\">\\n                <ag-select ref=\\\"legendPositionSelect\\\"></ag-select>\\n                <ag-slider ref=\\\"legendPaddingSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"markerSizeSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"markerStrokeSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"markerPaddingSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"itemPaddingXSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"itemPaddingYSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$Y([\n        agGridCommunity.RefSelector('legendGroup')\n    ], LegendPanel.prototype, \"legendGroup\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('legendPositionSelect')\n    ], LegendPanel.prototype, \"legendPositionSelect\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('legendPaddingSlider')\n    ], LegendPanel.prototype, \"legendPaddingSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('markerSizeSlider')\n    ], LegendPanel.prototype, \"markerSizeSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('markerStrokeSlider')\n    ], LegendPanel.prototype, \"markerStrokeSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('markerPaddingSlider')\n    ], LegendPanel.prototype, \"markerPaddingSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('itemPaddingXSlider')\n    ], LegendPanel.prototype, \"itemPaddingXSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.RefSelector('itemPaddingYSlider')\n    ], LegendPanel.prototype, \"itemPaddingYSlider\", void 0);\n    __decorate$Y([\n        agGridCommunity.Autowired('chartTranslator')\n    ], LegendPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$Y([\n        agGridCommunity.PostConstruct\n    ], LegendPanel.prototype, \"init\", null);\n    return LegendPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1I = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ShadowPanel = /** @class */ (function (_super) {\n    __extends$1I(ShadowPanel, _super);\n    function ShadowPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    ShadowPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical',\n            suppressOpenCloseIcons: true\n        };\n        this.setTemplate(ShadowPanel.TEMPLATE, { shadowGroup: groupParams });\n        this.shadowBlurSlider.setTextFieldWidth(45);\n        this.shadowXOffsetSlider.setTextFieldWidth(45);\n        this.shadowYOffsetSlider.setTextFieldWidth(45);\n        this.initSeriesShadow();\n    };\n    ShadowPanel.prototype.initSeriesShadow = function () {\n        var _this = this;\n        this.shadowGroup\n            .setTitle(this.chartTranslator.translate(\"shadow\"))\n            .setEnabled(this.chartController.getChartProxy().getShadowEnabled())\n            .hideOpenCloseIcons(true)\n            .hideEnabledCheckbox(false)\n            .onEnableChange(function (newValue) { return _this.chartController.getChartProxy().setShadowProperty(\"enabled\", newValue); });\n        this.shadowColorPicker\n            .setLabel(this.chartTranslator.translate(\"color\"))\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(\"rgba(0,0,0,0.5)\")\n            .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setShadowProperty(\"color\", newValue); });\n        var initInput = function (input, property, minValue, maxValue) {\n            input.setLabel(_this.chartTranslator.translate(property))\n                .setValue(_this.chartController.getChartProxy().getShadowProperty(property))\n                .setMinValue(minValue)\n                .setMaxValue(maxValue)\n                .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setShadowProperty(property, newValue); });\n        };\n        initInput(this.shadowBlurSlider, \"blur\", 0, 20);\n        initInput(this.shadowXOffsetSlider, \"xOffset\", -10, 10);\n        initInput(this.shadowYOffsetSlider, \"yOffset\", -10, 10);\n    };\n    ShadowPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"shadowGroup\\\">\\n                <ag-color-picker ref=\\\"shadowColorPicker\\\"></ag-color-picker>\\n                <ag-slider ref=\\\"shadowBlurSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"shadowXOffsetSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"shadowYOffsetSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$Z([\n        agGridCommunity.RefSelector('shadowGroup')\n    ], ShadowPanel.prototype, \"shadowGroup\", void 0);\n    __decorate$Z([\n        agGridCommunity.RefSelector('shadowColorPicker')\n    ], ShadowPanel.prototype, \"shadowColorPicker\", void 0);\n    __decorate$Z([\n        agGridCommunity.RefSelector('shadowBlurSlider')\n    ], ShadowPanel.prototype, \"shadowBlurSlider\", void 0);\n    __decorate$Z([\n        agGridCommunity.RefSelector('shadowXOffsetSlider')\n    ], ShadowPanel.prototype, \"shadowXOffsetSlider\", void 0);\n    __decorate$Z([\n        agGridCommunity.RefSelector('shadowYOffsetSlider')\n    ], ShadowPanel.prototype, \"shadowYOffsetSlider\", void 0);\n    __decorate$Z([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ShadowPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$Z([\n        agGridCommunity.PostConstruct\n    ], ShadowPanel.prototype, \"init\", null);\n    return ShadowPanel;\n}(agGridCommunity.Component));\n\nfunction initLineOpacitySlider(seriesLineOpacitySlider, chartTranslator, chartProxy) {\n    seriesLineOpacitySlider\n        .setLabel(chartTranslator.translate(\"strokeOpacity\"))\n        .setStep(0.05)\n        .setMaxValue(1)\n        .setTextFieldWidth(45)\n        .setValue(chartProxy.getSeriesOption(\"stroke.opacity\") || \"1\")\n        .onValueChange(function (newValue) { return chartProxy.setSeriesOption(\"stroke.opacity\", newValue); });\n}\nfunction initFillOpacitySlider(seriesFillOpacitySlider, chartTranslator, chartProxy) {\n    seriesFillOpacitySlider\n        .setLabel(chartTranslator.translate(\"fillOpacity\"))\n        .setStep(0.05)\n        .setMaxValue(1)\n        .setTextFieldWidth(45)\n        .setValue(chartProxy.getSeriesOption(\"fill.opacity\") || \"1\")\n        .onValueChange(function (newValue) { return chartProxy.setSeriesOption(\"fill.opacity\", newValue); });\n}\nfunction initFontPanelParams(chartTranslator, chartProxy) {\n    var initialFont = {\n        family: chartProxy.getSeriesOption(\"label.fontFamily\"),\n        style: chartProxy.getSeriesOption(\"label.fontStyle\"),\n        weight: chartProxy.getSeriesOption(\"label.fontWeight\"),\n        size: chartProxy.getSeriesOption(\"label.fontSize\"),\n        color: chartProxy.getSeriesOption(\"label.color\")\n    };\n    var setFont = function (font) {\n        if (font.family) {\n            chartProxy.setSeriesOption(\"label.fontFamily\", font.family);\n        }\n        if (font.weight) {\n            chartProxy.setSeriesOption(\"label.fontWeight\", font.weight);\n        }\n        if (font.style) {\n            chartProxy.setSeriesOption(\"label.fontStyle\", font.style);\n        }\n        if (font.size) {\n            chartProxy.setSeriesOption(\"label.fontSize\", font.size);\n        }\n        if (font.color) {\n            chartProxy.setSeriesOption(\"label.color\", font.color);\n        }\n    };\n    var params = {\n        name: chartTranslator.translate('labels'),\n        enabled: chartProxy.getSeriesOption(\"label.enabled\") || false,\n        setEnabled: function (enabled) { return chartProxy.setSeriesOption(\"label.enabled\", enabled); },\n        suppressEnabledCheckbox: false,\n        initialFont: initialFont,\n        setFont: setFont\n    };\n    return params;\n}\n\nvar __extends$1J = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar BarSeriesPanel = /** @class */ (function (_super) {\n    __extends$1J(BarSeriesPanel, _super);\n    function BarSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    BarSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(BarSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n        this.initSeriesTooltips();\n        this.initSeriesStrokeWidth();\n        this.initSeriesLineDash();\n        this.initOpacity();\n        this.initLabelPanel();\n        this.initShadowPanel();\n    };\n    BarSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    BarSeriesPanel.prototype.initSeriesStrokeWidth = function () {\n        var _this = this;\n        this.seriesStrokeWidthSlider\n            .setLabel(this.chartTranslator.translate(\"strokeWidth\"))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.width\", newValue); });\n    };\n    BarSeriesPanel.prototype.initSeriesLineDash = function () {\n        var _this = this;\n        this.seriesLineDashSlider\n            .setLabel(this.chartTranslator.translate('lineDash'))\n            .setMaxValue(30)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"lineDash\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"lineDash\", [newValue]); });\n    };\n    BarSeriesPanel.prototype.initOpacity = function () {\n        initLineOpacitySlider(this.seriesLineOpacitySlider, this.chartTranslator, this.getChartProxy());\n        initFillOpacitySlider(this.seriesFillOpacitySlider, this.chartTranslator, this.getChartProxy());\n    };\n    BarSeriesPanel.prototype.initLabelPanel = function () {\n        var params = initFontPanelParams(this.chartTranslator, this.getChartProxy());\n        var labelPanelComp = this.createBean(new FontPanel(params));\n        this.activePanels.push(labelPanelComp);\n        this.seriesGroup.addItem(labelPanelComp);\n    };\n    BarSeriesPanel.prototype.initShadowPanel = function () {\n        var shadowPanelComp = this.createBean(new ShadowPanel(this.chartController));\n        this.seriesGroup.addItem(shadowPanelComp);\n        this.activePanels.push(shadowPanelComp);\n    };\n    BarSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    BarSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    BarSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    BarSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n                <ag-slider ref=\\\"seriesStrokeWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineDashSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineOpacitySlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesFillOpacitySlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], BarSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], BarSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesStrokeWidthSlider')\n    ], BarSeriesPanel.prototype, \"seriesStrokeWidthSlider\", void 0);\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesLineDashSlider')\n    ], BarSeriesPanel.prototype, \"seriesLineDashSlider\", void 0);\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesLineOpacitySlider')\n    ], BarSeriesPanel.prototype, \"seriesLineOpacitySlider\", void 0);\n    __decorate$_([\n        agGridCommunity.RefSelector('seriesFillOpacitySlider')\n    ], BarSeriesPanel.prototype, \"seriesFillOpacitySlider\", void 0);\n    __decorate$_([\n        agGridCommunity.Autowired('chartTranslator')\n    ], BarSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$_([\n        agGridCommunity.PostConstruct\n    ], BarSeriesPanel.prototype, \"init\", null);\n    return BarSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1K = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AxisTicksPanel = /** @class */ (function (_super) {\n    __extends$1K(AxisTicksPanel, _super);\n    function AxisTicksPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    AxisTicksPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical',\n            suppressOpenCloseIcons: true\n        };\n        this.setTemplate(AxisTicksPanel.TEMPLATE, { axisTicksGroup: groupParams });\n        this.initAxisTicks();\n    };\n    AxisTicksPanel.prototype.initAxisTicks = function () {\n        var _this = this;\n        this.axisTicksGroup\n            .setTitle(this.chartTranslator.translate(\"ticks\"))\n            .hideOpenCloseIcons(true)\n            .hideEnabledCheckbox(true);\n        this.axisTicksColorPicker\n            .setLabel(this.chartTranslator.translate(\"color\"))\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getAxisProperty(\"tick.color\"))\n            .onValueChange(function (newColor) { return _this.getChartProxy().setAxisProperty(\"tick.color\", newColor); });\n        var initInput = function (expression, input, label, maxValue) {\n            input.setLabel(label)\n                .setValue(_this.getChartProxy().getAxisProperty(expression))\n                .setMaxValue(maxValue)\n                .setTextFieldWidth(45)\n                .onValueChange(function (newValue) { return _this.getChartProxy().setAxisProperty(expression, newValue); });\n        };\n        initInput(\"tick.width\", this.axisTicksWidthSlider, this.chartTranslator.translate(\"width\"), 10);\n        initInput(\"tick.size\", this.axisTicksSizeSlider, this.chartTranslator.translate(\"length\"), 30);\n    };\n    AxisTicksPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    AxisTicksPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"axisTicksGroup\\\">\\n                <ag-color-picker ref=\\\"axisTicksColorPicker\\\"></ag-color-picker>\\n                <ag-slider ref=\\\"axisTicksWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"axisTicksSizeSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$$([\n        agGridCommunity.RefSelector('axisTicksGroup')\n    ], AxisTicksPanel.prototype, \"axisTicksGroup\", void 0);\n    __decorate$$([\n        agGridCommunity.RefSelector('axisTicksColorPicker')\n    ], AxisTicksPanel.prototype, \"axisTicksColorPicker\", void 0);\n    __decorate$$([\n        agGridCommunity.RefSelector('axisTicksWidthSlider')\n    ], AxisTicksPanel.prototype, \"axisTicksWidthSlider\", void 0);\n    __decorate$$([\n        agGridCommunity.RefSelector('axisTicksSizeSlider')\n    ], AxisTicksPanel.prototype, \"axisTicksSizeSlider\", void 0);\n    __decorate$$([\n        agGridCommunity.Autowired('chartTranslator')\n    ], AxisTicksPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$$([\n        agGridCommunity.PostConstruct\n    ], AxisTicksPanel.prototype, \"init\", null);\n    return AxisTicksPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1L = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AxisPanel = /** @class */ (function (_super) {\n    __extends$1L(AxisPanel, _super);\n    function AxisPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    AxisPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(AxisPanel.TEMPLATE, { axisGroup: groupParams });\n        this.initAxis();\n        this.initAxisTicks();\n        this.initAxisLabels();\n    };\n    AxisPanel.prototype.initAxis = function () {\n        var _this = this;\n        var chartTranslator = this.chartTranslator;\n        this.axisGroup\n            .setTitle(chartTranslator.translate(\"axis\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n        this.axisColorInput\n            .setLabel(chartTranslator.translate(\"color\"))\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getAxisProperty(\"line.color\"))\n            .onValueChange(function (newColor) { return _this.getChartProxy().setAxisProperty(\"line.color\", newColor); });\n        this.axisLineWidthSlider\n            .setLabel(chartTranslator.translate(\"thickness\"))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getAxisProperty(\"line.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setAxisProperty(\"line.width\", newValue); });\n        if (agGridCommunity._.includes(['line', 'scatter', 'bubble'], this.chartController.getChartType()) && !this.chartController.isGrouping()) {\n            var options_1 = [\n                { value: '', text: chartTranslator.translate('automatic') }\n            ];\n            ['category', 'time', 'number'].forEach(function (type) {\n                options_1.push({ value: type, text: chartTranslator.translate(type) });\n            });\n            this.xAxisTypeSelect\n                .setLabel(chartTranslator.translate('xType'))\n                .setLabelWidth('flex')\n                .addOptions(options_1)\n                .setValue(this.getChartProxy().getChartOption('xAxis.type') || '')\n                .onValueChange(function (newValue) {\n                var chartProxy = _this.getChartProxy();\n                chartProxy.setChartOption('xAxis.type', typeof newValue === 'string' && newValue.length && newValue);\n                _this.chartController.updateForDataChange();\n            });\n        }\n        else {\n            this.xAxisTypeSelect.setDisplayed(false);\n        }\n    };\n    AxisPanel.prototype.initAxisTicks = function () {\n        var axisTicksComp = this.createBean(new AxisTicksPanel(this.chartController));\n        this.axisGroup.addItem(axisTicksComp);\n        this.activePanels.push(axisTicksComp);\n    };\n    AxisPanel.prototype.initAxisLabels = function () {\n        var _this = this;\n        var chartProxy = this.getChartProxy();\n        var initialFont = {\n            family: chartProxy.getAxisProperty(\"label.fontFamily\"),\n            style: chartProxy.getAxisProperty(\"label.fontStyle\"),\n            weight: chartProxy.getAxisProperty(\"label.fontWeight\"),\n            size: chartProxy.getAxisProperty(\"label.fontSize\"),\n            color: chartProxy.getAxisProperty(\"label.color\")\n        };\n        var setFont = function (font) {\n            var proxy = _this.getChartProxy();\n            if (font.family) {\n                proxy.setAxisProperty(\"label.fontFamily\", font.family);\n            }\n            if (font.weight) {\n                proxy.setAxisProperty(\"label.fontWeight\", font.weight);\n            }\n            if (font.style) {\n                proxy.setAxisProperty(\"label.fontStyle\", font.style);\n            }\n            if (font.size) {\n                proxy.setAxisProperty(\"label.fontSize\", font.size);\n            }\n            if (font.color) {\n                proxy.setAxisProperty(\"label.color\", font.color);\n            }\n            proxy.getChart().performLayout();\n        };\n        var params = {\n            enabled: true,\n            suppressEnabledCheckbox: true,\n            initialFont: initialFont,\n            setFont: setFont\n        };\n        var labelPanelComp = this.createBean(new FontPanel(params));\n        this.axisGroup.addItem(labelPanelComp);\n        this.activePanels.push(labelPanelComp);\n        this.addAdditionalLabelComps(labelPanelComp);\n    };\n    AxisPanel.prototype.addAdditionalLabelComps = function (labelPanelComp) {\n        var _this = this;\n        var createAngleComp = function (label, initialValue, updateFunc) {\n            var rotationInput = _this.createBean(new agGridCommunity.AgAngleSelect()\n                .setLabel(label)\n                .setLabelWidth(\"flex\")\n                .setValue(initialValue || 0)\n                .onValueChange(updateFunc));\n            labelPanelComp.addCompToPanel(rotationInput);\n        };\n        var degreesSymbol = String.fromCharCode(176);\n        var createLabelUpdateFunc = function (axisPosition) { return function (newValue) {\n            var chartProxy = _this.getChartProxy();\n            var chart = chartProxy.getChart();\n            var axis = find(chart.axes, function (currentAxis) { return currentAxis.position === axisPosition; });\n            if (axis) {\n                axis.label.rotation = newValue;\n                // if (axis.position === ChartAxisPosition.Bottom) {\n                //     // _.set(chartProxy.getChartOptions().xAxis, \"label.rotation\", newValue);\n                // } else if (axis.position === ChartAxisPosition.Left) {\n                //     // _.set(chartProxy.getChartOptions().yAxis, \"label.rotation\", newValue);\n                // }\n                chart.performLayout();\n            }\n        }; };\n        var xRotationLabel = this.chartTranslator.translate(\"xRotation\") + \" \" + degreesSymbol;\n        var yRotationLabel = this.chartTranslator.translate(\"yRotation\") + \" \" + degreesSymbol;\n        createAngleComp(xRotationLabel, this.getChartProxy().getChartOption(\"xAxis.label.rotation\"), createLabelUpdateFunc(ChartAxisPosition.Bottom));\n        createAngleComp(yRotationLabel, this.getChartProxy().getChartOption(\"yAxis.label.rotation\"), createLabelUpdateFunc(ChartAxisPosition.Left));\n        var labelPaddingSlider = this.createBean(new agGridCommunity.AgSlider());\n        labelPaddingSlider.setLabel(this.chartTranslator.translate(\"padding\"))\n            .setValue(this.getChartProxy().getAxisProperty(\"label.padding\"))\n            .setMaxValue(30)\n            .setTextFieldWidth(45)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setAxisProperty(\"label.padding\", newValue); });\n        labelPanelComp.addCompToPanel(labelPaddingSlider);\n    };\n    AxisPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    AxisPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    AxisPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    AxisPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"axisGroup\\\">\\n                <ag-color-picker ref=\\\"axisColorInput\\\"></ag-color-picker>\\n                <ag-slider ref=\\\"axisLineWidthSlider\\\"></ag-slider>\\n                <ag-select ref=\\\"xAxisTypeSelect\\\"></ag-select>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$10([\n        agGridCommunity.RefSelector('axisGroup')\n    ], AxisPanel.prototype, \"axisGroup\", void 0);\n    __decorate$10([\n        agGridCommunity.RefSelector('axisColorInput')\n    ], AxisPanel.prototype, \"axisColorInput\", void 0);\n    __decorate$10([\n        agGridCommunity.RefSelector('axisLineWidthSlider')\n    ], AxisPanel.prototype, \"axisLineWidthSlider\", void 0);\n    __decorate$10([\n        agGridCommunity.RefSelector('xAxisTypeSelect')\n    ], AxisPanel.prototype, \"xAxisTypeSelect\", void 0);\n    __decorate$10([\n        agGridCommunity.Autowired('chartTranslator')\n    ], AxisPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$10([\n        agGridCommunity.PostConstruct\n    ], AxisPanel.prototype, \"init\", null);\n    return AxisPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1M = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar NavigatorPanel = /** @class */ (function (_super) {\n    __extends$1M(NavigatorPanel, _super);\n    function NavigatorPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    NavigatorPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(NavigatorPanel.TEMPLATE, { navigatorGroup: groupParams });\n        this.initNavigator();\n    };\n    NavigatorPanel.prototype.initNavigator = function () {\n        var _this = this;\n        var chartTranslator = this.chartTranslator;\n        this.navigatorGroup\n            .setTitle(chartTranslator.translate(\"navigator\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(false)\n            .setEnabled(this.getChartProxy().getChartOption(\"navigator.enabled\") || false)\n            .onEnableChange(function (enabled) {\n            _this.getChartProxy().setChartOption(\"navigator.enabled\", enabled);\n            _this.navigatorGroup.toggleGroupExpand(true);\n        });\n        this.navigatorHeightSlider\n            .setLabel(chartTranslator.translate(\"height\"))\n            .setMinValue(10)\n            .setMaxValue(60)\n            .setTextFieldWidth(45)\n            .setValue(String(this.getChartProxy().getChartOption(\"navigator.height\") || \"30\"))\n            .onValueChange(function (height) { return _this.getChartProxy().setChartOption(\"navigator.height\", height); });\n    };\n    NavigatorPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    NavigatorPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    NavigatorPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    NavigatorPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"navigatorGroup\\\">\\n                <ag-slider ref=\\\"navigatorHeightSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$11([\n        agGridCommunity.RefSelector('navigatorGroup')\n    ], NavigatorPanel.prototype, \"navigatorGroup\", void 0);\n    __decorate$11([\n        agGridCommunity.RefSelector('navigatorHeightSlider')\n    ], NavigatorPanel.prototype, \"navigatorHeightSlider\", void 0);\n    __decorate$11([\n        agGridCommunity.Autowired('chartTranslator')\n    ], NavigatorPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$11([\n        agGridCommunity.PostConstruct\n    ], NavigatorPanel.prototype, \"init\", null);\n    return NavigatorPanel;\n}(agGridCommunity.Component));\n\n// deepMerge\nfunction emptyTarget$1(value) {\n    return Array.isArray(value) ? [] : {};\n}\nfunction cloneUnlessOtherwiseSpecified$1(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepMerge$1(emptyTarget$1(value), value, options)\n        : value;\n}\nfunction defaultArrayMerge$1(target, source, options) {\n    return target.concat(source).map(function (element) {\n        return cloneUnlessOtherwiseSpecified$1(element, options);\n    });\n}\nfunction getMergeFunction$1(key, options) {\n    if (!options.customMerge) {\n        return deepMerge$1;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepMerge$1;\n}\nfunction getEnumerableOwnPropertySymbols$1(target) {\n    return Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n            return target.propertyIsEnumerable(symbol);\n        })\n        : [];\n}\nfunction getKeys$1(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols$1(target));\n}\nfunction propertyIsOnObject$1(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe$1(target, key) {\n    return propertyIsOnObject$1(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\nfunction mergeObject$1(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n        getKeys$1(target).forEach(function (key) {\n            destination[key] = cloneUnlessOtherwiseSpecified$1(target[key], options);\n        });\n    }\n    getKeys$1(source).forEach(function (key) {\n        if (propertyIsUnsafe$1(target, key)) {\n            return;\n        }\n        if (propertyIsOnObject$1(target, key) && options.isMergeableObject(source[key])) {\n            destination[key] = getMergeFunction$1(key, options)(target[key], source[key], options);\n        }\n        else {\n            destination[key] = cloneUnlessOtherwiseSpecified$1(source[key], options);\n        }\n    });\n    return destination;\n}\nfunction defaultIsMergeableObject$1(value) {\n    return isNonNullObject$1(value) && !isSpecial$1(value);\n}\nfunction isNonNullObject$1(value) {\n    return !!value && typeof value === 'object';\n}\nfunction isSpecial$1(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]';\n}\nfunction deepMerge$1(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge$1;\n    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject$1;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified$1;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified$1(source, options);\n    }\n    else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options);\n    }\n    else {\n        return mergeObject$1(target, source, options);\n    }\n}\n\nvar __assign$7 = (undefined && undefined.__assign) || function () {\n    __assign$7 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$7.apply(this, arguments);\n};\nvar ChartProxy = /** @class */ (function () {\n    function ChartProxy(chartProxyParams) {\n        var _this = this;\n        this.chartProxyParams = chartProxyParams;\n        this.isDarkTheme = function () { return _this.chartProxyParams.isDarkTheme(); };\n        this.getFontColor = function () { return _this.isDarkTheme() ? 'rgb(221, 221, 221)' : 'rgb(87, 87, 87)'; };\n        this.getAxisGridColor = function () { return _this.isDarkTheme() ? 'rgb(100, 100, 100)' : 'rgb(219, 219, 219)'; };\n        this.getBackgroundColor = function () { return _this.isDarkTheme() ? '#2d3436' : 'white'; };\n        this.getChartPaddingOption = function (property) { return _this.chartOptions.padding ? \"\" + _this.chartOptions.padding[property] : ''; };\n        this.getShadowEnabled = function () { return !!_this.getShadowProperty('enabled'); };\n        this.chartId = chartProxyParams.chartId;\n        this.chartType = chartProxyParams.chartType;\n        this.eventService = chartProxyParams.eventService;\n        this.gridApi = chartProxyParams.gridApi;\n        this.columnApi = chartProxyParams.columnApi;\n        this.crossFiltering = chartProxyParams.crossFiltering;\n        this.crossFilterCallback = chartProxyParams.crossFilterCallback;\n    }\n    ChartProxy.prototype.recreateChart = function (options) {\n        var _this = this;\n        if (this.chart) {\n            this.destroyChart();\n        }\n        this.chart = this.createChart(options);\n        if (this.crossFiltering) {\n            // add event listener to chart canvas to detect when user wishes to reset filters\n            var resetFilters_1 = true;\n            this.chart.addEventListener('click', function (e) { return _this.crossFilterCallback(e, resetFilters_1); });\n        }\n    };\n    ChartProxy.prototype.getChart = function () {\n        return this.chart;\n    };\n    ChartProxy.prototype.downloadChart = function () {\n        var chart = this.chart;\n        var fileName = chart.title ? chart.title.text : 'chart';\n        chart.scene.download(fileName);\n    };\n    ChartProxy.prototype.getChartImageDataURL = function (type) {\n        return this.chart.scene.getDataURL(type);\n    };\n    ChartProxy.prototype.initChartOptions = function () {\n        this.initChartTheme();\n        this.chartOptions = this.getDefaultOptionsFromTheme(this.chartTheme);\n        // allow users to override options before they are applied\n        var processChartOptions = this.chartProxyParams.processChartOptions;\n        if (processChartOptions) {\n            var originalOptions = deepMerge$1({}, this.chartOptions);\n            var params = { type: this.chartType, options: this.chartOptions };\n            var overriddenOptions = processChartOptions(params);\n            // ensure we have everything we need, in case the processing removed necessary options\n            var safeOptions = this.getDefaultOptions();\n            agGridCommunity._.mergeDeep(safeOptions, overriddenOptions, false);\n            this.overridePalette(originalOptions, safeOptions);\n            this.chartOptions = safeOptions;\n        }\n    };\n    ChartProxy.prototype.paletteOverridden = function (originalOptions, overriddenOptions) {\n        return !agGridCommunity._.areEqual(originalOptions.seriesDefaults.fill.colors, overriddenOptions.seriesDefaults.fill.colors) ||\n            !agGridCommunity._.areEqual(originalOptions.seriesDefaults.stroke.colors, overriddenOptions.seriesDefaults.stroke.colors);\n    };\n    ChartProxy.prototype.initChartTheme = function () {\n        var _this = this;\n        var themeName = this.getSelectedTheme();\n        var stockTheme = this.isStockTheme(themeName);\n        var gridOptionsThemeOverrides = this.chartProxyParams.getGridOptionsChartThemeOverrides();\n        var apiThemeOverrides = this.chartProxyParams.apiChartThemeOverrides;\n        if (gridOptionsThemeOverrides || apiThemeOverrides) {\n            var themeOverrides_1 = {\n                overrides: this.mergeThemeOverrides(gridOptionsThemeOverrides, apiThemeOverrides)\n            };\n            var getCustomTheme = function () { return deepMerge$1(_this.lookupCustomChartTheme(themeName), themeOverrides_1); };\n            var theme = stockTheme ? __assign$7({ baseTheme: themeName }, themeOverrides_1) : getCustomTheme();\n            this.chartTheme = getChartTheme(theme);\n        }\n        else {\n            this.chartTheme = getChartTheme(stockTheme ? themeName : this.lookupCustomChartTheme(themeName));\n        }\n    };\n    ChartProxy.prototype.lookupCustomChartTheme = function (name) {\n        var customChartThemes = this.chartProxyParams.customChartThemes;\n        var customChartTheme = customChartThemes && customChartThemes[name];\n        if (!customChartTheme) {\n            console.warn(\"AG Grid: no stock theme exists with the name '\" + name + \"' and no \" +\n                \"custom chart theme with that name was supplied to 'customChartThemes'\");\n        }\n        return customChartTheme;\n    };\n    ChartProxy.prototype.isStockTheme = function (themeName) {\n        return agGridCommunity._.includes(Object.keys(themes), themeName);\n    };\n    ChartProxy.prototype.mergeThemeOverrides = function (gridOptionsThemeOverrides, apiThemeOverrides) {\n        if (!gridOptionsThemeOverrides) {\n            return apiThemeOverrides;\n        }\n        if (!apiThemeOverrides) {\n            return gridOptionsThemeOverrides;\n        }\n        return deepMerge$1(gridOptionsThemeOverrides, apiThemeOverrides);\n    };\n    ChartProxy.prototype.integratedToStandaloneChartType = function (integratedChartType) {\n        switch (integratedChartType) {\n            case agGridCommunity.ChartType.GroupedBar:\n            case agGridCommunity.ChartType.StackedBar:\n            case agGridCommunity.ChartType.NormalizedBar:\n                return 'bar';\n            case agGridCommunity.ChartType.GroupedColumn:\n            case agGridCommunity.ChartType.StackedColumn:\n            case agGridCommunity.ChartType.NormalizedColumn:\n                return 'column';\n            case agGridCommunity.ChartType.Line:\n                return 'line';\n            case agGridCommunity.ChartType.Area:\n            case agGridCommunity.ChartType.StackedArea:\n            case agGridCommunity.ChartType.NormalizedArea:\n                return 'area';\n            case agGridCommunity.ChartType.Scatter:\n            case agGridCommunity.ChartType.Bubble:\n                return 'scatter';\n            case agGridCommunity.ChartType.Histogram:\n                return 'histogram';\n            case agGridCommunity.ChartType.Pie:\n            case agGridCommunity.ChartType.Doughnut:\n                return 'pie';\n            default:\n                return 'cartesian';\n        }\n    };\n    ChartProxy.prototype.overridePalette = function (originalOptions, chartOptions) {\n        if (!this.chartProxyParams.allowPaletteOverride) {\n            return;\n        }\n        if (!this.paletteOverridden(originalOptions, chartOptions)) {\n            return;\n        }\n        var seriesDefaults = chartOptions.seriesDefaults;\n        var fillsOverridden = seriesDefaults.fill.colors;\n        var strokesOverridden = seriesDefaults.stroke.colors;\n        if (fillsOverridden || strokesOverridden) {\n            // due to series default refactoring it's possible for fills and strokes to have undefined values\n            var invalidFills = agGridCommunity._.includes(fillsOverridden, undefined);\n            var invalidStrokes = agGridCommunity._.includes(strokesOverridden, undefined);\n            if (invalidFills || invalidStrokes) {\n                return;\n            }\n            // both fills and strokes will need to be overridden\n            this.customPalette = {\n                fills: fillsOverridden,\n                strokes: strokesOverridden\n            };\n        }\n    };\n    ChartProxy.prototype.getStandaloneChartType = function () {\n        return this.integratedToStandaloneChartType(this.chartType);\n    };\n    // Merges theme defaults into default options. To be overridden in subclasses.\n    ChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = {};\n        var standaloneChartType = this.getStandaloneChartType();\n        options.title = theme.getConfig(standaloneChartType + '.title');\n        options.subtitle = theme.getConfig(standaloneChartType + '.subtitle');\n        options.background = theme.getConfig(standaloneChartType + '.background');\n        options.legend = theme.getConfig(standaloneChartType + '.legend');\n        options.navigator = theme.getConfig(standaloneChartType + '.navigator');\n        options.tooltip = {\n            enabled: theme.getConfig(standaloneChartType + '.tooltip.enabled'),\n            tracking: theme.getConfig(standaloneChartType + '.tooltip.tracking'),\n            class: theme.getConfig(standaloneChartType + '.tooltip.class'),\n            delay: theme.getConfig(standaloneChartType + '.tooltip.delay')\n        };\n        options.listeners = theme.getConfig(standaloneChartType + '.listeners');\n        options.padding = theme.getConfig(standaloneChartType + '.padding');\n        return options;\n    };\n    ChartProxy.prototype.getSelectedTheme = function () {\n        var chartThemeName = this.chartProxyParams.getChartThemeName();\n        var availableThemes = this.chartProxyParams.getChartThemes();\n        if (!agGridCommunity._.includes(availableThemes, chartThemeName)) {\n            chartThemeName = availableThemes[0];\n        }\n        return chartThemeName;\n    };\n    ChartProxy.prototype.getChartOptions = function () {\n        return this.chartOptions;\n    };\n    ChartProxy.prototype.getCustomPalette = function () {\n        return this.customPalette;\n    };\n    ChartProxy.prototype.getChartOption = function (expression) {\n        return agGridCommunity._.get(this.chartOptions, expression, undefined);\n    };\n    ChartProxy.prototype.setChartOption = function (expression, value) {\n        if (agGridCommunity._.get(this.chartOptions, expression, undefined) === value) {\n            // option is already set to the specified value\n            return;\n        }\n        agGridCommunity._.set(this.chartOptions, expression, value);\n        var mappings = {\n            'legend.item.marker.strokeWidth': 'legend.strokeWidth',\n            'legend.item.marker.size': 'legend.markerSize',\n            'legend.item.marker.padding': 'legend.itemSpacing',\n            'legend.item.label.fontFamily': 'legend.fontFamily',\n            'legend.item.label.fontStyle': 'legend.fontStyle',\n            'legend.item.label.fontWeight': 'legend.fontWeight',\n            'legend.item.label.fontSize': 'legend.fontSize',\n            'legend.item.label.color': 'legend.color',\n            'legend.item.paddingX': 'legend.layoutHorizontalSpacing',\n            'legend.item.paddingY': 'legend.layoutVerticalSpacing',\n        };\n        agGridCommunity._.set(this.chart, mappings[expression] || expression, value);\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartProxy.prototype.getSeriesOption = function (expression) {\n        return agGridCommunity._.get(this.chartOptions.seriesDefaults, expression, undefined);\n    };\n    ChartProxy.prototype.setSeriesOption = function (expression, value) {\n        if (agGridCommunity._.get(this.chartOptions.seriesDefaults, expression, undefined) === value) {\n            // option is already set to the specified value\n            return;\n        }\n        agGridCommunity._.set(this.chartOptions.seriesDefaults, expression, value);\n        var mappings = {\n            'stroke.width': 'strokeWidth',\n            'stroke.opacity': 'strokeOpacity',\n            'fill.opacity': 'fillOpacity',\n            'callout.colors': 'calloutColors'\n        };\n        var series = this.chart.series;\n        series.forEach(function (s) { return agGridCommunity._.set(s, mappings[expression] || expression, value); });\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartProxy.prototype.setTitleOption = function (property, value) {\n        if (agGridCommunity._.get(this.chartOptions.title, property, undefined) === value) {\n            // option is already set to the specified value\n            return;\n        }\n        this.chartOptions.title[property] = value;\n        if (!this.chart.title) {\n            this.chart.title = {};\n        }\n        this.chart.title[property] = value;\n        if (property === 'text') {\n            this.setTitleOption('enabled', agGridCommunity._.exists(value));\n        }\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartProxy.prototype.getTitleOption = function (property) {\n        return this.chartOptions.title[property];\n    };\n    ChartProxy.prototype.setChartPaddingOption = function (property, value) {\n        var padding = this.chartOptions.padding;\n        if (agGridCommunity._.get(padding, property, undefined) === value) {\n            // option is already set to the specified value\n            return;\n        }\n        if (!padding) {\n            padding = this.chartOptions.padding = { top: 0, right: 0, bottom: 0, left: 0 };\n            this.chart.padding = new Padding(0);\n        }\n        padding[property] = value;\n        this.chart.padding[property] = value;\n        this.chart.performLayout();\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartProxy.prototype.getShadowProperty = function (property) {\n        var seriesDefaults = this.chartOptions.seriesDefaults;\n        return seriesDefaults.shadow ? seriesDefaults.shadow[property] : '';\n    };\n    ChartProxy.prototype.setShadowProperty = function (property, value) {\n        var seriesDefaults = this.chartOptions.seriesDefaults;\n        if (agGridCommunity._.get(seriesDefaults.shadow, property, undefined) === value) {\n            // option is already set to the specified value\n            return;\n        }\n        if (!seriesDefaults.shadow) {\n            seriesDefaults.shadow = {\n                enabled: false,\n                blur: 0,\n                xOffset: 0,\n                yOffset: 0,\n                color: 'rgba(0,0,0,0.5)'\n            };\n        }\n        seriesDefaults.shadow[property] = value;\n        var series = this.getChart().series;\n        series.forEach(function (s) {\n            if (!s.shadow) {\n                var shadow = new DropShadow();\n                shadow.enabled = false;\n                shadow.blur = 0;\n                shadow.xOffset = 0;\n                shadow.yOffset = 0;\n                shadow.color = 'rgba(0,0,0,0.5)';\n                s.shadow = shadow;\n            }\n            s.shadow[property] = value;\n        });\n        this.raiseChartOptionsChangedEvent();\n    };\n    ChartProxy.prototype.raiseChartOptionsChangedEvent = function () {\n        var event = Object.freeze({\n            type: agGridCommunity.Events.EVENT_CHART_OPTIONS_CHANGED,\n            chartId: this.chartId,\n            chartType: this.chartType,\n            chartThemeName: this.chartProxyParams.getChartThemeName(),\n            chartOptions: this.chartOptions,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n        });\n        this.eventService.dispatchEvent(event);\n    };\n    ChartProxy.prototype.getDefaultFontOptions = function () {\n        return {\n            fontStyle: 'normal',\n            fontWeight: 'normal',\n            fontSize: 12,\n            fontFamily: 'Verdana, sans-serif',\n            color: this.getFontColor()\n        };\n    };\n    ChartProxy.prototype.getDefaultDropShadowOptions = function () {\n        return {\n            enabled: false,\n            blur: 5,\n            xOffset: 3,\n            yOffset: 3,\n            color: 'rgba(0, 0, 0, 0.5)',\n        };\n    };\n    ChartProxy.prototype.getPredefinedPalette = function () {\n        return this.chartTheme.palette;\n    };\n    ChartProxy.prototype.getPalette = function () {\n        return this.customPalette || this.chartTheme.palette;\n    };\n    //TODO remove all 'integrated' default chart options\n    ChartProxy.prototype.getDefaultChartOptions = function () {\n        return {\n            background: {},\n            padding: {},\n            title: {},\n            subtitle: {},\n            legend: {},\n            navigator: {},\n            seriesDefaults: {},\n            listeners: {}\n        };\n    };\n    ChartProxy.prototype.transformData = function (data, categoryKey) {\n        if (this.chart.axes.filter(function (a) { return a instanceof CategoryAxis; }).length < 1) {\n            return data;\n        }\n        // replace the values for the selected category with a complex object to allow for duplicated categories\n        return data.map(function (d, index) {\n            var value = d[categoryKey];\n            var valueString = value && value.toString ? value.toString() : '';\n            var datum = __assign$7({}, d);\n            datum[categoryKey] = { id: index, value: value, toString: function () { return valueString; } };\n            return datum;\n        });\n    };\n    ChartProxy.prototype.hexToRGBA = function (hex, alpha) {\n        var r = parseInt(hex.slice(1, 3), 16);\n        var g = parseInt(hex.slice(3, 5), 16);\n        var b = parseInt(hex.slice(5, 7), 16);\n        return alpha ? \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + alpha + \")\" : \"rgba(\" + r + \", \" + g + \", \" + b + \")\";\n    };\n    ChartProxy.prototype.destroy = function () {\n        this.destroyChart();\n    };\n    ChartProxy.prototype.destroyChart = function () {\n        if (this.chart) {\n            this.chart.destroy();\n            this.chart = undefined;\n        }\n    };\n    return ChartProxy;\n}());\n\nfunction isDate(value) {\n    return value instanceof Date;\n}\n\nvar __extends$1N = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$8 = (undefined && undefined.__assign) || function () {\n    __assign$8 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$8.apply(this, arguments);\n};\nvar CartesianChartProxy = /** @class */ (function (_super) {\n    __extends$1N(CartesianChartProxy, _super);\n    function CartesianChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.axisTypeToClassMap = {\n            number: NumberAxis,\n            category: CategoryAxis,\n            groupedCategory: GroupedCategoryAxis,\n            time: TimeAxis\n        };\n        return _this;\n    }\n    CartesianChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var _a;\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var standaloneChartType = this.getStandaloneChartType();\n        var flipXY = standaloneChartType === 'bar';\n        var xAxisType = (standaloneChartType === 'scatter' || standaloneChartType === 'histogram') ? 'number' : 'category';\n        var yAxisType = 'number';\n        if (flipXY) {\n            _a = [yAxisType, xAxisType], xAxisType = _a[0], yAxisType = _a[1];\n        }\n        var xAxisTheme = {};\n        var yAxisTheme = {};\n        xAxisTheme = deepMerge$1(xAxisTheme, theme.getConfig(standaloneChartType + '.axes.' + xAxisType));\n        xAxisTheme = deepMerge$1(xAxisTheme, theme.getConfig(standaloneChartType + '.axes.' + xAxisType + '.bottom'));\n        yAxisTheme = deepMerge$1(yAxisTheme, theme.getConfig(standaloneChartType + '.axes.' + yAxisType));\n        yAxisTheme = deepMerge$1(yAxisTheme, theme.getConfig(standaloneChartType + '.axes.' + yAxisType + '.left'));\n        options.xAxis = xAxisTheme;\n        options.yAxis = yAxisTheme;\n        return options;\n    };\n    CartesianChartProxy.prototype.getAxisProperty = function (expression) {\n        return agGridCommunity._.get(this.chartOptions.xAxis, expression, undefined);\n    };\n    CartesianChartProxy.prototype.setAxisProperty = function (expression, value) {\n        agGridCommunity._.set(this.chartOptions.xAxis, expression, value);\n        agGridCommunity._.set(this.chartOptions.yAxis, expression, value);\n        var chart = this.chart;\n        this.chart.axes.forEach(function (axis) { return agGridCommunity._.set(axis, expression, value); });\n        chart.performLayout();\n        this.raiseChartOptionsChangedEvent();\n    };\n    CartesianChartProxy.prototype.updateLabelRotation = function (categoryId, isHorizontalChart, axisType) {\n        if (isHorizontalChart === void 0) { isHorizontalChart = false; }\n        if (axisType === void 0) { axisType = 'category'; }\n        var labelRotation = 0;\n        var axisKey = isHorizontalChart ? 'yAxis' : 'xAxis';\n        var themeOverrides = this.chartProxyParams.getGridOptionsChartThemeOverrides();\n        var axisPosition = isHorizontalChart ? ChartAxisPosition.Left : ChartAxisPosition.Bottom;\n        var chartType = this.getStandaloneChartType();\n        var userThemeOverrideRotation;\n        var commonRotation = agGridCommunity._.get(themeOverrides, \"common.axes.\" + axisType + \".label.rotation\", undefined);\n        var cartesianRotation = agGridCommunity._.get(themeOverrides, \"cartesian.axes.\" + axisType + \".label.rotation\", undefined);\n        var cartesianPositionRotation = agGridCommunity._.get(themeOverrides, \"cartesian.axes.\" + axisType + \".\" + axisPosition + \".label.rotation\", undefined);\n        var chartTypeRotation = agGridCommunity._.get(themeOverrides, chartType + \".axes.\" + axisType + \".label.rotation\", undefined);\n        var chartTypePositionRotation = agGridCommunity._.get(themeOverrides, chartType + \".axes.\" + axisType + \".\" + axisPosition + \".label.rotation\", undefined);\n        if (typeof chartTypePositionRotation === 'number' && isFinite(chartTypePositionRotation)) {\n            userThemeOverrideRotation = chartTypePositionRotation;\n        }\n        else if (typeof chartTypeRotation === 'number' && isFinite(chartTypeRotation)) {\n            userThemeOverrideRotation = chartTypeRotation;\n        }\n        else if (typeof cartesianPositionRotation === 'number' && isFinite(cartesianPositionRotation)) {\n            userThemeOverrideRotation = cartesianPositionRotation;\n        }\n        else if (typeof cartesianRotation === 'number' && isFinite(cartesianRotation)) {\n            userThemeOverrideRotation = cartesianRotation;\n        }\n        else if (typeof commonRotation === 'number' && isFinite(commonRotation)) {\n            userThemeOverrideRotation = commonRotation;\n        }\n        if (categoryId !== ChartDataModel.DEFAULT_CATEGORY && !this.chartProxyParams.grouping) {\n            var label = this.chartOptions[axisKey].label;\n            if (label) {\n                if (userThemeOverrideRotation !== undefined) {\n                    labelRotation = userThemeOverrideRotation;\n                }\n                else {\n                    labelRotation = label.rotation || 335;\n                }\n            }\n        }\n        var axis = find(this.chart.axes, function (currentAxis) { return currentAxis.position === axisPosition; });\n        if (axis) {\n            axis.label.rotation = labelRotation;\n        }\n    };\n    CartesianChartProxy.prototype.getDefaultAxisOptions = function () {\n        var fontOptions = this.getDefaultFontOptions();\n        var stroke = this.getAxisGridColor();\n        var axisColor = \"rgba(195, 195, 195, 1)\";\n        return {\n            title: __assign$8(__assign$8({}, fontOptions), { enabled: false, fontSize: 14 }),\n            line: {\n                color: axisColor,\n                width: 1,\n            },\n            tick: {\n                color: axisColor,\n                size: 6,\n                width: 1,\n            },\n            label: __assign$8(__assign$8({}, fontOptions), { padding: 5, rotation: 0 }),\n            gridStyle: [{\n                    stroke: stroke,\n                    lineDash: [4, 2]\n                }]\n        };\n    };\n    CartesianChartProxy.prototype.getDefaultCartesianChartOptions = function () {\n        var options = this.getDefaultChartOptions();\n        options.xAxis = this.getDefaultAxisOptions();\n        options.yAxis = this.getDefaultAxisOptions();\n        return options;\n    };\n    CartesianChartProxy.prototype.getAxisClass = function (axisType) {\n        return this.axisTypeToClassMap[axisType];\n    };\n    CartesianChartProxy.prototype.updateAxes = function (baseAxisType, isHorizontalChart) {\n        if (baseAxisType === void 0) { baseAxisType = 'category'; }\n        if (isHorizontalChart === void 0) { isHorizontalChart = false; }\n        var baseAxis = isHorizontalChart ? this.getYAxis() : this.getXAxis();\n        if (!baseAxis) {\n            return;\n        }\n        if (this.chartProxyParams.grouping) {\n            if (!(baseAxis instanceof GroupedCategoryAxis)) {\n                this.recreateChart();\n            }\n            return;\n        }\n        var axisClass = this.axisTypeToClassMap[baseAxisType];\n        if (baseAxis instanceof axisClass) {\n            return;\n        }\n        var options = this.chartOptions;\n        if (isHorizontalChart && !options.yAxis.type) {\n            options = __assign$8(__assign$8({}, options), { yAxis: __assign$8({ type: baseAxisType }, options.yAxis) });\n        }\n        else if (!isHorizontalChart && !options.xAxis.type) {\n            options = __assign$8(__assign$8({}, options), { xAxis: __assign$8({ type: baseAxisType }, options.xAxis) });\n        }\n        this.recreateChart(options);\n    };\n    CartesianChartProxy.prototype.isTimeAxis = function (params) {\n        if (params.category && params.category.chartDataType) {\n            return params.category.chartDataType === 'time';\n        }\n        var testDatum = params.data[0];\n        var testValue = testDatum && testDatum[params.category.id];\n        return isDate(testValue);\n    };\n    CartesianChartProxy.prototype.getXAxisDefaults = function (xAxisType, options) {\n        if (xAxisType === 'time') {\n            var xAxisTheme = {};\n            var standaloneChartType = this.getStandaloneChartType();\n            xAxisTheme = deepMerge$1(xAxisTheme, this.chartTheme.getConfig(standaloneChartType + '.axes.time'));\n            xAxisTheme = deepMerge$1(xAxisTheme, this.chartTheme.getConfig(standaloneChartType + '.axes.time.bottom'));\n            return xAxisTheme;\n        }\n        return options.xAxis;\n    };\n    CartesianChartProxy.prototype.getXAxis = function () {\n        return find(this.chart.axes, function (a) { return a.position === ChartAxisPosition.Bottom; });\n    };\n    CartesianChartProxy.prototype.getYAxis = function () {\n        return find(this.chart.axes, function (a) { return a.position === ChartAxisPosition.Left; });\n    };\n    CartesianChartProxy.prototype.processDataForCrossFiltering = function (data, colId, params) {\n        var yKey = colId;\n        var atLeastOneSelectedPoint = false;\n        if (this.crossFiltering) {\n            data.forEach(function (d) {\n                d[colId + '-total'] = d[colId] + d[colId + '-filtered-out'];\n                if (d[colId + '-filtered-out'] > 0) {\n                    atLeastOneSelectedPoint = true;\n                }\n            });\n            var lastSelectedChartId = params.getCrossFilteringContext().lastSelectedChartId;\n            if (lastSelectedChartId === params.chartId) {\n                yKey = colId + '-total';\n            }\n        }\n        return { yKey: yKey, atLeastOneSelectedPoint: atLeastOneSelectedPoint };\n    };\n    CartesianChartProxy.prototype.updateSeriesForCrossFiltering = function (series, colId, chart, params, atLeastOneSelectedPoint) {\n        if (this.crossFiltering) {\n            // special custom marker handling to show and hide points\n            series.marker.enabled = true;\n            series.marker.formatter = function (p) {\n                return {\n                    fill: p.highlighted ? 'yellow' : p.fill,\n                    size: p.highlighted ? 12 : p.datum[colId] > 0 ? 8 : 0,\n                };\n            };\n            chart.tooltip.delay = 500;\n            // make line opaque when some points are deselected\n            var ctx = params.getCrossFilteringContext();\n            var lastSelectionOnThisChart = ctx.lastSelectedChartId === params.chartId;\n            var deselectedPoints = lastSelectionOnThisChart && atLeastOneSelectedPoint;\n            if (series instanceof AreaSeries) {\n                series.fillOpacity = deselectedPoints ? 0.3 : 1;\n            }\n            if (series instanceof LineSeries) {\n                series.strokeOpacity = deselectedPoints ? 0.3 : 1;\n            }\n            // add node click cross filtering callback to series\n            series.addEventListener('nodeClick', this.crossFilterCallback);\n        }\n    };\n    return CartesianChartProxy;\n}(ChartProxy));\n\nvar __extends$1O = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$9 = (undefined && undefined.__assign) || function () {\n    __assign$9 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$9.apply(this, arguments);\n};\nvar ScatterChartProxy = /** @class */ (function (_super) {\n    __extends$1O(ScatterChartProxy, _super);\n    function ScatterChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.getMarkersEnabled = function () { return true; }; // markers are always enabled on scatter charts\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    ScatterChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('scatter.series.scatter');\n        options.seriesDefaults = {\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity,\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            marker: {\n                enabled: seriesDefaults.marker.enabled,\n                shape: seriesDefaults.marker.shape,\n                size: seriesDefaults.marker.size,\n                strokeWidth: seriesDefaults.marker.strokeWidth\n            },\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners,\n            paired: true\n        };\n        return options;\n    };\n    ScatterChartProxy.prototype.createChart = function (options) {\n        options = options || this.chartOptions;\n        var agChartOptions = options;\n        agChartOptions.autoSize = true;\n        agChartOptions.axes = [__assign$9({ type: 'number', position: 'bottom' }, options.xAxis), __assign$9({ type: 'number', position: 'left' }, options.yAxis)];\n        return AgChart.create(agChartOptions, this.chartProxyParams.parentElement);\n    };\n    ScatterChartProxy.prototype.update = function (params) {\n        var _this = this;\n        if (params.fields.length < 2) {\n            this.chart.removeAllSeries();\n            return;\n        }\n        var fields = params.fields;\n        if (this.crossFiltering) {\n            // add additional filtered out field\n            fields.forEach(function (field) {\n                var crossFilteringField = __assign$9({}, field);\n                crossFilteringField.colId = field.colId + '-filtered-out';\n                fields.push(crossFilteringField);\n            });\n        }\n        var seriesDefaults = this.chartOptions.seriesDefaults;\n        var seriesDefinitions = this.getSeriesDefinitions(fields, seriesDefaults.paired);\n        var dataDomain;\n        if (this.crossFiltering) {\n            dataDomain = this.getCrossFilteringDataDomain(seriesDefinitions, params);\n        }\n        var chart = this.chart;\n        var existingSeriesById = chart.series.reduceRight(function (map, series, i) {\n            var matchingIndex = agGridCommunity._.findIndex(seriesDefinitions, function (s) {\n                return s.xField.colId === series.xKey &&\n                    s.yField.colId === series.yKey &&\n                    ((!s.sizeField && !series.sizeKey) || (s.sizeField && s.sizeField.colId === series.sizeKey));\n            });\n            if (matchingIndex === i) {\n                map.set(series.yKey, series);\n            }\n            else {\n                chart.removeSeries(series);\n            }\n            return map;\n        }, new Map());\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        if (this.crossFiltering) {\n            // introduce cross filtering transparent fills\n            var fillsMod_1 = [];\n            fills.forEach(function (fill) {\n                fillsMod_1.push(fill);\n                fillsMod_1.push(_this.hexToRGBA(fill, '0.3'));\n            });\n            fills = fillsMod_1;\n            // introduce cross filtering transparent strokes\n            var strokesMod_1 = [];\n            strokes.forEach(function (stroke) {\n                strokesMod_1.push(stroke);\n                strokesMod_1.push(_this.hexToRGBA(stroke, '0.3'));\n            });\n            strokes = strokesMod_1;\n        }\n        var labelFieldDefinition = params.category.id === ChartDataModel.DEFAULT_CATEGORY ? undefined : params.category;\n        var previousSeries;\n        seriesDefinitions.forEach(function (seriesDefinition, index) {\n            var existingSeries = existingSeriesById.get(seriesDefinition.yField.colId);\n            var marker = __assign$9({}, seriesDefaults.marker);\n            if (marker.type) { // deprecated\n                marker.shape = marker.type;\n                delete marker.type;\n            }\n            var series = existingSeries || AgChart.createComponent(__assign$9(__assign$9({}, seriesDefaults), { type: 'scatter', fillOpacity: seriesDefaults.fill.opacity, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, marker: marker, tooltip: {\n                    enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                    renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled && seriesDefaults.tooltip.renderer,\n                } }), 'scatter.series');\n            if (!series) {\n                return;\n            }\n            var _a = seriesDefinition, xFieldDefinition = _a.xField, yFieldDefinition = _a.yField, sizeFieldDefinition = _a.sizeField;\n            series.title = yFieldDefinition.displayName + \" vs \" + xFieldDefinition.displayName;\n            series.xKey = xFieldDefinition.colId;\n            series.xName = xFieldDefinition.displayName;\n            series.yKey = yFieldDefinition.colId;\n            series.yName = yFieldDefinition.displayName;\n            series.data = params.data;\n            series.fill = fills[index % fills.length];\n            series.stroke = strokes[index % strokes.length];\n            if (sizeFieldDefinition) {\n                series.sizeKey = sizeFieldDefinition.colId;\n                series.sizeName = sizeFieldDefinition.displayName;\n            }\n            else {\n                series.sizeKey = series.sizeName = undefined;\n            }\n            if (labelFieldDefinition) {\n                series.labelKey = labelFieldDefinition.id;\n                series.labelName = labelFieldDefinition.name;\n            }\n            else {\n                series.labelKey = series.labelName = undefined;\n            }\n            var isFilteredOutYKey = yFieldDefinition.colId.indexOf('-filtered-out') > -1;\n            if (_this.crossFiltering) {\n                if (!isFilteredOutYKey) {\n                    // sync toggling of legend item with hidden 'filtered out' item\n                    chart.legend.addEventListener('click', function (event) {\n                        series.toggleSeriesItem(event.itemId + '-filtered-out', event.enabled);\n                    });\n                }\n                if (dataDomain) {\n                    series.marker.domain = dataDomain;\n                }\n                chart.tooltip.delay = 500;\n                // hide 'filtered out' legend items\n                if (isFilteredOutYKey) {\n                    series.showInLegend = false;\n                }\n                // add node click cross filtering callback to series\n                series.addEventListener('nodeClick', _this.crossFilterCallback);\n            }\n            if (!existingSeries) {\n                chart.addSeriesAfter(series, previousSeries);\n            }\n            previousSeries = series;\n        });\n    };\n    ScatterChartProxy.prototype.getTooltipsEnabled = function () {\n        return this.chartOptions.seriesDefaults.tooltip != null && !!this.chartOptions.seriesDefaults.tooltip.enabled;\n    };\n    ScatterChartProxy.prototype.getDefaultOptions = function () {\n        var isBubble = this.chartType === agGridCommunity.ChartType.Bubble;\n        var options = this.getDefaultCartesianChartOptions();\n        options.seriesDefaults = __assign$9(__assign$9({}, options.seriesDefaults), { fill: __assign$9(__assign$9({}, options.seriesDefaults.fill), { opacity: isBubble ? 0.7 : 1 }), stroke: __assign$9(__assign$9({}, options.seriesDefaults.stroke), { width: 3 }), marker: {\n                shape: 'circle',\n                enabled: true,\n                size: 6,\n                maxSize: 30,\n                strokeWidth: 1,\n            }, tooltip: {\n                enabled: true,\n            }, paired: true });\n        return options;\n    };\n    ScatterChartProxy.prototype.getSeriesDefinitions = function (fields, paired) {\n        if (fields.length < 2) {\n            return [];\n        }\n        var isBubbleChart = this.chartType === agGridCommunity.ChartType.Bubble;\n        if (paired) {\n            if (isBubbleChart) {\n                return fields.map(function (currentxField, i) { return i % 3 === 0 ? ({\n                    xField: currentxField,\n                    yField: fields[i + 1],\n                    sizeField: fields[i + 2],\n                }) : null; }).filter(function (x) { return x && x.yField && x.sizeField; });\n            }\n            return fields.map(function (currentxField, i) { return i % 2 === 0 ? ({\n                xField: currentxField,\n                yField: fields[i + 1],\n            }) : null; }).filter(function (x) { return x && x.yField; });\n        }\n        var xField = fields[0];\n        if (isBubbleChart) {\n            return fields\n                .map(function (yField, i) { return i % 2 === 1 ? ({\n                xField: xField,\n                yField: yField,\n                sizeField: fields[i + 1],\n            }) : null; })\n                .filter(function (x) { return x && x.sizeField; });\n        }\n        return fields.filter(function (value, i) { return i > 0; }).map(function (yField) { return ({ xField: xField, yField: yField }); });\n    };\n    ScatterChartProxy.prototype.getCrossFilteringDataDomain = function (seriesDefinitions, params) {\n        var domain;\n        if (seriesDefinitions[0] && seriesDefinitions[0].sizeField) {\n            var sizeColId_1 = seriesDefinitions[0].sizeField.colId;\n            var allSizePoints_1 = [];\n            params.data.forEach(function (d) {\n                if (typeof d[sizeColId_1] !== 'undefined') {\n                    allSizePoints_1.push(d[sizeColId_1]);\n                }\n                if (typeof d[sizeColId_1 + '-filtered-out'] !== 'undefined') {\n                    allSizePoints_1.push(d[sizeColId_1 + '-filtered-out']);\n                }\n            });\n            if (allSizePoints_1.length > 0) {\n                domain = [Math.min.apply(Math, allSizePoints_1), Math.max.apply(Math, allSizePoints_1)];\n            }\n        }\n        return domain;\n    };\n    return ScatterChartProxy;\n}(CartesianChartProxy));\n\nvar __extends$1P = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MarkersPanel = /** @class */ (function (_super) {\n    __extends$1P(MarkersPanel, _super);\n    function MarkersPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    MarkersPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(MarkersPanel.TEMPLATE, { seriesMarkersGroup: groupParams });\n        this.initMarkers();\n    };\n    MarkersPanel.prototype.initMarkers = function () {\n        var _this = this;\n        // scatter charts should always show markers\n        var shouldHideEnabledCheckbox = this.chartController.getChartProxy() instanceof ScatterChartProxy;\n        var seriesMarkerShapeOptions = [\n            {\n                value: 'square',\n                text: 'Square'\n            },\n            {\n                value: 'circle',\n                text: 'Circle'\n            },\n            {\n                value: 'cross',\n                text: 'Cross'\n            },\n            {\n                value: 'diamond',\n                text: 'Diamond'\n            },\n            {\n                value: 'plus',\n                text: 'Plus'\n            },\n            {\n                value: 'triangle',\n                text: 'Triangle'\n            },\n            {\n                value: 'heart',\n                text: 'Heart'\n            }\n        ];\n        this.seriesMarkerShapeSelect\n            .addOptions(seriesMarkerShapeOptions)\n            .setLabel(this.chartTranslator.translate('shape'))\n            .setValue(this.chartController.getChartProxy().getSeriesOption(\"marker.shape\"))\n            .onValueChange(function (value) { return _this.chartController.getChartProxy().setSeriesOption(\"marker.shape\", value); });\n        this.seriesMarkersGroup\n            .setTitle(this.chartTranslator.translate(\"markers\"))\n            .hideEnabledCheckbox(shouldHideEnabledCheckbox)\n            .setEnabled(this.chartController.getChartProxy().getSeriesOption(\"marker.enabled\") || false)\n            .hideOpenCloseIcons(true)\n            .onEnableChange(function (newValue) { return _this.chartController.getChartProxy().setSeriesOption(\"marker.enabled\", newValue); });\n        var initInput = function (expression, input, labelKey, maxValue) {\n            input.setLabel(_this.chartTranslator.translate(labelKey))\n                .setValue(_this.chartController.getChartProxy().getSeriesOption(expression))\n                .setMaxValue(maxValue)\n                .setTextFieldWidth(45)\n                .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setSeriesOption(expression, newValue); });\n        };\n        if (this.chartController.getChartType() === agGridCommunity.ChartType.Bubble) {\n            initInput(\"marker.maxSize\", this.seriesMarkerMinSizeSlider, \"maxSize\", 60);\n            initInput(\"marker.size\", this.seriesMarkerSizeSlider, \"minSize\", 60);\n        }\n        else {\n            this.seriesMarkerMinSizeSlider.setDisplayed(false);\n            initInput(\"marker.size\", this.seriesMarkerSizeSlider, \"size\", 60);\n        }\n        initInput(\"marker.strokeWidth\", this.seriesMarkerStrokeWidthSlider, \"strokeWidth\", 10);\n    };\n    MarkersPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesMarkersGroup\\\">\\n                <ag-select ref=\\\"seriesMarkerShapeSelect\\\"></ag-select>\\n                <ag-slider ref=\\\"seriesMarkerMinSizeSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesMarkerSizeSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesMarkerStrokeWidthSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$12([\n        agGridCommunity.RefSelector('seriesMarkersGroup')\n    ], MarkersPanel.prototype, \"seriesMarkersGroup\", void 0);\n    __decorate$12([\n        agGridCommunity.RefSelector('seriesMarkerShapeSelect')\n    ], MarkersPanel.prototype, \"seriesMarkerShapeSelect\", void 0);\n    __decorate$12([\n        agGridCommunity.RefSelector('seriesMarkerSizeSlider')\n    ], MarkersPanel.prototype, \"seriesMarkerSizeSlider\", void 0);\n    __decorate$12([\n        agGridCommunity.RefSelector('seriesMarkerMinSizeSlider')\n    ], MarkersPanel.prototype, \"seriesMarkerMinSizeSlider\", void 0);\n    __decorate$12([\n        agGridCommunity.RefSelector('seriesMarkerStrokeWidthSlider')\n    ], MarkersPanel.prototype, \"seriesMarkerStrokeWidthSlider\", void 0);\n    __decorate$12([\n        agGridCommunity.Autowired('chartTranslator')\n    ], MarkersPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$12([\n        agGridCommunity.PostConstruct\n    ], MarkersPanel.prototype, \"init\", null);\n    return MarkersPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1Q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar LineSeriesPanel = /** @class */ (function (_super) {\n    __extends$1Q(LineSeriesPanel, _super);\n    function LineSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    LineSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(LineSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.initSeriesGroup();\n        this.initSeriesTooltips();\n        this.initSeriesLineWidth();\n        this.initSeriesLineDash();\n        this.initMarkersPanel();\n    };\n    LineSeriesPanel.prototype.initSeriesGroup = function () {\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n    };\n    LineSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    LineSeriesPanel.prototype.initSeriesLineWidth = function () {\n        var _this = this;\n        this.seriesLineWidthSlider\n            .setLabel(this.chartTranslator.translate('lineWidth'))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.width\", newValue); });\n    };\n    LineSeriesPanel.prototype.initSeriesLineDash = function () {\n        var _this = this;\n        this.seriesLineDashSlider\n            .setLabel(this.chartTranslator.translate('lineDash'))\n            .setMaxValue(30)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"lineDash\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"lineDash\", [newValue]); });\n    };\n    LineSeriesPanel.prototype.initMarkersPanel = function () {\n        var markersPanelComp = this.createBean(new MarkersPanel(this.chartController));\n        this.seriesGroup.addItem(markersPanelComp);\n        this.activePanels.push(markersPanelComp);\n    };\n    LineSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    LineSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    LineSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    LineSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n                <ag-slider ref=\\\"seriesLineWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineDashSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$13([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], LineSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$13([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], LineSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$13([\n        agGridCommunity.RefSelector('seriesLineWidthSlider')\n    ], LineSeriesPanel.prototype, \"seriesLineWidthSlider\", void 0);\n    __decorate$13([\n        agGridCommunity.RefSelector('seriesLineDashSlider')\n    ], LineSeriesPanel.prototype, \"seriesLineDashSlider\", void 0);\n    __decorate$13([\n        agGridCommunity.Autowired('chartTranslator')\n    ], LineSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$13([\n        agGridCommunity.PostConstruct\n    ], LineSeriesPanel.prototype, \"init\", null);\n    return LineSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1R = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar CalloutPanel = /** @class */ (function (_super) {\n    __extends$1R(CalloutPanel, _super);\n    function CalloutPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    CalloutPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(CalloutPanel.TEMPLATE, { calloutGroup: groupParams });\n        this.initCalloutOptions();\n    };\n    CalloutPanel.prototype.initCalloutOptions = function () {\n        var _this = this;\n        this.calloutGroup\n            .setTitle(this.chartTranslator.translate(\"callout\"))\n            .setEnabled(true)\n            .hideOpenCloseIcons(true)\n            .hideEnabledCheckbox(true);\n        var initInput = function (expression, input, labelKey, maxValue) {\n            input.setLabel(_this.chartTranslator.translate(labelKey))\n                .setValue(_this.chartController.getChartProxy().getSeriesOption(expression))\n                .setMaxValue(maxValue)\n                .setTextFieldWidth(45)\n                .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setSeriesOption(expression, newValue); });\n        };\n        initInput(\"callout.length\", this.calloutLengthSlider, \"length\", 40);\n        initInput(\"callout.strokeWidth\", this.calloutStrokeWidthSlider, \"strokeWidth\", 10);\n        initInput(\"label.offset\", this.labelOffsetSlider, \"offset\", 30);\n    };\n    CalloutPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"calloutGroup\\\">\\n                <ag-slider ref=\\\"calloutLengthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"calloutStrokeWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"labelOffsetSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$14([\n        agGridCommunity.RefSelector('calloutGroup')\n    ], CalloutPanel.prototype, \"calloutGroup\", void 0);\n    __decorate$14([\n        agGridCommunity.RefSelector('calloutLengthSlider')\n    ], CalloutPanel.prototype, \"calloutLengthSlider\", void 0);\n    __decorate$14([\n        agGridCommunity.RefSelector('calloutStrokeWidthSlider')\n    ], CalloutPanel.prototype, \"calloutStrokeWidthSlider\", void 0);\n    __decorate$14([\n        agGridCommunity.RefSelector('labelOffsetSlider')\n    ], CalloutPanel.prototype, \"labelOffsetSlider\", void 0);\n    __decorate$14([\n        agGridCommunity.Autowired('chartTranslator')\n    ], CalloutPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$14([\n        agGridCommunity.PostConstruct\n    ], CalloutPanel.prototype, \"init\", null);\n    return CalloutPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1S = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PieSeriesPanel = /** @class */ (function (_super) {\n    __extends$1S(PieSeriesPanel, _super);\n    function PieSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    PieSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(PieSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.initGroup();\n        this.initSeriesTooltips();\n        this.initSeriesStrokeWidth();\n        this.initOpacity();\n        this.initLabelPanel();\n        this.initShadowPanel();\n    };\n    PieSeriesPanel.prototype.initGroup = function () {\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n    };\n    PieSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    PieSeriesPanel.prototype.initSeriesStrokeWidth = function () {\n        var _this = this;\n        this.seriesStrokeWidthSlider\n            .setLabel(this.chartTranslator.translate(\"strokeWidth\"))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.width\", newValue); });\n    };\n    PieSeriesPanel.prototype.initOpacity = function () {\n        var _this = this;\n        this.seriesLineOpacitySlider\n            .setLabel(this.chartTranslator.translate(\"strokeOpacity\"))\n            .setStep(0.05)\n            .setMaxValue(1)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.opacity\") || \"1\")\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.opacity\", newValue); });\n        this.seriesFillOpacitySlider\n            .setLabel(this.chartTranslator.translate(\"fillOpacity\"))\n            .setStep(0.05)\n            .setMaxValue(1)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"fillOpacity\") || \"1\")\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"fillOpacity\", newValue); });\n    };\n    PieSeriesPanel.prototype.initLabelPanel = function () {\n        var _this = this;\n        var chartProxy = this.getChartProxy();\n        var initialFont = {\n            family: chartProxy.getSeriesOption(\"label.fontFamily\"),\n            style: chartProxy.getSeriesOption(\"label.fontStyle\"),\n            weight: chartProxy.getSeriesOption(\"label.fontWeight\"),\n            size: chartProxy.getSeriesOption(\"label.fontSize\"),\n            color: chartProxy.getSeriesOption(\"label.color\")\n        };\n        var setFont = function (font) {\n            var proxy = _this.getChartProxy();\n            if (font.family) {\n                proxy.setSeriesOption(\"label.fontFamily\", font.family);\n            }\n            if (font.weight) {\n                proxy.setSeriesOption(\"label.fontWeight\", font.weight);\n            }\n            if (font.style) {\n                proxy.setSeriesOption(\"label.fontStyle\", font.style);\n            }\n            if (font.size) {\n                proxy.setSeriesOption(\"label.fontSize\", font.size);\n            }\n            if (font.color) {\n                proxy.setSeriesOption(\"label.color\", font.color);\n            }\n        };\n        var params = {\n            name: this.chartTranslator.translate('labels'),\n            enabled: chartProxy.getSeriesOption(\"label.enabled\") || false,\n            setEnabled: function (enabled) { return _this.getChartProxy().setSeriesOption(\"label.enabled\", enabled); },\n            suppressEnabledCheckbox: false,\n            initialFont: initialFont,\n            setFont: setFont\n        };\n        var labelPanelComp = this.createBean(new FontPanel(params));\n        this.activePanels.push(labelPanelComp);\n        var calloutPanelComp = this.createBean(new CalloutPanel(this.chartController));\n        labelPanelComp.addCompToPanel(calloutPanelComp);\n        this.activePanels.push(calloutPanelComp);\n        this.seriesGroup.addItem(labelPanelComp);\n    };\n    PieSeriesPanel.prototype.initShadowPanel = function () {\n        var shadowPanelComp = this.createBean(new ShadowPanel(this.chartController));\n        this.seriesGroup.getGui().appendChild(shadowPanelComp.getGui());\n        this.seriesGroup.addItem(shadowPanelComp);\n    };\n    PieSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    PieSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    PieSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    PieSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n                <ag-slider ref=\\\"seriesStrokeWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineOpacitySlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesFillOpacitySlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$15([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], PieSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$15([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], PieSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$15([\n        agGridCommunity.RefSelector('seriesStrokeWidthSlider')\n    ], PieSeriesPanel.prototype, \"seriesStrokeWidthSlider\", void 0);\n    __decorate$15([\n        agGridCommunity.RefSelector('seriesLineOpacitySlider')\n    ], PieSeriesPanel.prototype, \"seriesLineOpacitySlider\", void 0);\n    __decorate$15([\n        agGridCommunity.RefSelector('seriesFillOpacitySlider')\n    ], PieSeriesPanel.prototype, \"seriesFillOpacitySlider\", void 0);\n    __decorate$15([\n        agGridCommunity.Autowired('chartTranslator')\n    ], PieSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$15([\n        agGridCommunity.PostConstruct\n    ], PieSeriesPanel.prototype, \"init\", null);\n    return PieSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1T = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar PaddingPanel = /** @class */ (function (_super) {\n    __extends$1T(PaddingPanel, _super);\n    function PaddingPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    PaddingPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical',\n            suppressOpenCloseIcons: true\n        };\n        this.setTemplate(PaddingPanel.TEMPLATE, { chartPaddingGroup: groupParams });\n        this.initGroup();\n        this.initChartPaddingItems();\n    };\n    PaddingPanel.prototype.initGroup = function () {\n        this.chartPaddingGroup\n            .setTitle(this.chartTranslator.translate(\"padding\"))\n            .hideOpenCloseIcons(true)\n            .hideEnabledCheckbox(true);\n    };\n    PaddingPanel.prototype.initChartPaddingItems = function () {\n        var _this = this;\n        var initInput = function (property, input) {\n            input.setLabel(_this.chartTranslator.translate(property))\n                .setValue(_this.chartController.getChartProxy().getChartPaddingOption(property))\n                .setMaxValue(200)\n                .setTextFieldWidth(45)\n                .onValueChange(function (newValue) { return _this.chartController.getChartProxy().setChartPaddingOption(property, newValue); });\n        };\n        initInput('top', this.paddingTopSlider);\n        initInput('right', this.paddingRightSlider);\n        initInput('bottom', this.paddingBottomSlider);\n        initInput('left', this.paddingLeftSlider);\n    };\n    PaddingPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"chartPaddingGroup\\\">\\n                <ag-slider ref=\\\"paddingTopSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"paddingRightSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"paddingBottomSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"paddingLeftSlider\\\"></ag-slider>\\n            </ag-group-component>\\n        <div>\";\n    __decorate$16([\n        agGridCommunity.RefSelector('chartPaddingGroup')\n    ], PaddingPanel.prototype, \"chartPaddingGroup\", void 0);\n    __decorate$16([\n        agGridCommunity.RefSelector('paddingTopSlider')\n    ], PaddingPanel.prototype, \"paddingTopSlider\", void 0);\n    __decorate$16([\n        agGridCommunity.RefSelector('paddingRightSlider')\n    ], PaddingPanel.prototype, \"paddingRightSlider\", void 0);\n    __decorate$16([\n        agGridCommunity.RefSelector('paddingBottomSlider')\n    ], PaddingPanel.prototype, \"paddingBottomSlider\", void 0);\n    __decorate$16([\n        agGridCommunity.RefSelector('paddingLeftSlider')\n    ], PaddingPanel.prototype, \"paddingLeftSlider\", void 0);\n    __decorate$16([\n        agGridCommunity.Autowired('chartTranslator')\n    ], PaddingPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$16([\n        agGridCommunity.PostConstruct\n    ], PaddingPanel.prototype, \"init\", null);\n    return PaddingPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1U = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar BackgroundPanel = /** @class */ (function (_super) {\n    __extends$1U(BackgroundPanel, _super);\n    function BackgroundPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.chartController = chartController;\n        return _this;\n    }\n    BackgroundPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-sub-level',\n            direction: 'vertical',\n            suppressOpenCloseIcons: true\n        };\n        this.setTemplate(BackgroundPanel.TEMPLATE, { chartBackgroundGroup: groupParams });\n        this.initGroup();\n        this.initColorPicker();\n    };\n    BackgroundPanel.prototype.initGroup = function () {\n        var _this = this;\n        this.group\n            .setTitle(this.chartTranslator.translate('background'))\n            .setEnabled(this.chartController.getChartProxy().getChartOption('background.visible'))\n            .hideOpenCloseIcons(true)\n            .hideEnabledCheckbox(false)\n            .onEnableChange(function (enabled) { return _this.chartController.getChartProxy().setChartOption('background.visible', enabled); });\n    };\n    BackgroundPanel.prototype.initColorPicker = function () {\n        var _this = this;\n        this.colorPicker\n            .setLabel(this.chartTranslator.translate('color'))\n            .setLabelWidth('flex')\n            .setInputWidth(45)\n            .setValue(this.chartController.getChartProxy().getChartOption('background.fill'))\n            .onValueChange(function (newColor) { return _this.chartController.getChartProxy().setChartOption('background.fill', newColor); });\n    };\n    BackgroundPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"chartBackgroundGroup\\\">\\n                <ag-color-picker ref=\\\"colorPicker\\\"></ag-color-picker>\\n            </ag-group-component>\\n        <div>\";\n    __decorate$17([\n        agGridCommunity.RefSelector('chartBackgroundGroup')\n    ], BackgroundPanel.prototype, \"group\", void 0);\n    __decorate$17([\n        agGridCommunity.RefSelector('colorPicker')\n    ], BackgroundPanel.prototype, \"colorPicker\", void 0);\n    __decorate$17([\n        agGridCommunity.Autowired('chartTranslator')\n    ], BackgroundPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$17([\n        agGridCommunity.PostConstruct\n    ], BackgroundPanel.prototype, \"init\", null);\n    return BackgroundPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1V = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TitlePanel = /** @class */ (function (_super) {\n    __extends$1V(TitlePanel, _super);\n    function TitlePanel(chartController) {\n        var _this = _super.call(this, TitlePanel.TEMPLATE) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    TitlePanel.prototype.init = function () {\n        this.initFontPanel();\n    };\n    TitlePanel.prototype.hasTitle = function () {\n        var chartProxy = this.chartController.getChartProxy();\n        var title = chartProxy.getChartOption('title');\n        return title && title.enabled && title.text && title.text.length > 0;\n    };\n    TitlePanel.prototype.initFontPanel = function () {\n        var _this = this;\n        var chartProxy = this.chartController.getChartProxy();\n        var hasTitle = this.hasTitle;\n        var setFont = function (font) {\n            var proxy = _this.chartController.getChartProxy();\n            if (font.family) {\n                proxy.setTitleOption('fontFamily', font.family);\n            }\n            if (font.weight) {\n                proxy.setTitleOption('fontWeight', font.weight);\n            }\n            if (font.style) {\n                proxy.setTitleOption('fontStyle', font.style);\n            }\n            if (font.size) {\n                proxy.setTitleOption('fontSize', font.size);\n            }\n            if (font.color) {\n                proxy.setTitleOption('color', font.color);\n            }\n        };\n        var initialFont = {\n            family: chartProxy.getChartOption('title.fontFamily'),\n            style: chartProxy.getChartOption('title.fontStyle'),\n            weight: chartProxy.getChartOption('title.fontWeight'),\n            size: chartProxy.getChartOption('title.fontSize'),\n            color: chartProxy.getChartOption('title.color')\n        };\n        if (!hasTitle) {\n            setFont(initialFont);\n        }\n        var fontPanelParams = {\n            name: this.chartTranslator.translate('title'),\n            enabled: this.hasTitle(),\n            suppressEnabledCheckbox: false,\n            initialFont: initialFont,\n            setFont: setFont,\n            setEnabled: function (enabled) {\n                var proxy = _this.chartController.getChartProxy();\n                if (enabled) {\n                    var newTitle = _this.disabledTitle || _this.chartTranslator.translate('titlePlaceholder');\n                    proxy.setTitleOption('text', newTitle);\n                    _this.disabledTitle = '';\n                }\n                else {\n                    _this.disabledTitle = proxy.getTitleOption('text');\n                    proxy.setTitleOption('text', '');\n                }\n            }\n        };\n        var fontPanelComp = this.createBean(new FontPanel(fontPanelParams));\n        this.getGui().appendChild(fontPanelComp.getGui());\n        this.activePanels.push(fontPanelComp);\n        // edits to the title can disable it, so keep the checkbox in sync:\n        this.addManagedListener(this.eventService, 'chartTitleEdit', function () {\n            fontPanelComp.setEnabled(_this.hasTitle());\n        });\n    };\n    TitlePanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    TitlePanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    TitlePanel.TEMPLATE = \"<div></div>\";\n    __decorate$18([\n        agGridCommunity.Autowired('chartTranslator')\n    ], TitlePanel.prototype, \"chartTranslator\", void 0);\n    __decorate$18([\n        agGridCommunity.PostConstruct\n    ], TitlePanel.prototype, \"init\", null);\n    return TitlePanel;\n}(agGridCommunity.Component));\n\nvar __extends$1W = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartPanel = /** @class */ (function (_super) {\n    __extends$1W(ChartPanel, _super);\n    function ChartPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    ChartPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(ChartPanel.TEMPLATE, { chartGroup: groupParams });\n        this.initGroup();\n        this.initTitles();\n        this.initPaddingPanel();\n        this.initBackgroundPanel();\n    };\n    ChartPanel.prototype.initGroup = function () {\n        this.chartGroup\n            .setTitle(this.chartTranslator.translate('chart'))\n            .toggleGroupExpand(true)\n            .hideEnabledCheckbox(true);\n    };\n    ChartPanel.prototype.initTitles = function () {\n        var titlePanelComp = this.createBean(new TitlePanel(this.chartController));\n        this.chartGroup.addItem(titlePanelComp);\n        this.activePanels.push(titlePanelComp);\n    };\n    ChartPanel.prototype.initPaddingPanel = function () {\n        var paddingPanelComp = this.createBean(new PaddingPanel(this.chartController));\n        this.chartGroup.addItem(paddingPanelComp);\n        this.activePanels.push(paddingPanelComp);\n    };\n    ChartPanel.prototype.initBackgroundPanel = function () {\n        var backgroundPanelComp = this.createBean(new BackgroundPanel(this.chartController));\n        this.chartGroup.addItem(backgroundPanelComp);\n        this.activePanels.push(backgroundPanelComp);\n    };\n    ChartPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    ChartPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    ChartPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"chartGroup\\\"></ag-group-component>\\n        </div>\";\n    __decorate$19([\n        agGridCommunity.RefSelector('chartGroup')\n    ], ChartPanel.prototype, \"chartGroup\", void 0);\n    __decorate$19([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ChartPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$19([\n        agGridCommunity.PostConstruct\n    ], ChartPanel.prototype, \"init\", null);\n    return ChartPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1X = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AreaSeriesPanel = /** @class */ (function (_super) {\n    __extends$1X(AreaSeriesPanel, _super);\n    function AreaSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    AreaSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(AreaSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.initSeriesGroup();\n        this.initSeriesTooltips();\n        this.initSeriesLineWidth();\n        this.initSeriesLineDash();\n        this.initOpacity();\n        this.initMarkersPanel();\n        this.initShadowPanel();\n    };\n    AreaSeriesPanel.prototype.initSeriesGroup = function () {\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n    };\n    AreaSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    AreaSeriesPanel.prototype.initSeriesLineWidth = function () {\n        var _this = this;\n        this.seriesLineWidthSlider\n            .setLabel(this.chartTranslator.translate(\"lineWidth\"))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.width\", newValue); });\n    };\n    AreaSeriesPanel.prototype.initSeriesLineDash = function () {\n        var _this = this;\n        this.seriesLineDashSlider\n            .setLabel(this.chartTranslator.translate('lineDash'))\n            .setMaxValue(30)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"lineDash\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"lineDash\", [newValue]); });\n    };\n    AreaSeriesPanel.prototype.initOpacity = function () {\n        initLineOpacitySlider(this.seriesLineOpacitySlider, this.chartTranslator, this.getChartProxy());\n        initFillOpacitySlider(this.seriesFillOpacitySlider, this.chartTranslator, this.getChartProxy());\n    };\n    AreaSeriesPanel.prototype.initMarkersPanel = function () {\n        var markersPanelComp = this.createBean(new MarkersPanel(this.chartController));\n        this.seriesGroup.addItem(markersPanelComp);\n        this.activePanels.push(markersPanelComp);\n    };\n    AreaSeriesPanel.prototype.initShadowPanel = function () {\n        var shadowPanelComp = this.createBean(new ShadowPanel(this.chartController));\n        this.seriesGroup.addItem(shadowPanelComp);\n        this.activePanels.push(shadowPanelComp);\n    };\n    AreaSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    AreaSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    AreaSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    AreaSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n                <ag-slider ref=\\\"seriesLineWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineDashSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineOpacitySlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesFillOpacitySlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], AreaSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], AreaSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesLineWidthSlider')\n    ], AreaSeriesPanel.prototype, \"seriesLineWidthSlider\", void 0);\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesLineDashSlider')\n    ], AreaSeriesPanel.prototype, \"seriesLineDashSlider\", void 0);\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesLineOpacitySlider')\n    ], AreaSeriesPanel.prototype, \"seriesLineOpacitySlider\", void 0);\n    __decorate$1a([\n        agGridCommunity.RefSelector('seriesFillOpacitySlider')\n    ], AreaSeriesPanel.prototype, \"seriesFillOpacitySlider\", void 0);\n    __decorate$1a([\n        agGridCommunity.Autowired('chartTranslator')\n    ], AreaSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$1a([\n        agGridCommunity.PostConstruct\n    ], AreaSeriesPanel.prototype, \"init\", null);\n    return AreaSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1Y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ScatterSeriesPanel = /** @class */ (function (_super) {\n    __extends$1Y(ScatterSeriesPanel, _super);\n    function ScatterSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    ScatterSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(ScatterSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.initSeriesGroup();\n        this.initSeriesTooltips();\n        this.initMarkersPanel();\n    };\n    ScatterSeriesPanel.prototype.initSeriesGroup = function () {\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n    };\n    ScatterSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    ScatterSeriesPanel.prototype.initMarkersPanel = function () {\n        var markersPanelComp = this.createBean(new MarkersPanel(this.chartController));\n        this.seriesGroup.addItem(markersPanelComp);\n        this.activePanels.push(markersPanelComp);\n    };\n    ScatterSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    ScatterSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    ScatterSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    ScatterSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$1b([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], ScatterSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$1b([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], ScatterSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$1b([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ScatterSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$1b([\n        agGridCommunity.PostConstruct\n    ], ScatterSeriesPanel.prototype, \"init\", null);\n    return ScatterSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1Z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar HistogramSeriesPanel = /** @class */ (function (_super) {\n    __extends$1Z(HistogramSeriesPanel, _super);\n    function HistogramSeriesPanel(chartController) {\n        var _this = _super.call(this) || this;\n        _this.activePanels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    HistogramSeriesPanel.prototype.init = function () {\n        var groupParams = {\n            cssIdentifier: 'charts-format-top-level',\n            direction: 'vertical'\n        };\n        this.setTemplate(HistogramSeriesPanel.TEMPLATE, { seriesGroup: groupParams });\n        this.seriesGroup\n            .setTitle(this.chartTranslator.translate(\"series\"))\n            .toggleGroupExpand(false)\n            .hideEnabledCheckbox(true);\n        this.initSeriesTooltips();\n        this.initSeriesStrokeWidth();\n        this.initSeriesLineDash();\n        this.initOpacity();\n        this.initLabelPanel();\n        this.initShadowPanel();\n        this.initBins();\n    };\n    HistogramSeriesPanel.prototype.initSeriesTooltips = function () {\n        var _this = this;\n        this.seriesTooltipsToggle\n            .setLabel(this.chartTranslator.translate(\"tooltips\"))\n            .setLabelAlignment(\"left\")\n            .setLabelWidth(\"flex\")\n            .setInputWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"tooltip.enabled\") || false)\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"tooltip.enabled\", newValue); });\n    };\n    HistogramSeriesPanel.prototype.initSeriesStrokeWidth = function () {\n        var _this = this;\n        this.seriesStrokeWidthSlider\n            .setLabel(this.chartTranslator.translate(\"strokeWidth\"))\n            .setMaxValue(10)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"stroke.width\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"stroke.width\", newValue); });\n    };\n    HistogramSeriesPanel.prototype.initSeriesLineDash = function () {\n        var _this = this;\n        this.seriesLineDashSlider\n            .setLabel(this.chartTranslator.translate('lineDash'))\n            .setMaxValue(30)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"lineDash\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"lineDash\", [newValue]); });\n    };\n    HistogramSeriesPanel.prototype.initOpacity = function () {\n        initLineOpacitySlider(this.seriesLineOpacitySlider, this.chartTranslator, this.getChartProxy());\n        initFillOpacitySlider(this.seriesFillOpacitySlider, this.chartTranslator, this.getChartProxy());\n    };\n    HistogramSeriesPanel.prototype.initBins = function () {\n        var _this = this;\n        this.seriesBinCountSlider\n            .setLabel(this.chartTranslator.translate(\"histogramBinCount\"))\n            .setMinValue(4)\n            .setMaxValue(100)\n            .setTextFieldWidth(45)\n            .setValue(this.getChartProxy().getSeriesOption(\"binCount\"))\n            .onValueChange(function (newValue) { return _this.getChartProxy().setSeriesOption(\"binCount\", newValue); });\n    };\n    HistogramSeriesPanel.prototype.initLabelPanel = function () {\n        var params = initFontPanelParams(this.chartTranslator, this.getChartProxy());\n        var labelPanelComp = this.createBean(new FontPanel(params));\n        this.activePanels.push(labelPanelComp);\n        this.seriesGroup.addItem(labelPanelComp);\n    };\n    HistogramSeriesPanel.prototype.initShadowPanel = function () {\n        var shadowPanelComp = this.createBean(new ShadowPanel(this.chartController));\n        this.seriesGroup.addItem(shadowPanelComp);\n        this.activePanels.push(shadowPanelComp);\n    };\n    HistogramSeriesPanel.prototype.destroyActivePanels = function () {\n        var _this = this;\n        this.activePanels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    HistogramSeriesPanel.prototype.getChartProxy = function () {\n        return this.chartController.getChartProxy();\n    };\n    HistogramSeriesPanel.prototype.destroy = function () {\n        this.destroyActivePanels();\n        _super.prototype.destroy.call(this);\n    };\n    HistogramSeriesPanel.TEMPLATE = \"<div>\\n            <ag-group-component ref=\\\"seriesGroup\\\">\\n                <ag-toggle-button ref=\\\"seriesTooltipsToggle\\\"></ag-toggle-button>\\n                <ag-slider ref=\\\"binCountSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesStrokeWidthSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineDashSlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesLineOpacitySlider\\\"></ag-slider>\\n                <ag-slider ref=\\\"seriesFillOpacitySlider\\\"></ag-slider>\\n            </ag-group-component>\\n        </div>\";\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesGroup')\n    ], HistogramSeriesPanel.prototype, \"seriesGroup\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesTooltipsToggle')\n    ], HistogramSeriesPanel.prototype, \"seriesTooltipsToggle\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('binCountSlider')\n    ], HistogramSeriesPanel.prototype, \"seriesBinCountSlider\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesStrokeWidthSlider')\n    ], HistogramSeriesPanel.prototype, \"seriesStrokeWidthSlider\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesLineOpacitySlider')\n    ], HistogramSeriesPanel.prototype, \"seriesLineOpacitySlider\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesLineDashSlider')\n    ], HistogramSeriesPanel.prototype, \"seriesLineDashSlider\", void 0);\n    __decorate$1c([\n        agGridCommunity.RefSelector('seriesFillOpacitySlider')\n    ], HistogramSeriesPanel.prototype, \"seriesFillOpacitySlider\", void 0);\n    __decorate$1c([\n        agGridCommunity.Autowired('chartTranslator')\n    ], HistogramSeriesPanel.prototype, \"chartTranslator\", void 0);\n    __decorate$1c([\n        agGridCommunity.PostConstruct\n    ], HistogramSeriesPanel.prototype, \"init\", null);\n    return HistogramSeriesPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1_ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartFormattingPanel = /** @class */ (function (_super) {\n    __extends$1_(ChartFormattingPanel, _super);\n    function ChartFormattingPanel(chartController) {\n        var _this = _super.call(this, ChartFormattingPanel.TEMPLATE) || this;\n        _this.panels = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    ChartFormattingPanel.prototype.init = function () {\n        this.createPanels();\n        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, this.createPanels.bind(this));\n    };\n    ChartFormattingPanel.prototype.createPanels = function () {\n        var chartType = this.chartController.getChartType();\n        var isGrouping = this.chartController.isGrouping();\n        if (chartType === this.chartType && isGrouping === this.isGrouping) {\n            // existing panels can be re-used\n            return;\n        }\n        this.destroyPanels();\n        this.addComponent(new ChartPanel(this.chartController));\n        this.addComponent(new LegendPanel(this.chartController));\n        switch (chartType) {\n            case agGridCommunity.ChartType.GroupedColumn:\n            case agGridCommunity.ChartType.StackedColumn:\n            case agGridCommunity.ChartType.NormalizedColumn:\n            case agGridCommunity.ChartType.GroupedBar:\n            case agGridCommunity.ChartType.StackedBar:\n            case agGridCommunity.ChartType.NormalizedBar:\n                this.addComponent(new AxisPanel(this.chartController));\n                this.addComponent(new NavigatorPanel(this.chartController));\n                this.addComponent(new BarSeriesPanel(this.chartController));\n                break;\n            case agGridCommunity.ChartType.Pie:\n            case agGridCommunity.ChartType.Doughnut:\n                this.addComponent(new PieSeriesPanel(this.chartController));\n                break;\n            case agGridCommunity.ChartType.Line:\n                this.addComponent(new AxisPanel(this.chartController));\n                this.addComponent(new NavigatorPanel(this.chartController));\n                this.addComponent(new LineSeriesPanel(this.chartController));\n                break;\n            case agGridCommunity.ChartType.Scatter:\n            case agGridCommunity.ChartType.Bubble:\n                this.addComponent(new AxisPanel(this.chartController));\n                this.addComponent(new NavigatorPanel(this.chartController));\n                this.addComponent(new ScatterSeriesPanel(this.chartController));\n                break;\n            case agGridCommunity.ChartType.Area:\n            case agGridCommunity.ChartType.StackedArea:\n            case agGridCommunity.ChartType.NormalizedArea:\n                this.addComponent(new AxisPanel(this.chartController));\n                this.addComponent(new NavigatorPanel(this.chartController));\n                this.addComponent(new AreaSeriesPanel(this.chartController));\n                break;\n            case agGridCommunity.ChartType.Histogram:\n                this.addComponent(new AxisPanel(this.chartController));\n                this.addComponent(new NavigatorPanel(this.chartController));\n                this.addComponent(new HistogramSeriesPanel(this.chartController));\n                break;\n            default:\n                console.warn(\"AG Grid: ChartFormattingPanel - unexpected chart type index: \" + chartType + \" supplied\");\n        }\n        this.chartType = chartType;\n        this.isGrouping = isGrouping;\n    };\n    ChartFormattingPanel.prototype.addComponent = function (component) {\n        this.createBean(component);\n        this.panels.push(component);\n        agGridCommunity._.addCssClass(component.getGui(), 'ag-chart-format-section');\n        this.getGui().appendChild(component.getGui());\n    };\n    ChartFormattingPanel.prototype.destroyPanels = function () {\n        var _this = this;\n        this.panels.forEach(function (panel) {\n            agGridCommunity._.removeFromParent(panel.getGui());\n            _this.destroyBean(panel);\n        });\n    };\n    ChartFormattingPanel.prototype.destroy = function () {\n        this.destroyPanels();\n        _super.prototype.destroy.call(this);\n    };\n    ChartFormattingPanel.TEMPLATE = \"<div class=\\\"ag-chart-format-wrapper\\\"></div>\";\n    __decorate$1d([\n        agGridCommunity.PostConstruct\n    ], ChartFormattingPanel.prototype, \"init\", null);\n    return ChartFormattingPanel;\n}(agGridCommunity.Component));\n\nvar __extends$1$ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MiniChart = /** @class */ (function (_super) {\n    __extends$1$(MiniChart, _super);\n    function MiniChart(container, tooltipName) {\n        var _this = _super.call(this) || this;\n        _this.size = 58;\n        _this.padding = 5;\n        _this.root = new Group();\n        var scene = new Scene(window.document, _this.size, _this.size);\n        agGridCommunity._.addCssClass(scene.canvas.element, 'ag-chart-mini-thumbnail-canvas');\n        scene.root = _this.root;\n        scene.container = container;\n        _this.scene = scene;\n        _this.tooltipName = tooltipName;\n        return _this;\n    }\n    MiniChart.prototype.init = function () {\n        this.scene.canvas.element.title = this.chartTranslator.translate(this.tooltipName);\n    };\n    __decorate$1e([\n        agGridCommunity.Autowired('chartTranslator')\n    ], MiniChart.prototype, \"chartTranslator\", void 0);\n    __decorate$1e([\n        agGridCommunity.PostConstruct\n    ], MiniChart.prototype, \"init\", null);\n    return MiniChart;\n}(agGridCommunity.Component));\n\nvar __extends$20 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MiniChartWithAxes = /** @class */ (function (_super) {\n    __extends$20(MiniChartWithAxes, _super);\n    function MiniChartWithAxes(container, tooltipName) {\n        var _this = _super.call(this, container, tooltipName) || this;\n        _this.stroke = 'gray';\n        _this.axisOvershoot = 3;\n        return _this;\n    }\n    MiniChartWithAxes.prototype.addAxes = function () {\n        var size = this.size;\n        var padding = this.padding;\n        var leftAxis = new Line();\n        leftAxis.x1 = padding;\n        leftAxis.y1 = padding;\n        leftAxis.x2 = padding;\n        leftAxis.y2 = size - padding + this.axisOvershoot;\n        leftAxis.stroke = this.stroke;\n        var bottomAxis = new Line();\n        bottomAxis.x1 = padding - this.axisOvershoot + 1;\n        bottomAxis.y1 = size - padding;\n        bottomAxis.x2 = size - padding + 1;\n        bottomAxis.y2 = size - padding;\n        bottomAxis.stroke = this.stroke;\n        var root = this.root;\n        root.append(leftAxis);\n        root.append(bottomAxis);\n    };\n    __decorate$1f([\n        agGridCommunity.PostConstruct\n    ], MiniChartWithAxes.prototype, \"addAxes\", null);\n    return MiniChartWithAxes;\n}(MiniChart));\n\nvar __extends$21 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniColumn = /** @class */ (function (_super) {\n    __extends$21(MiniColumn, _super);\n    function MiniColumn(container, fills, strokes) {\n        var _this = _super.call(this, container, \"groupedColumnTooltip\") || this;\n        var padding = _this.padding;\n        var size = _this.size;\n        var data = [2, 3, 4];\n        var xScale = new BandScale();\n        xScale.domain = [0, 1, 2];\n        xScale.range = [padding, size - padding];\n        xScale.paddingInner = 0.3;\n        xScale.paddingOuter = 0.3;\n        var yScale = new LinearScale();\n        yScale.domain = [0, 4];\n        yScale.range = [size - padding, padding];\n        var bottom = yScale.convert(0);\n        var width = xScale.bandwidth;\n        _this.bars = data.map(function (datum, i) {\n            var top = yScale.convert(datum);\n            var rect = new Rect();\n            rect.x = xScale.convert(i);\n            rect.y = top;\n            rect.width = width;\n            rect.height = bottom - top;\n            rect.strokeWidth = 1;\n            rect.crisp = true;\n            return rect;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.bars);\n        return _this;\n    }\n    MiniColumn.prototype.updateColors = function (fills, strokes) {\n        this.bars.forEach(function (bar, i) {\n            bar.fill = fills[i];\n            bar.stroke = strokes[i];\n        });\n    };\n    MiniColumn.chartType = agGridCommunity.ChartType.GroupedColumn;\n    return MiniColumn;\n}(MiniChartWithAxes));\n\nvar __extends$22 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniStackedColumn = /** @class */ (function (_super) {\n    __extends$22(MiniStackedColumn, _super);\n    function MiniStackedColumn(container, fills, strokes, data, yScaleDomain, tooltipName) {\n        if (data === void 0) { data = MiniStackedColumn.data; }\n        if (yScaleDomain === void 0) { yScaleDomain = [0, 16]; }\n        if (tooltipName === void 0) { tooltipName = \"stackedColumnTooltip\"; }\n        var _this = _super.call(this, container, tooltipName) || this;\n        var padding = _this.padding;\n        var size = _this.size;\n        var xScale = new BandScale();\n        xScale.domain = [0, 1, 2];\n        xScale.range = [padding, size - padding];\n        xScale.paddingInner = 0.3;\n        xScale.paddingOuter = 0.3;\n        var yScale = new LinearScale();\n        yScale.domain = yScaleDomain;\n        yScale.range = [size - padding, padding];\n        var bottom = yScale.convert(0);\n        var width = xScale.bandwidth;\n        _this.bars = data.map(function (series) {\n            return series.map(function (datum, i) {\n                var top = yScale.convert(datum);\n                var rect = new Rect();\n                rect.x = xScale.convert(i);\n                rect.y = top;\n                rect.width = width;\n                rect.height = bottom - top;\n                rect.strokeWidth = 1;\n                rect.crisp = true;\n                return rect;\n            });\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append([].concat.apply([], _this.bars));\n        return _this;\n    }\n    MiniStackedColumn.prototype.updateColors = function (fills, strokes) {\n        this.bars.forEach(function (series, i) {\n            return series.forEach(function (bar) {\n                bar.fill = fills[i];\n                bar.stroke = strokes[i];\n            });\n        });\n    };\n    MiniStackedColumn.chartType = agGridCommunity.ChartType.StackedColumn;\n    MiniStackedColumn.data = [\n        [8, 12, 16],\n        [6, 9, 12],\n        [2, 3, 4]\n    ];\n    return MiniStackedColumn;\n}(MiniChartWithAxes));\n\nvar __extends$23 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniNormalizedColumn = /** @class */ (function (_super) {\n    __extends$23(MiniNormalizedColumn, _super);\n    function MiniNormalizedColumn(container, fills, strokes) {\n        return _super.call(this, container, fills, strokes, MiniNormalizedColumn.data, [0, 10], \"normalizedColumnTooltip\") || this;\n    }\n    MiniNormalizedColumn.chartType = agGridCommunity.ChartType.NormalizedColumn;\n    MiniNormalizedColumn.data = [\n        [10, 10, 10],\n        [6, 7, 8],\n        [2, 4, 6]\n    ];\n    return MiniNormalizedColumn;\n}(MiniStackedColumn));\n\nvar __extends$24 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniBar = /** @class */ (function (_super) {\n    __extends$24(MiniBar, _super);\n    function MiniBar(container, fills, strokes) {\n        var _this = _super.call(this, container, \"groupedBarTooltip\") || this;\n        var padding = _this.padding;\n        var size = _this.size;\n        var data = [2, 3, 4];\n        var yScale = new BandScale();\n        yScale.domain = [0, 1, 2];\n        yScale.range = [padding, size - padding];\n        yScale.paddingInner = 0.3;\n        yScale.paddingOuter = 0.3;\n        var xScale = new LinearScale();\n        xScale.domain = [0, 4];\n        xScale.range = [size - padding, padding];\n        var bottom = xScale.convert(0);\n        var height = yScale.bandwidth;\n        _this.bars = data.map(function (datum, i) {\n            var rect = new Rect();\n            rect.x = padding;\n            rect.y = yScale.convert(i);\n            rect.width = bottom - xScale.convert(datum);\n            rect.height = height;\n            rect.strokeWidth = 1;\n            rect.crisp = true;\n            return rect;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.bars);\n        return _this;\n    }\n    MiniBar.prototype.updateColors = function (fills, strokes) {\n        this.bars.forEach(function (bar, i) {\n            bar.fill = fills[i];\n            bar.stroke = strokes[i];\n        });\n    };\n    MiniBar.chartType = agGridCommunity.ChartType.GroupedBar;\n    return MiniBar;\n}(MiniChartWithAxes));\n\nvar __extends$25 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniStackedBar = /** @class */ (function (_super) {\n    __extends$25(MiniStackedBar, _super);\n    function MiniStackedBar(container, fills, strokes, data, xScaleDomain, tooltipName) {\n        if (data === void 0) { data = MiniStackedBar.data; }\n        if (xScaleDomain === void 0) { xScaleDomain = [0, 16]; }\n        if (tooltipName === void 0) { tooltipName = \"stackedBarTooltip\"; }\n        var _this = _super.call(this, container, tooltipName) || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        var yScale = new BandScale();\n        yScale.domain = [0, 1, 2];\n        yScale.range = [padding, size - padding];\n        yScale.paddingInner = 0.3;\n        yScale.paddingOuter = 0.3;\n        var xScale = new LinearScale();\n        xScale.domain = xScaleDomain;\n        xScale.range = [size - padding, padding];\n        var bottom = xScale.convert(0);\n        var height = yScale.bandwidth;\n        _this.bars = data.map(function (series) {\n            return series.map(function (datum, i) {\n                var rect = new Rect();\n                rect.x = padding;\n                rect.y = yScale.convert(i);\n                rect.width = bottom - xScale.convert(datum);\n                rect.height = height;\n                rect.strokeWidth = 1;\n                rect.crisp = true;\n                return rect;\n            });\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append([].concat.apply([], _this.bars));\n        return _this;\n    }\n    MiniStackedBar.prototype.updateColors = function (fills, strokes) {\n        this.bars.forEach(function (series, i) {\n            return series.forEach(function (bar) {\n                bar.fill = fills[i];\n                bar.stroke = strokes[i];\n            });\n        });\n    };\n    MiniStackedBar.chartType = agGridCommunity.ChartType.StackedBar;\n    MiniStackedBar.data = [\n        [8, 12, 16],\n        [6, 9, 12],\n        [2, 3, 4]\n    ];\n    return MiniStackedBar;\n}(MiniChartWithAxes));\n\nvar __extends$26 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniNormalizedBar = /** @class */ (function (_super) {\n    __extends$26(MiniNormalizedBar, _super);\n    function MiniNormalizedBar(container, fills, strokes) {\n        return _super.call(this, container, fills, strokes, MiniNormalizedBar.data, [0, 10], \"normalizedBarTooltip\") || this;\n    }\n    MiniNormalizedBar.chartType = agGridCommunity.ChartType.NormalizedBar;\n    MiniNormalizedBar.data = [\n        [10, 10, 10],\n        [6, 7, 8],\n        [2, 4, 6]\n    ];\n    return MiniNormalizedBar;\n}(MiniStackedBar));\n\nvar __extends$27 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniDoughnut = /** @class */ (function (_super) {\n    __extends$27(MiniDoughnut, _super);\n    function MiniDoughnut(container, fills, strokes, centerRadiusScaler, tooltipName) {\n        if (centerRadiusScaler === void 0) { centerRadiusScaler = 0.6; }\n        if (tooltipName === void 0) { tooltipName = \"doughnutTooltip\"; }\n        var _this = _super.call(this, container, tooltipName) || this;\n        var radius = (_this.size - _this.padding * 2) / 2;\n        var center = radius + _this.padding;\n        var angles = [\n            [toRadians(-90), toRadians(30)],\n            [toRadians(30), toRadians(120)],\n            [toRadians(120), toRadians(180)],\n            [toRadians(180), toRadians(210)],\n            [toRadians(210), toRadians(240)],\n            [toRadians(240), toRadians(270)]\n        ];\n        _this.sectors = angles.map(function (_a) {\n            var startAngle = _a[0], endAngle = _a[1];\n            var sector = new Sector();\n            sector.centerX = center;\n            sector.centerY = center;\n            sector.innerRadius = radius * centerRadiusScaler;\n            sector.outerRadius = radius;\n            sector.startAngle = startAngle;\n            sector.endAngle = endAngle;\n            sector.stroke = undefined;\n            sector.strokeWidth = 1;\n            return sector;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.sectors);\n        return _this;\n    }\n    MiniDoughnut.prototype.updateColors = function (fills, strokes) {\n        this.sectors.forEach(function (sector, i) {\n            sector.fill = fills[i % fills.length];\n            sector.stroke = strokes[i % strokes.length];\n        });\n    };\n    MiniDoughnut.chartType = agGridCommunity.ChartType.Doughnut;\n    return MiniDoughnut;\n}(MiniChart));\n\nvar __extends$28 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniPie = /** @class */ (function (_super) {\n    __extends$28(MiniPie, _super);\n    function MiniPie(container, fills, strokes) {\n        return _super.call(this, container, fills, strokes, 0, \"pieTooltip\") || this;\n    }\n    MiniPie.chartType = agGridCommunity.ChartType.Pie;\n    return MiniPie;\n}(MiniDoughnut));\n\nvar __extends$29 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniLine = /** @class */ (function (_super) {\n    __extends$29(MiniLine, _super);\n    function MiniLine(container, fills, strokes) {\n        var _this = _super.call(this, container, \"lineTooltip\") || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        var xScale = new LinearScale();\n        xScale.domain = [0, 4];\n        xScale.range = [padding, size - padding];\n        var yScale = new LinearScale();\n        yScale.domain = [0, 10];\n        yScale.range = [size - padding, padding];\n        var data = [\n            [9, 7, 8, 5, 6],\n            [5, 6, 3, 4, 1],\n            [1, 3, 4, 8, 7]\n        ];\n        _this.lines = data.map(function (series) {\n            var line = new Path();\n            line.strokeWidth = 3;\n            line.lineCap = \"round\";\n            line.fill = undefined;\n            series.forEach(function (datum, i) {\n                line.path[i > 0 ? \"lineTo\" : \"moveTo\"](xScale.convert(i), yScale.convert(datum));\n            });\n            return line;\n        });\n        _this.updateColors(fills, strokes);\n        var clipRect = new ClipRect();\n        clipRect.x = clipRect.y = padding;\n        clipRect.width = clipRect.height = size - padding * 2;\n        clipRect.append(_this.lines);\n        _this.root.append(clipRect);\n        return _this;\n    }\n    MiniLine.prototype.updateColors = function (fills, strokes) {\n        this.lines.forEach(function (line, i) {\n            line.stroke = fills[i];\n        });\n    };\n    MiniLine.chartType = agGridCommunity.ChartType.Line;\n    return MiniLine;\n}(MiniChartWithAxes));\n\nvar __extends$2a = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniScatter = /** @class */ (function (_super) {\n    __extends$2a(MiniScatter, _super);\n    function MiniScatter(container, fills, strokes) {\n        var _this = _super.call(this, container, \"scatterTooltip\") || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        // [x, y] pairs\n        var data = [\n            [[0.3, 3], [1.1, 0.9], [2, 0.4], [3.4, 2.4]],\n            [[0, 0.3], [1, 2], [2.4, 1.4], [3, 0]]\n        ];\n        var xScale = new LinearScale();\n        xScale.domain = [-0.5, 4];\n        xScale.range = [padding * 2, size - padding];\n        var yScale = new LinearScale();\n        yScale.domain = [-0.5, 3.5];\n        yScale.range = [size - padding, padding];\n        var points = [];\n        data.forEach(function (series) {\n            series.forEach(function (_a) {\n                var x = _a[0], y = _a[1];\n                var arc = new Arc();\n                arc.strokeWidth = 1;\n                arc.centerX = xScale.convert(x);\n                arc.centerY = yScale.convert(y);\n                arc.radiusX = arc.radiusY = 2.5;\n                points.push(arc);\n            });\n        });\n        _this.points = points;\n        _this.updateColors(fills, strokes);\n        var clipRect = new ClipRect();\n        clipRect.x = clipRect.y = padding;\n        clipRect.width = clipRect.height = size - padding * 2;\n        clipRect.append(_this.points);\n        _this.root.append(clipRect);\n        return _this;\n    }\n    MiniScatter.prototype.updateColors = function (fills, strokes) {\n        this.points.forEach(function (line, i) {\n            line.stroke = strokes[i % strokes.length];\n            line.fill = fills[i % fills.length];\n        });\n    };\n    MiniScatter.chartType = agGridCommunity.ChartType.Scatter;\n    return MiniScatter;\n}(MiniChartWithAxes));\n\nvar __extends$2b = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniBubble = /** @class */ (function (_super) {\n    __extends$2b(MiniBubble, _super);\n    function MiniBubble(container, fills, strokes) {\n        var _this = _super.call(this, container, \"bubbleTooltip\") || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        // [x, y, radius] triples\n        var data = [\n            [[0.1, 0.3, 5], [0.5, 0.4, 7], [0.2, 0.8, 7]], [[0.8, 0.7, 5], [0.7, 0.3, 9]]\n        ];\n        var xScale = new LinearScale();\n        xScale.domain = [0, 1];\n        xScale.range = [padding * 2, size - padding];\n        var yScale = new LinearScale();\n        yScale.domain = [0, 1];\n        yScale.range = [size - padding, padding];\n        var points = [];\n        data.forEach(function (series) {\n            series.forEach(function (_a) {\n                var x = _a[0], y = _a[1], radius = _a[2];\n                var arc = new Arc();\n                arc.strokeWidth = 1;\n                arc.centerX = xScale.convert(x);\n                arc.centerY = yScale.convert(y);\n                arc.radiusX = arc.radiusY = radius;\n                arc.fillOpacity = 0.7;\n                points.push(arc);\n            });\n        });\n        _this.points = points;\n        _this.updateColors(fills, strokes);\n        var clipRect = new ClipRect();\n        clipRect.x = padding;\n        clipRect.y = padding;\n        clipRect.width = size - padding * 2;\n        clipRect.height = size - padding * 2;\n        clipRect.append(_this.points);\n        _this.root.append(clipRect);\n        return _this;\n    }\n    MiniBubble.prototype.updateColors = function (fills, strokes) {\n        this.points.forEach(function (line, i) {\n            line.stroke = strokes[i % strokes.length];\n            line.fill = fills[i % fills.length];\n        });\n    };\n    MiniBubble.chartType = agGridCommunity.ChartType.Bubble;\n    return MiniBubble;\n}(MiniChartWithAxes));\n\nvar __extends$2c = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniArea = /** @class */ (function (_super) {\n    __extends$2c(MiniArea, _super);\n    function MiniArea(container, fills, strokes, data) {\n        if (data === void 0) { data = MiniArea.data; }\n        var _this = _super.call(this, container, \"groupedAreaTooltip\") || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        var xScale = new BandScale();\n        xScale.domain = [0, 1, 2];\n        xScale.paddingInner = 1;\n        xScale.paddingOuter = 0;\n        xScale.range = [padding + 0.5, size - padding - 0.5];\n        var yScale = new LinearScale();\n        yScale.domain = [0, 6];\n        yScale.range = [size - padding + 0.5, padding];\n        var xCount = data.length;\n        var last = xCount * 2 - 1;\n        var pathData = [];\n        var bottomY = yScale.convert(0);\n        data.forEach(function (datum, i) {\n            var x = xScale.convert(i);\n            datum.forEach(function (yDatum, j) {\n                var y = yScale.convert(yDatum);\n                var points = pathData[j] || (pathData[j] = []);\n                points[i] = {\n                    x: x,\n                    y: y\n                };\n                points[last - i] = {\n                    x: x,\n                    y: bottomY\n                };\n            });\n        });\n        _this.areas = pathData.reverse().map(function (points) {\n            var area = new Path();\n            area.strokeWidth = 1;\n            area.fillOpacity = 0.7;\n            var path = area.path;\n            path.clear();\n            points.forEach(function (point, i) { return path[i > 0 ? \"lineTo\" : \"moveTo\"](point.x, point.y); });\n            path.closePath();\n            return area;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.areas);\n        return _this;\n    }\n    MiniArea.prototype.updateColors = function (fills, strokes) {\n        this.areas.forEach(function (area, i) {\n            area.fill = fills[i];\n            area.stroke = strokes[i];\n        });\n    };\n    MiniArea.chartType = agGridCommunity.ChartType.Area;\n    MiniArea.data = [\n        [1, 3, 5],\n        [2, 6, 4],\n        [5, 3, 1]\n    ];\n    return MiniArea;\n}(MiniChartWithAxes));\n\nvar __extends$2d = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniStackedArea = /** @class */ (function (_super) {\n    __extends$2d(MiniStackedArea, _super);\n    function MiniStackedArea(container, fills, strokes, data, tooltipName) {\n        if (data === void 0) { data = MiniStackedArea.data; }\n        if (tooltipName === void 0) { tooltipName = \"stackedAreaTooltip\"; }\n        var _this = _super.call(this, container, tooltipName) || this;\n        var size = _this.size;\n        var padding = _this.padding;\n        var xScale = new BandScale();\n        xScale.domain = [0, 1, 2];\n        xScale.paddingInner = 1;\n        xScale.paddingOuter = 0;\n        xScale.range = [padding + 0.5, size - padding - 0.5];\n        var yScale = new LinearScale();\n        yScale.domain = [0, 16];\n        yScale.range = [size - padding + 0.5, padding + 0.5];\n        var xCount = data.length;\n        var last = xCount * 2 - 1;\n        var pathData = [];\n        data.forEach(function (datum, i) {\n            var x = xScale.convert(i);\n            var total = 0;\n            datum.forEach(function (yDatum, j) {\n                var y = yScale.convert(total + yDatum);\n                var points = pathData[j] || (pathData[j] = []);\n                points[i] = {\n                    x: x,\n                    y: y\n                };\n                points[last - i] = {\n                    x: x,\n                    y: yScale.convert(total) // bottom y\n                };\n                total += yDatum;\n            });\n        });\n        _this.areas = pathData.map(function (points) {\n            var area = new Path();\n            area.strokeWidth = 1;\n            var path = area.path;\n            path.clear();\n            points.forEach(function (point, i) { return path[i > 0 ? \"lineTo\" : \"moveTo\"](point.x, point.y); });\n            path.closePath();\n            return area;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.areas);\n        return _this;\n    }\n    MiniStackedArea.prototype.updateColors = function (fills, strokes) {\n        this.areas.forEach(function (area, i) {\n            area.fill = fills[i];\n            area.stroke = strokes[i];\n        });\n    };\n    MiniStackedArea.chartType = agGridCommunity.ChartType.StackedArea;\n    MiniStackedArea.data = [\n        [2, 3, 2],\n        [3, 6, 5],\n        [6, 2, 2]\n    ];\n    return MiniStackedArea;\n}(MiniChartWithAxes));\n\nvar __extends$2e = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniNormalizedArea = /** @class */ (function (_super) {\n    __extends$2e(MiniNormalizedArea, _super);\n    function MiniNormalizedArea(container, fills, strokes, data) {\n        if (data === void 0) { data = MiniNormalizedArea.data; }\n        return _super.call(this, container, fills, strokes, data, \"normalizedAreaTooltip\") || this;\n    }\n    MiniNormalizedArea.chartType = agGridCommunity.ChartType.NormalizedArea;\n    MiniNormalizedArea.data = MiniStackedArea.data.map(function (stack) {\n        var sum = stack.reduce(function (p, c) { return p + c; }, 0);\n        return stack.map(function (v) { return v / sum * 16; });\n    });\n    return MiniNormalizedArea;\n}(MiniStackedArea));\n\nvar __extends$2f = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MiniHistogram = /** @class */ (function (_super) {\n    __extends$2f(MiniHistogram, _super);\n    function MiniHistogram(container, fills, strokes) {\n        var _this = _super.call(this, container, \"histogramTooltip\") || this;\n        var padding = _this.padding;\n        var size = _this.size;\n        // approx normal curve\n        var data = [2, 5, 11, 13, 10, 6, 1];\n        var xScale = new LinearScale();\n        xScale.domain = [0, data.length];\n        xScale.range = [padding, size - padding];\n        var yScale = new LinearScale();\n        yScale.domain = [0, data.reduce(function (a, b) { return Math.max(a, b); }, 0)];\n        yScale.range = [size - padding, padding];\n        var bottom = yScale.convert(0);\n        _this.bars = data.map(function (datum, i) {\n            var top = yScale.convert(datum);\n            var left = xScale.convert(i);\n            var right = xScale.convert(i + 1);\n            var rect = new Rect();\n            rect.x = left;\n            rect.y = top;\n            rect.width = right - left;\n            rect.height = bottom - top;\n            rect.strokeWidth = 1;\n            rect.crisp = true;\n            return rect;\n        });\n        _this.updateColors(fills, strokes);\n        _this.root.append(_this.bars);\n        return _this;\n    }\n    MiniHistogram.prototype.updateColors = function (_a, _b) {\n        var fill = _a[0];\n        var stroke = _b[0];\n        this.bars.forEach(function (bar) {\n            bar.fill = fill;\n            bar.stroke = stroke;\n        });\n    };\n    MiniHistogram.chartType = agGridCommunity.ChartType.Histogram;\n    return MiniHistogram;\n}(MiniChartWithAxes));\n\nvar __extends$2g = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MiniChartsContainer = /** @class */ (function (_super) {\n    __extends$2g(MiniChartsContainer, _super);\n    function MiniChartsContainer(chartController, fills, strokes) {\n        var _this = _super.call(this, MiniChartsContainer.TEMPLATE) || this;\n        _this.wrappers = {};\n        _this.chartController = chartController;\n        _this.fills = fills;\n        _this.strokes = strokes;\n        return _this;\n    }\n    MiniChartsContainer.prototype.init = function () {\n        var _this = this;\n        var chartGroups = {\n            columnGroup: [\n                MiniColumn,\n                MiniStackedColumn,\n                MiniNormalizedColumn\n            ],\n            barGroup: [\n                MiniBar,\n                MiniStackedBar,\n                MiniNormalizedBar\n            ],\n            pieGroup: [\n                MiniPie,\n                MiniDoughnut\n            ],\n            lineGroup: [\n                MiniLine\n            ],\n            scatterGroup: [\n                MiniScatter,\n                MiniBubble\n            ],\n            areaGroup: [\n                MiniArea,\n                MiniStackedArea,\n                MiniNormalizedArea\n            ],\n            histogramGroup: [\n                MiniHistogram\n            ]\n        };\n        var eGui = this.getGui();\n        Object.keys(chartGroups).forEach(function (group) {\n            var chartGroup = chartGroups[group];\n            var groupComponent = _this.createBean(new agGridCommunity.AgGroupComponent({\n                title: _this.chartTranslator.translate(group),\n                suppressEnabledCheckbox: true,\n                enabled: true,\n                suppressOpenCloseIcons: true,\n                cssIdentifier: 'charts-settings',\n                direction: 'horizontal'\n            }));\n            chartGroup.forEach(function (MiniClass) {\n                var miniWrapper = document.createElement('div');\n                agGridCommunity._.addCssClass(miniWrapper, 'ag-chart-mini-thumbnail');\n                _this.addManagedListener(miniWrapper, 'click', function () {\n                    _this.chartController.setChartType(MiniClass.chartType);\n                    _this.refreshSelected();\n                });\n                _this.wrappers[MiniClass.chartType] = miniWrapper;\n                _this.createBean(new MiniClass(miniWrapper, _this.fills, _this.strokes));\n                groupComponent.addItem(miniWrapper);\n            });\n            eGui.appendChild(groupComponent.getGui());\n        });\n        this.refreshSelected();\n    };\n    MiniChartsContainer.prototype.refreshSelected = function () {\n        var type = this.chartController.getChartType();\n        for (var wrapper in this.wrappers) {\n            agGridCommunity._.addOrRemoveCssClass(this.wrappers[wrapper], 'ag-selected', wrapper === type);\n        }\n    };\n    MiniChartsContainer.TEMPLATE = \"<div class=\\\"ag-chart-settings-mini-wrapper\\\"></div>\";\n    __decorate$1g([\n        agGridCommunity.Autowired('chartTranslator')\n    ], MiniChartsContainer.prototype, \"chartTranslator\", void 0);\n    __decorate$1g([\n        agGridCommunity.PostConstruct\n    ], MiniChartsContainer.prototype, \"init\", null);\n    return MiniChartsContainer;\n}(agGridCommunity.Component));\n\nvar __extends$2h = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartSettingsPanel = /** @class */ (function (_super) {\n    __extends$2h(ChartSettingsPanel, _super);\n    function ChartSettingsPanel(chartController) {\n        var _this = _super.call(this, ChartSettingsPanel.TEMPLATE) || this;\n        _this.miniCharts = [];\n        _this.cardItems = [];\n        _this.activePaletteIndex = 0;\n        _this.palettes = [];\n        _this.themes = [];\n        _this.chartController = chartController;\n        return _this;\n    }\n    ChartSettingsPanel.prototype.postConstruct = function () {\n        var _this = this;\n        this.resetPalettes();\n        this.ePrevBtn.insertAdjacentElement('afterbegin', agGridCommunity._.createIconNoSpan('previous', this.gridOptionsWrapper));\n        this.eNextBtn.insertAdjacentElement('afterbegin', agGridCommunity._.createIconNoSpan('next', this.gridOptionsWrapper));\n        this.addManagedListener(this.ePrevBtn, 'click', function () { return _this.setActivePalette(_this.getPrev(), 'left'); });\n        this.addManagedListener(this.eNextBtn, 'click', function () { return _this.setActivePalette(_this.getNext(), 'right'); });\n        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, this.resetPalettes.bind(this));\n    };\n    ChartSettingsPanel.prototype.resetPalettes = function () {\n        var _this = this;\n        var palettes = this.chartController.getPalettes();\n        if (agGridCommunity._.shallowCompare(palettes, this.palettes)) {\n            return;\n        }\n        this.palettes = palettes;\n        this.themes = this.chartController.getThemes();\n        this.activePaletteIndex = agGridCommunity._.findIndex(this.themes, function (name) { return name === _this.chartController.getThemeName(); });\n        this.cardItems = [];\n        agGridCommunity._.clearElement(this.eCardSelector);\n        this.destroyMiniCharts();\n        this.palettes.forEach(function (palette, index) {\n            var isActivePalette = _this.activePaletteIndex === index;\n            var fills = palette.fills, strokes = palette.strokes;\n            var miniChartsContainer = _this.createBean(new MiniChartsContainer(_this.chartController, fills, strokes));\n            _this.miniCharts.push(miniChartsContainer);\n            _this.eMiniChartsContainer.appendChild(miniChartsContainer.getGui());\n            _this.addCardLink(index);\n            if (isActivePalette) {\n                miniChartsContainer.refreshSelected();\n            }\n            else {\n                agGridCommunity._.addCssClass(miniChartsContainer.getGui(), 'ag-hidden');\n            }\n        });\n        agGridCommunity._.addOrRemoveCssClass(this.eNavBar, 'ag-hidden', this.palettes.length <= 1);\n        agGridCommunity._.radioCssClass(this.cardItems[this.activePaletteIndex], 'ag-selected', 'ag-not-selected');\n    };\n    ChartSettingsPanel.prototype.addCardLink = function (index) {\n        var _this = this;\n        var link = document.createElement('div');\n        agGridCommunity._.addCssClass(link, 'ag-chart-settings-card-item');\n        this.addManagedListener(link, 'click', function () {\n            var activePaletteIndex = _this.activePaletteIndex;\n            _this.setActivePalette(index, index < activePaletteIndex ? 'left' : 'right');\n        });\n        this.eCardSelector.appendChild(link);\n        this.cardItems.push(link);\n    };\n    ChartSettingsPanel.prototype.getPrev = function () {\n        var prev = this.activePaletteIndex - 1;\n        if (prev < 0) {\n            prev = this.palettes.length - 1;\n        }\n        return prev;\n    };\n    ChartSettingsPanel.prototype.getNext = function () {\n        var next = this.activePaletteIndex + 1;\n        if (next >= this.palettes.length) {\n            next = 0;\n        }\n        return next;\n    };\n    ChartSettingsPanel.prototype.setActivePalette = function (index, animationDirection) {\n        var _this = this;\n        if (this.isAnimating || this.activePaletteIndex === index) {\n            return;\n        }\n        agGridCommunity._.radioCssClass(this.cardItems[index], 'ag-selected', 'ag-not-selected');\n        var currentPalette = this.miniCharts[this.activePaletteIndex];\n        var currentGui = currentPalette.getGui();\n        var futurePalette = this.miniCharts[index];\n        var nextGui = futurePalette.getGui();\n        currentPalette.refreshSelected();\n        futurePalette.refreshSelected();\n        var multiplier = animationDirection === 'left' ? -1 : 1;\n        var final = nextGui.style.left = (agGridCommunity._.getAbsoluteWidth(this.getGui()) * multiplier) + \"px\";\n        var animatingClass = 'ag-animating';\n        agGridCommunity._.removeCssClass(nextGui, 'ag-hidden');\n        agGridCommunity._.addCssClass(currentGui, animatingClass);\n        agGridCommunity._.addCssClass(nextGui, animatingClass);\n        this.activePaletteIndex = index;\n        this.chartController.setChartThemeName(this.themes[index]);\n        this.isAnimating = true;\n        window.setTimeout(function () {\n            currentGui.style.left = -parseFloat(final) + \"px\";\n            nextGui.style.left = '0px';\n        }, 0);\n        window.setTimeout(function () {\n            _this.isAnimating = false;\n            agGridCommunity._.removeCssClass(currentGui, animatingClass);\n            agGridCommunity._.removeCssClass(nextGui, animatingClass);\n            agGridCommunity._.addCssClass(currentGui, 'ag-hidden');\n        }, 300);\n    };\n    ChartSettingsPanel.prototype.destroyMiniCharts = function () {\n        agGridCommunity._.clearElement(this.eMiniChartsContainer);\n        this.miniCharts = this.destroyBeans(this.miniCharts);\n    };\n    ChartSettingsPanel.prototype.destroy = function () {\n        this.destroyMiniCharts();\n        _super.prototype.destroy.call(this);\n    };\n    ChartSettingsPanel.TEMPLATE = \"<div class=\\\"ag-chart-settings-wrapper\\\">\\n            <div ref=\\\"eMiniChartsContainer\\\" class=\\\"ag-chart-settings-mini-charts-container\\\"></div>\\n            <div ref=\\\"eNavBar\\\" class=\\\"ag-chart-settings-nav-bar\\\">\\n                <div ref=\\\"ePrevBtn\\\" class=\\\"ag-chart-settings-prev\\\">\\n                    <button type=\\\"button\\\" class=\\\"ag-chart-settings-prev-button\\\"></button>\\n                </div>\\n                <div ref=\\\"eCardSelector\\\" class=\\\"ag-chart-settings-card-selector\\\"></div>\\n                <div ref=\\\"eNextBtn\\\" class=\\\"ag-chart-settings-next\\\">\\n                    <button type=\\\"button\\\" class=\\\"ag-chart-settings-next-button\\\"></button>\\n                </div>\\n            </div>\\n        </div>\";\n    __decorate$1h([\n        agGridCommunity.RefSelector('eMiniChartsContainer')\n    ], ChartSettingsPanel.prototype, \"eMiniChartsContainer\", void 0);\n    __decorate$1h([\n        agGridCommunity.RefSelector('eNavBar')\n    ], ChartSettingsPanel.prototype, \"eNavBar\", void 0);\n    __decorate$1h([\n        agGridCommunity.RefSelector('eCardSelector')\n    ], ChartSettingsPanel.prototype, \"eCardSelector\", void 0);\n    __decorate$1h([\n        agGridCommunity.RefSelector('ePrevBtn')\n    ], ChartSettingsPanel.prototype, \"ePrevBtn\", void 0);\n    __decorate$1h([\n        agGridCommunity.RefSelector('eNextBtn')\n    ], ChartSettingsPanel.prototype, \"eNextBtn\", void 0);\n    __decorate$1h([\n        agGridCommunity.PostConstruct\n    ], ChartSettingsPanel.prototype, \"postConstruct\", null);\n    return ChartSettingsPanel;\n}(agGridCommunity.Component));\n\nvar __extends$2i = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TabbedChartMenu = /** @class */ (function (_super) {\n    __extends$2i(TabbedChartMenu, _super);\n    function TabbedChartMenu(params) {\n        var _this = _super.call(this) || this;\n        _this.tabs = [];\n        _this.chartIcons = {};\n        var controller = params.controller, type = params.type, panels = params.panels;\n        _this.chartController = controller;\n        _this.currentChartType = type;\n        _this.panels = panels;\n        return _this;\n    }\n    TabbedChartMenu.prototype.init = function () {\n        var _this = this;\n        this.panels.forEach(function (panel) {\n            var panelType = panel.replace('chart', '').toLowerCase();\n            var _a = _this.createTab(panel, panelType, _this.getPanelClass(panelType)), comp = _a.comp, tab = _a.tab;\n            _this.tabs.push(tab);\n            _this.addDestroyFunc(function () { return _this.destroyBean(comp); });\n        });\n        this.tabbedLayout = new agGridCommunity.TabbedLayout({\n            items: this.tabs,\n            cssClass: 'ag-chart-tabbed-menu'\n        });\n        this.getContext().createBean(this.tabbedLayout);\n    };\n    TabbedChartMenu.prototype.createTab = function (name, title, ChildClass) {\n        var eWrapperDiv = document.createElement('div');\n        agGridCommunity._.addCssClass(eWrapperDiv, 'ag-chart-tab');\n        agGridCommunity._.addCssClass(eWrapperDiv, \"ag-chart-\" + title);\n        var comp = new ChildClass(this.chartController);\n        this.getContext().createBean(comp);\n        eWrapperDiv.appendChild(comp.getGui());\n        var titleEl = document.createElement('div');\n        var translatedTitle = this.chartTranslator.translate(title);\n        titleEl.innerText = translatedTitle;\n        return {\n            comp: comp,\n            tab: {\n                title: titleEl,\n                titleLabel: translatedTitle,\n                bodyPromise: agGridCommunity.AgPromise.resolve(eWrapperDiv),\n                name: name\n            }\n        };\n    };\n    TabbedChartMenu.prototype.getMinDimensions = function () {\n        return this.tabbedLayout.getMinDimensions();\n    };\n    TabbedChartMenu.prototype.updateCurrentChartType = function (chartType) {\n        agGridCommunity._.removeCssClass(this.chartIcons[this.currentChartType], 'ag-selected');\n        this.currentChartType = chartType;\n        agGridCommunity._.addCssClass(this.chartIcons[chartType], 'ag-selected');\n    };\n    TabbedChartMenu.prototype.showTab = function (tab) {\n        var tabItem = this.tabs[tab];\n        this.tabbedLayout.showItem(tabItem);\n    };\n    TabbedChartMenu.prototype.getGui = function () {\n        return this.tabbedLayout && this.tabbedLayout.getGui();\n    };\n    TabbedChartMenu.prototype.destroy = function () {\n        if (this.parentComponent && this.parentComponent.isAlive()) {\n            this.destroyBean(this.parentComponent);\n        }\n        _super.prototype.destroy.call(this);\n    };\n    TabbedChartMenu.prototype.getPanelClass = function (panelType) {\n        switch (panelType) {\n            case TabbedChartMenu.TAB_DATA:\n                return ChartDataPanel;\n            case TabbedChartMenu.TAB_FORMAT:\n                return ChartFormattingPanel;\n            default:\n                return ChartSettingsPanel;\n        }\n    };\n    TabbedChartMenu.EVENT_TAB_SELECTED = 'tabSelected';\n    TabbedChartMenu.TAB_MAIN = 'settings';\n    TabbedChartMenu.TAB_DATA = 'data';\n    TabbedChartMenu.TAB_FORMAT = 'format';\n    __decorate$1i([\n        agGridCommunity.Autowired('chartTranslator')\n    ], TabbedChartMenu.prototype, \"chartTranslator\", void 0);\n    __decorate$1i([\n        agGridCommunity.PostConstruct\n    ], TabbedChartMenu.prototype, \"init\", null);\n    return TabbedChartMenu;\n}(agGridCommunity.Component));\n\nvar __extends$2j = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartMenu = /** @class */ (function (_super) {\n    __extends$2j(ChartMenu, _super);\n    function ChartMenu(eChartContainer, eMenuPanelContainer, chartController) {\n        var _this = _super.call(this, ChartMenu.TEMPLATE) || this;\n        _this.eChartContainer = eChartContainer;\n        _this.eMenuPanelContainer = eMenuPanelContainer;\n        _this.chartController = chartController;\n        _this.buttons = {\n            chartSettings: ['menu', function () { return _this.showMenu(\"chartSettings\"); }],\n            chartData: ['menu', function () { return _this.showMenu(\"chartData\"); }],\n            chartFormat: ['menu', function () { return _this.showMenu(\"chartFormat\"); }],\n            chartLink: ['linked', function (e) { return _this.toggleDetached(e); }],\n            chartUnlink: ['unlinked', function (e) { return _this.toggleDetached(e); }],\n            chartDownload: ['save', function () { return _this.saveChart(); }]\n        };\n        _this.tabs = [];\n        _this.menuVisible = false;\n        return _this;\n    }\n    ChartMenu.prototype.postConstruct = function () {\n        this.createButtons();\n        this.refreshMenuClasses();\n    };\n    ChartMenu.prototype.isVisible = function () {\n        return this.menuVisible;\n    };\n    ChartMenu.prototype.getToolbarOptions = function () {\n        var _this = this;\n        var tabOptions = [\n            'chartSettings',\n            'chartData',\n            'chartFormat',\n            this.chartController.isChartLinked() ? 'chartLink' : 'chartUnlink',\n            'chartDownload'\n        ];\n        var toolbarItemsFunc = this.gridOptionsWrapper.getChartToolbarItemsFunc();\n        if (toolbarItemsFunc) {\n            var params = {\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                defaultItems: tabOptions\n            };\n            tabOptions = toolbarItemsFunc(params).filter(function (option) {\n                if (!_this.buttons[option]) {\n                    console.warn(\"AG Grid: '\" + option + \" is not a valid Chart Toolbar Option\");\n                    return false;\n                }\n                return true;\n            });\n        }\n        // pivot charts use the column tool panel instead of the data panel\n        if (this.chartController.isPivotChart()) {\n            tabOptions = tabOptions.filter(function (option) { return option !== 'chartData'; });\n        }\n        var ignoreOptions = ['chartUnlink', 'chartLink', 'chartDownload'];\n        this.tabs = tabOptions.filter(function (option) { return ignoreOptions.indexOf(option) === -1; });\n        return tabOptions.filter(function (value) {\n            return ignoreOptions.indexOf(value) !== -1 ||\n                (_this.tabs.length && value === _this.tabs[0]);\n        });\n    };\n    ChartMenu.prototype.toggleDetached = function (e) {\n        var target = e.target;\n        var active = agGridCommunity._.containsClass(target, 'ag-icon-linked');\n        agGridCommunity._.addOrRemoveCssClass(target, 'ag-icon-linked', !active);\n        agGridCommunity._.addOrRemoveCssClass(target, 'ag-icon-unlinked', active);\n        var tooltipKey = active ? 'chartUnlinkToolbarTooltip' : 'chartLinkToolbarTooltip';\n        var tooltipTitle = this.chartTranslator.translate(tooltipKey);\n        if (tooltipTitle) {\n            target.title = tooltipTitle;\n        }\n        this.chartController.detachChartRange();\n    };\n    ChartMenu.prototype.createButtons = function () {\n        var _this = this;\n        var chartToolbarOptions = this.getToolbarOptions();\n        var gui = this.getGui();\n        chartToolbarOptions.forEach(function (button) {\n            var buttonConfig = _this.buttons[button];\n            var iconName = buttonConfig[0], callback = buttonConfig[1];\n            var buttonEl = agGridCommunity._.createIconNoSpan(iconName, _this.gridOptionsWrapper, undefined, true);\n            agGridCommunity._.addCssClass(buttonEl, 'ag-chart-menu-icon');\n            var tooltipTitle = _this.chartTranslator.translate(button + 'ToolbarTooltip');\n            if (tooltipTitle) {\n                buttonEl.title = tooltipTitle;\n            }\n            _this.addManagedListener(buttonEl, 'click', callback);\n            gui.appendChild(buttonEl);\n        });\n    };\n    ChartMenu.prototype.saveChart = function () {\n        var event = { type: ChartMenu.EVENT_DOWNLOAD_CHART };\n        this.dispatchEvent(event);\n    };\n    ChartMenu.prototype.createMenuPanel = function (defaultTab) {\n        var _this = this;\n        var width = this.gridOptionsWrapper.chartMenuPanelWidth();\n        var menuPanel = this.menuPanel = this.createBean(new agGridCommunity.AgPanel({\n            minWidth: width,\n            width: width,\n            height: '100%',\n            closable: true,\n            hideTitleBar: true,\n            cssIdentifier: 'chart-menu'\n        }));\n        menuPanel.setParentComponent(this);\n        this.eMenuPanelContainer.appendChild(menuPanel.getGui());\n        this.tabbedMenu = this.createBean(new TabbedChartMenu({\n            controller: this.chartController,\n            type: this.chartController.getChartType(),\n            panels: this.tabs\n        }));\n        this.addManagedListener(menuPanel, agGridCommunity.Component.EVENT_DESTROYED, function () { return _this.destroyBean(_this.tabbedMenu); });\n        return new agGridCommunity.AgPromise(function (res) {\n            window.setTimeout(function () {\n                menuPanel.setBodyComponent(_this.tabbedMenu);\n                _this.tabbedMenu.showTab(defaultTab);\n                _this.addManagedListener(_this.eChartContainer, 'click', function (event) {\n                    if (_this.getGui().contains(event.target)) {\n                        return;\n                    }\n                    if (_this.menuVisible) {\n                        _this.hideMenu();\n                    }\n                });\n                res(menuPanel);\n            }, 100);\n        });\n    };\n    ChartMenu.prototype.showContainer = function () {\n        if (!this.menuPanel) {\n            return;\n        }\n        this.menuVisible = true;\n        this.showParent(this.menuPanel.getWidth());\n        this.refreshMenuClasses();\n    };\n    ChartMenu.prototype.showMenu = function (tabName) {\n        var tab = this.tabs.indexOf(tabName);\n        if (!this.menuPanel) {\n            this.createMenuPanel(tab).then(this.showContainer.bind(this));\n        }\n        else {\n            this.showContainer();\n        }\n    };\n    ChartMenu.prototype.hideMenu = function () {\n        var _this = this;\n        this.hideParent();\n        window.setTimeout(function () {\n            _this.menuVisible = false;\n            _this.refreshMenuClasses();\n        }, 500);\n    };\n    ChartMenu.prototype.refreshMenuClasses = function () {\n        agGridCommunity._.addOrRemoveCssClass(this.eChartContainer, 'ag-chart-menu-visible', this.menuVisible);\n        agGridCommunity._.addOrRemoveCssClass(this.eChartContainer, 'ag-chart-menu-hidden', !this.menuVisible);\n    };\n    ChartMenu.prototype.showParent = function (width) {\n        this.eMenuPanelContainer.style.minWidth = width + \"px\";\n    };\n    ChartMenu.prototype.hideParent = function () {\n        this.eMenuPanelContainer.style.minWidth = '0';\n    };\n    ChartMenu.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.menuPanel && this.menuPanel.isAlive()) {\n            this.destroyBean(this.menuPanel);\n        }\n    };\n    ChartMenu.EVENT_DOWNLOAD_CHART = \"downloadChart\";\n    ChartMenu.TEMPLATE = \"<div class=\\\"ag-chart-menu\\\"></div>\";\n    __decorate$1j([\n        agGridCommunity.Autowired('chartTranslator')\n    ], ChartMenu.prototype, \"chartTranslator\", void 0);\n    __decorate$1j([\n        agGridCommunity.PostConstruct\n    ], ChartMenu.prototype, \"postConstruct\", null);\n    return ChartMenu;\n}(agGridCommunity.Component));\n\nvar __extends$2k = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$a = (undefined && undefined.__assign) || function () {\n    __assign$a = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$a.apply(this, arguments);\n};\nvar __decorate$1k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TitleEdit = /** @class */ (function (_super) {\n    __extends$2k(TitleEdit, _super);\n    function TitleEdit(chartMenu) {\n        var _this = _super.call(this, TitleEdit.TEMPLATE) || this;\n        _this.chartMenu = chartMenu;\n        return _this;\n    }\n    TitleEdit.prototype.init = function () {\n        var _this = this;\n        this.addManagedListener(this.getGui(), 'keypress', function (e) {\n            if (e.key === 'Enter') {\n                _this.endEditing();\n            }\n        });\n        this.addManagedListener(this.getGui(), 'blur', this.endEditing.bind(this));\n    };\n    /* should be called when the containing component changes to a new chart proxy */\n    TitleEdit.prototype.setChartProxy = function (chartProxy) {\n        var _this = this;\n        if (this.chartProxy) {\n            for (var i = 0; i++; i < this.destroyableChartListeners.length) {\n                this.destroyableChartListeners[i]();\n            }\n            this.destroyableChartListeners = [];\n        }\n        this.chartProxy = chartProxy;\n        var chart = this.chartProxy.getChart();\n        var canvas = chart.scene.canvas.element;\n        var destroyDbleClickListener = this.addManagedListener(canvas, 'dblclick', function (event) {\n            var title = chart.title;\n            if (title && title.node.containsPoint(event.offsetX, event.offsetY)) {\n                var bbox = title.node.computeBBox();\n                var xy = title.node.inverseTransformPoint(bbox.x, bbox.y);\n                _this.startEditing(__assign$a(__assign$a({}, bbox), xy));\n            }\n        });\n        var destroyMouseMoveListener = this.addManagedListener(canvas, 'mousemove', function (event) {\n            var title = chart.title;\n            var inTitle = title && title.enabled && title.node.containsPoint(event.offsetX, event.offsetY);\n            canvas.style.cursor = inTitle ? 'pointer' : '';\n        });\n        this.destroyableChartListeners = [\n            destroyDbleClickListener,\n            destroyMouseMoveListener\n        ];\n    };\n    TitleEdit.prototype.startEditing = function (titleBBox) {\n        if (this.chartMenu && this.chartMenu.isVisible()) {\n            // currently we ignore requests to edit the chart title while the chart menu is showing\n            // because the click to edit the chart will also close the chart menu, making the position\n            // of the title change.\n            return;\n        }\n        var minimumTargetInputWidth = 300;\n        var maximumInputWidth = this.chartProxy.getChart().width;\n        var inputWidth = Math.max(Math.min(titleBBox.width + 20, maximumInputWidth), minimumTargetInputWidth);\n        var inputElement = this.getGui();\n        agGridCommunity._.addCssClass(inputElement, 'currently-editing');\n        var inputStyle = inputElement.style;\n        // match style of input to title that we're editing\n        inputStyle.fontFamily = this.chartProxy.getTitleOption('fontFamily');\n        inputStyle.fontWeight = this.chartProxy.getTitleOption('fontWeight');\n        inputStyle.fontStyle = this.chartProxy.getTitleOption('fontStyle');\n        inputStyle.fontSize = this.chartProxy.getTitleOption('fontSize') + 'px';\n        inputStyle.color = this.chartProxy.getTitleOption('color');\n        // populate the input with the title, unless the title is the placeholder:\n        var oldTitle = this.chartProxy.getTitleOption('text');\n        var inputValue = oldTitle === this.chartTranslator.translate('titlePlaceholder') ? '' : oldTitle;\n        inputElement.value = inputValue;\n        var inputRect = inputElement.getBoundingClientRect();\n        inputStyle.left = Math.round(titleBBox.x + titleBBox.width / 2 - inputWidth / 2) + 'px';\n        inputStyle.top = Math.round(titleBBox.y + titleBBox.height / 2 - inputRect.height / 2) + 'px';\n        inputStyle.width = Math.round(inputWidth) + 'px';\n        inputElement.focus();\n    };\n    TitleEdit.prototype.endEditing = function () {\n        var value = this.getGui().value;\n        this.chartProxy.setTitleOption('text', value);\n        this.eventService.dispatchEvent({ type: 'chartTitleEdit' });\n        agGridCommunity._.removeCssClass(this.getGui(), 'currently-editing');\n    };\n    TitleEdit.TEMPLATE = \"<input\\n            class=\\\"ag-chart-title-edit\\\"\\n            style=\\\"padding:0; border:none; border-radius: 0; min-height: 0; text-align: center;\\\" />\\n        \";\n    __decorate$1k([\n        agGridCommunity.Autowired('chartTranslator')\n    ], TitleEdit.prototype, \"chartTranslator\", void 0);\n    __decorate$1k([\n        agGridCommunity.PostConstruct\n    ], TitleEdit.prototype, \"init\", null);\n    return TitleEdit;\n}(agGridCommunity.Component));\n\nvar __extends$2l = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$b = (undefined && undefined.__assign) || function () {\n    __assign$b = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$b.apply(this, arguments);\n};\nvar BarChartProxy = /** @class */ (function (_super) {\n    __extends$2l(BarChartProxy, _super);\n    function BarChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    BarChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var integratedChartType = this.chartType;\n        var standaloneChartType = this.getStandaloneChartType();\n        var seriesType = integratedChartType === agGridCommunity.ChartType.GroupedBar\n            || integratedChartType === agGridCommunity.ChartType.StackedBar\n            || integratedChartType === agGridCommunity.ChartType.NormalizedBar ? 'bar' : 'column';\n        var seriesDefaults = theme.getConfig(standaloneChartType + '.series.' + seriesType);\n        options.seriesDefaults = {\n            shadow: seriesDefaults.shadow,\n            label: seriesDefaults.label,\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: seriesDefaults.fills || theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity\n            },\n            stroke: {\n                colors: seriesDefaults.strokes || theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            lineDash: seriesDefaults.lineDash ? seriesDefaults.lineDash : [0],\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    BarChartProxy.prototype.createChart = function (options) {\n        var _a = this.chartProxyParams, grouping = _a.grouping, parentElement = _a.parentElement;\n        var isColumn = this.isColumnChart();\n        options = options || this.chartOptions;\n        var seriesDefaults = options.seriesDefaults;\n        var agChartOptions = options;\n        if (grouping) {\n            agChartOptions.type = 'groupedCategory';\n        }\n        agChartOptions.autoSize = true;\n        agChartOptions.axes = [__assign$b(__assign$b({}, (isColumn ? options.xAxis : options.yAxis)), { position: isColumn ? 'bottom' : 'left', type: grouping ? 'groupedCategory' : 'category' }), __assign$b(__assign$b({}, (isColumn ? options.yAxis : options.xAxis)), { position: isColumn ? 'left' : 'bottom', type: 'number' })];\n        agChartOptions.series = [__assign$b(__assign$b({}, this.getSeriesDefaults()), { fills: seriesDefaults.fill.colors, fillOpacity: seriesDefaults.fill.opacity, strokes: seriesDefaults.stroke.colors, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, tooltip: {\n                    enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                    renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled && seriesDefaults.tooltip.renderer,\n                } })];\n        agChartOptions.container = parentElement;\n        return AgChart.create(agChartOptions);\n    };\n    BarChartProxy.prototype.update = function (params) {\n        var _this = this;\n        this.chartProxyParams.grouping = params.grouping;\n        this.updateAxes('category', !this.isColumnChart());\n        var chart = this.chart;\n        var barSeries = chart.series[0];\n        var palette = this.getPalette();\n        var fields = params.fields;\n        if (this.crossFiltering) {\n            // add additional filtered out field\n            fields.forEach(function (field) {\n                var crossFilteringField = __assign$b({}, field);\n                crossFilteringField.colId = field.colId + '-filtered-out';\n                fields.push(crossFilteringField);\n            });\n            // introduce cross filtering transparent fills\n            var fills_1 = [];\n            palette.fills.forEach(function (fill) {\n                fills_1.push(fill);\n                fills_1.push(_this.hexToRGBA(fill, '0.3'));\n            });\n            barSeries.fills = fills_1;\n            // introduce cross filtering transparent strokes\n            var strokes = [];\n            palette.strokes.forEach(function (stroke) {\n                fills_1.push(stroke);\n                fills_1.push(_this.hexToRGBA(stroke, '0.3'));\n            });\n            barSeries.strokes = strokes;\n            // disable series highlighting by default\n            barSeries.highlightStyle.fill = undefined;\n            // hide 'filtered out' legend items\n            var colIds = params.fields.map(function (f) { return f.colId; });\n            barSeries.hideInLegend = colIds.filter(function (colId) { return colId.includes('-filtered-out'); });\n            // sync toggling of legend item with hidden 'filtered out' item\n            chart.legend.addEventListener('click', function (event) {\n                barSeries.toggleSeriesItem(event.itemId + '-filtered-out', event.enabled);\n            });\n            chart.tooltip.delay = 500;\n            // add node click cross filtering callback to series\n            barSeries.addEventListener('nodeClick', this.crossFilterCallback);\n        }\n        else {\n            barSeries.fills = palette.fills;\n            barSeries.strokes = palette.strokes;\n        }\n        barSeries.data = this.transformData(params.data, params.category.id);\n        barSeries.xKey = params.category.id;\n        barSeries.xName = params.category.name;\n        barSeries.yKeys = params.fields.map(function (f) { return f.colId; });\n        barSeries.yNames = params.fields.map(function (f) { return f.displayName; });\n        this.updateLabelRotation(params.category.id, !this.isColumnChart());\n    };\n    BarChartProxy.prototype.getDefaultOptions = function () {\n        var fontOptions = this.getDefaultFontOptions();\n        var options = this.getDefaultCartesianChartOptions();\n        options.seriesDefaults = __assign$b(__assign$b({}, options.seriesDefaults), { tooltip: {\n                enabled: true,\n            }, label: __assign$b(__assign$b({}, fontOptions), { enabled: false }), shadow: this.getDefaultDropShadowOptions() });\n        return options;\n    };\n    BarChartProxy.prototype.isColumnChart = function () {\n        return agGridCommunity._.includes([agGridCommunity.ChartType.Column, agGridCommunity.ChartType.GroupedColumn, agGridCommunity.ChartType.StackedColumn, agGridCommunity.ChartType.NormalizedColumn], this.chartType);\n    };\n    BarChartProxy.prototype.getSeriesDefaults = function () {\n        var chartType = this.chartType;\n        var isColumn = this.isColumnChart();\n        var isGrouped = !this.crossFiltering && (chartType === agGridCommunity.ChartType.GroupedColumn || chartType === agGridCommunity.ChartType.GroupedBar);\n        var isNormalized = !this.crossFiltering && (chartType === agGridCommunity.ChartType.NormalizedColumn || chartType === agGridCommunity.ChartType.NormalizedBar);\n        return __assign$b(__assign$b({}, this.chartOptions.seriesDefaults), { type: isColumn ? 'column' : 'bar', grouped: isGrouped, normalizedTo: isNormalized ? 100 : undefined });\n    };\n    return BarChartProxy;\n}(CartesianChartProxy));\n\nvar __extends$2m = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$c = (undefined && undefined.__assign) || function () {\n    __assign$c = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$c.apply(this, arguments);\n};\nvar AreaChartProxy = /** @class */ (function (_super) {\n    __extends$2m(AreaChartProxy, _super);\n    function AreaChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    AreaChartProxy.prototype.createChart = function (options) {\n        var _a = this.chartProxyParams, grouping = _a.grouping, parentElement = _a.parentElement;\n        var seriesDefaults = this.getSeriesDefaults();\n        var marker = __assign$c({}, seriesDefaults.marker);\n        if (marker.type) { // deprecated\n            marker.shape = marker.type;\n            delete marker.type;\n        }\n        options = options || this.chartOptions;\n        var agChartOptions = options;\n        var xAxisType = options.xAxis.type ? options.xAxis.type : 'category';\n        if (grouping) {\n            agChartOptions.type = 'groupedCategory';\n        }\n        agChartOptions.autoSize = true;\n        agChartOptions.axes = [__assign$c({ type: grouping ? 'groupedCategory' : xAxisType, position: 'bottom', paddingInner: 1, paddingOuter: 0 }, this.getXAxisDefaults(xAxisType, options)), __assign$c({ type: 'number', position: 'left' }, options.yAxis)];\n        agChartOptions.series = [__assign$c(__assign$c({}, seriesDefaults), { type: 'area', fills: seriesDefaults.fill.colors, fillOpacity: seriesDefaults.fill.opacity, strokes: seriesDefaults.stroke.colors, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, tooltip: {\n                    enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                    renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n                }, marker: marker })];\n        return AgChart.create(agChartOptions, parentElement);\n    };\n    AreaChartProxy.prototype.update = function (params) {\n        this.chartProxyParams.grouping = params.grouping;\n        var axisType = this.isTimeAxis(params) ? 'time' : 'category';\n        this.updateAxes(axisType);\n        if (this.chartType === agGridCommunity.ChartType.Area) {\n            // area charts have multiple series\n            this.updateAreaChart(params);\n        }\n        else {\n            // stacked and normalized has a single series\n            var areaSeries = this.chart.series[0];\n            if (!areaSeries) {\n                var seriesDefaults = this.getSeriesDefaults();\n                var marker = __assign$c({}, seriesDefaults.marker);\n                if (marker.type) { // deprecated\n                    marker.shape = marker.type;\n                    delete marker.type;\n                }\n                areaSeries = AgChart.createComponent(__assign$c(__assign$c({}, seriesDefaults), { fills: seriesDefaults.fill.colors, fillOpacity: seriesDefaults.fill.opacity, strokes: seriesDefaults.stroke.colors, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, marker: marker }), 'area.series');\n                if (areaSeries) {\n                    this.chart.addSeries(areaSeries);\n                }\n                else {\n                    return;\n                }\n            }\n            var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n            areaSeries.data = this.transformData(params.data, params.category.id);\n            areaSeries.xKey = params.category.id;\n            areaSeries.xName = params.category.name;\n            areaSeries.yKeys = params.fields.map(function (f) { return f.colId; });\n            areaSeries.yNames = params.fields.map(function (f) { return f.displayName; });\n            areaSeries.fills = fills;\n            areaSeries.strokes = strokes;\n        }\n        this.updateLabelRotation(params.category.id, false, axisType);\n    };\n    AreaChartProxy.prototype.updateAreaChart = function (params) {\n        var _this = this;\n        var chart = this.chart;\n        if (params.fields.length === 0) {\n            chart.removeAllSeries();\n            return;\n        }\n        var fieldIds = params.fields.map(function (f) { return f.colId; });\n        var existingSeriesById = chart.series\n            .reduceRight(function (map, series, i) {\n            var id = series.yKeys[0];\n            if (fieldIds.indexOf(id) === i) {\n                map.set(id, series);\n            }\n            else {\n                chart.removeSeries(series);\n            }\n            return map;\n        }, new Map());\n        var data = this.transformData(params.data, params.category.id);\n        var previousSeries;\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        params.fields.forEach(function (f, index) {\n            var _a = _this.processDataForCrossFiltering(data, f.colId, params), yKey = _a.yKey, atLeastOneSelectedPoint = _a.atLeastOneSelectedPoint;\n            var areaSeries = existingSeriesById.get(f.colId);\n            var fill = fills[index % fills.length];\n            var stroke = strokes[index % strokes.length];\n            if (areaSeries) {\n                areaSeries.data = data;\n                areaSeries.xKey = params.category.id;\n                areaSeries.xName = params.category.name;\n                areaSeries.yKeys = [yKey];\n                areaSeries.yNames = [f.displayName];\n                areaSeries.fills = [fill];\n                areaSeries.strokes = [stroke];\n            }\n            else {\n                var seriesDefaults = _this.getSeriesDefaults();\n                var marker = __assign$c({}, seriesDefaults.marker);\n                if (marker.type) { // deprecated\n                    marker.shape = marker.type;\n                    delete marker.type;\n                }\n                var options = __assign$c(__assign$c({}, seriesDefaults), { data: data, xKey: params.category.id, xName: params.category.name, yKeys: [yKey], yNames: [f.displayName], fills: [fill], strokes: [stroke], fillOpacity: seriesDefaults.fill.opacity, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, marker: marker });\n                areaSeries = AgChart.createComponent(options, 'area.series');\n                chart.addSeriesAfter(areaSeries, previousSeries);\n            }\n            _this.updateSeriesForCrossFiltering(areaSeries, f.colId, chart, params, atLeastOneSelectedPoint);\n            previousSeries = areaSeries;\n        });\n    };\n    AreaChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('area.series.area');\n        options.seriesDefaults = {\n            shadow: seriesDefaults.shadow,\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            marker: {\n                enabled: seriesDefaults.marker.enabled,\n                shape: seriesDefaults.marker.shape,\n                size: seriesDefaults.marker.size,\n                strokeWidth: seriesDefaults.marker.strokeWidth,\n                formatter: seriesDefaults.marker.formatter\n            },\n            lineDash: seriesDefaults.lineDash ? seriesDefaults.lineDash : [0],\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    AreaChartProxy.prototype.getDefaultOptions = function () {\n        var options = this.getDefaultCartesianChartOptions();\n        options.xAxis.label.rotation = 335;\n        options.seriesDefaults = __assign$c(__assign$c({}, options.seriesDefaults), { fill: __assign$c(__assign$c({}, options.seriesDefaults.fill), { opacity: this.chartType === agGridCommunity.ChartType.Area ? 0.7 : 1 }), stroke: __assign$c(__assign$c({}, options.seriesDefaults.stroke), { width: 3 }), marker: {\n                shape: 'circle',\n                enabled: true,\n                size: 6,\n                strokeWidth: 1,\n            }, tooltip: {\n                enabled: true,\n            }, shadow: this.getDefaultDropShadowOptions() });\n        return options;\n    };\n    AreaChartProxy.prototype.getSeriesDefaults = function () {\n        return __assign$c(__assign$c({}, this.chartOptions.seriesDefaults), { type: 'area', normalizedTo: this.chartType === agGridCommunity.ChartType.NormalizedArea ? 100 : undefined });\n    };\n    return AreaChartProxy;\n}(CartesianChartProxy));\n\nvar __extends$2n = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$d = (undefined && undefined.__assign) || function () {\n    __assign$d = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$d.apply(this, arguments);\n};\nvar LineChartProxy = /** @class */ (function (_super) {\n    __extends$2n(LineChartProxy, _super);\n    function LineChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    LineChartProxy.prototype.createChart = function (options) {\n        var _a = this.chartProxyParams, grouping = _a.grouping, parentElement = _a.parentElement;\n        options = options || this.chartOptions;\n        var agChartOptions = options;\n        agChartOptions.autoSize = true;\n        var xAxisType = options.xAxis.type ? options.xAxis.type : 'category';\n        if (grouping) {\n            agChartOptions.type = 'groupedCategory';\n        }\n        agChartOptions.axes = [__assign$d({ type: grouping ? 'groupedCategory' : xAxisType, position: 'bottom' }, this.getXAxisDefaults(xAxisType, options)), __assign$d({ type: 'number', position: 'left' }, options.yAxis)];\n        return AgChart.create(agChartOptions, parentElement);\n    };\n    LineChartProxy.prototype.update = function (params) {\n        var _this = this;\n        this.chartProxyParams.grouping = params.grouping;\n        if (params.fields.length === 0) {\n            this.chart.removeAllSeries();\n            return;\n        }\n        var axisType = this.isTimeAxis(params) ? 'time' : 'category';\n        this.updateAxes(axisType);\n        var chart = this.chart;\n        var fields = params.fields;\n        var fieldIds = fields.map(function (f) { return f.colId; });\n        var data = this.transformData(params.data, params.category.id);\n        var existingSeriesById = chart.series.reduceRight(function (map, series, i) {\n            var id = series.yKey;\n            if (fieldIds.indexOf(id) === i) {\n                map.set(id, series);\n            }\n            else {\n                chart.removeSeries(series);\n            }\n            return map;\n        }, new Map());\n        var previousSeries;\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        fields.forEach(function (f, index) {\n            var _a = _this.processDataForCrossFiltering(data, f.colId, params), yKey = _a.yKey, atLeastOneSelectedPoint = _a.atLeastOneSelectedPoint;\n            var lineSeries = existingSeriesById.get(f.colId);\n            var fill = fills[index % fills.length];\n            var stroke = strokes[index % strokes.length];\n            if (lineSeries) {\n                lineSeries.title = f.displayName;\n                lineSeries.data = data;\n                lineSeries.xKey = params.category.id;\n                lineSeries.xName = params.category.name;\n                lineSeries.yKey = yKey;\n                lineSeries.yName = f.displayName;\n                lineSeries.marker.fill = fill;\n                lineSeries.marker.stroke = stroke;\n                lineSeries.stroke = fill; // this is deliberate, so that the line colours match the fills of other series\n            }\n            else {\n                var seriesDefaults = _this.chartOptions.seriesDefaults;\n                var marker = __assign$d(__assign$d({}, seriesDefaults.marker), { fill: fill,\n                    stroke: stroke });\n                if (marker.type) { // deprecated\n                    marker.shape = marker.type;\n                    delete marker.type;\n                }\n                var options = __assign$d(__assign$d({}, seriesDefaults), { type: 'line', title: f.displayName, data: data, xKey: params.category.id, xName: params.category.name, yKey: yKey, yName: f.displayName, fill: fill, stroke: fill, fillOpacity: seriesDefaults.fill.opacity, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, tooltip: {\n                        enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                        renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled && seriesDefaults.tooltip.renderer,\n                    }, marker: marker });\n                lineSeries = AgChart.createComponent(options, 'line.series');\n                chart.addSeriesAfter(lineSeries, previousSeries);\n            }\n            _this.updateSeriesForCrossFiltering(lineSeries, f.colId, chart, params, atLeastOneSelectedPoint);\n            previousSeries = lineSeries;\n        });\n        this.updateLabelRotation(params.category.id, false, axisType);\n    };\n    LineChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('line.series.line');\n        options.seriesDefaults = {\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: [],\n                opacity: 1\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            marker: {\n                enabled: seriesDefaults.marker.enabled,\n                shape: seriesDefaults.marker.shape,\n                size: seriesDefaults.marker.size,\n                strokeWidth: seriesDefaults.marker.strokeWidth,\n                formatter: seriesDefaults.marker.formatter\n            },\n            lineDash: seriesDefaults.lineDash ? seriesDefaults.lineDash : [0],\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    LineChartProxy.prototype.getDefaultOptions = function () {\n        var options = this.getDefaultCartesianChartOptions();\n        options.xAxis.label.rotation = 335;\n        options.seriesDefaults = __assign$d(__assign$d({}, options.seriesDefaults), { stroke: __assign$d(__assign$d({}, options.seriesDefaults.stroke), { width: 3 }), marker: {\n                enabled: true,\n                shape: 'circle',\n                size: 6,\n                strokeWidth: 1,\n            }, tooltip: {\n                enabled: true,\n            } });\n        return options;\n    };\n    return LineChartProxy;\n}(CartesianChartProxy));\n\nvar __extends$2o = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar PolarChartProxy = /** @class */ (function (_super) {\n    __extends$2o(PolarChartProxy, _super);\n    function PolarChartProxy(params) {\n        return _super.call(this, params) || this;\n    }\n    PolarChartProxy.prototype.addCrossFilteringTooltipRenderer = function (pieSeries) {\n        pieSeries.tooltip.renderer = function (params) {\n            var label = params.datum[params.labelKey];\n            var ratio = params.datum[params.radiusKey];\n            var totalValue = params.angleValue;\n            var value = totalValue * ratio;\n            return {\n                content: label + \": \" + value,\n            };\n        };\n    };\n    return PolarChartProxy;\n}(ChartProxy));\n\nvar __extends$2p = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$e = (undefined && undefined.__assign) || function () {\n    __assign$e = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$e.apply(this, arguments);\n};\nvar PieChartProxy = /** @class */ (function (_super) {\n    __extends$2p(PieChartProxy, _super);\n    function PieChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    PieChartProxy.prototype.createChart = function (options) {\n        options = options || this.chartOptions;\n        var seriesDefaults = options.seriesDefaults;\n        var agChartOptions = options;\n        agChartOptions.autoSize = true;\n        agChartOptions.series = [__assign$e(__assign$e({}, seriesDefaults), { fills: seriesDefaults.fill.colors, fillOpacity: seriesDefaults.fill.opacity, strokes: seriesDefaults.stroke.colors, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, type: 'pie' })];\n        return AgChart.create(agChartOptions, this.chartProxyParams.parentElement);\n    };\n    PieChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('pie.series.pie');\n        options.seriesDefaults = {\n            title: seriesDefaults.title,\n            label: seriesDefaults.label,\n            callout: seriesDefaults.callout,\n            shadow: seriesDefaults.shadow,\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            lineDash: seriesDefaults.lineDash,\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    PieChartProxy.prototype.update = function (params) {\n        var chart = this.chart;\n        if (params.fields.length === 0) {\n            chart.removeAllSeries();\n            return;\n        }\n        var field = params.fields[0];\n        var angleField = field;\n        if (this.crossFiltering) {\n            // add additional filtered out field\n            var fields_1 = params.fields;\n            fields_1.forEach(function (field) {\n                var crossFilteringField = __assign$e({}, field);\n                crossFilteringField.colId = field.colId + '-filtered-out';\n                fields_1.push(crossFilteringField);\n            });\n            var filteredOutField_1 = fields_1[1];\n            params.data.forEach(function (d) {\n                d[field.colId + '-total'] = d[field.colId] + d[filteredOutField_1.colId];\n                d[field.colId] = d[field.colId] / d[field.colId + '-total'];\n                d[filteredOutField_1.colId] = 1;\n            });\n            var opaqueSeries = chart.series[1];\n            var radiusField = filteredOutField_1;\n            opaqueSeries = this.updateSeries(chart, opaqueSeries, angleField, radiusField, params, undefined);\n            radiusField = angleField;\n            var filteredSeries = chart.series[0];\n            this.updateSeries(chart, filteredSeries, angleField, radiusField, params, opaqueSeries);\n        }\n        else {\n            var series = chart.series[0];\n            this.updateSeries(chart, series, angleField, angleField, params, undefined);\n        }\n    };\n    PieChartProxy.prototype.updateSeries = function (chart, series, angleField, field, params, opaqueSeries) {\n        var _this = this;\n        var existingSeriesId = series && series.angleKey;\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        var seriesDefaults = this.chartOptions.seriesDefaults;\n        var pieSeries = series;\n        var calloutColors = seriesDefaults.callout && seriesDefaults.callout.colors;\n        if (existingSeriesId !== field.colId) {\n            chart.removeSeries(series);\n            pieSeries = AgChart.createComponent(__assign$e(__assign$e({}, seriesDefaults), { type: 'pie', angleKey: this.crossFiltering ? angleField.colId + '-total' : angleField.colId, radiusKey: this.crossFiltering ? field.colId : undefined, title: __assign$e(__assign$e({}, seriesDefaults.title), { text: seriesDefaults.title.text || params.fields[0].displayName }), fills: seriesDefaults.fill.colors, fillOpacity: seriesDefaults.fill.opacity, strokes: seriesDefaults.stroke.colors, strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, tooltip: {\n                    enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                    renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled && seriesDefaults.tooltip.renderer,\n                } }), 'pie.series');\n            if (this.crossFiltering && !pieSeries.tooltip.renderer) {\n                // only add renderer if user hasn't provided one\n                this.addCrossFilteringTooltipRenderer(pieSeries);\n            }\n        }\n        pieSeries.angleName = field.displayName;\n        pieSeries.labelKey = params.category.id;\n        pieSeries.labelName = params.category.name;\n        pieSeries.data = params.data;\n        if (this.crossFiltering) {\n            pieSeries.radiusMin = 0;\n            pieSeries.radiusMax = 1;\n            var isOpaqueSeries = !opaqueSeries;\n            if (isOpaqueSeries) {\n                pieSeries.fills = fills.map(function (fill) { return _this.hexToRGBA(fill, '0.3'); });\n                pieSeries.strokes = strokes.map(function (stroke) { return _this.hexToRGBA(stroke, '0.3'); });\n                pieSeries.showInLegend = false;\n            }\n            else {\n                chart.legend.addEventListener('click', function (event) {\n                    if (opaqueSeries) {\n                        opaqueSeries.toggleSeriesItem(event.itemId, event.enabled);\n                    }\n                });\n                pieSeries.fills = fills;\n                pieSeries.strokes = strokes;\n                if (calloutColors) {\n                    pieSeries.callout.colors = strokes;\n                }\n            }\n            chart.tooltip.delay = 500;\n            // disable series highlighting by default\n            pieSeries.highlightStyle.fill = undefined;\n            pieSeries.addEventListener(\"nodeClick\", this.crossFilterCallback);\n        }\n        else {\n            pieSeries.fills = fills;\n            pieSeries.strokes = strokes;\n            if (calloutColors) {\n                pieSeries.callout.colors = strokes;\n            }\n        }\n        chart.addSeries(pieSeries);\n        return pieSeries;\n    };\n    PieChartProxy.prototype.getDefaultOptions = function () {\n        var strokes = this.getPredefinedPalette().strokes;\n        var options = this.getDefaultChartOptions();\n        var fontOptions = this.getDefaultFontOptions();\n        options.seriesDefaults = __assign$e(__assign$e({}, options.seriesDefaults), { title: __assign$e(__assign$e({}, fontOptions), { enabled: false, fontSize: 12, fontWeight: 'bold' }), callout: {\n                colors: strokes,\n                length: 10,\n                strokeWidth: 2,\n            }, label: __assign$e(__assign$e({}, fontOptions), { enabled: false, offset: 3, minAngle: 0 }), tooltip: {\n                enabled: true,\n            }, shadow: this.getDefaultDropShadowOptions() });\n        return options;\n    };\n    return PieChartProxy;\n}(PolarChartProxy));\n\nvar __extends$2q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$f = (undefined && undefined.__assign) || function () {\n    __assign$f = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$f.apply(this, arguments);\n};\nvar DoughnutChartProxy = /** @class */ (function (_super) {\n    __extends$2q(DoughnutChartProxy, _super);\n    function DoughnutChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    DoughnutChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('pie.series.pie');\n        options.seriesDefaults = {\n            title: seriesDefaults.title,\n            label: seriesDefaults.label,\n            callout: seriesDefaults.callout,\n            shadow: seriesDefaults.shadow,\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            lineDash: seriesDefaults.lineDash,\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    DoughnutChartProxy.prototype.createChart = function (options) {\n        options = options || this.chartOptions;\n        var agChartOptions = options;\n        agChartOptions.type = 'pie';\n        agChartOptions.autoSize = true;\n        agChartOptions.series = [];\n        return AgChart.create(agChartOptions, this.chartProxyParams.parentElement);\n    };\n    DoughnutChartProxy.prototype.update = function (params) {\n        var _this = this;\n        if (params.fields.length === 0) {\n            this.chart.removeAllSeries();\n            return;\n        }\n        var doughnutChart = this.chart;\n        var fieldIds = params.fields.map(function (f) { return f.colId; });\n        var seriesMap = {};\n        doughnutChart.series.forEach(function (series) {\n            var pieSeries = series;\n            var id = pieSeries.angleKey;\n            if (agGridCommunity._.includes(fieldIds, id)) {\n                seriesMap[id] = pieSeries;\n            }\n        });\n        var seriesDefaults = this.chartOptions.seriesDefaults;\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        var numFields = params.fields.length;\n        var offset = 0;\n        if (this.crossFiltering) {\n            params.fields.forEach(function (field, index) {\n                var filteredOutField = __assign$f({}, field);\n                filteredOutField.colId = field.colId + '-filtered-out';\n                params.data.forEach(function (d) {\n                    d[field.colId + '-total'] = d[field.colId] + d[filteredOutField.colId];\n                    d[field.colId] = d[field.colId] / d[field.colId + '-total'];\n                    d[filteredOutField.colId] = 1;\n                });\n                var _a = _this.updateSeries({\n                    seriesMap: seriesMap,\n                    angleField: field,\n                    field: filteredOutField,\n                    seriesDefaults: seriesDefaults,\n                    index: index,\n                    params: params,\n                    fills: fills,\n                    strokes: strokes,\n                    doughnutChart: doughnutChart,\n                    offset: offset,\n                    numFields: numFields,\n                    opaqueSeries: undefined\n                }), updatedOffset = _a.updatedOffset, pieSeries = _a.pieSeries;\n                _this.updateSeries({\n                    seriesMap: seriesMap,\n                    angleField: field,\n                    field: field,\n                    seriesDefaults: seriesDefaults,\n                    index: index,\n                    params: params,\n                    fills: fills,\n                    strokes: strokes,\n                    doughnutChart: doughnutChart,\n                    offset: offset,\n                    numFields: numFields,\n                    opaqueSeries: pieSeries\n                });\n                offset = updatedOffset;\n            });\n        }\n        else {\n            params.fields.forEach(function (f, index) {\n                var updatedOffset = _this.updateSeries({\n                    seriesMap: seriesMap,\n                    angleField: f,\n                    field: f,\n                    seriesDefaults: seriesDefaults,\n                    index: index,\n                    params: params,\n                    fills: fills,\n                    strokes: strokes,\n                    doughnutChart: doughnutChart,\n                    offset: offset,\n                    numFields: numFields,\n                    opaqueSeries: undefined\n                }).updatedOffset;\n                offset = updatedOffset;\n            });\n        }\n        // Because repaints are automatic, it's important to remove/add/update series at once,\n        // so that we don't get painted twice.\n        doughnutChart.series = agGridCommunity._.values(seriesMap);\n    };\n    DoughnutChartProxy.prototype.updateSeries = function (updateParams) {\n        var _this = this;\n        var existingSeries = updateParams.seriesMap[updateParams.field.colId];\n        var seriesOptions = __assign$f(__assign$f({}, updateParams.seriesDefaults), { type: 'pie', angleKey: this.crossFiltering ? updateParams.angleField.colId + '-total' : updateParams.angleField.colId, radiusKey: this.crossFiltering ? updateParams.field.colId : undefined, showInLegend: updateParams.index === 0, title: __assign$f(__assign$f({}, updateParams.seriesDefaults.title), { text: updateParams.seriesDefaults.title.text || updateParams.field.displayName }), fills: updateParams.seriesDefaults.fill.colors, fillOpacity: updateParams.seriesDefaults.fill.opacity, strokes: updateParams.seriesDefaults.stroke.colors, strokeOpacity: updateParams.seriesDefaults.stroke.opacity, strokeWidth: updateParams.seriesDefaults.stroke.width, tooltip: {\n                enabled: updateParams.seriesDefaults.tooltip && updateParams.seriesDefaults.tooltip.enabled,\n                renderer: (updateParams.seriesDefaults.tooltip && updateParams.seriesDefaults.tooltip.enabled && updateParams.seriesDefaults.tooltip.renderer) || undefined,\n            } });\n        var calloutColors = seriesOptions.callout && seriesOptions.callout.colors;\n        var pieSeries = existingSeries || AgChart.createComponent(seriesOptions, 'pie.series');\n        if (!existingSeries) {\n            if (this.crossFiltering && !pieSeries.tooltip.renderer) {\n                // only add renderer if user hasn't provided one\n                this.addCrossFilteringTooltipRenderer(pieSeries);\n            }\n        }\n        pieSeries.angleName = updateParams.field.displayName;\n        pieSeries.labelKey = updateParams.params.category.id;\n        pieSeries.labelName = updateParams.params.category.name;\n        pieSeries.data = updateParams.params.data;\n        // Normally all series provide legend items for every slice.\n        // For our use case, where all series have the same number of slices in the same order with the same labels\n        // (all of which can be different in other use cases) we don't want to show repeating labels in the legend,\n        // so we only show legend items for the first series, and then when the user toggles the slices of the\n        // first series in the legend, we programmatically toggle the corresponding slices of other series.\n        if (updateParams.index === 0) {\n            pieSeries.toggleSeriesItem = function (itemId, enabled) {\n                if (updateParams.doughnutChart) {\n                    updateParams.doughnutChart.series.forEach(function (series) {\n                        series.seriesItemEnabled[itemId] = enabled;\n                    });\n                }\n                pieSeries.scheduleData();\n            };\n        }\n        if (this.crossFiltering) {\n            pieSeries.radiusMin = 0;\n            pieSeries.radiusMax = 1;\n            var isOpaqueSeries = !updateParams.opaqueSeries;\n            if (isOpaqueSeries) {\n                pieSeries.fills = updateParams.fills.map(function (fill) { return _this.hexToRGBA(fill, '0.3'); });\n                pieSeries.strokes = updateParams.strokes.map(function (stroke) { return _this.hexToRGBA(stroke, '0.3'); });\n                pieSeries.showInLegend = false;\n            }\n            else {\n                updateParams.doughnutChart.legend.addEventListener('click', function (event) {\n                    if (updateParams.opaqueSeries) {\n                        updateParams.opaqueSeries.toggleSeriesItem(event.itemId, event.enabled);\n                    }\n                });\n                pieSeries.fills = updateParams.fills;\n                pieSeries.strokes = updateParams.strokes;\n                if (calloutColors) {\n                    pieSeries.callout.colors = updateParams.strokes;\n                }\n            }\n            // disable series highlighting by default\n            pieSeries.highlightStyle.fill = undefined;\n            pieSeries.addEventListener(\"nodeClick\", this.crossFilterCallback);\n            updateParams.doughnutChart.tooltip.delay = 500;\n        }\n        else {\n            pieSeries.fills = updateParams.fills;\n            pieSeries.strokes = updateParams.strokes;\n            if (calloutColors) {\n                pieSeries.callout.colors = updateParams.strokes;\n            }\n        }\n        var offsetAmount = updateParams.numFields > 1 ? 20 : 40;\n        pieSeries.outerRadiusOffset = updateParams.offset;\n        updateParams.offset -= offsetAmount;\n        pieSeries.innerRadiusOffset = updateParams.offset;\n        updateParams.offset -= offsetAmount;\n        if (!existingSeries) {\n            updateParams.seriesMap[updateParams.field.colId] = pieSeries;\n        }\n        return { updatedOffset: updateParams.offset, pieSeries: pieSeries };\n    };\n    DoughnutChartProxy.prototype.getDefaultOptions = function () {\n        var strokes = this.getPredefinedPalette().strokes;\n        var options = this.getDefaultChartOptions();\n        var fontOptions = this.getDefaultFontOptions();\n        options.seriesDefaults = __assign$f(__assign$f({}, options.seriesDefaults), { title: __assign$f(__assign$f({}, fontOptions), { enabled: true, fontSize: 12, fontWeight: 'bold' }), callout: {\n                colors: strokes,\n                length: 10,\n                strokeWidth: 2,\n            }, label: __assign$f(__assign$f({}, fontOptions), { enabled: false, offset: 3, minAngle: 0 }), tooltip: {\n                enabled: true,\n            }, shadow: this.getDefaultDropShadowOptions() });\n        return options;\n    };\n    return DoughnutChartProxy;\n}(PolarChartProxy));\n\nvar __extends$2r = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$g = (undefined && undefined.__assign) || function () {\n    __assign$g = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$g.apply(this, arguments);\n};\nvar HistogramChartProxy = /** @class */ (function (_super) {\n    __extends$2r(HistogramChartProxy, _super);\n    function HistogramChartProxy(params) {\n        var _this = _super.call(this, params) || this;\n        _this.initChartOptions();\n        _this.recreateChart();\n        return _this;\n    }\n    HistogramChartProxy.prototype.getDefaultOptionsFromTheme = function (theme) {\n        var options = _super.prototype.getDefaultOptionsFromTheme.call(this, theme);\n        var seriesDefaults = theme.getConfig('histogram.series.histogram');\n        options.seriesDefaults = {\n            shadow: this.getDefaultDropShadowOptions(),\n            label: seriesDefaults.label,\n            tooltip: {\n                enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                renderer: seriesDefaults.tooltip && seriesDefaults.tooltip.renderer\n            },\n            fill: {\n                colors: theme.palette.fills,\n                opacity: seriesDefaults.fillOpacity\n            },\n            stroke: {\n                colors: theme.palette.strokes,\n                opacity: seriesDefaults.strokeOpacity,\n                width: seriesDefaults.strokeWidth\n            },\n            lineDash: seriesDefaults.lineDash ? seriesDefaults.lineDash : [0],\n            lineDashOffset: seriesDefaults.lineDashOffset,\n            highlightStyle: seriesDefaults.highlightStyle,\n            listeners: seriesDefaults.listeners\n        };\n        return options;\n    };\n    HistogramChartProxy.prototype.createChart = function (options) {\n        var parentElement = this.chartProxyParams.parentElement;\n        var seriesDefaults = this.getSeriesDefaults();\n        options = options || this.chartOptions;\n        var agChartOptions = options;\n        agChartOptions.autoSize = true;\n        agChartOptions.axes = [__assign$g({ type: 'number', position: 'bottom' }, options.xAxis), __assign$g({ type: 'number', position: 'left' }, options.yAxis)];\n        agChartOptions.series = [__assign$g(__assign$g({}, seriesDefaults), { fill: seriesDefaults.fill.colors[0], fillOpacity: seriesDefaults.fill.opacity, stroke: seriesDefaults.stroke.colors[0], strokeOpacity: seriesDefaults.stroke.opacity, strokeWidth: seriesDefaults.stroke.width, tooltip: {\n                    enabled: seriesDefaults.tooltip && seriesDefaults.tooltip.enabled,\n                    renderer: (seriesDefaults.tooltip && seriesDefaults.tooltip.enabled && seriesDefaults.tooltip.renderer) || undefined,\n                }, type: 'histogram' })];\n        return AgChart.create(agChartOptions, parentElement);\n    };\n    HistogramChartProxy.prototype.update = function (params) {\n        var xField = params.fields[0];\n        var chart = this.chart;\n        var series = chart.series[0];\n        series.data = params.data;\n        series.xKey = xField.colId;\n        series.xName = xField.displayName;\n        // for now, only constant width is supported via integrated charts\n        series.areaPlot = false;\n        var _a = this.getPalette(), fills = _a.fills, strokes = _a.strokes;\n        series.fill = fills[0];\n        series.stroke = strokes[0];\n    };\n    HistogramChartProxy.prototype.getDefaultOptions = function () {\n        var fontOptions = this.getDefaultFontOptions();\n        var options = this.getDefaultCartesianChartOptions();\n        options.xAxis.label.rotation = 0;\n        options.yAxis.label.rotation = 0;\n        options.seriesDefaults = __assign$g(__assign$g({}, options.seriesDefaults), { tooltip: {\n                enabled: true,\n            }, label: __assign$g(__assign$g({}, fontOptions), { enabled: false }), shadow: this.getDefaultDropShadowOptions(), binCount: 10 });\n        return options;\n    };\n    HistogramChartProxy.prototype.getSeriesDefaults = function () {\n        return __assign$g({}, this.chartOptions.seriesDefaults);\n    };\n    return HistogramChartProxy;\n}(CartesianChartProxy));\n\nvar __extends$2s = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar GridChartComp = /** @class */ (function (_super) {\n    __extends$2s(GridChartComp, _super);\n    function GridChartComp(params) {\n        var _this = _super.call(this, GridChartComp.TEMPLATE) || this;\n        _this.params = params;\n        return _this;\n    }\n    GridChartComp.prototype.init = function () {\n        var availableChartThemes = this.gridOptionsWrapper.getChartThemes();\n        if (availableChartThemes.length < 1) {\n            throw new Error('Cannot create chart: no chart themes are available to be used.');\n        }\n        var chartThemeName = this.params.chartThemeName;\n        if (!agGridCommunity._.includes(availableChartThemes, chartThemeName)) {\n            chartThemeName = availableChartThemes[0];\n        }\n        var modelParams = {\n            pivotChart: this.params.pivotChart,\n            chartType: this.params.chartType,\n            chartThemeName: chartThemeName,\n            aggFunc: this.params.aggFunc,\n            cellRange: this.params.cellRange,\n            suppressChartRanges: this.params.suppressChartRanges,\n            unlinkChart: this.params.unlinkChart,\n            crossFiltering: this.params.crossFiltering,\n        };\n        var isRtl = this.gridOptionsWrapper.isEnableRtl();\n        agGridCommunity._.addCssClass(this.getGui(), isRtl ? 'ag-rtl' : 'ag-ltr');\n        this.model = this.createBean(new ChartDataModel(modelParams));\n        this.chartController = this.createManagedBean(new ChartController(this.model));\n        this.validateCustomThemes();\n        // create chart before dialog to ensure dialog is correct size\n        this.createChart();\n        if (this.params.insideDialog) {\n            this.addDialog();\n        }\n        this.addMenu();\n        this.addTitleEditComp();\n        this.addManagedListener(this.getGui(), 'focusin', this.setActiveChartCellRange.bind(this));\n        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, this.refresh.bind(this));\n        if (this.chartMenu) {\n            // chart menu may not exist, i.e. cross filtering\n            this.addManagedListener(this.chartMenu, ChartMenu.EVENT_DOWNLOAD_CHART, this.downloadChart.bind(this));\n        }\n        this.refresh();\n        this.raiseChartCreatedEvent();\n    };\n    GridChartComp.prototype.validateCustomThemes = function () {\n        var suppliedThemes = this.gridOptionsWrapper.getChartThemes();\n        var customChartThemes = this.gridOptionsWrapper.getCustomChartThemes();\n        if (customChartThemes) {\n            agGridCommunity._.getAllKeysInObjects([customChartThemes]).forEach(function (customThemeName) {\n                if (!agGridCommunity._.includes(suppliedThemes, customThemeName)) {\n                    console.warn(\"AG Grid: a custom chart theme with the name '\" + customThemeName + \"' has been \" +\n                        \"supplied but not added to the 'chartThemes' list\");\n                }\n            });\n        }\n    };\n    GridChartComp.prototype.createChart = function () {\n        var _this = this;\n        var width, height;\n        // if chart already exists, destroy it and remove it from DOM\n        if (this.chartProxy) {\n            var chart = this.chartProxy.getChart();\n            if (chart) {\n                // preserve existing width/height\n                width = chart.width;\n                height = chart.height;\n            }\n            this.chartProxy.destroy();\n        }\n        var processChartOptionsFunc = this.params.processChartOptions || this.gridOptionsWrapper.getProcessChartOptionsFunc();\n        var customChartThemes = this.gridOptionsWrapper.getCustomChartThemes();\n        var chartType = this.model.getChartType();\n        var isGrouping = this.model.isGrouping();\n        var crossFilterCallback = function (event, reset) {\n            var ctx = _this.params.crossFilteringContext;\n            ctx.lastSelectedChartId = reset ? '' : _this.model.getChartId();\n            _this.crossFilter.filter(event, reset);\n        };\n        var chartProxyParams = {\n            chartId: this.model.getChartId(),\n            chartType: chartType,\n            chartThemeName: this.model.getChartThemeName(),\n            processChartOptions: processChartOptionsFunc,\n            getChartThemeName: this.getChartThemeName.bind(this),\n            getChartThemes: this.getChartThemes.bind(this),\n            customChartThemes: customChartThemes,\n            getGridOptionsChartThemeOverrides: this.getGridOptionsChartThemeOverrides.bind(this),\n            apiChartThemeOverrides: this.params.chartThemeOverrides,\n            allowPaletteOverride: !this.params.chartThemeName,\n            isDarkTheme: this.environment.isThemeDark.bind(this.environment),\n            crossFiltering: this.params.crossFiltering,\n            crossFilterCallback: crossFilterCallback,\n            parentElement: this.eChart,\n            width: width,\n            height: height,\n            grouping: isGrouping,\n            document: this.gridOptionsWrapper.getDocument(),\n            eventService: this.eventService,\n            gridApi: this.gridApi,\n            columnApi: this.columnApi,\n        };\n        // set local state used to detect when chart changes\n        this.chartType = chartType;\n        this.chartThemeName = this.model.getChartThemeName();\n        this.chartProxy = GridChartComp.createChartProxy(chartProxyParams);\n        if (!this.chartProxy) {\n            console.warn('AG Grid: invalid chart type supplied: ', chartProxyParams.chartType);\n            return;\n        }\n        this.titleEdit && this.titleEdit.setChartProxy(this.chartProxy);\n        var canvas = this.eChart.querySelector('canvas');\n        if (canvas) {\n            agGridCommunity._.addCssClass(canvas, 'ag-charts-canvas');\n        }\n        this.chartController.setChartProxy(this.chartProxy);\n    };\n    GridChartComp.prototype.getChartThemeName = function () {\n        return this.chartController.getThemeName();\n    };\n    GridChartComp.prototype.getChartThemes = function () {\n        return this.chartController.getThemes();\n    };\n    GridChartComp.prototype.getGridOptionsChartThemeOverrides = function () {\n        return this.gridOptionsWrapper.getChartThemeOverrides();\n    };\n    GridChartComp.createChartProxy = function (chartProxyParams) {\n        switch (chartProxyParams.chartType) {\n            case agGridCommunity.ChartType.Column:\n            case agGridCommunity.ChartType.Bar:\n            case agGridCommunity.ChartType.GroupedColumn:\n            case agGridCommunity.ChartType.StackedColumn:\n            case agGridCommunity.ChartType.NormalizedColumn:\n            case agGridCommunity.ChartType.GroupedBar:\n            case agGridCommunity.ChartType.StackedBar:\n            case agGridCommunity.ChartType.NormalizedBar:\n                return new BarChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Pie:\n                return new PieChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Doughnut:\n                return new DoughnutChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Area:\n            case agGridCommunity.ChartType.StackedArea:\n            case agGridCommunity.ChartType.NormalizedArea:\n                return new AreaChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Line:\n                return new LineChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Scatter:\n            case agGridCommunity.ChartType.Bubble:\n                return new ScatterChartProxy(chartProxyParams);\n            case agGridCommunity.ChartType.Histogram:\n                return new HistogramChartProxy(chartProxyParams);\n        }\n    };\n    GridChartComp.prototype.addDialog = function () {\n        var _this = this;\n        var title = this.chartTranslator.translate(this.params.pivotChart ? 'pivotChartTitle' : 'rangeChartTitle');\n        var _a = this.getBestDialogSize(), width = _a.width, height = _a.height;\n        this.chartDialog = new agGridCommunity.AgDialog({\n            resizable: true,\n            movable: true,\n            maximizable: true,\n            title: title,\n            width: width,\n            height: height,\n            component: this,\n            centered: true,\n            closable: true\n        });\n        this.getContext().createBean(this.chartDialog);\n        this.chartDialog.addEventListener(agGridCommunity.AgDialog.EVENT_DESTROYED, function () { return _this.destroy(); });\n    };\n    GridChartComp.prototype.getBestDialogSize = function () {\n        var popupParent = this.popupService.getPopupParent();\n        var maxWidth = agGridCommunity._.getAbsoluteWidth(popupParent) * 0.75;\n        var maxHeight = agGridCommunity._.getAbsoluteHeight(popupParent) * 0.75;\n        var ratio = 0.553;\n        var _a = this.chartProxy.getChartOptions(), width = _a.width, height = _a.height;\n        if (width && height) {\n            return { width: width, height: height };\n        }\n        var chart = this.chartProxy.getChart();\n        width = this.params.insideDialog ? 850 : chart.width;\n        height = this.params.insideDialog ? 470 : chart.height;\n        if (width > maxWidth || height > maxHeight) {\n            width = Math.min(width, maxWidth);\n            height = Math.round(width * ratio);\n            if (height > maxHeight) {\n                height = maxHeight;\n                width = Math.min(width, Math.round(height / ratio));\n            }\n        }\n        return { width: width, height: height };\n    };\n    GridChartComp.prototype.addMenu = function () {\n        if (!this.params.crossFiltering) {\n            this.chartMenu = this.createBean(new ChartMenu(this.eChartContainer, this.eMenuContainer, this.chartController));\n            this.eChartContainer.appendChild(this.chartMenu.getGui());\n        }\n    };\n    GridChartComp.prototype.addTitleEditComp = function () {\n        this.titleEdit = this.createBean(new TitleEdit(this.chartMenu));\n        this.eTitleEditContainer.appendChild(this.titleEdit.getGui());\n        if (this.chartProxy) {\n            this.titleEdit.setChartProxy(this.chartProxy);\n        }\n    };\n    GridChartComp.prototype.refresh = function () {\n        if (this.shouldRecreateChart()) {\n            this.createChart();\n        }\n        this.updateChart();\n    };\n    GridChartComp.prototype.shouldRecreateChart = function () {\n        return this.chartType !== this.model.getChartType() || this.chartThemeName !== this.model.getChartThemeName();\n    };\n    GridChartComp.prototype.getCurrentChartType = function () {\n        return this.chartType;\n    };\n    GridChartComp.prototype.getChartModel = function () {\n        return this.chartController.getChartModel();\n    };\n    GridChartComp.prototype.updateChart = function () {\n        var _this = this;\n        var _a = this, model = _a.model, chartProxy = _a.chartProxy;\n        var selectedCols = model.getSelectedValueColState();\n        var fields = selectedCols.map(function (c) { return ({ colId: c.colId, displayName: c.displayName }); });\n        var data = model.getData();\n        var chartEmpty = this.handleEmptyChart(data, fields);\n        if (chartEmpty) {\n            return;\n        }\n        var selectedDimension = model.getSelectedDimension();\n        var chartUpdateParams = {\n            data: data,\n            grouping: model.isGrouping(),\n            category: {\n                id: selectedDimension.colId,\n                name: selectedDimension.displayName,\n                chartDataType: this.getChartDataType(selectedDimension.colId)\n            },\n            fields: fields,\n            chartId: this.model.getChartId(),\n            getCrossFilteringContext: function () { return _this.params.crossFilteringContext; },\n        };\n        chartProxy.update(chartUpdateParams);\n        this.titleEdit.setChartProxy(this.chartProxy);\n    };\n    GridChartComp.prototype.getChartDataType = function (colId) {\n        var column = this.columnController.getPrimaryColumn(colId);\n        return column ? column.getColDef().chartDataType : undefined;\n    };\n    GridChartComp.prototype.handleEmptyChart = function (data, fields) {\n        var container = this.chartProxy.getChart().container;\n        var pivotModeDisabled = this.model.isPivotChart() && !this.model.isPivotMode();\n        var minFieldsRequired = 1;\n        if (this.chartController.isActiveXYChart()) {\n            minFieldsRequired = this.model.getChartType() === agGridCommunity.ChartType.Bubble ? 3 : 2;\n        }\n        var isEmptyChart = fields.length < minFieldsRequired || data.length === 0;\n        if (container) {\n            var isEmpty = pivotModeDisabled || isEmptyChart;\n            agGridCommunity._.setDisplayed(this.eChart, !isEmpty);\n            agGridCommunity._.setDisplayed(this.eEmpty, isEmpty);\n        }\n        if (pivotModeDisabled) {\n            this.eEmpty.innerText = this.chartTranslator.translate('pivotChartRequiresPivotMode');\n            return true;\n        }\n        if (isEmptyChart) {\n            this.eEmpty.innerText = this.chartTranslator.translate('noDataToChart');\n            return true;\n        }\n        return false;\n    };\n    GridChartComp.prototype.downloadChart = function () {\n        this.chartProxy.downloadChart();\n    };\n    GridChartComp.prototype.getUnderlyingChart = function () {\n        return this.chartProxy.getChart();\n    };\n    GridChartComp.prototype.refreshCanvasSize = function () {\n        if (!this.params.insideDialog) {\n            return;\n        }\n        var _a = this, chartProxy = _a.chartProxy, eChart = _a.eChart;\n        if (this.chartMenu.isVisible()) {\n            // we don't want the menu showing to affect the chart options\n            var chart = this.chartProxy.getChart();\n            chart.height = agGridCommunity._.getInnerHeight(eChart);\n            chart.width = agGridCommunity._.getInnerWidth(eChart);\n        }\n        else {\n            chartProxy.setChartOption('width', agGridCommunity._.getInnerWidth(eChart));\n            chartProxy.setChartOption('height', agGridCommunity._.getInnerHeight(eChart));\n        }\n    };\n    GridChartComp.prototype.setActiveChartCellRange = function (focusEvent) {\n        if (this.getGui().contains(focusEvent.relatedTarget)) {\n            return;\n        }\n        this.chartController.setChartRange(true);\n        this.gridApi.focusController.clearFocusedCell();\n    };\n    GridChartComp.prototype.raiseChartCreatedEvent = function () {\n        var chartModel = this.chartController.getChartModel();\n        var event = Object.freeze({\n            type: agGridCommunity.Events.EVENT_CHART_CREATED,\n            chartId: chartModel.chartId,\n            chartModel: chartModel,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n        });\n        this.eventService.dispatchEvent(event);\n    };\n    GridChartComp.prototype.raiseChartDestroyedEvent = function () {\n        var event = Object.freeze({\n            type: agGridCommunity.Events.EVENT_CHART_DESTROYED,\n            chartId: this.model.getChartId(),\n            api: this.gridApi,\n            columnApi: this.columnApi,\n        });\n        this.eventService.dispatchEvent(event);\n    };\n    GridChartComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.chartProxy) {\n            this.chartProxy.destroy();\n        }\n        this.destroyBean(this.chartMenu);\n        // don't want to invoke destroy() on the Dialog (prevents destroy loop)\n        if (this.chartDialog && this.chartDialog.isAlive()) {\n            this.destroyBean(this.chartDialog);\n        }\n        // if the user is providing containers for the charts, we need to clean up, otherwise the old chart\n        // data will still be visible although the chart is no longer bound to the grid\n        var eGui = this.getGui();\n        agGridCommunity._.clearElement(eGui);\n        // remove from parent, so if user provided container, we detach from the provided dom element\n        agGridCommunity._.removeFromParent(eGui);\n        this.raiseChartDestroyedEvent();\n    };\n    GridChartComp.TEMPLATE = \"<div class=\\\"ag-chart\\\" tabindex=\\\"-1\\\">\\n            <div ref=\\\"eChartContainer\\\" tabindex=\\\"-1\\\" class=\\\"ag-chart-components-wrapper\\\">\\n                <div ref=\\\"eChart\\\" class=\\\"ag-chart-canvas-wrapper\\\"></div>\\n                <div ref=\\\"eEmpty\\\" class=\\\"ag-chart-empty-text ag-unselectable\\\"></div>\\n            </div>\\n            <div ref=\\\"eTitleEditContainer\\\"></div>\\n            <div ref=\\\"eMenuContainer\\\" class=\\\"ag-chart-docked-container\\\"></div>\\n        </div>\";\n    __decorate$1l([\n        agGridCommunity.RefSelector('eChart')\n    ], GridChartComp.prototype, \"eChart\", void 0);\n    __decorate$1l([\n        agGridCommunity.RefSelector('eChartContainer')\n    ], GridChartComp.prototype, \"eChartContainer\", void 0);\n    __decorate$1l([\n        agGridCommunity.RefSelector('eMenuContainer')\n    ], GridChartComp.prototype, \"eMenuContainer\", void 0);\n    __decorate$1l([\n        agGridCommunity.RefSelector('eEmpty')\n    ], GridChartComp.prototype, \"eEmpty\", void 0);\n    __decorate$1l([\n        agGridCommunity.RefSelector('eTitleEditContainer')\n    ], GridChartComp.prototype, \"eTitleEditContainer\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('environment')\n    ], GridChartComp.prototype, \"environment\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('chartTranslator')\n    ], GridChartComp.prototype, \"chartTranslator\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('columnController')\n    ], GridChartComp.prototype, \"columnController\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('chartCrossFilter')\n    ], GridChartComp.prototype, \"crossFilter\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('gridApi')\n    ], GridChartComp.prototype, \"gridApi\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('columnApi')\n    ], GridChartComp.prototype, \"columnApi\", void 0);\n    __decorate$1l([\n        agGridCommunity.Autowired('popupService')\n    ], GridChartComp.prototype, \"popupService\", void 0);\n    __decorate$1l([\n        agGridCommunity.PostConstruct\n    ], GridChartComp.prototype, \"init\", null);\n    return GridChartComp;\n}(agGridCommunity.Component));\n\nvar __extends$2t = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartService = /** @class */ (function (_super) {\n    __extends$2t(ChartService, _super);\n    function ChartService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // we destroy all charts bound to this grid when grid is destroyed. activeCharts contains all charts, including\n        // those in developer provided containers.\n        _this.activeCharts = new Set();\n        _this.activeChartComps = new Set();\n        // this shared (singleton) context is used by cross filtering in line and area charts\n        _this.crossFilteringContext = {\n            lastSelectedChartId: '',\n        };\n        return _this;\n    }\n    ChartService.prototype.getChartModels = function () {\n        var models = [];\n        this.activeChartComps.forEach(function (c) { return models.push(c.getChartModel()); });\n        return models;\n    };\n    ChartService.prototype.createChartFromCurrentRange = function (chartType) {\n        if (chartType === void 0) { chartType = agGridCommunity.ChartType.GroupedColumn; }\n        var selectedRange = this.getSelectedRange();\n        return this.createChart(selectedRange, chartType);\n    };\n    ChartService.prototype.restoreChart = function (model, chartContainer) {\n        if (!model) {\n            console.warn(\"AG Grid - unable to restore chart as no chart model is provided\");\n            return;\n        }\n        if (model.modelType && model.modelType === 'pivot') {\n            return this.createPivotChart(this.mapToPivotParams(model, chartContainer));\n        }\n        return this.createRangeChart(this.mapToRangeParam(model, chartContainer));\n    };\n    ChartService.prototype.createRangeChart = function (params) {\n        var cellRange = this.rangeController\n            ? this.rangeController.createCellRangeFromCellRangeParams(params.cellRange)\n            : undefined;\n        if (!cellRange) {\n            console.warn(\"AG Grid - unable to create chart as no range is selected\");\n            return;\n        }\n        return this.createChart(cellRange, params.chartType, params.chartThemeName, false, params.suppressChartRanges, params.chartContainer, params.aggFunc, params.chartThemeOverrides, params.unlinkChart, params.processChartOptions);\n    };\n    ChartService.prototype.createPivotChart = function (params) {\n        // if required enter pivot mode\n        if (!this.columnController.isPivotMode()) {\n            this.columnController.setPivotMode(true, \"pivotChart\");\n        }\n        // pivot chart range contains all visible column without a row range to include all rows\n        var chartAllRangeParams = {\n            rowStartIndex: null,\n            rowEndIndex: null,\n            columns: this.columnController.getAllDisplayedColumns().map(function (col) { return col.getColId(); })\n        };\n        var cellRange = this.rangeController\n            ? this.rangeController.createCellRangeFromCellRangeParams(chartAllRangeParams)\n            : undefined;\n        if (!cellRange) {\n            console.warn(\"AG Grid - unable to create chart as there are no columns in the grid.\");\n            return;\n        }\n        return this.createChart(cellRange, params.chartType, params.chartThemeName, true, true, params.chartContainer, undefined, params.chartThemeOverrides, params.unlinkChart, params.processChartOptions);\n    };\n    ChartService.prototype.createCrossFilterChart = function (params) {\n        var cellRange = this.rangeController\n            ? this.rangeController.createCellRangeFromCellRangeParams(params.cellRange)\n            : undefined;\n        if (!cellRange) {\n            console.warn(\"AG Grid - unable to create chart as no range is selected\");\n            return;\n        }\n        var crossFiltering = true;\n        var suppressChartRangesSupplied = typeof params.suppressChartRanges !== 'undefined' && params.suppressChartRanges !== null;\n        var suppressChartRanges = suppressChartRangesSupplied ? params.suppressChartRanges : true;\n        return this.createChart(cellRange, params.chartType, params.chartThemeName, false, suppressChartRanges, params.chartContainer, params.aggFunc, params.chartThemeOverrides, params.unlinkChart, undefined, crossFiltering);\n    };\n    ChartService.prototype.createChart = function (cellRange, chartType, chartThemeName, pivotChart, suppressChartRanges, container, aggFunc, chartThemeOverrides, unlinkChart, processChartOptions, crossFiltering) {\n        var _this = this;\n        if (pivotChart === void 0) { pivotChart = false; }\n        if (suppressChartRanges === void 0) { suppressChartRanges = false; }\n        if (unlinkChart === void 0) { unlinkChart = false; }\n        if (crossFiltering === void 0) { crossFiltering = false; }\n        var createChartContainerFunc = this.gridOptionsWrapper.getCreateChartContainerFunc();\n        var params = {\n            pivotChart: pivotChart,\n            cellRange: cellRange,\n            chartType: chartType,\n            chartThemeName: chartThemeName,\n            insideDialog: !(container || createChartContainerFunc),\n            suppressChartRanges: suppressChartRanges,\n            aggFunc: aggFunc,\n            chartThemeOverrides: chartThemeOverrides,\n            processChartOptions: processChartOptions,\n            unlinkChart: unlinkChart,\n            crossFiltering: crossFiltering,\n            crossFilteringContext: this.crossFilteringContext\n        };\n        var chartComp = new GridChartComp(params);\n        this.context.createBean(chartComp);\n        var chartRef = this.createChartRef(chartComp);\n        if (container) {\n            // if container exists, means developer initiated chart create via API, so place in provided container\n            container.appendChild(chartComp.getGui());\n            // if the chart container was placed outside of an element that\n            // has the grid's theme, we manually add the current theme to\n            // make sure all styles for the chartMenu are rendered correctly\n            var theme = this.environment.getTheme();\n            if (theme.el && !theme.el.contains(container)) {\n                agGridCommunity._.addCssClass(container, theme.theme);\n            }\n        }\n        else if (createChartContainerFunc) {\n            // otherwise user created chart via grid UI, check if developer provides containers (eg if the application\n            // is using its own dialogs rather than the grid provided dialogs)\n            createChartContainerFunc(chartRef);\n        }\n        else {\n            // add listener to remove from active charts list when charts are destroyed, e.g. closing chart dialog\n            chartComp.addEventListener(GridChartComp.EVENT_DESTROYED, function () {\n                _this.activeChartComps.delete(chartComp);\n                _this.activeCharts.delete(chartRef);\n            });\n        }\n        return chartRef;\n    };\n    ChartService.prototype.createChartRef = function (chartComp) {\n        var _this = this;\n        var chartRef = {\n            destroyChart: function () {\n                if (_this.activeCharts.has(chartRef)) {\n                    _this.context.destroyBean(chartComp);\n                    _this.activeChartComps.delete(chartComp);\n                    _this.activeCharts.delete(chartRef);\n                }\n            },\n            chartElement: chartComp.getGui(),\n            chart: chartComp.getUnderlyingChart()\n        };\n        this.activeCharts.add(chartRef);\n        this.activeChartComps.add(chartComp);\n        return chartRef;\n    };\n    ChartService.prototype.getSelectedRange = function () {\n        var ranges = this.rangeController.getCellRanges();\n        return ranges.length > 0 ? ranges[0] : {};\n    };\n    ChartService.prototype.mapToRangeParam = function (model, chartContainer) {\n        return {\n            cellRange: model.cellRange,\n            chartType: model.chartType,\n            chartThemeName: model.chartThemeName,\n            chartContainer: chartContainer,\n            suppressChartRanges: model.suppressChartRanges,\n            aggFunc: model.aggFunc,\n            unlinkChart: model.unlinkChart,\n            processChartOptions: function () { return model.chartOptions; }\n        };\n    };\n    ChartService.prototype.mapToPivotParams = function (model, chartContainer) {\n        return {\n            chartType: model.chartType,\n            chartThemeName: model.chartThemeName,\n            chartContainer: chartContainer,\n            unlinkChart: model.unlinkChart,\n            processChartOptions: function () { return model.chartOptions; }\n        };\n    };\n    ChartService.prototype.destroyAllActiveCharts = function () {\n        this.activeCharts.forEach(function (chart) { return chart.destroyChart(); });\n    };\n    __decorate$1m([\n        agGridCommunity.Optional('rangeController')\n    ], ChartService.prototype, \"rangeController\", void 0);\n    __decorate$1m([\n        agGridCommunity.Autowired('columnController')\n    ], ChartService.prototype, \"columnController\", void 0);\n    __decorate$1m([\n        agGridCommunity.Autowired('environment')\n    ], ChartService.prototype, \"environment\", void 0);\n    __decorate$1m([\n        agGridCommunity.PreDestroy\n    ], ChartService.prototype, \"destroyAllActiveCharts\", null);\n    ChartService = __decorate$1m([\n        agGridCommunity.Bean('chartService')\n    ], ChartService);\n    return ChartService;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2u = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartTranslator = /** @class */ (function (_super) {\n    __extends$2u(ChartTranslator, _super);\n    function ChartTranslator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChartTranslator_1 = ChartTranslator;\n    ChartTranslator.prototype.translate = function (toTranslate) {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        var defaultTranslation = ChartTranslator_1.DEFAULT_TRANSLATIONS[toTranslate];\n        return translate(toTranslate, defaultTranslation);\n    };\n    var ChartTranslator_1;\n    ChartTranslator.DEFAULT_TRANSLATIONS = {\n        pivotChartTitle: 'Pivot Chart',\n        rangeChartTitle: 'Range Chart',\n        settings: 'Settings',\n        data: 'Data',\n        format: 'Format',\n        categories: 'Categories',\n        defaultCategory: '(None)',\n        series: 'Series',\n        xyValues: 'X Y Values',\n        paired: 'Paired Mode',\n        axis: 'Axis',\n        navigator: 'Navigator',\n        color: 'Color',\n        thickness: 'Thickness',\n        xType: 'X Type',\n        automatic: 'Automatic',\n        category: 'Category',\n        number: 'Number',\n        time: 'Time',\n        xRotation: 'X Rotation',\n        yRotation: 'Y Rotation',\n        ticks: 'Ticks',\n        width: 'Width',\n        height: 'Height',\n        length: 'Length',\n        padding: 'Padding',\n        spacing: 'Spacing',\n        chart: 'Chart',\n        title: 'Title',\n        titlePlaceholder: 'Chart title - double click to edit',\n        background: 'Background',\n        font: 'Font',\n        top: 'Top',\n        right: 'Right',\n        bottom: 'Bottom',\n        left: 'Left',\n        labels: 'Labels',\n        size: 'Size',\n        shape: 'Shape',\n        minSize: 'Minimum Size',\n        maxSize: 'Maximum Size',\n        legend: 'Legend',\n        position: 'Position',\n        markerSize: 'Marker Size',\n        markerStroke: 'Marker Stroke',\n        markerPadding: 'Marker Padding',\n        itemSpacing: 'Item Spacing',\n        itemPaddingX: 'Item Padding X',\n        itemPaddingY: 'Item Padding Y',\n        layoutHorizontalSpacing: 'Horizontal Spacing',\n        layoutVerticalSpacing: 'Vertical Spacing',\n        strokeWidth: 'Stroke Width',\n        offset: 'Offset',\n        offsets: 'Offsets',\n        tooltips: 'Tooltips',\n        callout: 'Callout',\n        markers: 'Markers',\n        shadow: 'Shadow',\n        blur: 'Blur',\n        xOffset: 'X Offset',\n        yOffset: 'Y Offset',\n        lineWidth: 'Line Width',\n        lineDash: 'Line Dash',\n        normal: 'Normal',\n        bold: 'Bold',\n        italic: 'Italic',\n        boldItalic: 'Bold Italic',\n        predefined: 'Predefined',\n        fillOpacity: 'Fill Opacity',\n        strokeOpacity: 'Line Opacity',\n        histogramBinCount: 'Bin count',\n        columnGroup: 'Column',\n        barGroup: 'Bar',\n        pieGroup: 'Pie',\n        lineGroup: 'Line',\n        scatterGroup: 'X Y (Scatter)',\n        areaGroup: 'Area',\n        histogramGroup: 'Histogram',\n        groupedColumnTooltip: 'Grouped',\n        stackedColumnTooltip: 'Stacked',\n        normalizedColumnTooltip: '100% Stacked',\n        groupedBarTooltip: 'Grouped',\n        stackedBarTooltip: 'Stacked',\n        normalizedBarTooltip: '100% Stacked',\n        pieTooltip: 'Pie',\n        doughnutTooltip: 'Doughnut',\n        lineTooltip: 'Line',\n        groupedAreaTooltip: 'Area',\n        stackedAreaTooltip: 'Stacked',\n        normalizedAreaTooltip: '100% Stacked',\n        scatterTooltip: 'Scatter',\n        bubbleTooltip: 'Bubble',\n        histogramTooltip: 'Histogram',\n        noDataToChart: 'No data available to be charted.',\n        pivotChartRequiresPivotMode: 'Pivot Chart requires Pivot Mode enabled.',\n        chartSettingsToolbarTooltip: 'Menu',\n        chartLinkToolbarTooltip: 'Linked to Grid',\n        chartUnlinkToolbarTooltip: 'Unlinked from Grid',\n        chartDownloadToolbarTooltip: 'Download Chart',\n    };\n    ChartTranslator = ChartTranslator_1 = __decorate$1n([\n        agGridCommunity.Bean(\"chartTranslator\")\n    ], ChartTranslator);\n    return ChartTranslator;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2v = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ChartCrossFilter = /** @class */ (function (_super) {\n    __extends$2v(ChartCrossFilter, _super);\n    function ChartCrossFilter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChartCrossFilter_1 = ChartCrossFilter;\n    ChartCrossFilter.prototype.filter = function (event, reset) {\n        if (reset === void 0) { reset = false; }\n        var filterModel = this.gridApi.getFilterModel();\n        // filters should be reset when user clicks on canvas background\n        if (reset) {\n            this.resetFilters(filterModel);\n            return;\n        }\n        var colId = ChartCrossFilter_1.extractFilterColId(event);\n        if (this.isValidColumnFilter(colId)) {\n            // update filters based on current chart selections\n            this.updateFilters(filterModel, event);\n        }\n        else {\n            console.warn(\"AG Grid: cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' \" +\n                \"to be defined on the column with id: '\" + colId + \"'\");\n        }\n    };\n    ChartCrossFilter.prototype.resetFilters = function (filterModel) {\n        var filtersExist = Object.keys(filterModel).length > 0;\n        if (filtersExist) {\n            // only reset filters / charts when necessary to prevent undesirable flickering effect\n            this.gridApi.setFilterModel(null);\n            this.gridApi.onFilterChanged();\n        }\n    };\n    ChartCrossFilter.prototype.updateFilters = function (filterModel, event) {\n        var _a;\n        var dataKey = ChartCrossFilter_1.extractFilterColId(event);\n        var rawValue = event.datum[dataKey];\n        if (rawValue === undefined) {\n            return;\n        }\n        var selectedValue = rawValue.toString();\n        var filterColId = dataKey.replace('-filtered-out', '');\n        if (event.event.metaKey || event.event.ctrlKey) {\n            var existingGridValues = this.getCurrentGridValuesForCategory(filterColId);\n            var valueAlreadyExists = agGridCommunity._.includes(existingGridValues, selectedValue);\n            var updatedValues = void 0;\n            if (valueAlreadyExists) {\n                updatedValues = existingGridValues.filter(function (v) { return v !== selectedValue; });\n            }\n            else {\n                updatedValues = existingGridValues;\n                updatedValues.push(selectedValue);\n            }\n            filterModel[filterColId] = this.getUpdatedFilterModel(filterColId, updatedValues);\n        }\n        else {\n            var updatedValues = [selectedValue];\n            filterModel = (_a = {}, _a[filterColId] = this.getUpdatedFilterModel(filterColId, updatedValues), _a);\n        }\n        this.gridApi.setFilterModel(filterModel);\n    };\n    ChartCrossFilter.prototype.getUpdatedFilterModel = function (colId, updatedValues) {\n        var columnFilterType = this.getColumnFilterType(colId);\n        if (columnFilterType === 'agMultiColumnFilter') {\n            return { filterType: 'multi', filterModels: [null, { filterType: 'set', values: updatedValues }] };\n        }\n        return { filterType: 'set', values: updatedValues };\n    };\n    ChartCrossFilter.prototype.getCurrentGridValuesForCategory = function (dataKey) {\n        var filteredValues = [];\n        var gridContainsValue = agGridCommunity._.includes;\n        this.gridApi.forEachNodeAfterFilter(function (rowNode) {\n            if (!rowNode.group) {\n                var value = rowNode.data[dataKey] + '';\n                if (!gridContainsValue(filteredValues, value)) {\n                    filteredValues.push(value);\n                }\n            }\n        });\n        return filteredValues;\n    };\n    ChartCrossFilter.extractFilterColId = function (event) {\n        return event.xKey ? event.xKey : event.labelKey;\n    };\n    ChartCrossFilter.prototype.isValidColumnFilter = function (colId) {\n        if (colId.indexOf('-filtered-out')) {\n            colId = colId.replace('-filtered-out', '');\n        }\n        var filterType = this.getColumnFilterType(colId);\n        if (typeof filterType === 'boolean') {\n            return filterType;\n        }\n        return agGridCommunity._.includes(['agSetColumnFilter', 'agMultiColumnFilter'], filterType);\n    };\n    ChartCrossFilter.prototype.getColumnFilterType = function (colId) {\n        var gridColumn = this.columnController.getGridColumn(colId);\n        return gridColumn ? gridColumn.getColDef().filter : undefined;\n    };\n    var ChartCrossFilter_1;\n    __decorate$1o([\n        agGridCommunity.Autowired('gridApi')\n    ], ChartCrossFilter.prototype, \"gridApi\", void 0);\n    __decorate$1o([\n        agGridCommunity.Autowired('columnController')\n    ], ChartCrossFilter.prototype, \"columnController\", void 0);\n    ChartCrossFilter = ChartCrossFilter_1 = __decorate$1o([\n        agGridCommunity.Bean(\"chartCrossFilter\")\n    ], ChartCrossFilter);\n    return ChartCrossFilter;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2w = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays$7 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar RangeController = /** @class */ (function (_super) {\n    __extends$2w(RangeController, _super);\n    function RangeController() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.cellRanges = [];\n        _this.bodyScrollListener = _this.onBodyScroll.bind(_this);\n        _this.dragging = false;\n        return _this;\n    }\n    RangeController.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n        this.autoScrollService = new AutoScrollService(this.gridPanel, this.gridOptionsWrapper);\n    };\n    RangeController.prototype.init = function () {\n        this.logger = this.loggerFactory.create('RangeController');\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.removeAllCellRanges.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.removeAllCellRanges.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.removeAllCellRanges.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGED, this.removeAllCellRanges.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_GROUP_OPENED, this.refreshLastRangeStart.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_MOVED, this.refreshLastRangeStart.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PINNED, this.refreshLastRangeStart.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_VISIBLE, this.onColumnVisibleChange.bind(this));\n    };\n    RangeController.prototype.onColumnVisibleChange = function () {\n        var _this = this;\n        // first move start column in last cell range (i.e. series chart range)\n        this.refreshLastRangeStart();\n        // then check if the column visibility has changed in any cell range\n        this.cellRanges.forEach(function (cellRange) {\n            var beforeCols = cellRange.columns;\n            // remove hidden cols from cell range\n            cellRange.columns = cellRange.columns.filter(function (col) { return col.isVisible(); });\n            var colsInRangeChanged = !agGridCommunity._.areEqual(beforeCols, cellRange.columns);\n            if (colsInRangeChanged) {\n                // notify users and other parts of grid (i.e. status panel) that range has changed\n                _this.dispatchChangedEvent(false, true, cellRange.id);\n            }\n        });\n    };\n    RangeController.prototype.refreshLastRangeStart = function () {\n        var lastRange = agGridCommunity._.last(this.cellRanges);\n        if (!lastRange) {\n            return;\n        }\n        this.refreshRangeStart(lastRange);\n    };\n    RangeController.prototype.isContiguousRange = function (cellRange) {\n        var rangeColumns = cellRange.columns;\n        if (!rangeColumns.length) {\n            return false;\n        }\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var allPositions = rangeColumns.map(function (c) { return allColumns.indexOf(c); }).sort(function (a, b) { return a - b; });\n        return agGridCommunity._.last(allPositions) - allPositions[0] + 1 === rangeColumns.length;\n    };\n    RangeController.prototype.getRangeStartRow = function (cellRange) {\n        if (cellRange.startRow && cellRange.endRow) {\n            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow) ?\n                cellRange.startRow : cellRange.endRow;\n        }\n        var rowPinned = this.pinnedRowModel.getPinnedTopRowCount() > 0 ? agGridCommunity.Constants.PINNED_TOP : undefined;\n        return { rowIndex: 0, rowPinned: rowPinned };\n    };\n    RangeController.prototype.getRangeEndRow = function (cellRange) {\n        if (cellRange.startRow && cellRange.endRow) {\n            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow) ?\n                cellRange.endRow : cellRange.startRow;\n        }\n        var pinnedBottomRowCount = this.pinnedRowModel.getPinnedBottomRowCount();\n        var pinnedBottom = pinnedBottomRowCount > 0;\n        if (pinnedBottom) {\n            return {\n                rowIndex: pinnedBottomRowCount - 1,\n                rowPinned: agGridCommunity.Constants.PINNED_BOTTOM\n            };\n        }\n        return {\n            rowIndex: this.rowModel.getRowCount() - 1,\n            rowPinned: undefined\n        };\n    };\n    RangeController.prototype.setRangeToCell = function (cell, appendRange) {\n        if (appendRange === void 0) { appendRange = false; }\n        if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n            return;\n        }\n        var columns = this.calculateColumnsBetween(cell.column, cell.column);\n        if (!columns) {\n            return;\n        }\n        var suppressMultiRangeSelections = this.gridOptionsWrapper.isSuppressMultiRangeSelection();\n        // if not appending, then clear previous range selections\n        if (suppressMultiRangeSelections || !appendRange || agGridCommunity._.missing(this.cellRanges)) {\n            this.removeAllCellRanges(true);\n        }\n        var rowForCell = {\n            rowIndex: cell.rowIndex,\n            rowPinned: cell.rowPinned\n        };\n        // if there is already a range for this cell, then we reuse the same range, otherwise the user\n        // can ctrl & click a cell many times and hit ctrl+c, which would result in the cell getting copied\n        // many times to the clipboard.\n        var cellRange;\n        for (var i = 0; i < this.cellRanges.length; i++) {\n            var range = this.cellRanges[i];\n            var matches = \n            // check cols are same\n            (range.columns && range.columns.length === 1 && range.columns[0] === cell.column) &&\n                // check rows are same\n                this.rowPositionUtils.sameRow(rowForCell, range.startRow) &&\n                this.rowPositionUtils.sameRow(rowForCell, range.endRow);\n            if (matches) {\n                cellRange = range;\n                break;\n            }\n        }\n        if (cellRange) {\n            // we need it at the end of the list, as the dragStart picks the last created\n            // range as the start point for the drag\n            if (agGridCommunity._.last(this.cellRanges) !== cellRange) {\n                agGridCommunity._.removeFromArray(this.cellRanges, cellRange);\n                this.cellRanges.push(cellRange);\n            }\n        }\n        else {\n            cellRange = {\n                startRow: rowForCell,\n                endRow: rowForCell,\n                columns: columns,\n                startColumn: cell.column\n            };\n            this.cellRanges.push(cellRange);\n        }\n        this.newestRangeStartCell = cell;\n        this.onDragStop();\n        this.dispatchChangedEvent(true, true, cellRange.id);\n    };\n    RangeController.prototype.extendLatestRangeToCell = function (cellPosition) {\n        if (this.isEmpty() || !this.newestRangeStartCell) {\n            return;\n        }\n        var cellRange = agGridCommunity._.last(this.cellRanges);\n        this.updateRangeEnd(cellRange, cellPosition);\n    };\n    RangeController.prototype.updateRangeEnd = function (cellRange, cellPosition, silent) {\n        if (silent === void 0) { silent = false; }\n        var endColumn = cellPosition.column;\n        var colsToAdd = this.calculateColumnsBetween(cellRange.startColumn, endColumn);\n        if (!colsToAdd || this.isLastCellOfRange(cellRange, cellPosition)) {\n            return;\n        }\n        cellRange.columns = colsToAdd;\n        cellRange.endRow = { rowIndex: cellPosition.rowIndex, rowPinned: cellPosition.rowPinned };\n        if (!silent) {\n            this.dispatchChangedEvent(true, true, cellRange.id);\n        }\n    };\n    RangeController.prototype.refreshRangeStart = function (cellRange) {\n        var startColumn = cellRange.startColumn, columns = cellRange.columns;\n        var moveColInCellRange = function (colToMove, moveToFront) {\n            var otherCols = cellRange.columns.filter(function (col) { return col !== colToMove; });\n            if (colToMove) {\n                cellRange.startColumn = colToMove;\n                cellRange.columns = moveToFront ? __spreadArrays$7([colToMove], otherCols) : __spreadArrays$7(otherCols, [colToMove]);\n            }\n            else {\n                cellRange.columns = otherCols;\n            }\n        };\n        var _a = this.getRangeEdgeColumns(cellRange), left = _a.left, right = _a.right;\n        var shouldMoveLeftCol = startColumn === columns[0] && startColumn !== left;\n        if (shouldMoveLeftCol) {\n            moveColInCellRange(left, true);\n            return;\n        }\n        var shouldMoveRightCol = startColumn === agGridCommunity._.last(columns) && startColumn === right;\n        if (shouldMoveRightCol) {\n            moveColInCellRange(right, false);\n            return;\n        }\n    };\n    RangeController.prototype.getRangeEdgeColumns = function (cellRange) {\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var allIndices = cellRange.columns\n            .map(function (c) { return allColumns.indexOf(c); })\n            .filter(function (i) { return i > -1; })\n            .sort(function (a, b) { return a - b; });\n        return {\n            left: allColumns[allIndices[0]],\n            right: allColumns[agGridCommunity._.last(allIndices)]\n        };\n    };\n    // returns true if successful, false if not successful\n    RangeController.prototype.extendLatestRangeInDirection = function (key) {\n        if (this.isEmpty() || !this.newestRangeStartCell) {\n            return;\n        }\n        var lastRange = agGridCommunity._.last(this.cellRanges);\n        var startCell = this.newestRangeStartCell;\n        var firstCol = lastRange.columns[0];\n        var lastCol = agGridCommunity._.last(lastRange.columns);\n        // find the cell that is at the furthest away corner from the starting cell\n        var endCellIndex = lastRange.endRow.rowIndex;\n        var endCellFloating = lastRange.endRow.rowPinned;\n        var endCellColumn = startCell.column === firstCol ? lastCol : firstCol;\n        var endCell = { column: endCellColumn, rowIndex: endCellIndex, rowPinned: endCellFloating };\n        var newEndCell = this.cellNavigationService.getNextCellToFocus(key, endCell);\n        // if user is at end of grid, so no cell to extend to, we return false\n        if (!newEndCell) {\n            return;\n        }\n        this.setCellRange({\n            rowStartIndex: startCell.rowIndex,\n            rowStartPinned: startCell.rowPinned,\n            rowEndIndex: newEndCell.rowIndex,\n            rowEndPinned: newEndCell.rowPinned,\n            columnStart: startCell.column,\n            columnEnd: newEndCell.column\n        });\n        return newEndCell;\n    };\n    RangeController.prototype.setCellRange = function (params) {\n        if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n            return;\n        }\n        this.removeAllCellRanges(true);\n        this.addCellRange(params);\n    };\n    RangeController.prototype.setCellRanges = function (cellRanges) {\n        var _this = this;\n        if (agGridCommunity._.shallowCompare(this.cellRanges, cellRanges)) {\n            return;\n        }\n        this.removeAllCellRanges(true);\n        cellRanges.forEach(function (newRange) {\n            if (newRange.columns && newRange.startRow) {\n                _this.newestRangeStartCell = {\n                    rowIndex: newRange.startRow.rowIndex,\n                    rowPinned: newRange.startRow.rowPinned,\n                    column: newRange.columns[0]\n                };\n            }\n            _this.cellRanges.push(newRange);\n        });\n        this.dispatchChangedEvent(false, true);\n    };\n    RangeController.prototype.createCellRangeFromCellRangeParams = function (params) {\n        var _this = this;\n        var columns;\n        if (params.columns) {\n            columns = params.columns.map(function (c) { return _this.columnController.getColumnWithValidation(c); }).filter(function (c) { return c; });\n        }\n        else {\n            var columnStart = this.columnController.getColumnWithValidation(params.columnStart);\n            var columnEnd = this.columnController.getColumnWithValidation(params.columnEnd);\n            if (!columnStart || !columnEnd) {\n                return;\n            }\n            columns = this.calculateColumnsBetween(columnStart, columnEnd);\n        }\n        if (!columns) {\n            return;\n        }\n        var startRow = params.rowStartIndex != null ? {\n            rowIndex: params.rowStartIndex,\n            rowPinned: params.rowStartPinned\n        } : undefined;\n        var endRow = params.rowEndIndex != null ? {\n            rowIndex: params.rowEndIndex,\n            rowPinned: params.rowEndPinned\n        } : undefined;\n        return {\n            startRow: startRow,\n            endRow: endRow,\n            columns: columns,\n            startColumn: columns[0]\n        };\n    };\n    RangeController.prototype.addCellRange = function (params) {\n        if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n            return;\n        }\n        var newRange = this.createCellRangeFromCellRangeParams(params);\n        if (newRange) {\n            this.cellRanges.push(newRange);\n            this.dispatchChangedEvent(false, true, newRange.id);\n        }\n    };\n    RangeController.prototype.getCellRanges = function () {\n        return this.cellRanges;\n    };\n    RangeController.prototype.isEmpty = function () {\n        return this.cellRanges.length === 0;\n    };\n    RangeController.prototype.isMoreThanOneCell = function () {\n        if (this.cellRanges.length === 0) {\n            // no ranges, so not more than one cell\n            return false;\n        }\n        else if (this.cellRanges.length > 1) {\n            // many ranges, so more than one cell\n            return true;\n        }\n        // only one range, return true if range has more than one\n        var range = this.cellRanges[0];\n        var startRow = this.getRangeStartRow(range);\n        var endRow = this.getRangeEndRow(range);\n        return startRow.rowPinned !== endRow.rowPinned ||\n            startRow.rowIndex !== endRow.rowIndex ||\n            range.columns.length !== 1;\n    };\n    RangeController.prototype.removeAllCellRanges = function (silent) {\n        if (this.isEmpty()) {\n            return;\n        }\n        this.onDragStop();\n        this.cellRanges.length = 0;\n        if (!silent) {\n            this.dispatchChangedEvent(false, true);\n        }\n    };\n    // as the user is dragging outside of the panel, the div starts to scroll, which in turn\n    // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate\n    // the selection my mimicking a new mouse event\n    RangeController.prototype.onBodyScroll = function () {\n        this.onDragging(this.lastMouseEvent);\n    };\n    RangeController.prototype.isCellInAnyRange = function (cell) {\n        return this.getCellRangeCount(cell) > 0;\n    };\n    RangeController.prototype.isCellInSpecificRange = function (cell, range) {\n        var columnInRange = range.columns !== null && agGridCommunity._.includes(range.columns, cell.column);\n        var rowInRange = this.isRowInRange(cell.rowIndex, cell.rowPinned, range);\n        return columnInRange && rowInRange;\n    };\n    RangeController.prototype.isLastCellOfRange = function (cellRange, cell) {\n        var startRow = cellRange.startRow, endRow = cellRange.endRow;\n        var lastRow = this.rowPositionUtils.before(startRow, endRow) ? endRow : startRow;\n        var isLastRow = cell.rowIndex === lastRow.rowIndex && cell.rowPinned === lastRow.rowPinned;\n        var rangeFirstIndexColumn = cellRange.columns[0];\n        var rangeLastIndexColumn = agGridCommunity._.last(cellRange.columns);\n        var lastRangeColumn = cellRange.startColumn === rangeFirstIndexColumn ? rangeLastIndexColumn : rangeFirstIndexColumn;\n        var isLastColumn = cell.column === lastRangeColumn;\n        return isLastColumn && isLastRow;\n    };\n    RangeController.prototype.isBottomRightCell = function (cellRange, cell) {\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var allPositions = cellRange.columns.map(function (c) { return allColumns.indexOf(c); }).sort(function (a, b) { return a - b; });\n        var startRow = cellRange.startRow, endRow = cellRange.endRow;\n        var lastRow = this.rowPositionUtils.before(startRow, endRow) ? endRow : startRow;\n        var isRightColumn = allColumns.indexOf(cell.column) === agGridCommunity._.last(allPositions);\n        var isLastRow = cell.rowIndex === lastRow.rowIndex && agGridCommunity._.makeNull(cell.rowPinned) === agGridCommunity._.makeNull(lastRow.rowPinned);\n        return isRightColumn && isLastRow;\n    };\n    // returns the number of ranges this cell is in\n    RangeController.prototype.getCellRangeCount = function (cell) {\n        var _this = this;\n        if (this.isEmpty()) {\n            return 0;\n        }\n        return this.cellRanges.filter(function (cellRange) { return _this.isCellInSpecificRange(cell, cellRange); }).length;\n    };\n    RangeController.prototype.isRowInRange = function (rowIndex, floating, cellRange) {\n        var firstRow = this.getRangeStartRow(cellRange);\n        var lastRow = this.getRangeEndRow(cellRange);\n        var thisRow = { rowIndex: rowIndex, rowPinned: floating };\n        // compare rowPinned with == instead of === because it can be `null` or `undefined`\n        var equalsFirstRow = thisRow.rowIndex === firstRow.rowIndex && thisRow.rowPinned == firstRow.rowPinned;\n        var equalsLastRow = thisRow.rowIndex === lastRow.rowIndex && thisRow.rowPinned == lastRow.rowPinned;\n        if (equalsFirstRow || equalsLastRow) {\n            return true;\n        }\n        var afterFirstRow = !this.rowPositionUtils.before(thisRow, firstRow);\n        var beforeLastRow = this.rowPositionUtils.before(thisRow, lastRow);\n        return afterFirstRow && beforeLastRow;\n    };\n    RangeController.prototype.getDraggingRange = function () {\n        return this.draggingRange;\n    };\n    RangeController.prototype.onDragStart = function (mouseEvent) {\n        if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n            return;\n        }\n        var ctrlKey = mouseEvent.ctrlKey, metaKey = mouseEvent.metaKey, shiftKey = mouseEvent.shiftKey;\n        // ctrlKey for windows, metaKey for Apple\n        var multiKeyPressed = ctrlKey || metaKey;\n        var allowMulti = !this.gridOptionsWrapper.isSuppressMultiRangeSelection();\n        var multiSelectKeyPressed = allowMulti ? multiKeyPressed : false;\n        var mouseCell = this.mouseEventService.getCellPositionForEvent(mouseEvent);\n        var extendRange = shiftKey && agGridCommunity._.existsAndNotEmpty(this.cellRanges);\n        if (agGridCommunity._.missing(mouseCell)) {\n            // if drag wasn't on cell, then do nothing, including do not set dragging=true,\n            // (which them means onDragging and onDragStop do nothing)\n            return;\n        }\n        if (!multiSelectKeyPressed && (!extendRange || agGridCommunity._.exists(agGridCommunity._.last(this.cellRanges).type))) {\n            this.removeAllCellRanges(true);\n        }\n        this.dragging = true;\n        this.draggingCell = mouseCell;\n        this.lastMouseEvent = mouseEvent;\n        if (!extendRange) {\n            this.newestRangeStartCell = mouseCell;\n        }\n        // if we didn't clear the ranges, then dragging means the user clicked, and when the\n        // user clicks it means a range of one cell was created. we need to extend this range\n        // rather than creating another range. otherwise we end up with two distinct ranges\n        // from a drag operation (one from click, and one from drag).\n        if (this.cellRanges.length > 0) {\n            this.draggingRange = agGridCommunity._.last(this.cellRanges);\n        }\n        else {\n            var mouseRowPosition = {\n                rowIndex: mouseCell.rowIndex,\n                rowPinned: mouseCell.rowPinned\n            };\n            this.draggingRange = {\n                startRow: mouseRowPosition,\n                endRow: mouseRowPosition,\n                columns: [mouseCell.column],\n                startColumn: this.newestRangeStartCell.column\n            };\n            this.cellRanges.push(this.draggingRange);\n        }\n        this.gridPanel.addScrollEventListener(this.bodyScrollListener);\n        this.dispatchChangedEvent(true, false, this.draggingRange.id);\n    };\n    RangeController.prototype.onDragging = function (mouseEvent) {\n        var _this = this;\n        if (!this.dragging || !mouseEvent) {\n            return;\n        }\n        this.lastMouseEvent = mouseEvent;\n        var cellPosition = this.mouseEventService.getCellPositionForEvent(mouseEvent);\n        var isMouseAndStartInPinned = function (position) {\n            return cellPosition && cellPosition.rowPinned === position && _this.newestRangeStartCell.rowPinned === position;\n        };\n        var skipVerticalScroll = isMouseAndStartInPinned('top') || isMouseAndStartInPinned('bottom');\n        this.autoScrollService.check(mouseEvent, skipVerticalScroll);\n        if (!cellPosition ||\n            !this.draggingCell ||\n            this.cellPositionUtils.equals(this.draggingCell, cellPosition)) {\n            return;\n        }\n        var columns = this.calculateColumnsBetween(this.newestRangeStartCell.column, cellPosition.column);\n        if (!columns) {\n            return;\n        }\n        this.draggingCell = cellPosition;\n        this.draggingRange.endRow = {\n            rowIndex: cellPosition.rowIndex,\n            rowPinned: cellPosition.rowPinned\n        };\n        this.draggingRange.columns = columns;\n        this.dispatchChangedEvent(false, false, this.draggingRange.id);\n    };\n    RangeController.prototype.onDragStop = function () {\n        if (!this.dragging) {\n            return;\n        }\n        var id = this.draggingRange.id;\n        this.autoScrollService.ensureCleared();\n        this.gridPanel.removeScrollEventListener(this.bodyScrollListener);\n        this.lastMouseEvent = null;\n        this.dragging = false;\n        this.draggingRange = undefined;\n        this.draggingCell = undefined;\n        this.dispatchChangedEvent(false, true, id);\n    };\n    RangeController.prototype.dispatchChangedEvent = function (started, finished, id) {\n        var event = Object.freeze({\n            type: agGridCommunity.Events.EVENT_RANGE_SELECTION_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            started: started,\n            finished: finished,\n            id: id,\n        });\n        this.eventService.dispatchEvent(event);\n    };\n    RangeController.prototype.calculateColumnsBetween = function (columnFrom, columnTo) {\n        var allColumns = this.columnController.getAllDisplayedColumns();\n        var isSameColumn = columnFrom === columnTo;\n        var fromIndex = allColumns.indexOf(columnFrom);\n        if (fromIndex < 0) {\n            console.warn(\"AG Grid: column \" + columnFrom.getId() + \" is not visible\");\n            return;\n        }\n        var toIndex = isSameColumn ? fromIndex : allColumns.indexOf(columnTo);\n        if (toIndex < 0) {\n            console.warn(\"AG Grid: column \" + columnTo.getId() + \" is not visible\");\n            return;\n        }\n        if (isSameColumn) {\n            return [columnFrom];\n        }\n        var firstIndex = Math.min(fromIndex, toIndex);\n        var lastIndex = firstIndex === fromIndex ? toIndex : fromIndex;\n        var columns = [];\n        for (var i = firstIndex; i <= lastIndex; i++) {\n            columns.push(allColumns[i]);\n        }\n        return columns;\n    };\n    __decorate$1p([\n        agGridCommunity.Autowired('loggerFactory')\n    ], RangeController.prototype, \"loggerFactory\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('rowModel')\n    ], RangeController.prototype, \"rowModel\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('columnController')\n    ], RangeController.prototype, \"columnController\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('mouseEventService')\n    ], RangeController.prototype, \"mouseEventService\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('columnApi')\n    ], RangeController.prototype, \"columnApi\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('gridApi')\n    ], RangeController.prototype, \"gridApi\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('cellNavigationService')\n    ], RangeController.prototype, \"cellNavigationService\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired(\"pinnedRowModel\")\n    ], RangeController.prototype, \"pinnedRowModel\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('rowPositionUtils')\n    ], RangeController.prototype, \"rowPositionUtils\", void 0);\n    __decorate$1p([\n        agGridCommunity.Autowired('cellPositionUtils')\n    ], RangeController.prototype, \"cellPositionUtils\", void 0);\n    __decorate$1p([\n        agGridCommunity.PostConstruct\n    ], RangeController.prototype, \"init\", null);\n    RangeController = __decorate$1p([\n        agGridCommunity.Bean('rangeController')\n    ], RangeController);\n    return RangeController;\n}(agGridCommunity.BeanStub));\nvar AutoScrollService = /** @class */ (function () {\n    function AutoScrollService(gridPanel, gridOptionsWrapper) {\n        this.tickingInterval = null;\n        this.gridPanel = gridPanel;\n        this.gridOptionsWrapper = gridOptionsWrapper;\n    }\n    AutoScrollService.prototype.check = function (mouseEvent, skipVerticalScroll) {\n        if (skipVerticalScroll === void 0) { skipVerticalScroll = false; }\n        var rect = this.gridPanel.getBodyClientRect();\n        skipVerticalScroll = skipVerticalScroll || this.gridOptionsWrapper.getDomLayout() !== agGridCommunity.Constants.DOM_LAYOUT_NORMAL;\n        // we don't do ticking if grid is auto height unless we have a horizontal scroller\n        if (skipVerticalScroll && !this.gridPanel.isHorizontalScrollShowing()) {\n            return;\n        }\n        this.tickLeft = mouseEvent.clientX < (rect.left + 20);\n        this.tickRight = mouseEvent.clientX > (rect.right - 20);\n        this.tickUp = mouseEvent.clientY < (rect.top + 20) && !skipVerticalScroll;\n        this.tickDown = mouseEvent.clientY > (rect.bottom - 20) && !skipVerticalScroll;\n        if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {\n            this.ensureTickingStarted();\n        }\n        else {\n            this.ensureCleared();\n        }\n    };\n    AutoScrollService.prototype.ensureTickingStarted = function () {\n        if (this.tickingInterval === null) {\n            this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);\n            this.tickCount = 0;\n        }\n    };\n    AutoScrollService.prototype.doTick = function () {\n        this.tickCount++;\n        var vScrollPosition = this.gridPanel.getVScrollPosition();\n        var hScrollPosition = this.gridPanel.getHScrollPosition();\n        var tickAmount;\n        tickAmount = this.tickCount > 20 ? 200 : (this.tickCount > 10 ? 80 : 40);\n        if (this.tickUp) {\n            this.gridPanel.setVerticalScrollPosition(vScrollPosition.top - tickAmount);\n        }\n        if (this.tickDown) {\n            this.gridPanel.setVerticalScrollPosition(vScrollPosition.top + tickAmount);\n        }\n        if (this.tickLeft) {\n            this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left - tickAmount);\n        }\n        if (this.tickRight) {\n            this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left + tickAmount);\n        }\n    };\n    AutoScrollService.prototype.ensureCleared = function () {\n        if (this.tickingInterval) {\n            window.clearInterval(this.tickingInterval);\n            this.tickingInterval = null;\n        }\n    };\n    return AutoScrollService;\n}());\n\nvar __extends$2x = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AbstractSelectionHandle = /** @class */ (function (_super) {\n    __extends$2x(AbstractSelectionHandle, _super);\n    function AbstractSelectionHandle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.changedCalculatedValues = false;\n        _this.dragging = false;\n        _this.shouldDestroyOnEndDragging = false;\n        return _this;\n    }\n    AbstractSelectionHandle.prototype.init = function () {\n        var _this = this;\n        this.dragService.addDragSource({\n            dragStartPixels: 0,\n            eElement: this.getGui(),\n            onDragStart: this.onDragStart.bind(this),\n            onDragging: function (e) {\n                _this.dragging = true;\n                _this.rangeController.autoScrollService.check(e);\n                if (_this.changedCalculatedValues) {\n                    _this.onDrag(e);\n                    _this.changedCalculatedValues = false;\n                }\n            },\n            onDragStop: function (e) {\n                _this.dragging = false;\n                _this.onDragEnd(e);\n                _this.clearValues();\n                _this.rangeController.autoScrollService.ensureCleared();\n                // TODO: this causes a bug where if there are multiple grids in the same page, all of them will\n                // be affected by a drag on any. Move it to the root element.\n                agGridCommunity._.removeCssClass(document.body, _this.getDraggingCssClass());\n                if (_this.shouldDestroyOnEndDragging) {\n                    _this.destroy();\n                }\n            }\n        });\n        this.addManagedListener(this.getGui(), 'mousedown', this.preventRangeExtension.bind(this));\n    };\n    AbstractSelectionHandle.prototype.isDragging = function () {\n        return this.dragging;\n    };\n    AbstractSelectionHandle.prototype.getCellComp = function () {\n        return this.cellComp;\n    };\n    AbstractSelectionHandle.prototype.setCellComp = function (cellComp) {\n        this.cellComp = cellComp;\n    };\n    AbstractSelectionHandle.prototype.getCellRange = function () {\n        return this.cellRange;\n    };\n    AbstractSelectionHandle.prototype.setCellRange = function (range) {\n        this.cellRange = range;\n    };\n    AbstractSelectionHandle.prototype.getRangeStartRow = function () {\n        return this.rangeStartRow;\n    };\n    AbstractSelectionHandle.prototype.setRangeStartRow = function (row) {\n        this.rangeStartRow = row;\n    };\n    AbstractSelectionHandle.prototype.getRangeEndRow = function () {\n        return this.rangeEndRow;\n    };\n    AbstractSelectionHandle.prototype.setRangeEndRow = function (row) {\n        this.rangeEndRow = row;\n    };\n    AbstractSelectionHandle.prototype.getLastCellHovered = function () {\n        return this.lastCellHovered;\n    };\n    AbstractSelectionHandle.prototype.preventRangeExtension = function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n    };\n    AbstractSelectionHandle.prototype.onDragStart = function (e) {\n        this.cellHoverListener = this.addManagedListener(this.rowRenderer.getGridCore().getRootGui(), 'mousemove', this.updateValuesOnMove.bind(this));\n        agGridCommunity._.addCssClass(document.body, this.getDraggingCssClass());\n    };\n    AbstractSelectionHandle.prototype.getDraggingCssClass = function () {\n        return \"ag-dragging-\" + (this.type === agGridCommunity.SelectionHandleType.FILL ? 'fill' : 'range') + \"-handle\";\n    };\n    AbstractSelectionHandle.prototype.updateValuesOnMove = function (e) {\n        var cell = this.mouseEventService.getCellPositionForEvent(e);\n        if (cell === this.lastCellHovered) {\n            return;\n        }\n        this.lastCellHovered = cell;\n        this.changedCalculatedValues = true;\n    };\n    AbstractSelectionHandle.prototype.getType = function () {\n        return this.type;\n    };\n    AbstractSelectionHandle.prototype.refresh = function (cellComp) {\n        var _this = this;\n        var oldCellComp = this.getCellComp();\n        var eGui = this.getGui();\n        var cellRange = agGridCommunity._.last(this.rangeController.getCellRanges());\n        var start = cellRange.startRow;\n        var end = cellRange.endRow;\n        if (start && end) {\n            var isBefore = this.rowPositionUtils.before(end, start);\n            if (isBefore) {\n                this.setRangeStartRow(end);\n                this.setRangeEndRow(start);\n            }\n            else {\n                this.setRangeStartRow(start);\n                this.setRangeEndRow(end);\n            }\n        }\n        if (oldCellComp !== cellComp || !agGridCommunity._.isVisible(eGui)) {\n            this.setCellComp(cellComp);\n            window.setTimeout(function () {\n                if (_this.isAlive()) {\n                    cellComp.appendChild(eGui);\n                }\n            }, 1);\n        }\n        this.setCellRange(cellRange);\n    };\n    AbstractSelectionHandle.prototype.clearValues = function () {\n        this.lastCellHovered = undefined;\n        this.removeListeners();\n    };\n    AbstractSelectionHandle.prototype.removeListeners = function () {\n        if (this.cellHoverListener) {\n            this.cellHoverListener();\n            this.cellHoverListener = undefined;\n        }\n    };\n    AbstractSelectionHandle.prototype.destroy = function () {\n        if (!this.shouldDestroyOnEndDragging && this.isDragging()) {\n            agGridCommunity._.setDisplayed(this.getGui(), false);\n            this.shouldDestroyOnEndDragging = true;\n            return;\n        }\n        this.shouldDestroyOnEndDragging = false;\n        _super.prototype.destroy.call(this);\n        this.removeListeners();\n        var eGui = this.getGui();\n        if (eGui.parentElement) {\n            eGui.parentElement.removeChild(eGui);\n        }\n    };\n    __decorate$1q([\n        agGridCommunity.Autowired(\"rowRenderer\")\n    ], AbstractSelectionHandle.prototype, \"rowRenderer\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired(\"dragService\")\n    ], AbstractSelectionHandle.prototype, \"dragService\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired(\"rangeController\")\n    ], AbstractSelectionHandle.prototype, \"rangeController\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired(\"mouseEventService\")\n    ], AbstractSelectionHandle.prototype, \"mouseEventService\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired(\"columnController\")\n    ], AbstractSelectionHandle.prototype, \"columnController\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired(\"cellNavigationService\")\n    ], AbstractSelectionHandle.prototype, \"cellNavigationService\", void 0);\n    __decorate$1q([\n        agGridCommunity.Autowired('rowPositionUtils')\n    ], AbstractSelectionHandle.prototype, \"rowPositionUtils\", void 0);\n    __decorate$1q([\n        agGridCommunity.PostConstruct\n    ], AbstractSelectionHandle.prototype, \"init\", null);\n    return AbstractSelectionHandle;\n}(agGridCommunity.Component));\n\nvar __extends$2y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$h = (undefined && undefined.__assign) || function () {\n    __assign$h = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$h.apply(this, arguments);\n};\nvar __decorate$1r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __spreadArrays$8 = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar FillHandle = /** @class */ (function (_super) {\n    __extends$2y(FillHandle, _super);\n    function FillHandle() {\n        var _this = _super.call(this, FillHandle.TEMPLATE) || this;\n        _this.markedCellComps = [];\n        _this.cellValues = [];\n        _this.isUp = false;\n        _this.isLeft = false;\n        _this.isReduce = false;\n        _this.type = agGridCommunity.SelectionHandleType.FILL;\n        return _this;\n    }\n    FillHandle.prototype.updateValuesOnMove = function (e) {\n        _super.prototype.updateValuesOnMove.call(this, e);\n        if (!this.initialXY) {\n            this.initialXY = this.mouseEventService.getNormalisedPosition(e);\n        }\n        var _a = this.initialXY, x = _a.x, y = _a.y;\n        var _b = this.mouseEventService.getNormalisedPosition(e), newX = _b.x, newY = _b.y;\n        var diffX = Math.abs(x - newX);\n        var diffY = Math.abs(y - newY);\n        var allowedDirection = this.gridOptionsWrapper.getFillHandleDirection();\n        var direction;\n        if (allowedDirection === 'xy') {\n            direction = diffX > diffY ? 'x' : 'y';\n        }\n        else {\n            direction = allowedDirection;\n        }\n        if (direction !== this.dragAxis) {\n            this.dragAxis = direction;\n            this.changedCalculatedValues = true;\n        }\n    };\n    FillHandle.prototype.onDrag = function (e) {\n        if (!this.initialPosition) {\n            var cellComp = this.getCellComp();\n            if (!cellComp) {\n                return;\n            }\n            this.initialPosition = cellComp.getCellPosition();\n        }\n        var lastCellHovered = this.getLastCellHovered();\n        if (lastCellHovered) {\n            this.markPathFrom(this.initialPosition, lastCellHovered);\n        }\n    };\n    FillHandle.prototype.onDragEnd = function (e) {\n        this.initialXY = null;\n        if (!this.markedCellComps.length) {\n            return;\n        }\n        var isX = this.dragAxis === 'x';\n        var initialRange = this.getCellRange();\n        var colLen = initialRange.columns.length;\n        var rangeStartRow = this.getRangeStartRow();\n        var rangeEndRow = this.getRangeEndRow();\n        var finalRange;\n        if (!this.isUp && !this.isLeft) {\n            finalRange = this.rangeController.createCellRangeFromCellRangeParams({\n                rowStartIndex: rangeStartRow.rowIndex,\n                rowStartPinned: rangeStartRow.rowPinned,\n                columnStart: initialRange.columns[0],\n                rowEndIndex: isX ? rangeEndRow.rowIndex : this.lastCellMarked.rowIndex,\n                rowEndPinned: isX ? rangeEndRow.rowPinned : this.lastCellMarked.rowPinned,\n                columnEnd: isX ? this.lastCellMarked.column : initialRange.columns[colLen - 1]\n            });\n        }\n        else {\n            var startRow = isX ? rangeStartRow : this.lastCellMarked;\n            finalRange = this.rangeController.createCellRangeFromCellRangeParams({\n                rowStartIndex: startRow.rowIndex,\n                rowStartPinned: startRow.rowPinned,\n                columnStart: isX ? this.lastCellMarked.column : initialRange.columns[0],\n                rowEndIndex: rangeEndRow.rowIndex,\n                rowEndPinned: rangeEndRow.rowPinned,\n                columnEnd: initialRange.columns[colLen - 1]\n            });\n        }\n        if (finalRange) {\n            // raising fill events for undo / redo\n            this.raiseFillStartEvent();\n            this.handleValueChanged(initialRange, finalRange, e);\n            this.rangeController.setCellRanges([finalRange]);\n            this.raiseFillEndEvent(initialRange, finalRange);\n        }\n    };\n    FillHandle.prototype.raiseFillStartEvent = function () {\n        var fillStartEvent = {\n            type: agGridCommunity.Events.EVENT_FILL_START,\n            columnApi: this.gridOptionsWrapper.getColumnApi(),\n            api: this.gridOptionsWrapper.getApi()\n        };\n        this.eventService.dispatchEvent(fillStartEvent);\n    };\n    FillHandle.prototype.raiseFillEndEvent = function (initialRange, finalRange) {\n        var fillEndEvent = {\n            type: agGridCommunity.Events.EVENT_FILL_END,\n            columnApi: this.gridOptionsWrapper.getColumnApi(),\n            api: this.gridOptionsWrapper.getApi(),\n            initialRange: initialRange,\n            finalRange: finalRange\n        };\n        this.eventService.dispatchEvent(fillEndEvent);\n    };\n    FillHandle.prototype.handleValueChanged = function (initialRange, finalRange, e) {\n        var _this = this;\n        var initialRangeEndRow = this.rangeController.getRangeEndRow(initialRange);\n        var initialRangeStartRow = this.rangeController.getRangeStartRow(initialRange);\n        var finalRangeEndRow = this.rangeController.getRangeEndRow(finalRange);\n        var finalRangeStartRow = this.rangeController.getRangeStartRow(finalRange);\n        var isVertical = this.dragAxis === 'y';\n        // if the range is being reduced in size, all we need to do is\n        // clear the cells that are no longer part of the range\n        if (this.isReduce && !this.gridOptionsWrapper.isSuppressClearOnFillReduction()) {\n            var columns = isVertical\n                ? initialRange.columns\n                : initialRange.columns.filter(function (col) { return finalRange.columns.indexOf(col) < 0; });\n            var startRow = isVertical ? this.cellNavigationService.getRowBelow(finalRangeEndRow) : finalRangeStartRow;\n            if (startRow) {\n                this.clearCellsInRange(startRow, initialRangeEndRow, columns);\n            }\n            return;\n        }\n        var withinInitialRange = true;\n        var values = [];\n        var initialValues = [];\n        var idx = 0;\n        var resetValues = function () {\n            values.length = 0;\n            initialValues.length = 0;\n            idx = 0;\n        };\n        var iterateAcrossCells = function (column, columns) {\n            var currentRow = _this.isUp ? initialRangeEndRow : initialRangeStartRow;\n            var finished = false;\n            if (isVertical) {\n                withinInitialRange = true;\n                resetValues();\n            }\n            var _loop_1 = function () {\n                var rowNode = _this.rowPositionUtils.getRowNode(currentRow);\n                if (!rowNode) {\n                    return \"break\";\n                }\n                if (isVertical && column) {\n                    fillValues(values, column, rowNode, function () {\n                        return !_this.rowPositionUtils.sameRow(currentRow, _this.isUp ? initialRangeStartRow : initialRangeEndRow);\n                    });\n                }\n                else if (columns) {\n                    withinInitialRange = true;\n                    resetValues();\n                    columns.forEach(function (col) { return fillValues(values, col, rowNode, function () { return col !== (_this.isLeft ? initialRange.columns[0] : agGridCommunity._.last(initialRange.columns)); }); });\n                }\n                finished = _this.rowPositionUtils.sameRow(currentRow, _this.isUp ? finalRangeStartRow : finalRangeEndRow);\n                currentRow = _this.isUp\n                    ? _this.cellNavigationService.getRowAbove(currentRow)\n                    : _this.cellNavigationService.getRowBelow(currentRow);\n            };\n            while (!finished && currentRow) {\n                var state_1 = _loop_1();\n                if (state_1 === \"break\")\n                    break;\n            }\n        };\n        var fillValues = function (currentValues, col, rowNode, updateInitialSet) {\n            var currentValue;\n            if (withinInitialRange) {\n                currentValue = _this.valueService.getValue(col, rowNode);\n                initialValues.push(currentValue);\n                withinInitialRange = updateInitialSet();\n            }\n            else {\n                currentValue = _this.processValues(e, currentValues, initialValues, col, rowNode, idx++);\n                if (col.isCellEditable(rowNode)) {\n                    rowNode.setDataValue(col, currentValue);\n                }\n            }\n            currentValues.push(currentValue);\n        };\n        if (isVertical) {\n            initialRange.columns.forEach(function (col) {\n                iterateAcrossCells(col);\n            });\n        }\n        else {\n            var columns = this.isLeft ? __spreadArrays$8(finalRange.columns).reverse() : finalRange.columns;\n            iterateAcrossCells(undefined, columns);\n        }\n    };\n    FillHandle.prototype.clearCellsInRange = function (startRow, endRow, columns) {\n        var _this = this;\n        var currentRow = startRow;\n        var finished = false;\n        var _loop_2 = function () {\n            var rowNode = this_1.rowPositionUtils.getRowNode(currentRow);\n            // should never happen, defensive programming\n            if (!rowNode) {\n                return \"break\";\n            }\n            columns.forEach(function (col) {\n                if (col.isCellEditable(rowNode)) {\n                    _this.valueService.setValue(rowNode, col, null);\n                }\n            });\n            finished = this_1.rowPositionUtils.sameRow(currentRow, endRow);\n            currentRow = this_1.cellNavigationService.getRowBelow(currentRow);\n        };\n        var this_1 = this;\n        while (!finished && currentRow) {\n            var state_2 = _loop_2();\n            if (state_2 === \"break\")\n                break;\n        }\n    };\n    FillHandle.prototype.processValues = function (event, values, initialValues, col, rowNode, idx) {\n        var userFillOperation = this.gridOptionsWrapper.getFillOperation();\n        var isVertical = this.dragAxis === 'y';\n        var direction;\n        if (isVertical) {\n            direction = this.isUp ? 'up' : 'down';\n        }\n        else {\n            direction = this.isLeft ? 'left' : 'right';\n        }\n        if (userFillOperation) {\n            var userResult = userFillOperation({\n                event: event,\n                values: values,\n                initialValues: initialValues,\n                currentIndex: idx,\n                currentCellValue: this.valueService.getValue(col, rowNode),\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n                direction: direction,\n                column: isVertical ? col : undefined,\n                rowNode: !isVertical ? rowNode : undefined // only present if left / right\n            });\n            if (userResult !== false) {\n                return userResult;\n            }\n        }\n        var allNumbers = !values.some(function (val) {\n            var asFloat = parseFloat(val);\n            return isNaN(asFloat) || asFloat.toString() !== val.toString();\n        });\n        // values should be copied in order if the alt key is pressed\n        // or if the values contain strings and numbers\n        // However, if we only have one initial value selected, and that\n        // value is a number and we are also pressing alt, then we should\n        // increment or decrement the value by 1 based on direction.\n        if (event.altKey || !allNumbers) {\n            if (allNumbers && initialValues.length === 1) {\n                var multiplier = (this.isUp || this.isLeft) ? -1 : 1;\n                return parseFloat(agGridCommunity._.last(values)) + 1 * multiplier;\n            }\n            return values[idx % values.length];\n        }\n        return agGridCommunity._.last(agGridCommunity._.findLineByLeastSquares(values.map(Number)));\n    };\n    FillHandle.prototype.clearValues = function () {\n        this.clearMarkedPath();\n        this.clearCellValues();\n        this.lastCellMarked = undefined;\n        _super.prototype.clearValues.call(this);\n    };\n    FillHandle.prototype.clearMarkedPath = function () {\n        this.markedCellComps.forEach(function (cellComp) {\n            var eGui = cellComp.getGui();\n            agGridCommunity._.removeCssClass(eGui, 'ag-selection-fill-top');\n            agGridCommunity._.removeCssClass(eGui, 'ag-selection-fill-right');\n            agGridCommunity._.removeCssClass(eGui, 'ag-selection-fill-bottom');\n            agGridCommunity._.removeCssClass(eGui, 'ag-selection-fill-left');\n        });\n        this.markedCellComps.length = 0;\n        this.isUp = false;\n        this.isLeft = false;\n        this.isReduce = false;\n    };\n    FillHandle.prototype.clearCellValues = function () {\n        this.cellValues.length = 0;\n    };\n    FillHandle.prototype.markPathFrom = function (initialPosition, currentPosition) {\n        this.clearMarkedPath();\n        this.clearCellValues();\n        if (this.dragAxis === 'y') {\n            if (this.rowPositionUtils.sameRow(currentPosition, initialPosition)) {\n                return;\n            }\n            var isBefore = this.rowPositionUtils.before(currentPosition, initialPosition);\n            var rangeStartRow = this.getRangeStartRow();\n            var rangeEndRow = this.getRangeEndRow();\n            if (isBefore && ((currentPosition.rowPinned == rangeStartRow.rowPinned &&\n                currentPosition.rowIndex >= rangeStartRow.rowIndex) ||\n                (rangeStartRow.rowPinned != rangeEndRow.rowPinned &&\n                    currentPosition.rowPinned == rangeEndRow.rowPinned &&\n                    currentPosition.rowIndex <= rangeEndRow.rowIndex))) {\n                this.reduceVertical(initialPosition, currentPosition);\n                this.isReduce = true;\n            }\n            else {\n                this.extendVertical(initialPosition, currentPosition, isBefore);\n                this.isReduce = false;\n            }\n        }\n        else {\n            var initialColumn = initialPosition.column;\n            var currentColumn = currentPosition.column;\n            if (initialColumn === currentColumn) {\n                return;\n            }\n            var displayedColumns = this.columnController.getAllDisplayedColumns();\n            var initialIndex = displayedColumns.indexOf(initialColumn);\n            var currentIndex = displayedColumns.indexOf(currentColumn);\n            if (currentIndex <= initialIndex && currentIndex >= displayedColumns.indexOf(this.getCellRange().columns[0])) {\n                this.reduceHorizontal(initialPosition, currentPosition);\n                this.isReduce = true;\n            }\n            else {\n                this.extendHorizontal(initialPosition, currentPosition, currentIndex < initialIndex);\n                this.isReduce = false;\n            }\n        }\n        this.lastCellMarked = currentPosition;\n    };\n    FillHandle.prototype.extendVertical = function (initialPosition, endPosition, isMovingUp) {\n        var _a = this, rowRenderer = _a.rowRenderer, rangeController = _a.rangeController;\n        var row = initialPosition;\n        do {\n            var cellRange = this.getCellRange();\n            var colLen = cellRange.columns.length;\n            for (var i = 0; i < colLen; i++) {\n                var column = cellRange.columns[i];\n                var rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };\n                var cellPos = __assign$h(__assign$h({}, rowPos), { column: column });\n                var cellInRange = rangeController.isCellInSpecificRange(cellPos, cellRange);\n                var isInitialRow = this.rowPositionUtils.sameRow(row, initialPosition);\n                if (isMovingUp) {\n                    this.isUp = true;\n                }\n                if (!isInitialRow) {\n                    var cellComp = rowRenderer.getComponentForCell(cellPos);\n                    if (cellComp) {\n                        this.markedCellComps.push(cellComp);\n                        var eGui = cellComp.getGui();\n                        if (!cellInRange) {\n                            agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-left', i === 0);\n                            agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-right', i === colLen - 1);\n                        }\n                        agGridCommunity._.addOrRemoveCssClass(eGui, isMovingUp ? 'ag-selection-fill-top' : 'ag-selection-fill-bottom', this.rowPositionUtils.sameRow(row, endPosition));\n                    }\n                }\n            }\n            if (this.rowPositionUtils.sameRow(row, endPosition)) {\n                break;\n            }\n        } while (\n        // tslint:disable-next-line\n        row = isMovingUp\n            ? this.cellNavigationService.getRowAbove(row)\n            : this.cellNavigationService.getRowBelow(row));\n    };\n    FillHandle.prototype.reduceVertical = function (initialPosition, endPosition) {\n        var row = initialPosition;\n        do {\n            var cellRange = this.getCellRange();\n            var colLen = cellRange.columns.length;\n            var isLastRow = this.rowPositionUtils.sameRow(row, endPosition);\n            for (var i = 0; i < colLen; i++) {\n                var rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };\n                var celPos = __assign$h(__assign$h({}, rowPos), { column: cellRange.columns[i] });\n                var cellComp = this.rowRenderer.getComponentForCell(celPos);\n                if (cellComp) {\n                    this.markedCellComps.push(cellComp);\n                    var eGui = cellComp.getGui();\n                    agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-bottom', this.rowPositionUtils.sameRow(row, endPosition));\n                }\n            }\n            if (isLastRow) {\n                break;\n            }\n            // tslint:disable-next-line\n        } while (row = this.cellNavigationService.getRowAbove(row));\n    };\n    FillHandle.prototype.extendHorizontal = function (initialPosition, endPosition, isMovingLeft) {\n        var _this = this;\n        var allCols = this.columnController.getAllDisplayedColumns();\n        var startCol = allCols.indexOf(isMovingLeft ? endPosition.column : initialPosition.column);\n        var endCol = allCols.indexOf(isMovingLeft ? this.getCellRange().columns[0] : endPosition.column);\n        var offset = isMovingLeft ? 0 : 1;\n        var colsToMark = allCols.slice(startCol + offset, endCol + offset);\n        var rangeStartRow = this.getRangeStartRow();\n        var rangeEndRow = this.getRangeEndRow();\n        colsToMark.forEach(function (column) {\n            var row = rangeStartRow;\n            var isLastRow = false;\n            do {\n                isLastRow = _this.rowPositionUtils.sameRow(row, rangeEndRow);\n                var cellComp = _this.rowRenderer.getComponentForCell({\n                    rowIndex: row.rowIndex,\n                    rowPinned: row.rowPinned,\n                    column: column\n                });\n                if (cellComp) {\n                    _this.markedCellComps.push(cellComp);\n                    var eGui = cellComp.getGui();\n                    agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-top', _this.rowPositionUtils.sameRow(row, rangeStartRow));\n                    agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-bottom', _this.rowPositionUtils.sameRow(row, rangeEndRow));\n                    if (isMovingLeft) {\n                        _this.isLeft = true;\n                        agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-left', column === colsToMark[0]);\n                    }\n                    else {\n                        agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-right', column === agGridCommunity._.last(colsToMark));\n                    }\n                }\n                row = _this.cellNavigationService.getRowBelow(row);\n            } while (!isLastRow);\n        });\n    };\n    FillHandle.prototype.reduceHorizontal = function (initialPosition, endPosition) {\n        var _this = this;\n        var allCols = this.columnController.getAllDisplayedColumns();\n        var startCol = allCols.indexOf(endPosition.column);\n        var endCol = allCols.indexOf(initialPosition.column);\n        var colsToMark = allCols.slice(startCol, endCol);\n        var rangeStartRow = this.getRangeStartRow();\n        var rangeEndRow = this.getRangeEndRow();\n        colsToMark.forEach(function (column) {\n            var row = rangeStartRow;\n            var isLastRow = false;\n            do {\n                isLastRow = _this.rowPositionUtils.sameRow(row, rangeEndRow);\n                var cellComp = _this.rowRenderer.getComponentForCell({\n                    rowIndex: row.rowIndex,\n                    rowPinned: row.rowPinned,\n                    column: column\n                });\n                if (cellComp) {\n                    _this.markedCellComps.push(cellComp);\n                    var eGui = cellComp.getGui();\n                    agGridCommunity._.addOrRemoveCssClass(eGui, 'ag-selection-fill-right', column === colsToMark[0]);\n                }\n                row = _this.cellNavigationService.getRowBelow(row);\n            } while (!isLastRow);\n        });\n    };\n    FillHandle.prototype.refresh = function (cellComp) {\n        var cellRange = this.rangeController.getCellRanges()[0];\n        var isColumnRange = !cellRange.startRow || !cellRange.endRow;\n        if (isColumnRange) {\n            this.destroy();\n            return;\n        }\n        _super.prototype.refresh.call(this, cellComp);\n    };\n    FillHandle.TEMPLATE = \"<div class=\\\"ag-fill-handle\\\"></div>\";\n    __decorate$1r([\n        agGridCommunity.Autowired('valueService')\n    ], FillHandle.prototype, \"valueService\", void 0);\n    return FillHandle;\n}(AbstractSelectionHandle));\n\nvar __extends$2z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$i = (undefined && undefined.__assign) || function () {\n    __assign$i = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$i.apply(this, arguments);\n};\nvar RangeHandle$1 = /** @class */ (function (_super) {\n    __extends$2z(RangeHandle, _super);\n    function RangeHandle() {\n        var _this = _super.call(this, RangeHandle.TEMPLATE) || this;\n        _this.type = agGridCommunity.SelectionHandleType.RANGE;\n        _this.rangeFixed = false;\n        return _this;\n    }\n    RangeHandle.prototype.onDrag = function (e) {\n        var lastCellHovered = this.getLastCellHovered();\n        if (!lastCellHovered) {\n            return;\n        }\n        var cellRanges = this.rangeController.getCellRanges();\n        var lastRange = agGridCommunity._.last(cellRanges);\n        if (!this.rangeFixed) {\n            this.fixRangeStartEnd(lastRange);\n            this.rangeFixed = true;\n        }\n        this.endPosition = {\n            rowIndex: lastCellHovered.rowIndex,\n            rowPinned: lastCellHovered.rowPinned,\n            column: lastCellHovered.column\n        };\n        // check if the cell ranges are for a chart\n        if (cellRanges.length === 2 && cellRanges[0].type === agGridCommunity.CellRangeType.DIMENSION && lastRange.type === agGridCommunity.CellRangeType.VALUE) {\n            var rowChanged = !this.rowPositionUtils.sameRow(this.endPosition, this.rangeController.getRangeEndRow(lastRange));\n            if (rowChanged) {\n                // ensure the dimension range is kept in sync with the value range (which has the handle)\n                this.rangeController.updateRangeEnd(cellRanges[0], __assign$i(__assign$i({}, this.endPosition), { column: cellRanges[0].columns[0] }), true);\n            }\n        }\n        this.rangeController.extendLatestRangeToCell(this.endPosition);\n    };\n    RangeHandle.prototype.onDragEnd = function (e) {\n        var cellRange = agGridCommunity._.last(this.rangeController.getCellRanges());\n        this.fixRangeStartEnd(cellRange);\n        this.rangeFixed = false;\n    };\n    RangeHandle.prototype.fixRangeStartEnd = function (cellRange) {\n        var startRow = this.rangeController.getRangeStartRow(cellRange);\n        var endRow = this.rangeController.getRangeEndRow(cellRange);\n        var column = cellRange.columns[0];\n        cellRange.startRow = startRow;\n        cellRange.endRow = endRow;\n        cellRange.startColumn = column;\n    };\n    RangeHandle.TEMPLATE = \"<div class=\\\"ag-range-handle\\\"></div>\";\n    return RangeHandle;\n}(AbstractSelectionHandle));\n\nvar __extends$2A = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SelectionHandleFactory = /** @class */ (function (_super) {\n    __extends$2A(SelectionHandleFactory, _super);\n    function SelectionHandleFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SelectionHandleFactory.prototype.createSelectionHandle = function (type) {\n        return this.createBean(type === agGridCommunity.SelectionHandleType.RANGE ? new RangeHandle$1() : new FillHandle());\n    };\n    SelectionHandleFactory = __decorate$1s([\n        agGridCommunity.Bean('selectionHandleFactory')\n    ], SelectionHandleFactory);\n    return SelectionHandleFactory;\n}(agGridCommunity.BeanStub));\n\nvar RangeSelectionModule = {\n    moduleName: agGridCommunity.ModuleNames.RangeSelectionModule,\n    beans: [RangeController, SelectionHandleFactory],\n    agStackComponents: [\n        { componentName: 'AgFillHandle', componentClass: FillHandle },\n        { componentName: 'AgRangeHandle', componentClass: RangeHandle$1 }\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar GridChartsModule = {\n    moduleName: agGridCommunity.ModuleNames.GridChartsModule,\n    beans: [\n        ChartService, ChartTranslator, ChartCrossFilter\n    ],\n    dependantModules: [\n        RangeSelectionModule,\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2B = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DetailCellRenderer = /** @class */ (function (_super) {\n    __extends$2B(DetailCellRenderer, _super);\n    function DetailCellRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.needRefresh = false;\n        _this.loadRowDataVersion = 0;\n        return _this;\n    }\n    DetailCellRenderer.prototype.init = function (params) {\n        var _this = this;\n        // if embedFullWidthRows=true, then this component could be in a pinned section. we should not show detail\n        // component if in the pinned section, on in the main body section.\n        if (params.pinned) {\n            this.setTemplate('<div class=\"ag-details-row\"></div>');\n            return;\n        }\n        this.params = params;\n        var autoHeight = this.gridOptionsWrapper.isDetailRowAutoHeight();\n        this.checkForDeprecations();\n        this.ensureValidRefreshStrategy();\n        this.selectAndSetTemplate(autoHeight);\n        if (agGridCommunity._.exists(this.eDetailGrid)) {\n            this.addThemeToDetailGrid();\n            this.createDetailsGrid(autoHeight);\n            this.registerDetailWithMaster();\n            this.loadRowData();\n            window.setTimeout(function () {\n                // ensure detail grid api still exists (grid may be destroyed when async call tries to set data)\n                if (_this.detailGridOptions.api) {\n                    _this.detailGridOptions.api.doLayout();\n                }\n            }, 0);\n        }\n        else {\n            console.warn('AG Grid: reference to eDetailGrid was missing from the details template. ' +\n                'Please add ref=\"eDetailGrid\" to the template.');\n        }\n        this.addManagedListener(params.node.parent, agGridCommunity.RowNode.EVENT_DATA_CHANGED, function () {\n            _this.needRefresh = true;\n        });\n        // this.setupAutoGridHeight();\n    };\n    DetailCellRenderer.prototype.refresh = function () {\n        var GET_GRID_TO_REFRESH = false;\n        var GET_GRID_TO_DO_NOTHING = true;\n        // if we return true, it means we pretend to the grid\n        // that we have refreshed, so refresh will never happen.\n        var doNotRefresh = !this.needRefresh || this.params.refreshStrategy === 'nothing';\n        if (doNotRefresh) {\n            // we do nothing in this refresh method, and also tell the grid to do nothing\n            return GET_GRID_TO_DO_NOTHING;\n        }\n        // reset flag, so don't refresh again until more data changes.\n        this.needRefresh = false;\n        if (this.params.refreshStrategy === 'everything') {\n            // we want full refresh, so tell the grid to destroy and recreate this cell\n            return GET_GRID_TO_REFRESH;\n        }\n        else {\n            // do the refresh here, and tell the grid to do nothing\n            this.loadRowData();\n            return GET_GRID_TO_DO_NOTHING;\n        }\n    };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    DetailCellRenderer.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    DetailCellRenderer.prototype.checkForDeprecations = function () {\n        if (this.params.suppressRefresh) {\n            console.warn(\"AG Grid: as of v23.2.0, cellRendererParams.suppressRefresh for Detail Cell Renderer is no \" +\n                \"longer used. Please set cellRendererParams.refreshStrategy = 'nothing' instead.\");\n            this.params.refreshStrategy = 'nothing';\n        }\n    };\n    DetailCellRenderer.prototype.ensureValidRefreshStrategy = function () {\n        switch (this.params.refreshStrategy) {\n            case 'rows':\n            case 'nothing':\n            case 'everything':\n                return;\n        }\n        // check for incorrectly supplied refresh strategy\n        if (this.params.refreshStrategy) {\n            console.warn(\"AG Grid: invalid cellRendererParams.refreshStrategy = '\" + this.params.refreshStrategy +\n                \"' supplied, defaulting to refreshStrategy = 'rows'.\");\n        }\n        // use default strategy\n        this.params.refreshStrategy = 'rows';\n    };\n    DetailCellRenderer.prototype.addThemeToDetailGrid = function () {\n        // this is needed by environment service of the child grid, the class needs to be on\n        // the grid div itself - the browser's CSS on the other hand just inherits from the parent grid theme.\n        var theme = this.environment.getTheme().theme;\n        if (theme) {\n            agGridCommunity._.addCssClass(this.eDetailGrid, theme);\n        }\n    };\n    DetailCellRenderer.prototype.registerDetailWithMaster = function () {\n        var rowId = this.params.node.id;\n        var masterGridApi = this.params.api;\n        var gridInfo = {\n            id: rowId,\n            api: this.detailGridOptions.api,\n            columnApi: this.detailGridOptions.columnApi\n        };\n        var rowNode = this.params.node;\n        // register with api\n        masterGridApi.addDetailGridInfo(rowId, gridInfo);\n        // register with node\n        rowNode.detailGridInfo = gridInfo;\n        this.addDestroyFunc(function () {\n            masterGridApi.removeDetailGridInfo(rowId); // unregister from api\n            rowNode.detailGridInfo = null; // unregister from node\n        });\n    };\n    DetailCellRenderer.prototype.selectAndSetTemplate = function (autoHeight) {\n        var _this = this;\n        var setDefaultTemplate = function () {\n            _this.setTemplate(DetailCellRenderer.TEMPLATE);\n            _this.addCssClass(autoHeight ? 'ag-details-row-auto-height' : 'ag-details-row-fixed-height');\n            agGridCommunity._.addCssClass(_this.eDetailGrid, autoHeight ? 'ag-details-grid-auto-height' : 'ag-details-grid-fixed-height');\n        };\n        if (agGridCommunity._.missing(this.params.template)) {\n            // use default template\n            setDefaultTemplate();\n        }\n        else {\n            // use user provided template\n            if (typeof this.params.template === 'string') {\n                this.setTemplate(this.params.template);\n            }\n            else if (typeof this.params.template === 'function') {\n                var templateFunc = this.params.template;\n                var template = templateFunc(this.params);\n                this.setTemplate(template);\n            }\n            else {\n                console.warn('AG Grid: detailCellRendererParams.template should be function or string');\n                setDefaultTemplate();\n            }\n        }\n    };\n    DetailCellRenderer.prototype.createDetailsGrid = function (autoHeight) {\n        // we clone the detail grid options, as otherwise it would be shared\n        // across many instances, and that would be a problem because we set\n        // api and columnApi into gridOptions\n        var _this = this;\n        var gridOptions = this.params.detailGridOptions;\n        if (agGridCommunity._.missing(gridOptions)) {\n            console.warn('AG Grid: could not find detail grid options for master detail, ' +\n                'please set gridOptions.detailCellRendererParams.detailGridOptions');\n        }\n        // IMPORTANT - gridOptions must be cloned\n        this.detailGridOptions = agGridCommunity._.cloneObject(gridOptions);\n        if (autoHeight) {\n            this.detailGridOptions.domLayout = 'autoHeight';\n        }\n        // tslint:disable-next-line\n        new agGridCommunity.Grid(this.eDetailGrid, this.detailGridOptions, {\n            $scope: this.params.$scope,\n            $compile: this.params.$compile,\n            providedBeanInstances: {\n                // a temporary fix for AG-1574\n                // AG-1715 raised to do a wider ranging refactor to improve this\n                agGridReact: this.params.agGridReact,\n                // AG-1716 - directly related to AG-1574 and AG-1715\n                frameworkComponentWrapper: this.params.frameworkComponentWrapper\n            }\n        });\n        this.addDestroyFunc(function () {\n            if (_this.detailGridOptions.api) {\n                _this.detailGridOptions.api.destroy();\n            }\n        });\n    };\n    DetailCellRenderer.prototype.loadRowData = function () {\n        var _this = this;\n        // in case a refresh happens before the last refresh completes (as we depend on async\n        // application logic) we keep track on what the latest call was.\n        this.loadRowDataVersion++;\n        var versionThisCall = this.loadRowDataVersion;\n        var userFunc = this.params.getDetailRowData;\n        if (!userFunc) {\n            console.warn('AG Grid: could not find getDetailRowData for master / detail, ' +\n                'please set gridOptions.detailCellRendererParams.getDetailRowData');\n            return;\n        }\n        var successCallback = function (rowData) {\n            var mostRecentCall = _this.loadRowDataVersion === versionThisCall;\n            if (mostRecentCall) {\n                _this.setRowData(rowData);\n            }\n        };\n        var funcParams = {\n            node: this.params.node,\n            // we take data from node, rather than params.data\n            // as the data could have been updated with new instance\n            data: this.params.node.data,\n            successCallback: successCallback,\n            context: this.gridOptionsWrapper.getContext()\n        };\n        userFunc(funcParams);\n    };\n    DetailCellRenderer.prototype.setRowData = function (rowData) {\n        // ensure detail grid api still exists (grid may be destroyed when async call tries to set data)\n        if (this.detailGridOptions.api) {\n            this.detailGridOptions.api.setRowData(rowData);\n        }\n    };\n    DetailCellRenderer.TEMPLATE = \"<div class=\\\"ag-details-row\\\">\\n            <div ref=\\\"eDetailGrid\\\" class=\\\"ag-details-grid\\\"></div>\\n        </div>\";\n    __decorate$1t([\n        agGridCommunity.Autowired('environment')\n    ], DetailCellRenderer.prototype, \"environment\", void 0);\n    __decorate$1t([\n        agGridCommunity.RefSelector('eDetailGrid')\n    ], DetailCellRenderer.prototype, \"eDetailGrid\", void 0);\n    return DetailCellRenderer;\n}(agGridCommunity.Component));\n\nvar MasterDetailModule = {\n    moduleName: agGridCommunity.ModuleNames.MasterDetailModule,\n    beans: [],\n    userComponents: [\n        { componentName: 'agDetailCellRenderer', componentClass: DetailCellRenderer }\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2C = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MenuPanel = /** @class */ (function (_super) {\n    __extends$2C(MenuPanel, _super);\n    function MenuPanel(wrappedComponent) {\n        var _this = _super.call(this, undefined, true) || this;\n        _this.wrappedComponent = wrappedComponent;\n        _this.setTemplateFromElement(wrappedComponent.getGui());\n        return _this;\n    }\n    MenuPanel.prototype.handleKeyDown = function (e) {\n        if (e.keyCode === agGridCommunity.KeyCode.ESCAPE) {\n            this.closePanel();\n        }\n    };\n    MenuPanel.prototype.onTabKeyDown = function (e) {\n        _super.prototype.onTabKeyDown.call(this, e);\n        if (e.defaultPrevented) {\n            return;\n        }\n        this.closePanel();\n        e.preventDefault();\n    };\n    MenuPanel.prototype.closePanel = function () {\n        var menuItem = this.parentComponent;\n        menuItem.closeSubMenu();\n        setTimeout(function () { return menuItem.getGui().focus(); }, 0);\n    };\n    return MenuPanel;\n}(agGridCommunity.ManagedFocusComponent));\n\nvar __extends$2D = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MenuItemComponent = /** @class */ (function (_super) {\n    __extends$2D(MenuItemComponent, _super);\n    function MenuItemComponent(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        _this.isActive = false;\n        _this.subMenuIsOpen = false;\n        _this.setTemplate(/* html */ \"<div class=\\\"\" + _this.getClassName() + \"\\\" tabindex=\\\"-1\\\" role=\\\"treeitem\\\"></div>\");\n        return _this;\n    }\n    MenuItemComponent.prototype.init = function () {\n        var _this = this;\n        this.addIcon();\n        this.addName();\n        this.addShortcut();\n        this.addSubMenu();\n        this.addTooltip();\n        var eGui = this.getGui();\n        if (this.params.disabled) {\n            this.addCssClass(this.getClassName('disabled'));\n            agGridCommunity._.setAriaDisabled(eGui, true);\n        }\n        else {\n            this.addGuiEventListener('click', function (e) { return _this.onItemSelected(e); });\n            this.addGuiEventListener('keydown', function (e) {\n                if (e.keyCode === agGridCommunity.KeyCode.ENTER || e.keyCode === agGridCommunity.KeyCode.SPACE) {\n                    e.preventDefault();\n                    _this.onItemSelected(e);\n                }\n            });\n            this.addGuiEventListener('mouseenter', function () { return _this.onMouseEnter(); });\n            this.addGuiEventListener('mouseleave', function () { return _this.onMouseLeave(); });\n        }\n        if (this.params.cssClasses) {\n            this.params.cssClasses.forEach(function (it) { return agGridCommunity._.addCssClass(eGui, it); });\n        }\n    };\n    MenuItemComponent.prototype.isDisabled = function () {\n        return !!this.params.disabled;\n    };\n    MenuItemComponent.prototype.openSubMenu = function (activateFirstItem) {\n        var _this = this;\n        if (activateFirstItem === void 0) { activateFirstItem = false; }\n        this.closeSubMenu();\n        if (!this.params.subMenu) {\n            return;\n        }\n        var ePopup = agGridCommunity._.loadTemplate(/* html */ \"<div class=\\\"ag-menu\\\" role=\\\"presentation\\\"></div>\");\n        var destroySubMenu;\n        if (this.params.subMenu instanceof Array) {\n            var currentLevel = agGridCommunity._.getAriaLevel(this.getGui());\n            var nextLevel = isNaN(currentLevel) ? 1 : (currentLevel + 1);\n            var childMenu_1 = this.createBean(new MenuList(nextLevel));\n            childMenu_1.setParentComponent(this);\n            childMenu_1.addMenuItems(this.params.subMenu);\n            ePopup.appendChild(childMenu_1.getGui());\n            // bubble menu item selected events\n            this.addManagedListener(childMenu_1, MenuItemComponent.EVENT_MENU_ITEM_SELECTED, function (e) { return _this.dispatchEvent(e); });\n            childMenu_1.addGuiEventListener('mouseenter', function () { return _this.cancelDeactivate(); });\n            destroySubMenu = function () { return _this.destroyBean(childMenu_1); };\n            if (activateFirstItem) {\n                setTimeout(function () { return childMenu_1.activateFirstItem(); }, 0);\n            }\n        }\n        else {\n            var subMenu_1 = this.params.subMenu;\n            var menuPanel = this.createBean(new MenuPanel(subMenu_1));\n            menuPanel.setParentComponent(this);\n            var subMenuGui_1 = menuPanel.getGui();\n            var mouseEvent_1 = 'mouseenter';\n            var mouseEnterListener_1 = function () { return _this.cancelDeactivate(); };\n            subMenuGui_1.addEventListener(mouseEvent_1, mouseEnterListener_1);\n            destroySubMenu = function () { return subMenuGui_1.removeEventListener(mouseEvent_1, mouseEnterListener_1); };\n            ePopup.appendChild(subMenuGui_1);\n            if (subMenu_1.afterGuiAttached) {\n                setTimeout(function () { return subMenu_1.afterGuiAttached(); }, 0);\n            }\n        }\n        var eGui = this.getGui();\n        var positionCallback = this.popupService.positionPopupForMenu.bind(this.popupService, { eventSource: eGui, ePopup: ePopup });\n        var addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: ePopup,\n            positionCallback: positionCallback,\n            anchorToElement: eGui\n        });\n        this.subMenuIsOpen = true;\n        agGridCommunity._.setAriaExpanded(eGui, true);\n        this.hideSubMenu = function () {\n            if (addPopupRes) {\n                addPopupRes.hideFunc();\n            }\n            _this.subMenuIsOpen = false;\n            agGridCommunity._.setAriaExpanded(eGui, false);\n            destroySubMenu();\n        };\n    };\n    MenuItemComponent.prototype.closeSubMenu = function () {\n        if (!this.hideSubMenu) {\n            return;\n        }\n        this.hideSubMenu();\n        this.hideSubMenu = null;\n        agGridCommunity._.setAriaExpanded(this.getGui(), false);\n    };\n    MenuItemComponent.prototype.isSubMenuOpen = function () {\n        return this.subMenuIsOpen;\n    };\n    MenuItemComponent.prototype.activate = function (openSubMenu) {\n        var _this = this;\n        this.cancelActivate();\n        if (this.params.disabled) {\n            return;\n        }\n        this.isActive = true;\n        this.addCssClass(this.getClassName('active'));\n        this.getGui().focus();\n        if (openSubMenu && this.params.subMenu) {\n            window.setTimeout(function () {\n                if (_this.isAlive() && _this.isActive) {\n                    _this.openSubMenu();\n                }\n            }, 300);\n        }\n        this.onItemActivated();\n    };\n    MenuItemComponent.prototype.deactivate = function () {\n        this.cancelDeactivate();\n        this.removeCssClass(this.getClassName('active'));\n        this.isActive = false;\n        if (this.subMenuIsOpen) {\n            this.hideSubMenu();\n        }\n    };\n    MenuItemComponent.prototype.addIcon = function () {\n        if (!this.params.checked && !this.params.icon && this.params.isCompact) {\n            return;\n        }\n        var icon = agGridCommunity._.loadTemplate(/* html */ \"<span ref=\\\"eIcon\\\" class=\\\"\" + this.getClassName('part') + \" \" + this.getClassName('icon') + \"\\\" role=\\\"presentation\\\"></span>\");\n        if (this.params.checked) {\n            icon.appendChild(agGridCommunity._.createIconNoSpan('check', this.gridOptionsWrapper));\n        }\n        else if (this.params.icon) {\n            if (agGridCommunity._.isNodeOrElement(this.params.icon)) {\n                icon.appendChild(this.params.icon);\n            }\n            else if (typeof this.params.icon === 'string') {\n                icon.innerHTML = this.params.icon;\n            }\n            else {\n                console.warn('AG Grid: menu item icon must be DOM node or string');\n            }\n        }\n        this.getGui().appendChild(icon);\n    };\n    MenuItemComponent.prototype.addName = function () {\n        if (!this.params.name && this.params.isCompact) {\n            return;\n        }\n        var name = agGridCommunity._.loadTemplate(/* html */ \"<span ref=\\\"eName\\\" class=\\\"\" + this.getClassName('part') + \" \" + this.getClassName('text') + \"\\\">\" + (this.params.name || '') + \"</span>\");\n        this.getGui().appendChild(name);\n    };\n    MenuItemComponent.prototype.addTooltip = function () {\n        if (!this.params.tooltip) {\n            return;\n        }\n        this.tooltip = this.params.tooltip;\n        if (this.gridOptionsWrapper.isEnableBrowserTooltips()) {\n            this.getGui().setAttribute('title', this.tooltip);\n        }\n        else {\n            this.createManagedBean(new agGridCommunity.TooltipFeature(this));\n        }\n    };\n    MenuItemComponent.prototype.getTooltipParams = function () {\n        return {\n            location: 'menu',\n            value: this.tooltip\n        };\n    };\n    MenuItemComponent.prototype.addShortcut = function () {\n        if (!this.params.shortcut && this.params.isCompact) {\n            return;\n        }\n        var shortcut = agGridCommunity._.loadTemplate(/* html */ \"<span ref=\\\"eShortcut\\\" class=\\\"\" + this.getClassName('part') + \" \" + this.getClassName('shortcut') + \"\\\">\" + (this.params.shortcut || '') + \"</span>\");\n        this.getGui().appendChild(shortcut);\n    };\n    MenuItemComponent.prototype.addSubMenu = function () {\n        if (!this.params.subMenu && this.params.isCompact) {\n            return;\n        }\n        var pointer = agGridCommunity._.loadTemplate(/* html */ \"<span ref=\\\"ePopupPointer\\\" class=\\\"\" + this.getClassName('part') + \" \" + this.getClassName('popup-pointer') + \"\\\"></span>\");\n        var eGui = this.getGui();\n        if (this.params.subMenu) {\n            var iconName = this.gridOptionsWrapper.isEnableRtl() ? 'smallLeft' : 'smallRight';\n            agGridCommunity._.setAriaExpanded(eGui, false);\n            pointer.appendChild(agGridCommunity._.createIconNoSpan(iconName, this.gridOptionsWrapper));\n        }\n        eGui.appendChild(pointer);\n    };\n    MenuItemComponent.prototype.onItemSelected = function (event) {\n        if (this.params.action) {\n            this.params.action();\n        }\n        else {\n            this.openSubMenu(event && event.type === 'keydown');\n        }\n        if (this.params.subMenu && !this.params.action) {\n            return;\n        }\n        var e = {\n            type: MenuItemComponent.EVENT_MENU_ITEM_SELECTED,\n            action: this.params.action,\n            checked: this.params.checked,\n            cssClasses: this.params.cssClasses,\n            disabled: this.params.disabled,\n            icon: this.params.icon,\n            name: this.params.name,\n            shortcut: this.params.shortcut,\n            subMenu: this.params.subMenu,\n            tooltip: this.params.tooltip,\n            event: event\n        };\n        this.dispatchEvent(e);\n    };\n    MenuItemComponent.prototype.onItemActivated = function () {\n        var event = {\n            type: MenuItemComponent.EVENT_MENU_ITEM_ACTIVATED,\n            menuItem: this,\n        };\n        this.dispatchEvent(event);\n    };\n    MenuItemComponent.prototype.cancelActivate = function () {\n        if (this.activateTimeoutId) {\n            window.clearTimeout(this.activateTimeoutId);\n            this.activateTimeoutId = 0;\n        }\n    };\n    MenuItemComponent.prototype.cancelDeactivate = function () {\n        if (this.deactivateTimeoutId) {\n            window.clearTimeout(this.deactivateTimeoutId);\n            this.deactivateTimeoutId = 0;\n        }\n    };\n    MenuItemComponent.prototype.onMouseEnter = function () {\n        var _this = this;\n        this.cancelDeactivate();\n        if (this.params.isAnotherSubMenuOpen()) {\n            // wait to see if the user enters the open sub-menu\n            this.activateTimeoutId = window.setTimeout(function () { return _this.activate(true); }, MenuItemComponent.ACTIVATION_DELAY);\n        }\n        else {\n            // activate immediately\n            this.activate(true);\n        }\n    };\n    MenuItemComponent.prototype.onMouseLeave = function () {\n        var _this = this;\n        this.cancelActivate();\n        if (this.isSubMenuOpen()) {\n            // wait to see if the user enters the sub-menu\n            this.deactivateTimeoutId = window.setTimeout(function () { return _this.deactivate(); }, MenuItemComponent.ACTIVATION_DELAY);\n        }\n        else {\n            // de-activate immediately\n            this.deactivate();\n        }\n    };\n    MenuItemComponent.prototype.getClassName = function (suffix) {\n        var prefix = this.params.isCompact ? 'ag-compact-menu-option' : 'ag-menu-option';\n        return suffix ? prefix + \"-\" + suffix : prefix;\n    };\n    MenuItemComponent.EVENT_MENU_ITEM_SELECTED = 'menuItemSelected';\n    MenuItemComponent.EVENT_MENU_ITEM_ACTIVATED = 'menuItemActivated';\n    MenuItemComponent.ACTIVATION_DELAY = 80;\n    __decorate$1u([\n        agGridCommunity.Autowired('popupService')\n    ], MenuItemComponent.prototype, \"popupService\", void 0);\n    __decorate$1u([\n        agGridCommunity.PostConstruct\n    ], MenuItemComponent.prototype, \"init\", null);\n    return MenuItemComponent;\n}(agGridCommunity.Component));\n\nvar __extends$2E = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$j = (undefined && undefined.__assign) || function () {\n    __assign$j = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$j.apply(this, arguments);\n};\nvar MenuList = /** @class */ (function (_super) {\n    __extends$2E(MenuList, _super);\n    function MenuList(level) {\n        if (level === void 0) { level = 1; }\n        var _this = _super.call(this, /* html */ \"<div class=\\\"ag-menu-list\\\" role=\\\"tree\\\"></div>\", true) || this;\n        _this.level = level;\n        _this.menuItems = [];\n        return _this;\n    }\n    MenuList.prototype.onTabKeyDown = function (e) {\n        var parent = this.getParentComponent();\n        var isManaged = parent && parent instanceof agGridCommunity.ManagedFocusComponent;\n        if (!isManaged) {\n            e.preventDefault();\n        }\n        if (e.shiftKey) {\n            this.closeIfIsChild(e);\n        }\n    };\n    MenuList.prototype.handleKeyDown = function (e) {\n        switch (e.keyCode) {\n            case agGridCommunity.KeyCode.UP:\n            case agGridCommunity.KeyCode.RIGHT:\n            case agGridCommunity.KeyCode.DOWN:\n            case agGridCommunity.KeyCode.LEFT:\n                e.preventDefault();\n                this.handleNavKey(e.keyCode);\n                break;\n            case agGridCommunity.KeyCode.ESCAPE:\n                var topMenu = this.findTopMenu();\n                if (topMenu) {\n                    this.focusController.focusInto(topMenu.getGui());\n                }\n                break;\n        }\n    };\n    MenuList.prototype.clearActiveItem = function () {\n        if (this.activeMenuItem) {\n            this.activeMenuItem.deactivate();\n            this.activeMenuItem = null;\n        }\n    };\n    MenuList.prototype.addMenuItems = function (menuItems) {\n        var _this = this;\n        if (menuItems == null) {\n            return;\n        }\n        menuItems.forEach(function (menuItemOrString) {\n            if (menuItemOrString === 'separator') {\n                _this.addSeparator();\n            }\n            else if (typeof menuItemOrString === 'string') {\n                console.warn(\"AG Grid: unrecognised menu item \" + menuItemOrString);\n            }\n            else {\n                _this.addItem(menuItemOrString);\n            }\n        });\n    };\n    MenuList.prototype.addItem = function (menuItemDef) {\n        var _this = this;\n        var menuItem = this.createManagedBean(new MenuItemComponent(__assign$j(__assign$j({}, menuItemDef), { isAnotherSubMenuOpen: function () { return agGridCommunity._.some(_this.menuItems, function (m) { return m.isSubMenuOpen(); }); } })));\n        menuItem.setParentComponent(this);\n        agGridCommunity._.setAriaLevel(menuItem.getGui(), this.level);\n        this.menuItems.push(menuItem);\n        this.appendChild(menuItem.getGui());\n        this.addManagedListener(menuItem, MenuItemComponent.EVENT_MENU_ITEM_SELECTED, function (event) {\n            _this.dispatchEvent(event);\n        });\n        this.addManagedListener(menuItem, MenuItemComponent.EVENT_MENU_ITEM_ACTIVATED, function (event) {\n            if (_this.activeMenuItem && _this.activeMenuItem !== event.menuItem) {\n                _this.activeMenuItem.deactivate();\n            }\n            _this.activeMenuItem = event.menuItem;\n        });\n    };\n    MenuList.prototype.activateFirstItem = function () {\n        var item = this.menuItems.filter(function (currentItem) { return !currentItem.isDisabled(); })[0];\n        if (!item) {\n            return;\n        }\n        item.activate();\n    };\n    MenuList.prototype.addSeparator = function () {\n        var separatorHtml = /* html */ \"\\n            <div class=\\\"ag-menu-separator\\\" aria-hidden=\\\"true\\\">\\n                <div class=\\\"ag-menu-separator-part\\\"></div>\\n                <div class=\\\"ag-menu-separator-part\\\"></div>\\n                <div class=\\\"ag-menu-separator-part\\\"></div>\\n                <div class=\\\"ag-menu-separator-part\\\"></div>\\n            </div>\";\n        this.appendChild(agGridCommunity._.loadTemplate(separatorHtml));\n    };\n    MenuList.prototype.findTopMenu = function () {\n        var parent = this.getParentComponent();\n        if (!parent && this instanceof MenuList) {\n            return this;\n        }\n        while (true) {\n            var nextParent = parent && parent.getParentComponent && parent.getParentComponent();\n            if (!nextParent || (!(nextParent instanceof MenuList || nextParent instanceof MenuItemComponent))) {\n                break;\n            }\n            parent = nextParent;\n        }\n        return parent instanceof MenuList ? parent : undefined;\n    };\n    MenuList.prototype.handleNavKey = function (key) {\n        switch (key) {\n            case agGridCommunity.KeyCode.UP:\n            case agGridCommunity.KeyCode.DOWN:\n                var nextItem = this.findNextItem(key === agGridCommunity.KeyCode.UP);\n                if (nextItem && nextItem !== this.activeMenuItem) {\n                    nextItem.activate();\n                }\n                return;\n        }\n        var left = this.gridOptionsWrapper.isEnableRtl() ? agGridCommunity.KeyCode.RIGHT : agGridCommunity.KeyCode.LEFT;\n        if (key === left) {\n            this.closeIfIsChild();\n        }\n        else {\n            this.openChild();\n        }\n    };\n    MenuList.prototype.closeIfIsChild = function (e) {\n        var parentItem = this.getParentComponent();\n        if (parentItem && parentItem instanceof MenuItemComponent) {\n            if (e) {\n                e.preventDefault();\n            }\n            parentItem.closeSubMenu();\n            parentItem.getGui().focus();\n        }\n    };\n    MenuList.prototype.openChild = function () {\n        if (this.activeMenuItem) {\n            this.activeMenuItem.openSubMenu(true);\n        }\n    };\n    MenuList.prototype.findNextItem = function (up) {\n        var items = this.menuItems.filter(function (item) { return !item.isDisabled(); });\n        if (!items.length) {\n            return;\n        }\n        if (!this.activeMenuItem) {\n            return up ? agGridCommunity._.last(items) : items[0];\n        }\n        if (up) {\n            items.reverse();\n        }\n        var nextItem;\n        var foundCurrent = false;\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            if (!foundCurrent) {\n                if (item === this.activeMenuItem) {\n                    foundCurrent = true;\n                }\n                continue;\n            }\n            nextItem = item;\n            break;\n        }\n        return nextItem || this.activeMenuItem;\n    };\n    MenuList.prototype.destroy = function () {\n        this.clearActiveItem();\n        _super.prototype.destroy.call(this);\n    };\n    return MenuList;\n}(agGridCommunity.ManagedFocusComponent));\n\nvar __extends$2F = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar EnterpriseMenuFactory = /** @class */ (function (_super) {\n    __extends$2F(EnterpriseMenuFactory, _super);\n    function EnterpriseMenuFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EnterpriseMenuFactory.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n    };\n    EnterpriseMenuFactory.prototype.hideActiveMenu = function () {\n        this.destroyBean(this.activeMenu);\n    };\n    EnterpriseMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent, defaultTab) {\n        var _this = this;\n        this.showMenu(column, function (menu) {\n            var ePopup = menu.getGui();\n            _this.popupService.positionPopupUnderMouseEvent({\n                type: 'columnMenu',\n                column: column,\n                mouseEvent: mouseEvent,\n                ePopup: ePopup\n            });\n            if (defaultTab) {\n                menu.showTab(defaultTab);\n            }\n        }, defaultTab, undefined, mouseEvent.target);\n    };\n    EnterpriseMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource, defaultTab, restrictToTabs) {\n        var _this = this;\n        var multiplier = -1;\n        var alignSide = 'left';\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            multiplier = 1;\n            alignSide = 'right';\n        }\n        this.showMenu(column, function (menu) {\n            var minDims = menu.getMinDimensions();\n            var minWidth = minDims.width, minHeight = minDims.height;\n            var ePopup = menu.getGui();\n            _this.popupService.positionPopupUnderComponent({\n                type: 'columnMenu',\n                column: column,\n                eventSource: eventSource,\n                ePopup: ePopup,\n                minWidth: minWidth,\n                minHeight: minHeight,\n                alignSide: alignSide,\n                nudgeX: 9 * multiplier,\n                nudgeY: -23,\n                keepWithinBounds: true\n            });\n            if (defaultTab) {\n                menu.showTab(defaultTab);\n            }\n        }, defaultTab, restrictToTabs, eventSource);\n    };\n    EnterpriseMenuFactory.prototype.showMenu = function (column, positionCallback, defaultTab, restrictToTabs, eventSource) {\n        var _this = this;\n        var menu = this.createBean(new EnterpriseMenu(column, this.lastSelectedTab, restrictToTabs));\n        var eMenuGui = menu.getGui();\n        var anchorToElement = eventSource || this.gridPanel.getGui();\n        var closedFuncs = [];\n        closedFuncs.push(function (e) {\n            _this.destroyBean(menu);\n            column.setMenuVisible(false, 'contextMenu');\n            var isKeyboardEvent = e instanceof KeyboardEvent;\n            if (isKeyboardEvent && eventSource && agGridCommunity._.isVisible(eventSource)) {\n                var focusableEl = _this.focusController.findTabbableParent(eventSource);\n                if (focusableEl) {\n                    focusableEl.focus();\n                }\n            }\n        });\n        // need to show filter before positioning, as only after filter\n        // is visible can we find out what the width of it is\n        var addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: eMenuGui,\n            closeOnEsc: true,\n            closedCallback: function (e) {\n                closedFuncs.forEach(function (f) { return f(e); });\n            },\n            afterGuiAttached: function (params) { return menu.afterGuiAttached(params); },\n            positionCallback: function () { return positionCallback(menu); },\n            anchorToElement: anchorToElement\n        });\n        if (addPopupRes) {\n            // if user starts showing / hiding columns, or otherwise move the underlying column\n            // for this menu, we want to stop tracking the menu with the column position. otherwise\n            // the menu would move as the user is using the columns tab inside the menu.\n            var stopAnchoringFunc_1 = addPopupRes.stopAnchoringFunc;\n            if (stopAnchoringFunc_1) {\n                column.addEventListener(agGridCommunity.Column.EVENT_LEFT_CHANGED, stopAnchoringFunc_1);\n                column.addEventListener(agGridCommunity.Column.EVENT_VISIBLE_CHANGED, stopAnchoringFunc_1);\n                closedFuncs.push(function () {\n                    column.removeEventListener(agGridCommunity.Column.EVENT_LEFT_CHANGED, stopAnchoringFunc_1);\n                    column.removeEventListener(agGridCommunity.Column.EVENT_VISIBLE_CHANGED, stopAnchoringFunc_1);\n                });\n            }\n        }\n        if (!defaultTab) {\n            menu.showTabBasedOnPreviousSelection();\n        }\n        menu.addEventListener(EnterpriseMenu.EVENT_TAB_SELECTED, function (event) {\n            _this.lastSelectedTab = event.key;\n        });\n        column.setMenuVisible(true, 'contextMenu');\n        this.activeMenu = menu;\n        menu.addEventListener(agGridCommunity.BeanStub.EVENT_DESTROYED, function () {\n            if (_this.activeMenu === menu) {\n                _this.activeMenu = null;\n            }\n        });\n    };\n    EnterpriseMenuFactory.prototype.isMenuEnabled = function (column) {\n        return column.getMenuTabs(EnterpriseMenu.TABS_DEFAULT).length > 0;\n    };\n    __decorate$1v([\n        agGridCommunity.Autowired('popupService')\n    ], EnterpriseMenuFactory.prototype, \"popupService\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('focusController')\n    ], EnterpriseMenuFactory.prototype, \"focusController\", void 0);\n    EnterpriseMenuFactory = __decorate$1v([\n        agGridCommunity.Bean('menuFactory')\n    ], EnterpriseMenuFactory);\n    return EnterpriseMenuFactory;\n}(agGridCommunity.BeanStub));\nvar EnterpriseMenu = /** @class */ (function (_super) {\n    __extends$2F(EnterpriseMenu, _super);\n    function EnterpriseMenu(column, initialSelection, restrictTo) {\n        var _this = _super.call(this) || this;\n        _this.tabFactories = {};\n        _this.includeChecks = {};\n        _this.timeOfLastColumnChange = Date.now();\n        _this.column = column;\n        _this.initialSelection = initialSelection;\n        _this.tabFactories[EnterpriseMenu.TAB_GENERAL] = _this.createMainPanel.bind(_this);\n        _this.tabFactories[EnterpriseMenu.TAB_FILTER] = _this.createFilterPanel.bind(_this);\n        _this.tabFactories[EnterpriseMenu.TAB_COLUMNS] = _this.createColumnsPanel.bind(_this);\n        _this.includeChecks[EnterpriseMenu.TAB_GENERAL] = function () { return true; };\n        _this.includeChecks[EnterpriseMenu.TAB_FILTER] = function () { return column.isFilterAllowed(); };\n        _this.includeChecks[EnterpriseMenu.TAB_COLUMNS] = function () { return true; };\n        _this.restrictTo = restrictTo;\n        return _this;\n    }\n    EnterpriseMenu.prototype.getMinDimensions = function () {\n        return this.tabbedLayout.getMinDimensions();\n    };\n    EnterpriseMenu.prototype.init = function () {\n        var _this = this;\n        var tabs = this.getTabsToCreate().map(function (name) { return _this.createTab(name); });\n        this.tabbedLayout = new agGridCommunity.TabbedLayout({\n            items: tabs,\n            cssClass: 'ag-menu',\n            onActiveItemClicked: this.onHidePopup.bind(this),\n            onItemClicked: this.onTabItemClicked.bind(this)\n        });\n        this.createBean(this.tabbedLayout);\n        if (this.mainMenuList) {\n            this.mainMenuList.setParentComponent(this.tabbedLayout);\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n    };\n    EnterpriseMenu.prototype.getTabsToCreate = function () {\n        var _this = this;\n        if (this.restrictTo) {\n            return this.restrictTo;\n        }\n        return this.column.getMenuTabs(EnterpriseMenu.TABS_DEFAULT)\n            .filter(function (tabName) { return _this.isValidMenuTabItem(tabName); })\n            .filter(function (tabName) { return _this.isNotSuppressed(tabName); })\n            .filter(function (tabName) { return _this.isModuleLoaded(tabName); });\n    };\n    EnterpriseMenu.prototype.isModuleLoaded = function (menuTabName) {\n        if (menuTabName === EnterpriseMenu.TAB_COLUMNS) {\n            return agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.ColumnToolPanelModule);\n        }\n        return true;\n    };\n    EnterpriseMenu.prototype.isValidMenuTabItem = function (menuTabName) {\n        var isValid = true;\n        var itemsToConsider = EnterpriseMenu.TABS_DEFAULT;\n        if (this.restrictTo != null) {\n            isValid = this.restrictTo.indexOf(menuTabName) > -1;\n            itemsToConsider = this.restrictTo;\n        }\n        isValid = isValid && EnterpriseMenu.TABS_DEFAULT.indexOf(menuTabName) > -1;\n        if (!isValid) {\n            console.warn(\"Trying to render an invalid menu item '\" + menuTabName + \"'. Check that your 'menuTabs' contains one of [\" + itemsToConsider + \"]\");\n        }\n        return isValid;\n    };\n    EnterpriseMenu.prototype.isNotSuppressed = function (menuTabName) {\n        return this.includeChecks[menuTabName]();\n    };\n    EnterpriseMenu.prototype.createTab = function (name) {\n        return this.tabFactories[name]();\n    };\n    EnterpriseMenu.prototype.showTabBasedOnPreviousSelection = function () {\n        // show the tab the user was on last time they had a menu open\n        this.showTab(this.initialSelection);\n    };\n    EnterpriseMenu.prototype.showTab = function (toShow) {\n        if (this.tabItemColumns && toShow === EnterpriseMenu.TAB_COLUMNS) {\n            this.tabbedLayout.showItem(this.tabItemColumns);\n        }\n        else if (this.tabItemFilter && toShow === EnterpriseMenu.TAB_FILTER) {\n            this.tabbedLayout.showItem(this.tabItemFilter);\n        }\n        else if (this.tabItemGeneral && toShow === EnterpriseMenu.TAB_GENERAL) {\n            this.tabbedLayout.showItem(this.tabItemGeneral);\n        }\n        else {\n            this.tabbedLayout.showFirstItem();\n        }\n    };\n    EnterpriseMenu.prototype.onTabItemClicked = function (event) {\n        var key = null;\n        switch (event.item) {\n            case this.tabItemColumns:\n                key = EnterpriseMenu.TAB_COLUMNS;\n                break;\n            case this.tabItemFilter:\n                key = EnterpriseMenu.TAB_FILTER;\n                break;\n            case this.tabItemGeneral:\n                key = EnterpriseMenu.TAB_GENERAL;\n                break;\n        }\n        if (key) {\n            this.activateTab(key);\n        }\n    };\n    EnterpriseMenu.prototype.activateTab = function (tab) {\n        var ev = {\n            type: EnterpriseMenu.EVENT_TAB_SELECTED,\n            key: tab\n        };\n        this.dispatchEvent(ev);\n    };\n    EnterpriseMenu.prototype.getMenuItems = function () {\n        var defaultMenuOptions = this.getDefaultMenuOptions();\n        var result;\n        var userFunc = this.gridOptionsWrapper.getMainMenuItemsFunc();\n        if (userFunc) {\n            result = userFunc({\n                column: this.column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n                defaultItems: defaultMenuOptions\n            });\n        }\n        else {\n            result = defaultMenuOptions;\n        }\n        // GUI looks weird when two separators are side by side. this can happen accidentally\n        // if we remove items from the menu then two separators can edit up adjacent.\n        agGridCommunity._.removeRepeatsFromArray(result, EnterpriseMenu.MENU_ITEM_SEPARATOR);\n        return result;\n    };\n    EnterpriseMenu.prototype.getDefaultMenuOptions = function () {\n        var result = [];\n        var allowPinning = !this.column.getColDef().lockPinned;\n        var rowGroupCount = this.columnController.getRowGroupColumns().length;\n        var doingGrouping = rowGroupCount > 0;\n        var groupedByThisColumn = this.columnController.getRowGroupColumns().indexOf(this.column) >= 0;\n        var allowValue = this.column.isAllowValue();\n        var allowRowGroup = this.column.isAllowRowGroup();\n        var isPrimary = this.column.isPrimary();\n        var pivotModeOn = this.columnController.isPivotMode();\n        var isInMemoryRowModel = this.rowModel.getType() === agGridCommunity.Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        var allowValueAgg = \n        // if primary, then only allow aggValue if grouping and it's a value columns\n        (isPrimary && doingGrouping && allowValue)\n            // secondary columns can always have aggValue, as it means it's a pivot value column\n            || !isPrimary;\n        if (allowPinning) {\n            result.push('pinSubMenu');\n        }\n        if (allowValueAgg) {\n            result.push('valueAggSubMenu');\n        }\n        if (allowPinning || allowValueAgg) {\n            result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);\n        }\n        result.push('autoSizeThis');\n        result.push('autoSizeAll');\n        result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);\n        if (allowRowGroup && this.column.isPrimary()) {\n            if (groupedByThisColumn) {\n                result.push('rowUnGroup');\n            }\n            else {\n                result.push('rowGroup');\n            }\n        }\n        result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);\n        result.push('resetColumns');\n        // only add grouping expand/collapse if grouping in the InMemoryRowModel\n        // if pivoting, we only have expandable groups if grouping by 2 or more columns\n        // as the lowest level group is not expandable while pivoting.\n        // if not pivoting, then any active row group can be expanded.\n        var allowExpandAndContract = isInMemoryRowModel && (usingTreeData || rowGroupCount > (pivotModeOn ? 1 : 0));\n        if (allowExpandAndContract) {\n            result.push('expandAll');\n            result.push('contractAll');\n        }\n        return result;\n    };\n    EnterpriseMenu.prototype.createMainPanel = function () {\n        this.mainMenuList = this.createManagedBean(new MenuList());\n        var menuItems = this.getMenuItems();\n        var menuItemsMapped = this.menuItemMapper.mapWithStockItems(menuItems, this.column);\n        this.mainMenuList.addMenuItems(menuItemsMapped);\n        this.mainMenuList.addEventListener(MenuItemComponent.EVENT_MENU_ITEM_SELECTED, this.onHidePopup.bind(this));\n        this.tabItemGeneral = {\n            title: agGridCommunity._.createIconNoSpan('menu', this.gridOptionsWrapper, this.column),\n            titleLabel: EnterpriseMenu.TAB_GENERAL.replace('MenuTab', ''),\n            bodyPromise: agGridCommunity.AgPromise.resolve(this.mainMenuList.getGui()),\n            name: EnterpriseMenu.TAB_GENERAL\n        };\n        return this.tabItemGeneral;\n    };\n    EnterpriseMenu.prototype.onHidePopup = function () {\n        this.hidePopupFunc();\n        // this method only gets called when the menu was closed by selection an option\n        // in this case we highlight the cell that was previously highlighted\n        var focusedCell = this.focusController.getFocusedCell();\n        if (focusedCell) {\n            var rowIndex = focusedCell.rowIndex, rowPinned = focusedCell.rowPinned, column = focusedCell.column;\n            this.focusController.setFocusedCell(rowIndex, column, rowPinned, true);\n        }\n    };\n    EnterpriseMenu.prototype.createFilterPanel = function () {\n        var filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.column, 'COLUMN_MENU');\n        var afterFilterAttachedCallback = function (params) {\n            if (!filterWrapper.filterPromise) {\n                return;\n            }\n            // slightly odd block this - this promise will always have been resolved by the time it gets here, so won't be\n            // async (_unless_ in react or similar, but if so why not encountered before now?).\n            // I'd suggest a future improvement would be to remove/replace this promise as this block just wont work if it is\n            // async and is confusing if you don't have this context\n            filterWrapper.filterPromise.then(function (filter) {\n                if (filter && filter.afterGuiAttached) {\n                    filter.afterGuiAttached(params);\n                }\n            });\n        };\n        this.tabItemFilter = {\n            title: agGridCommunity._.createIconNoSpan('filter', this.gridOptionsWrapper, this.column),\n            titleLabel: EnterpriseMenu.TAB_FILTER.replace('MenuTab', ''),\n            bodyPromise: filterWrapper.guiPromise,\n            afterAttachedCallback: afterFilterAttachedCallback,\n            name: EnterpriseMenu.TAB_FILTER\n        };\n        return this.tabItemFilter;\n    };\n    EnterpriseMenu.prototype.createColumnsPanel = function () {\n        var eWrapperDiv = document.createElement('div');\n        agGridCommunity._.addCssClass(eWrapperDiv, 'ag-menu-column-select-wrapper');\n        this.columnSelectPanel = this.createManagedBean(new PrimaryColsPanel());\n        var columnsMenuParams = this.column.getColDef().columnsMenuParams;\n        if (!columnsMenuParams) {\n            columnsMenuParams = {};\n        }\n        this.columnSelectPanel.init(false, {\n            suppressValues: false,\n            suppressPivots: false,\n            suppressRowGroups: false,\n            suppressPivotMode: false,\n            contractColumnSelection: !!columnsMenuParams.contractColumnSelection,\n            suppressColumnExpandAll: !!columnsMenuParams.suppressColumnExpandAll,\n            suppressColumnFilter: !!columnsMenuParams.suppressColumnFilter,\n            suppressColumnSelectAll: !!columnsMenuParams.suppressColumnSelectAll,\n            suppressSideButtons: false,\n            suppressSyncLayoutWithGrid: !!columnsMenuParams.suppressSyncLayoutWithGrid,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        }, 'columnMenu');\n        agGridCommunity._.addCssClass(this.columnSelectPanel.getGui(), 'ag-menu-column-select');\n        eWrapperDiv.appendChild(this.columnSelectPanel.getGui());\n        this.tabItemColumns = {\n            title: agGridCommunity._.createIconNoSpan('columns', this.gridOptionsWrapper, this.column),\n            titleLabel: EnterpriseMenu.TAB_COLUMNS.replace('MenuTab', ''),\n            bodyPromise: agGridCommunity.AgPromise.resolve(eWrapperDiv),\n            name: EnterpriseMenu.TAB_COLUMNS\n        };\n        return this.tabItemColumns;\n    };\n    EnterpriseMenu.prototype.afterGuiAttached = function (params) {\n        var hidePopup = params.hidePopup;\n        this.tabbedLayout.setAfterAttachedParams({ container: 'columnMenu', hidePopup: hidePopup });\n        this.hidePopupFunc = hidePopup;\n        this.addDestroyFunc(hidePopup);\n    };\n    EnterpriseMenu.prototype.getGui = function () {\n        return this.tabbedLayout.getGui();\n    };\n    EnterpriseMenu.prototype.onDisplayedColumnsChanged = function () {\n        this.timeOfLastColumnChange = Date.now();\n    };\n    EnterpriseMenu.EVENT_TAB_SELECTED = 'tabSelected';\n    EnterpriseMenu.TAB_FILTER = 'filterMenuTab';\n    EnterpriseMenu.TAB_GENERAL = 'generalMenuTab';\n    EnterpriseMenu.TAB_COLUMNS = 'columnsMenuTab';\n    EnterpriseMenu.TABS_DEFAULT = [EnterpriseMenu.TAB_GENERAL, EnterpriseMenu.TAB_FILTER, EnterpriseMenu.TAB_COLUMNS];\n    EnterpriseMenu.MENU_ITEM_SEPARATOR = 'separator';\n    __decorate$1v([\n        agGridCommunity.Autowired('columnController')\n    ], EnterpriseMenu.prototype, \"columnController\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('filterManager')\n    ], EnterpriseMenu.prototype, \"filterManager\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('gridApi')\n    ], EnterpriseMenu.prototype, \"gridApi\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('columnApi')\n    ], EnterpriseMenu.prototype, \"columnApi\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('menuItemMapper')\n    ], EnterpriseMenu.prototype, \"menuItemMapper\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('rowModel')\n    ], EnterpriseMenu.prototype, \"rowModel\", void 0);\n    __decorate$1v([\n        agGridCommunity.Autowired('focusController')\n    ], EnterpriseMenu.prototype, \"focusController\", void 0);\n    __decorate$1v([\n        agGridCommunity.PostConstruct\n    ], EnterpriseMenu.prototype, \"init\", null);\n    return EnterpriseMenu;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2G = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar CSS_MENU = 'ag-menu';\nvar CSS_CONTEXT_MENU_OPEN = ' ag-context-menu-open';\nvar ContextMenuFactory = /** @class */ (function (_super) {\n    __extends$2G(ContextMenuFactory, _super);\n    function ContextMenuFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ContextMenuFactory.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n    };\n    ContextMenuFactory.prototype.hideActiveMenu = function () {\n        this.destroyBean(this.activeMenu);\n    };\n    ContextMenuFactory.prototype.getMenuItems = function (node, column, value) {\n        var defaultMenuOptions = [];\n        if (agGridCommunity._.exists(node) && agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.ClipboardModule)) {\n            if (column) {\n                // only makes sense if column exists, could have originated from a row\n                defaultMenuOptions.push('copy', 'copyWithHeaders', 'paste', 'separator');\n            }\n        }\n        if (this.gridOptionsWrapper.isEnableCharts() &&\n            agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.RangeSelectionModule) &&\n            agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.GridChartsModule)) {\n            if (this.columnController.isPivotMode()) {\n                defaultMenuOptions.push('pivotChart');\n            }\n            if (this.rangeController && !this.rangeController.isEmpty()) {\n                defaultMenuOptions.push('chartRange');\n            }\n        }\n        if (agGridCommunity._.exists(node)) {\n            // if user clicks a cell\n            var csvModuleMissing = !agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.CsvExportModule);\n            var excelModuleMissing = !agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.ExcelExportModule);\n            var suppressExcel = this.gridOptionsWrapper.isSuppressExcelExport() || excelModuleMissing;\n            var suppressCsv = this.gridOptionsWrapper.isSuppressCsvExport() || csvModuleMissing;\n            var onIPad = agGridCommunity._.isIOSUserAgent();\n            var anyExport = !onIPad && (!suppressExcel || !suppressCsv);\n            if (anyExport) {\n                defaultMenuOptions.push('export');\n            }\n        }\n        if (this.gridOptionsWrapper.getContextMenuItemsFunc()) {\n            var userFunc = this.gridOptionsWrapper.getContextMenuItemsFunc();\n            var params = {\n                node: node,\n                column: column,\n                value: value,\n                defaultItems: defaultMenuOptions.length ? defaultMenuOptions : undefined,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            return userFunc ? userFunc(params) : undefined;\n        }\n        return defaultMenuOptions;\n    };\n    ContextMenuFactory.prototype.showMenu = function (node, column, value, mouseEvent, anchorToElement) {\n        var _this = this;\n        var menuItems = this.getMenuItems(node, column, value);\n        var eGridPanelGui = this.gridPanel.getGui();\n        if (menuItems === undefined || agGridCommunity._.missingOrEmpty(menuItems)) {\n            return false;\n        }\n        var menu = new ContextMenu(menuItems);\n        this.createBean(menu);\n        var eMenuGui = menu.getGui();\n        var positionParams = {\n            column: column,\n            rowNode: node,\n            type: 'contextMenu',\n            mouseEvent: mouseEvent,\n            ePopup: eMenuGui,\n            // move one pixel away so that accidentally double clicking\n            // won't show the browser's contextmenu\n            nudgeX: 1,\n            nudgeY: 1\n        };\n        var positionCallback = this.popupService.positionPopupUnderMouseEvent.bind(this.popupService, positionParams);\n        var addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: eMenuGui,\n            closeOnEsc: true,\n            closedCallback: function () {\n                agGridCommunity._.removeCssClass(eGridPanelGui, CSS_CONTEXT_MENU_OPEN);\n                _this.destroyBean(menu);\n            },\n            click: mouseEvent,\n            positionCallback: positionCallback,\n            // so when browser is scrolled down, or grid is scrolled, context menu stays with cell\n            anchorToElement: anchorToElement\n        });\n        if (addPopupRes) {\n            agGridCommunity._.addCssClass(eGridPanelGui, CSS_CONTEXT_MENU_OPEN);\n            menu.afterGuiAttached({ container: 'contextMenu', hidePopup: addPopupRes.hideFunc });\n        }\n        // there should never be an active menu at this point, however it was found\n        // that you could right click a second time just 1 or 2 pixels from the first\n        // click, and another menu would pop up. so somehow the logic for closing the\n        // first menu (clicking outside should close it) was glitchy somehow. an easy\n        // way to avoid this is just remove the old context menu here if it exists.\n        if (this.activeMenu) {\n            this.hideActiveMenu();\n        }\n        this.activeMenu = menu;\n        menu.addEventListener(agGridCommunity.BeanStub.EVENT_DESTROYED, function () {\n            if (_this.activeMenu === menu) {\n                _this.activeMenu = null;\n            }\n        });\n        // hide the popup if something gets selected\n        if (addPopupRes) {\n            menu.addEventListener(MenuItemComponent.EVENT_MENU_ITEM_SELECTED, addPopupRes.hideFunc);\n        }\n        return true;\n    };\n    __decorate$1w([\n        agGridCommunity.Autowired('popupService')\n    ], ContextMenuFactory.prototype, \"popupService\", void 0);\n    __decorate$1w([\n        agGridCommunity.Optional('rangeController')\n    ], ContextMenuFactory.prototype, \"rangeController\", void 0);\n    __decorate$1w([\n        agGridCommunity.Autowired('columnController')\n    ], ContextMenuFactory.prototype, \"columnController\", void 0);\n    ContextMenuFactory = __decorate$1w([\n        agGridCommunity.Bean('contextMenuFactory')\n    ], ContextMenuFactory);\n    return ContextMenuFactory;\n}(agGridCommunity.BeanStub));\nvar ContextMenu = /** @class */ (function (_super) {\n    __extends$2G(ContextMenu, _super);\n    function ContextMenu(menuItems) {\n        var _this = _super.call(this, /* html */ \"<div class=\\\"\" + CSS_MENU + \"\\\" role=\\\"presentation\\\"></div>\") || this;\n        _this.menuList = null;\n        _this.focusedCell = null;\n        _this.menuItems = menuItems;\n        return _this;\n    }\n    ContextMenu.prototype.addMenuItems = function () {\n        var _this = this;\n        var menuList = this.createBean(new MenuList());\n        var menuItemsMapped = this.menuItemMapper.mapWithStockItems(this.menuItems, null);\n        menuList.addMenuItems(menuItemsMapped);\n        this.appendChild(menuList);\n        this.menuList = menuList;\n        menuList.addEventListener(MenuItemComponent.EVENT_MENU_ITEM_SELECTED, function (e) { return _this.dispatchEvent(e); });\n    };\n    ContextMenu.prototype.afterGuiAttached = function (params) {\n        if (params.hidePopup) {\n            this.addDestroyFunc(params.hidePopup);\n        }\n        this.focusedCell = this.focusController.getFocusedCell();\n        if (this.menuList) {\n            this.focusController.focusInto(this.menuList.getGui());\n        }\n    };\n    ContextMenu.prototype.restoreFocusedCell = function () {\n        var currentFocusedCell = this.focusController.getFocusedCell();\n        if (currentFocusedCell && this.focusedCell && this.cellPositionUtils.equals(currentFocusedCell, this.focusedCell)) {\n            var _a = this.focusedCell, rowIndex = _a.rowIndex, rowPinned = _a.rowPinned, column = _a.column;\n            var doc = this.gridOptionsWrapper.getDocument();\n            if (doc.activeElement === doc.body) {\n                this.focusController.setFocusedCell(rowIndex, column, rowPinned, true);\n            }\n        }\n    };\n    ContextMenu.prototype.destroy = function () {\n        this.restoreFocusedCell();\n        _super.prototype.destroy.call(this);\n    };\n    __decorate$1w([\n        agGridCommunity.Autowired('menuItemMapper')\n    ], ContextMenu.prototype, \"menuItemMapper\", void 0);\n    __decorate$1w([\n        agGridCommunity.Autowired('focusController')\n    ], ContextMenu.prototype, \"focusController\", void 0);\n    __decorate$1w([\n        agGridCommunity.Autowired('cellPositionUtils')\n    ], ContextMenu.prototype, \"cellPositionUtils\", void 0);\n    __decorate$1w([\n        agGridCommunity.PostConstruct\n    ], ContextMenu.prototype, \"addMenuItems\", null);\n    return ContextMenu;\n}(agGridCommunity.Component));\n\nvar __extends$2H = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MenuItemMapper = /** @class */ (function (_super) {\n    __extends$2H(MenuItemMapper, _super);\n    function MenuItemMapper() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MenuItemMapper.prototype.mapWithStockItems = function (originalList, column) {\n        var _this = this;\n        if (!originalList) {\n            return [];\n        }\n        var resultList = [];\n        originalList.forEach(function (menuItemOrString) {\n            var result;\n            if (typeof menuItemOrString === 'string') {\n                result = _this.getStockMenuItem(menuItemOrString, column);\n            }\n            else {\n                result = menuItemOrString;\n            }\n            // if no mapping, can happen when module is not loaded but user tries to use module anyway\n            if (!result) {\n                return;\n            }\n            var resultDef = result;\n            var subMenu = resultDef.subMenu;\n            if (subMenu && subMenu instanceof Array) {\n                resultDef.subMenu = _this.mapWithStockItems(resultDef.subMenu, column);\n            }\n            if (result != null) {\n                resultList.push(result);\n            }\n        });\n        return resultList;\n    };\n    MenuItemMapper.prototype.getStockMenuItem = function (key, column) {\n        var _this = this;\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var skipHeaderOnAutoSize = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n        switch (key) {\n            case 'pinSubMenu':\n                return {\n                    name: localeTextFunc('pinColumn', 'Pin Column'),\n                    icon: agGridCommunity._.createIconNoSpan('menuPin', this.gridOptionsWrapper, null),\n                    subMenu: ['pinLeft', 'pinRight', 'clearPinned']\n                };\n            case 'pinLeft':\n                return {\n                    name: localeTextFunc('pinLeft', 'Pin Left'),\n                    action: function () { return _this.columnController.setColumnPinned(column, agGridCommunity.Constants.PINNED_LEFT, \"contextMenu\"); },\n                    checked: !!column && column.isPinnedLeft()\n                };\n            case 'pinRight':\n                return {\n                    name: localeTextFunc('pinRight', 'Pin Right'),\n                    action: function () { return _this.columnController.setColumnPinned(column, agGridCommunity.Constants.PINNED_RIGHT, \"contextMenu\"); },\n                    checked: !!column && column.isPinnedRight()\n                };\n            case 'clearPinned':\n                return {\n                    name: localeTextFunc('noPin', 'No Pin'),\n                    action: function () { return _this.columnController.setColumnPinned(column, null, \"contextMenu\"); },\n                    checked: !!column && !column.isPinned()\n                };\n            case 'valueAggSubMenu':\n                if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.RowGroupingModule, 'Aggregation from Menu')) {\n                    return {\n                        name: localeTextFunc('valueAggregation', 'Value Aggregation'),\n                        icon: agGridCommunity._.createIconNoSpan('menuValue', this.gridOptionsWrapper, null),\n                        subMenu: this.createAggregationSubMenu(column)\n                    };\n                }\n                else {\n                    return null;\n                }\n            case 'autoSizeThis':\n                return {\n                    name: localeTextFunc('autosizeThiscolumn', 'Autosize This Column'),\n                    action: function () { return _this.columnController.autoSizeColumn(column, skipHeaderOnAutoSize, \"contextMenu\"); }\n                };\n            case 'autoSizeAll':\n                return {\n                    name: localeTextFunc('autosizeAllColumns', 'Autosize All Columns'),\n                    action: function () { return _this.columnController.autoSizeAllColumns(skipHeaderOnAutoSize, \"contextMenu\"); }\n                };\n            case 'rowGroup':\n                return {\n                    name: localeTextFunc('groupBy', 'Group by') + ' ' + agGridCommunity._.escapeString(this.columnController.getDisplayNameForColumn(column, 'header')),\n                    action: function () { return _this.columnController.addRowGroupColumn(column, \"contextMenu\"); },\n                    icon: agGridCommunity._.createIconNoSpan('menuAddRowGroup', this.gridOptionsWrapper, null)\n                };\n            case 'rowUnGroup':\n                return {\n                    name: localeTextFunc('ungroupBy', 'Un-Group by') + ' ' + agGridCommunity._.escapeString(this.columnController.getDisplayNameForColumn(column, 'header')),\n                    action: function () { return _this.columnController.removeRowGroupColumn(column, \"contextMenu\"); },\n                    icon: agGridCommunity._.createIconNoSpan('menuRemoveRowGroup', this.gridOptionsWrapper, null)\n                };\n            case 'resetColumns':\n                return {\n                    name: localeTextFunc('resetColumns', 'Reset Columns'),\n                    action: function () { return _this.columnController.resetColumnState(\"contextMenu\"); }\n                };\n            case 'expandAll':\n                return {\n                    name: localeTextFunc('expandAll', 'Expand All'),\n                    action: function () { return _this.gridApi.expandAll(); }\n                };\n            case 'contractAll':\n                return {\n                    name: localeTextFunc('collapseAll', 'Collapse All'),\n                    action: function () { return _this.gridApi.collapseAll(); }\n                };\n            case 'copy':\n                if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.ClipboardModule, 'Copy from Menu')) {\n                    return {\n                        name: localeTextFunc('copy', 'Copy'),\n                        shortcut: localeTextFunc('ctrlC', 'Ctrl+C'),\n                        icon: agGridCommunity._.createIconNoSpan('clipboardCopy', this.gridOptionsWrapper, null),\n                        action: function () { return _this.clipboardService.copyToClipboard(false); }\n                    };\n                }\n                else {\n                    return null;\n                }\n            case 'copyWithHeaders':\n                if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.ClipboardModule, 'Copy with Headers from Menu')) {\n                    return {\n                        name: localeTextFunc('copyWithHeaders', 'Copy with Headers'),\n                        // shortcut: localeTextFunc('ctrlC','Ctrl+C'),\n                        icon: agGridCommunity._.createIconNoSpan('clipboardCopy', this.gridOptionsWrapper, null),\n                        action: function () { return _this.clipboardService.copyToClipboard(true); }\n                    };\n                }\n                else {\n                    return null;\n                }\n            case 'paste':\n                if (agGridCommunity.ModuleRegistry.assertRegistered(agGridCommunity.ModuleNames.ClipboardModule, 'Copy with Headers from Menu')) {\n                    return {\n                        name: localeTextFunc('paste', 'Paste'),\n                        shortcut: localeTextFunc('ctrlV', 'Ctrl+V'),\n                        disabled: true,\n                        icon: agGridCommunity._.createIconNoSpan('clipboardPaste', this.gridOptionsWrapper, null),\n                        action: function () { return _this.clipboardService.pasteFromClipboard(); }\n                    };\n                }\n                else {\n                    return null;\n                }\n            case 'export':\n                var exportSubMenuItems = [];\n                var csvModuleLoaded = agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.CsvExportModule);\n                var excelModuleLoaded = agGridCommunity.ModuleRegistry.isRegistered(agGridCommunity.ModuleNames.ExcelExportModule);\n                if (!this.gridOptionsWrapper.isSuppressCsvExport() && csvModuleLoaded) {\n                    exportSubMenuItems.push('csvExport');\n                }\n                if (!this.gridOptionsWrapper.isSuppressExcelExport() && excelModuleLoaded) {\n                    exportSubMenuItems.push('excelExport');\n                    exportSubMenuItems.push('excelXmlExport');\n                }\n                return {\n                    name: localeTextFunc('export', 'Export'),\n                    subMenu: exportSubMenuItems,\n                    icon: agGridCommunity._.createIconNoSpan('save', this.gridOptionsWrapper, null),\n                };\n            case 'csvExport':\n                return {\n                    name: localeTextFunc('csvExport', 'CSV Export'),\n                    action: function () { return _this.gridApi.exportDataAsCsv({}); }\n                };\n            case 'excelExport':\n                return {\n                    name: localeTextFunc('excelExport', 'Excel Export (.xlsx)&lrm;'),\n                    action: function () { return _this.gridApi.exportDataAsExcel({\n                        exportMode: 'xlsx'\n                    }); }\n                };\n            case 'excelXmlExport':\n                return {\n                    name: localeTextFunc('excelXmlExport', 'Excel Export (.xml)&lrm;'),\n                    action: function () { return _this.gridApi.exportDataAsExcel({\n                        exportMode: 'xml'\n                    }); }\n                };\n            case 'separator':\n                return 'separator';\n            default:\n                var chartMenuItem = this.getChartItems(key);\n                if (chartMenuItem) {\n                    return chartMenuItem;\n                }\n                else {\n                    console.warn(\"AG Grid: unknown menu item type \" + key);\n                    return null;\n                }\n        }\n    };\n    MenuItemMapper.prototype.getChartItems = function (key) {\n        var _this = this;\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var pivotChartMenuItem = function (localeKey, defaultText, chartType) {\n            return {\n                name: localeTextFunc(localeKey, defaultText),\n                action: function () { return _this.chartService.createPivotChart({ chartType: chartType }); }\n            };\n        };\n        var rangeChartMenuItem = function (localeKey, defaultText, chartType) {\n            return {\n                name: localeTextFunc(localeKey, defaultText),\n                action: function () { return _this.chartService.createChartFromCurrentRange(chartType); }\n            };\n        };\n        switch (key) {\n            // case 'pivotChartAndPivotMode':\n            //     return {\n            //         name: localeTextFunc('pivotChartAndPivotMode', 'Pivot Chart & Pivot Mode&lrm;'),\n            //         action: () => this.chartService.pivotChart(ChartType.GroupedColumn),\n            //         icon: _.createIconNoSpan('chart', this.gridOptionsWrapper, null)\n            //     };\n            case 'pivotChart':\n                return {\n                    name: localeTextFunc('pivotChart', 'Pivot Chart'),\n                    subMenu: [\n                        'pivotColumnChart',\n                        'pivotBarChart',\n                        'pivotPieChart',\n                        'pivotLineChart',\n                        'pivotXYChart',\n                        'pivotAreaChart'\n                    ],\n                    icon: agGridCommunity._.createIconNoSpan('chart', this.gridOptionsWrapper, null),\n                };\n            case 'chartRange':\n                return {\n                    name: localeTextFunc('chartRange', 'Chart Range'),\n                    subMenu: [\n                        'rangeColumnChart',\n                        'rangeBarChart',\n                        'rangePieChart',\n                        'rangeLineChart',\n                        'rangeXYChart',\n                        'rangeAreaChart',\n                        'rangeHistogramChart'\n                    ],\n                    icon: agGridCommunity._.createIconNoSpan('chart', this.gridOptionsWrapper, null),\n                };\n            case 'pivotColumnChart':\n                return {\n                    name: localeTextFunc('columnChart', 'Column'),\n                    subMenu: ['pivotGroupedColumn', 'pivotStackedColumn', 'pivotNormalizedColumn']\n                };\n            case 'pivotGroupedColumn':\n                return pivotChartMenuItem('groupedColumn', 'Grouped&lrm;', agGridCommunity.ChartType.GroupedColumn);\n            case 'pivotStackedColumn':\n                return pivotChartMenuItem('stackedColumn', 'Stacked&lrm;', agGridCommunity.ChartType.StackedColumn);\n            case 'pivotNormalizedColumn':\n                return pivotChartMenuItem('normalizedColumn', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedColumn);\n            case 'rangeColumnChart':\n                return {\n                    name: localeTextFunc('columnChart', 'Column'),\n                    subMenu: ['rangeGroupedColumn', 'rangeStackedColumn', 'rangeNormalizedColumn']\n                };\n            case 'rangeGroupedColumn':\n                return rangeChartMenuItem('groupedColumn', 'Grouped&lrm;', agGridCommunity.ChartType.GroupedColumn);\n            case 'rangeStackedColumn':\n                return rangeChartMenuItem('stackedColumn', 'Stacked&lrm;', agGridCommunity.ChartType.StackedColumn);\n            case 'rangeNormalizedColumn':\n                return rangeChartMenuItem('normalizedColumn', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedColumn);\n            case 'pivotBarChart':\n                return {\n                    name: localeTextFunc('barChart', 'Bar'),\n                    subMenu: ['pivotGroupedBar', 'pivotStackedBar', 'pivotNormalizedBar']\n                };\n            case 'pivotGroupedBar':\n                return pivotChartMenuItem('groupedBar', 'Grouped&lrm;', agGridCommunity.ChartType.GroupedBar);\n            case 'pivotStackedBar':\n                return pivotChartMenuItem('stackedBar', 'Stacked&lrm;', agGridCommunity.ChartType.StackedBar);\n            case 'pivotNormalizedBar':\n                return pivotChartMenuItem('normalizedBar', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedBar);\n            case 'rangeBarChart':\n                return {\n                    name: localeTextFunc('barChart', 'Bar'),\n                    subMenu: ['rangeGroupedBar', 'rangeStackedBar', 'rangeNormalizedBar']\n                };\n            case 'rangeGroupedBar':\n                return rangeChartMenuItem('groupedBar', 'Grouped&lrm;', agGridCommunity.ChartType.GroupedBar);\n            case 'rangeStackedBar':\n                return rangeChartMenuItem('stackedBar', 'Stacked&lrm;', agGridCommunity.ChartType.StackedBar);\n            case 'rangeNormalizedBar':\n                return rangeChartMenuItem('normalizedBar', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedBar);\n            case 'pivotPieChart':\n                return {\n                    name: localeTextFunc('pieChart', 'Pie'),\n                    subMenu: ['pivotPie', 'pivotDoughnut']\n                };\n            case 'pivotPie':\n                return pivotChartMenuItem('pie', 'Pie&lrm;', agGridCommunity.ChartType.Pie);\n            case 'pivotDoughnut':\n                return pivotChartMenuItem('doughnut', 'Doughnut&lrm;', agGridCommunity.ChartType.Doughnut);\n            case 'rangePieChart':\n                return {\n                    name: localeTextFunc('pieChart', 'Pie'),\n                    subMenu: ['rangePie', 'rangeDoughnut']\n                };\n            case 'rangePie':\n                return rangeChartMenuItem('pie', 'Pie&lrm;', agGridCommunity.ChartType.Pie);\n            case 'rangeDoughnut':\n                return rangeChartMenuItem('doughnut', 'Doughnut&lrm;', agGridCommunity.ChartType.Doughnut);\n            case 'pivotLineChart':\n                return pivotChartMenuItem('line', 'Line&lrm;', agGridCommunity.ChartType.Line);\n            case 'rangeLineChart':\n                return rangeChartMenuItem('line', 'Line&lrm;', agGridCommunity.ChartType.Line);\n            case 'pivotXYChart':\n                return {\n                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),\n                    subMenu: ['pivotScatter', 'pivotBubble']\n                };\n            case 'pivotScatter':\n                return pivotChartMenuItem('scatter', 'Scatter&lrm;', agGridCommunity.ChartType.Scatter);\n            case 'pivotBubble':\n                return pivotChartMenuItem('bubble', 'Bubble&lrm;', agGridCommunity.ChartType.Bubble);\n            case 'rangeXYChart':\n                return {\n                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),\n                    subMenu: ['rangeScatter', 'rangeBubble']\n                };\n            case 'rangeScatter':\n                return rangeChartMenuItem('scatter', 'Scatter&lrm;', agGridCommunity.ChartType.Scatter);\n            case 'rangeBubble':\n                return rangeChartMenuItem('bubble', 'Bubble&lrm;', agGridCommunity.ChartType.Bubble);\n            case 'pivotAreaChart':\n                return {\n                    name: localeTextFunc('areaChart', 'Area'),\n                    subMenu: ['pivotArea', 'pivotStackedArea', 'pivotNormalizedArea']\n                };\n            case 'pivotArea':\n                return pivotChartMenuItem('area', 'Area&lrm;', agGridCommunity.ChartType.Area);\n            case 'pivotStackedArea':\n                return pivotChartMenuItem('stackedArea', 'Stacked&lrm;', agGridCommunity.ChartType.StackedArea);\n            case 'pivotNormalizedArea':\n                return pivotChartMenuItem('normalizedArea', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedArea);\n            case 'rangeAreaChart':\n                return {\n                    name: localeTextFunc('areaChart', 'Area'),\n                    subMenu: ['rangeArea', 'rangeStackedArea', 'rangeNormalizedArea']\n                };\n            case 'rangeArea':\n                return rangeChartMenuItem('area', 'Area&lrm;', agGridCommunity.ChartType.Area);\n            case 'rangeStackedArea':\n                return rangeChartMenuItem('stackedArea', 'Stacked&lrm;', agGridCommunity.ChartType.StackedArea);\n            case 'rangeNormalizedArea':\n                return rangeChartMenuItem('normalizedArea', '100% Stacked&lrm;', agGridCommunity.ChartType.NormalizedArea);\n            case 'rangeHistogramChart':\n                return rangeChartMenuItem('histogramChart', 'Histogram&lrm;', agGridCommunity.ChartType.Histogram);\n            default:\n                return null;\n        }\n    };\n    MenuItemMapper.prototype.createAggregationSubMenu = function (column) {\n        var _this = this;\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        var columnIsAlreadyAggValue = column.isValueActive();\n        var funcNames = this.aggFuncService.getFuncNames(column);\n        var columnToUse;\n        if (column.isPrimary()) {\n            columnToUse = column;\n        }\n        else {\n            var pivotValueColumn = column.getColDef().pivotValueColumn;\n            columnToUse = agGridCommunity._.exists(pivotValueColumn) ? pivotValueColumn : undefined;\n        }\n        var result = [];\n        funcNames.forEach(function (funcName) {\n            result.push({\n                name: localeTextFunc(funcName, funcName),\n                action: function () {\n                    _this.columnController.setColumnAggFunc(columnToUse, funcName, \"contextMenu\");\n                    _this.columnController.addValueColumn(columnToUse, \"contextMenu\");\n                },\n                checked: columnIsAlreadyAggValue && columnToUse.getAggFunc() === funcName\n            });\n        });\n        return result;\n    };\n    __decorate$1x([\n        agGridCommunity.Autowired('columnController')\n    ], MenuItemMapper.prototype, \"columnController\", void 0);\n    __decorate$1x([\n        agGridCommunity.Autowired('gridApi')\n    ], MenuItemMapper.prototype, \"gridApi\", void 0);\n    __decorate$1x([\n        agGridCommunity.Optional('clipboardService')\n    ], MenuItemMapper.prototype, \"clipboardService\", void 0);\n    __decorate$1x([\n        agGridCommunity.Optional('aggFuncService')\n    ], MenuItemMapper.prototype, \"aggFuncService\", void 0);\n    __decorate$1x([\n        agGridCommunity.Optional('chartService')\n    ], MenuItemMapper.prototype, \"chartService\", void 0);\n    MenuItemMapper = __decorate$1x([\n        agGridCommunity.Bean('menuItemMapper')\n    ], MenuItemMapper);\n    return MenuItemMapper;\n}(agGridCommunity.BeanStub));\n\nvar MenuModule = {\n    moduleName: agGridCommunity.ModuleNames.MenuModule,\n    beans: [EnterpriseMenuFactory, ContextMenuFactory, MenuItemMapper],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2I = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$k = (undefined && undefined.__assign) || function () {\n    __assign$k = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$k.apply(this, arguments);\n};\nvar __decorate$1y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MultiFilter = /** @class */ (function (_super) {\n    __extends$2I(MultiFilter, _super);\n    function MultiFilter() {\n        var _this = _super.call(this, /* html */ \"<div class=\\\"ag-multi-filter ag-menu-list-compact\\\"></div>\", true) || this;\n        _this.filterDefs = [];\n        _this.filters = [];\n        _this.guiDestroyFuncs = [];\n        _this.activeFilterIndices = [];\n        _this.lastActivatedMenuItem = null;\n        return _this;\n    }\n    MultiFilter.getFilterDefs = function (params) {\n        var filters = params.filters;\n        return filters && filters.length > 0 ?\n            filters :\n            [{ filter: 'agTextColumnFilter' }, { filter: 'agSetColumnFilter' }];\n    };\n    MultiFilter.prototype.init = function (params) {\n        var _this = this;\n        this.params = params;\n        this.filterDefs = MultiFilter.getFilterDefs(params);\n        var column = params.column, filterChangedCallback = params.filterChangedCallback;\n        this.column = column;\n        this.filterChangedCallback = filterChangedCallback;\n        var filterPromises = [];\n        agGridCommunity._.forEach(this.filterDefs, function (filterDef, index) {\n            var filterPromise = _this.createFilter(filterDef, index);\n            if (filterPromise != null) {\n                filterPromises.push(filterPromise);\n            }\n        });\n        // we have to refresh the GUI here to ensure that Angular components are not rendered in odd places\n        return agGridCommunity.AgPromise\n            .all(filterPromises)\n            .then(function (filters) { _this.filters = filters; _this.refreshGui('columnMenu'); });\n    };\n    MultiFilter.prototype.refreshGui = function (container) {\n        var _this = this;\n        if (container === this.lastOpenedInContainer) {\n            return;\n        }\n        this.clearGui();\n        this.destroyChildren();\n        agGridCommunity._.forEach(this.filters, function (filter, index) {\n            if (index > 0) {\n                _this.appendChild(agGridCommunity._.loadTemplate(/* html */ \"<div class=\\\"ag-filter-separator\\\"></div>\"));\n            }\n            var filterDef = _this.filterDefs[index];\n            var filterTitle = _this.getFilterTitle(filter, filterDef);\n            var filterGui;\n            if (filterDef.display === 'subMenu' && container !== 'toolPanel') {\n                // prevent sub-menu being used in tool panel\n                var menuItem = _this.insertFilterMenu(filter, filterTitle);\n                filterGui = menuItem.getGui();\n            }\n            else if (filterDef.display === 'subMenu' || filterDef.display === 'accordion') {\n                // sub-menus should appear as groups in the tool panel\n                var group = _this.insertFilterGroup(filter, filterTitle);\n                filterGui = group.getGui();\n            }\n            else {\n                // display inline\n                filterGui = filter.getGui();\n            }\n            _this.appendChild(filterGui);\n        });\n        this.lastOpenedInContainer = container;\n    };\n    MultiFilter.prototype.getFilterTitle = function (filter, filterDef) {\n        if (filterDef.title != null) {\n            return filterDef.title;\n        }\n        var filterWithoutType = filter;\n        return typeof filterWithoutType.getFilterTitle === 'function' ? filterWithoutType.getFilterTitle() : 'Filter';\n    };\n    MultiFilter.prototype.destroyChildren = function () {\n        agGridCommunity._.forEach(this.guiDestroyFuncs, function (func) { return func(); });\n        this.guiDestroyFuncs.length = 0;\n    };\n    MultiFilter.prototype.insertFilterMenu = function (filter, name) {\n        var _this = this;\n        var menuItem = this.createBean(new MenuItemComponent({\n            name: name,\n            subMenu: filter,\n            cssClasses: ['ag-multi-filter-menu-item'],\n            isCompact: true,\n            isAnotherSubMenuOpen: function () { return false; },\n        }));\n        menuItem.setParentComponent(this);\n        this.guiDestroyFuncs.push(function () { return _this.destroyBean(menuItem); });\n        this.addManagedListener(menuItem, MenuItemComponent.EVENT_MENU_ITEM_ACTIVATED, function (event) {\n            if (_this.lastActivatedMenuItem && _this.lastActivatedMenuItem !== event.menuItem) {\n                _this.lastActivatedMenuItem.deactivate();\n            }\n            _this.lastActivatedMenuItem = event.menuItem;\n        });\n        menuItem.addGuiEventListener('focusin', function () { return menuItem.activate(); });\n        menuItem.addGuiEventListener('focusout', function () {\n            if (!menuItem.isSubMenuOpen()) {\n                menuItem.deactivate();\n            }\n        });\n        return menuItem;\n    };\n    MultiFilter.prototype.insertFilterGroup = function (filter, title) {\n        var _this = this;\n        var group = this.createBean(new agGridCommunity.AgGroupComponent({\n            title: title,\n            cssIdentifier: 'multi-filter',\n        }));\n        this.guiDestroyFuncs.push(function () { return _this.destroyBean(group); });\n        group.addItem(filter.getGui());\n        group.toggleGroupExpand(false);\n        if (filter.afterGuiAttached) {\n            var params_1 = { container: this.lastOpenedInContainer, suppressFocus: true };\n            group.addManagedListener(group, agGridCommunity.AgGroupComponent.EVENT_EXPANDED, function () { return filter.afterGuiAttached(params_1); });\n        }\n        return group;\n    };\n    MultiFilter.prototype.isFilterActive = function () {\n        return agGridCommunity._.some(this.filters, function (filter) { return filter.isFilterActive(); });\n    };\n    MultiFilter.prototype.getLastActiveFilterIndex = function () {\n        return this.activeFilterIndices.length > 0 ? this.activeFilterIndices[this.activeFilterIndices.length - 1] : null;\n    };\n    MultiFilter.prototype.doesFilterPass = function (params, filterToSkip) {\n        var rowPasses = true;\n        this.filters.forEach(function (filter) {\n            if (!rowPasses || filter === filterToSkip || !filter.isFilterActive()) {\n                return;\n            }\n            rowPasses = filter.doesFilterPass(params);\n        });\n        return rowPasses;\n    };\n    MultiFilter.prototype.getFilterType = function () {\n        return 'multi';\n    };\n    MultiFilter.prototype.getModelFromUi = function () {\n        var model = {\n            filterType: this.getFilterType(),\n            filterModels: agGridCommunity._.map(this.filters, function (filter) {\n                var providedFilter = filter;\n                if (typeof providedFilter.getModelFromUi === 'function') {\n                    return providedFilter.getModelFromUi();\n                }\n                return null;\n            })\n        };\n        return model;\n    };\n    MultiFilter.prototype.getModel = function () {\n        if (!this.isFilterActive()) {\n            return null;\n        }\n        var model = {\n            filterType: this.getFilterType(),\n            filterModels: agGridCommunity._.map(this.filters, function (filter) {\n                if (filter.isFilterActive()) {\n                    return filter.getModel();\n                }\n                return null;\n            })\n        };\n        return model;\n    };\n    MultiFilter.prototype.setModel = function (model) {\n        var setFilterModel = function (filter, filterModel) {\n            return new agGridCommunity.AgPromise(function (resolve) {\n                var promise = filter.setModel(filterModel);\n                promise ? promise.then(function () { return resolve(); }) : resolve();\n            });\n        };\n        var promises = [];\n        if (model == null) {\n            promises = agGridCommunity._.map(this.filters, function (filter) { return setFilterModel(filter, null); });\n        }\n        else {\n            agGridCommunity._.forEach(this.filters, function (filter, index) {\n                var filterModel = model.filterModels.length > index ? model.filterModels[index] : null;\n                promises.push(setFilterModel(filter, filterModel));\n            });\n        }\n        return agGridCommunity.AgPromise.all(promises).then(function () { });\n    };\n    MultiFilter.prototype.getChildFilterInstance = function (index) {\n        return this.filters[index];\n    };\n    MultiFilter.prototype.afterGuiAttached = function (params) {\n        if (params) {\n            this.refreshGui(params.container);\n        }\n        var filters = this.params.filters;\n        var suppressFocus = filters && agGridCommunity._.some(filters, function (filter) { return filter.display && filter.display !== 'inline'; });\n        this.executeFunctionIfExists('afterGuiAttached', __assign$k(__assign$k({}, params || {}), { suppressFocus: suppressFocus }));\n        if (suppressFocus) {\n            // reset focus to the top of the container, and blur\n            this.forceFocusOutOfContainer(true);\n        }\n    };\n    MultiFilter.prototype.onAnyFilterChanged = function () {\n        this.executeFunctionIfExists('onAnyFilterChanged');\n    };\n    MultiFilter.prototype.onNewRowsLoaded = function () {\n        this.executeFunctionIfExists('onNewRowsLoaded');\n    };\n    MultiFilter.prototype.destroy = function () {\n        var _this = this;\n        agGridCommunity._.forEach(this.filters, function (filter) {\n            filter.setModel(null);\n            _this.destroyBean(filter);\n        });\n        this.filters.length = 0;\n        this.destroyChildren();\n        _super.prototype.destroy.call(this);\n    };\n    MultiFilter.prototype.executeFunctionIfExists = function (name) {\n        var params = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            params[_i - 1] = arguments[_i];\n        }\n        // The first filter is always the \"dominant\" one. By iterating in reverse order we ensure the first filter\n        // always gets the last say\n        agGridCommunity._.forEachReverse(this.filters, function (filter) {\n            var func = filter[name];\n            if (typeof func === 'function') {\n                func.apply(filter, params);\n            }\n        });\n    };\n    MultiFilter.prototype.createFilter = function (filterDef, index) {\n        var _this = this;\n        var _a = this.params, filterModifiedCallback = _a.filterModifiedCallback, doesRowPassOtherFilter = _a.doesRowPassOtherFilter;\n        var filterInstance;\n        var filterParams = __assign$k(__assign$k({}, this.filterManager.createFilterParams(this.column, this.column.getColDef())), { filterModifiedCallback: filterModifiedCallback, filterChangedCallback: function () { return _this.filterChanged(index); }, doesRowPassOtherFilter: function (node) {\n                return doesRowPassOtherFilter(node) && _this.doesFilterPass({ node: node, data: node.data }, filterInstance);\n            } });\n        var filterPromise = this.userComponentFactory.newFilterComponent(filterDef, filterParams, 'agTextColumnFilter');\n        if (filterPromise != null) {\n            return filterPromise.then(function (filter) { return filterInstance = filter; });\n        }\n        return filterPromise;\n    };\n    MultiFilter.prototype.filterChanged = function (index) {\n        var changedFilter = this.filters[index];\n        agGridCommunity._.removeFromArray(this.activeFilterIndices, index);\n        if (changedFilter.isFilterActive()) {\n            this.activeFilterIndices.push(index);\n        }\n        this.filterChangedCallback();\n        agGridCommunity._.forEach(this.filters, function (filter) {\n            if (filter === changedFilter) {\n                return;\n            }\n            if (typeof filter.onAnyFilterChanged === 'function') {\n                filter.onAnyFilterChanged();\n            }\n        });\n    };\n    MultiFilter.prototype.onFocusIn = function (e) {\n        if (this.lastActivatedMenuItem != null && !this.lastActivatedMenuItem.getGui().contains(e.target)) {\n            this.lastActivatedMenuItem.deactivate();\n            this.lastActivatedMenuItem = null;\n        }\n    };\n    __decorate$1y([\n        agGridCommunity.Autowired('filterManager')\n    ], MultiFilter.prototype, \"filterManager\", void 0);\n    __decorate$1y([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], MultiFilter.prototype, \"userComponentFactory\", void 0);\n    return MultiFilter;\n}(agGridCommunity.ManagedFocusComponent));\n\nvar __extends$2J = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign$l = (undefined && undefined.__assign) || function () {\n    __assign$l = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign$l.apply(this, arguments);\n};\nvar __decorate$1z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MultiFloatingFilterComp = /** @class */ (function (_super) {\n    __extends$2J(MultiFloatingFilterComp, _super);\n    function MultiFloatingFilterComp() {\n        var _this = _super.call(this, /* html */ \"<div class=\\\"ag-multi-floating-filter ag-floating-filter-input\\\"></div>\") || this;\n        _this.floatingFilters = [];\n        return _this;\n    }\n    MultiFloatingFilterComp.prototype.init = function (params) {\n        var _this = this;\n        this.params = params;\n        var filterParams = params.filterParams;\n        var floatingFilterPromises = [];\n        agGridCommunity._.forEach(MultiFilter.getFilterDefs(filterParams), function (filterDef, index) {\n            var floatingFilterParams = __assign$l(__assign$l({}, params), { \n                // set the parent filter instance for each floating filter to the relevant child filter instance\n                parentFilterInstance: function (callback) {\n                    params.parentFilterInstance(function (parent) {\n                        var childFilterInstance = parent.getChildFilterInstance(index);\n                        callback(childFilterInstance);\n                    });\n                } });\n            var floatingFilterPromise = _this.createFloatingFilter(filterDef, floatingFilterParams);\n            if (floatingFilterPromise != null) {\n                floatingFilterPromises.push(floatingFilterPromise);\n            }\n        });\n        return agGridCommunity.AgPromise.all(floatingFilterPromises).then(function (floatingFilters) {\n            agGridCommunity._.forEach(floatingFilters, function (floatingFilter, index) {\n                _this.floatingFilters.push(floatingFilter);\n                var gui = floatingFilter.getGui();\n                _this.appendChild(gui);\n                if (index > 0) {\n                    agGridCommunity._.setDisplayed(gui, false);\n                }\n            });\n        });\n    };\n    MultiFloatingFilterComp.prototype.onParentModelChanged = function (model, event) {\n        var _this = this;\n        // We don't want to update the floating filter if the floating filter caused the change,\n        // because the UI is already in sync. if we didn't do this, the UI would behave strangely\n        // as it would be updating as the user is typing\n        if (event && event.afterFloatingFilter) {\n            return;\n        }\n        this.params.parentFilterInstance(function (parent) {\n            if (model == null) {\n                agGridCommunity._.forEach(_this.floatingFilters, function (filter, i) {\n                    filter.onParentModelChanged(null, event);\n                    agGridCommunity._.setDisplayed(filter.getGui(), i === 0);\n                });\n            }\n            else {\n                var lastActiveFloatingFilterIndex_1 = parent.getLastActiveFilterIndex();\n                agGridCommunity._.forEach(_this.floatingFilters, function (filter, i) {\n                    var filterModel = model.filterModels.length > i ? model.filterModels[i] : null;\n                    filter.onParentModelChanged(filterModel, event);\n                    var shouldShow = lastActiveFloatingFilterIndex_1 == null ? i === 0 : i === lastActiveFloatingFilterIndex_1;\n                    agGridCommunity._.setDisplayed(filter.getGui(), shouldShow);\n                });\n            }\n        });\n    };\n    MultiFloatingFilterComp.prototype.destroy = function () {\n        this.destroyBeans(this.floatingFilters);\n        this.floatingFilters.length = 0;\n        _super.prototype.destroy.call(this);\n    };\n    MultiFloatingFilterComp.prototype.createFloatingFilter = function (filterDef, params) {\n        var defaultComponentName = agGridCommunity.FloatingFilterWrapper.getDefaultFloatingFilterType(filterDef) || 'agTextColumnFloatingFilter';\n        return this.userComponentFactory.newFloatingFilterComponent(filterDef, params, defaultComponentName);\n    };\n    __decorate$1z([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], MultiFloatingFilterComp.prototype, \"userComponentFactory\", void 0);\n    return MultiFloatingFilterComp;\n}(agGridCommunity.Component));\n\nvar MultiFilterModule = {\n    moduleName: agGridCommunity.ModuleNames.MultiFilterModule,\n    beans: [],\n    userComponents: [\n        { componentName: 'agMultiColumnFilter', componentClass: MultiFilter },\n        { componentName: 'agMultiColumnFloatingFilter', componentClass: MultiFloatingFilterComp },\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2K = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RichSelectRow = /** @class */ (function (_super) {\n    __extends$2K(RichSelectRow, _super);\n    function RichSelectRow(params) {\n        var _this = _super.call(this, /* html */ \"<div class=\\\"ag-rich-select-row\\\"></div>\") || this;\n        _this.params = params;\n        return _this;\n    }\n    RichSelectRow.prototype.setState = function (value, valueFormatted, selected) {\n        var rendererSuccessful = this.populateWithRenderer(value, valueFormatted);\n        if (!rendererSuccessful) {\n            this.populateWithoutRenderer(value, valueFormatted);\n        }\n        agGridCommunity._.addOrRemoveCssClass(this.getGui(), 'ag-rich-select-row-selected', selected);\n    };\n    RichSelectRow.prototype.populateWithoutRenderer = function (value, valueFormatted) {\n        var valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;\n        var valueToRender = valueFormattedExits ? valueFormatted : value;\n        if (agGridCommunity._.exists(valueToRender) && valueToRender !== '') {\n            // not using innerHTML to prevent injection of HTML\n            // https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Security_considerations\n            this.getGui().textContent = valueToRender.toString();\n        }\n        else {\n            // putting in blank, so if missing, at least the user can click on it\n            this.getGui().innerHTML = '&nbsp;';\n        }\n    };\n    RichSelectRow.prototype.populateWithRenderer = function (value, valueFormatted) {\n        var _this = this;\n        // bad coder here - we are not populating all values of the cellRendererParams\n        var params = {\n            value: value,\n            valueFormatted: valueFormatted,\n            api: this.gridOptionsWrapper.getApi()\n        };\n        var cellRendererPromise = this.userComponentFactory.newCellRenderer(this.params, params);\n        if (cellRendererPromise != null) {\n            agGridCommunity._.bindCellRendererToHtmlElement(cellRendererPromise, this.getGui());\n        }\n        else {\n            this.getGui().innerText = params.valueFormatted != null ? params.valueFormatted : params.value;\n        }\n        if (cellRendererPromise) {\n            cellRendererPromise.then(function (childComponent) {\n                _this.addDestroyFunc(function () {\n                    _this.getContext().destroyBean(childComponent);\n                });\n            });\n            return true;\n        }\n        return false;\n    };\n    __decorate$1A([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], RichSelectRow.prototype, \"userComponentFactory\", void 0);\n    return RichSelectRow;\n}(agGridCommunity.Component));\n\nvar __extends$2L = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RichSelectCellEditor = /** @class */ (function (_super) {\n    __extends$2L(RichSelectCellEditor, _super);\n    function RichSelectCellEditor() {\n        var _this = _super.call(this, RichSelectCellEditor.TEMPLATE) || this;\n        _this.selectionConfirmed = false;\n        _this.searchString = '';\n        return _this;\n    }\n    RichSelectCellEditor.prototype.init = function (params) {\n        this.params = params;\n        this.selectedValue = params.value;\n        this.originalSelectedValue = params.value;\n        this.focusAfterAttached = params.cellStartedEdit;\n        var icon = agGridCommunity._.createIconNoSpan('smallDown', this.gridOptionsWrapper);\n        agGridCommunity._.addCssClass(icon, 'ag-rich-select-value-icon');\n        this.eValue.appendChild(icon);\n        this.virtualList = this.getContext().createBean(new agGridCommunity.VirtualList('rich-select'));\n        this.virtualList.setComponentCreator(this.createRowComponent.bind(this));\n        this.eList.appendChild(this.virtualList.getGui());\n        if (agGridCommunity._.exists(this.params.cellHeight)) {\n            this.virtualList.setRowHeight(this.params.cellHeight);\n        }\n        this.renderSelectedValue();\n        if (agGridCommunity._.missing(params.values)) {\n            console.warn('AG Grid: richSelectCellEditor requires values for it to work');\n            return;\n        }\n        var values = params.values;\n        this.virtualList.setModel({\n            getRowCount: function () { return values.length; },\n            getRow: function (index) { return values[index]; }\n        });\n        this.addGuiEventListener('keydown', this.onKeyDown.bind(this));\n        var virtualListGui = this.virtualList.getGui();\n        this.addManagedListener(virtualListGui, 'click', this.onClick.bind(this));\n        this.addManagedListener(virtualListGui, 'mousemove', this.onMouseMove.bind(this));\n        var debounceDelay = agGridCommunity._.exists(params.searchDebounceDelay) ? params.searchDebounceDelay : 300;\n        this.clearSearchString = agGridCommunity._.debounce(this.clearSearchString, debounceDelay);\n        if (agGridCommunity._.exists(params.charPress)) {\n            this.searchText(params.charPress);\n        }\n    };\n    RichSelectCellEditor.prototype.onKeyDown = function (event) {\n        var key = event.key;\n        switch (key) {\n            case agGridCommunity.KeyName.ENTER:\n                this.onEnterKeyDown();\n                break;\n            case agGridCommunity.KeyName.DOWN:\n            case agGridCommunity.KeyName.UP:\n                this.onNavigationKeyPressed(event, key);\n                break;\n            default:\n                this.searchText(event);\n        }\n    };\n    RichSelectCellEditor.prototype.onEnterKeyDown = function () {\n        this.selectionConfirmed = true;\n        this.params.stopEditing();\n    };\n    RichSelectCellEditor.prototype.onNavigationKeyPressed = function (event, key) {\n        // if we don't preventDefault the page body and/or grid scroll will move.\n        event.preventDefault();\n        var oldIndex = this.params.values.indexOf(this.selectedValue);\n        var newIndex = key === agGridCommunity.KeyName.UP ? oldIndex - 1 : oldIndex + 1;\n        if (newIndex >= 0 && newIndex < this.params.values.length) {\n            var valueToSelect = this.params.values[newIndex];\n            this.setSelectedValue(valueToSelect);\n        }\n    };\n    RichSelectCellEditor.prototype.searchText = function (key) {\n        if (typeof key !== 'string') {\n            var keyName = key.key;\n            if (keyName === agGridCommunity.KeyName.BACKSPACE) {\n                this.searchString = this.searchString.slice(0, -1);\n                keyName = '';\n            }\n            else if (!agGridCommunity._.isEventFromPrintableCharacter(key)) {\n                return;\n            }\n            this.searchText(keyName);\n            return;\n        }\n        this.searchString += key;\n        this.runSearch();\n        this.clearSearchString();\n    };\n    RichSelectCellEditor.prototype.runSearch = function () {\n        var values = this.params.values;\n        var searchStrings;\n        if (typeof values[0] === 'number' || typeof values[0] === 'string') {\n            searchStrings = values.map(String);\n        }\n        if (typeof values[0] === 'object' && this.params.colDef.keyCreator) {\n            searchStrings = values.map(this.params.colDef.keyCreator);\n        }\n        if (!searchStrings) {\n            return;\n        }\n        var topSuggestion = agGridCommunity._.fuzzySuggestions(this.searchString, searchStrings, true, true)[0];\n        if (!topSuggestion) {\n            return;\n        }\n        var topSuggestionIndex = searchStrings.indexOf(topSuggestion);\n        var topValue = values[topSuggestionIndex];\n        this.setSelectedValue(topValue);\n    };\n    RichSelectCellEditor.prototype.clearSearchString = function () {\n        this.searchString = '';\n    };\n    RichSelectCellEditor.prototype.renderSelectedValue = function () {\n        var _this = this;\n        var valueFormatted = this.params.formatValue(this.selectedValue);\n        var eValue = this.eValue;\n        var params = {\n            value: this.selectedValue,\n            valueFormatted: valueFormatted,\n            api: this.gridOptionsWrapper.getApi()\n        };\n        var promise = this.userComponentFactory.newCellRenderer(this.params, params);\n        if (agGridCommunity._.exists(promise)) {\n            agGridCommunity._.bindCellRendererToHtmlElement(promise, eValue);\n            promise.then(function (renderer) {\n                _this.addDestroyFunc(function () { return _this.getContext().destroyBean(renderer); });\n            });\n        }\n        else {\n            if (agGridCommunity._.exists(this.selectedValue)) {\n                eValue.innerHTML = valueFormatted;\n            }\n            else {\n                agGridCommunity._.clearElement(eValue);\n            }\n        }\n    };\n    RichSelectCellEditor.prototype.setSelectedValue = function (value) {\n        if (this.selectedValue === value) {\n            return;\n        }\n        var index = this.params.values.indexOf(value);\n        if (index === -1) {\n            return;\n        }\n        this.selectedValue = value;\n        this.virtualList.ensureIndexVisible(index);\n        this.virtualList.refresh();\n    };\n    RichSelectCellEditor.prototype.createRowComponent = function (value) {\n        var valueFormatted = this.params.formatValue(value);\n        var row = new RichSelectRow(this.params);\n        this.getContext().createBean(row);\n        row.setState(value, valueFormatted, value === this.selectedValue);\n        return row;\n    };\n    RichSelectCellEditor.prototype.onMouseMove = function (mouseEvent) {\n        var rect = this.virtualList.getGui().getBoundingClientRect();\n        var scrollTop = this.virtualList.getScrollTop();\n        var mouseY = mouseEvent.clientY - rect.top + scrollTop;\n        var row = Math.floor(mouseY / this.virtualList.getRowHeight());\n        var value = this.params.values[row];\n        // not using utils.exist() as want empty string test to pass\n        if (value !== undefined) {\n            this.setSelectedValue(value);\n        }\n    };\n    RichSelectCellEditor.prototype.onClick = function () {\n        this.selectionConfirmed = true;\n        this.params.stopEditing();\n    };\n    // we need to have the gui attached before we can draw the virtual rows, as the\n    // virtual row logic needs info about the gui state\n    RichSelectCellEditor.prototype.afterGuiAttached = function () {\n        var selectedIndex = this.params.values.indexOf(this.selectedValue);\n        // we have to call this here to get the list to have the right height, ie\n        // otherwise it would not have scrolls yet and ensureIndexVisible would do nothing\n        this.virtualList.refresh();\n        if (selectedIndex >= 0) {\n            this.virtualList.ensureIndexVisible(selectedIndex);\n        }\n        // we call refresh again, as the list could of moved, and we need to render the new rows\n        this.virtualList.refresh();\n        if (this.focusAfterAttached) {\n            this.getGui().focus();\n        }\n    };\n    RichSelectCellEditor.prototype.getValue = function () {\n        // NOTE: we don't use valueParser for Set Filter. The user should provide values that are to be\n        // set into the data. valueParser only really makese sense when the user is typing in text (not picking\n        // form a set).\n        return this.selectionConfirmed ? this.selectedValue : this.originalSelectedValue;\n    };\n    // tab index is needed so we can focus, which is needed for keyboard events\n    RichSelectCellEditor.TEMPLATE = \"<div class=\\\"ag-rich-select\\\" tabindex=\\\"-1\\\">\\n            <div ref=\\\"eValue\\\" class=\\\"ag-rich-select-value\\\"></div>\\n            <div ref=\\\"eList\\\" class=\\\"ag-rich-select-list\\\"></div>\\n        </div>\";\n    __decorate$1B([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], RichSelectCellEditor.prototype, \"userComponentFactory\", void 0);\n    __decorate$1B([\n        agGridCommunity.RefSelector('eValue')\n    ], RichSelectCellEditor.prototype, \"eValue\", void 0);\n    __decorate$1B([\n        agGridCommunity.RefSelector('eList')\n    ], RichSelectCellEditor.prototype, \"eList\", void 0);\n    return RichSelectCellEditor;\n}(agGridCommunity.PopupComponent));\n\nvar RichSelectModule = {\n    moduleName: agGridCommunity.ModuleNames.RichSelectModule,\n    beans: [],\n    userComponents: [\n        { componentName: 'agRichSelect', componentClass: RichSelectCellEditor },\n        { componentName: 'agRichSelectCellEditor', componentClass: RichSelectCellEditor }\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2M = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ServerSideRowModel = /** @class */ (function (_super) {\n    __extends$2M(ServerSideRowModel, _super);\n    function ServerSideRowModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.pauseStoreUpdateListening = false;\n        return _this;\n    }\n    // we don't implement as lazy row heights is not supported in this row model\n    ServerSideRowModel.prototype.ensureRowHeightsValid = function () { return false; };\n    ServerSideRowModel.prototype.start = function () {\n        var datasource = this.gridOptionsWrapper.getServerSideDatasource();\n        if (datasource) {\n            this.setDatasource(datasource);\n        }\n    };\n    ServerSideRowModel.prototype.destroyDatasource = function () {\n        if (!this.datasource) {\n            return;\n        }\n        if (this.datasource.destroy) {\n            this.datasource.destroy();\n        }\n        this.rowRenderer.datasourceChanged();\n        this.datasource = undefined;\n    };\n    ServerSideRowModel.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ServerSideRowModel');\n    };\n    ServerSideRowModel.prototype.addEventListeners = function () {\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_STORE_UPDATED, this.onStoreUpdated.bind(this));\n        var resetListener = this.resetRootStore.bind(this);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_VALUE_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, resetListener);\n    };\n    ServerSideRowModel.prototype.setDatasource = function (datasource) {\n        this.destroyDatasource();\n        this.datasource = datasource;\n        this.resetRootStore();\n    };\n    ServerSideRowModel.prototype.isLastRowIndexKnown = function () {\n        var cache = this.getRootStore();\n        if (!cache) {\n            return false;\n        }\n        return cache.isLastRowIndexKnown();\n    };\n    ServerSideRowModel.prototype.onColumnEverything = function () {\n        // this is a hack for one customer only, so they can suppress the resetting of the columns.\n        // The problem the customer had was they were api.setColumnDefs() after the data source came\n        // back with data. So this stops the reload from the grid after the data comes back.\n        // Once we have \"AG-1591 Allow delta changes to columns\" fixed, then this hack can be taken out.\n        if (this.gridOptionsWrapper.isSuppressEnterpriseResetOnNewColumns()) {\n            return;\n        }\n        // every other customer can continue as normal and have it working!!!\n        // if first time, alwasy reset\n        if (!this.storeParams) {\n            this.resetRootStore();\n            return;\n        }\n        // check if anything pertaining to fetching data has changed, and if it has, reset, but if\n        // it has not, don't reset\n        var rowGroupColumnVos = this.columnsToValueObjects(this.columnController.getRowGroupColumns());\n        var valueColumnVos = this.columnsToValueObjects(this.columnController.getValueColumns());\n        var pivotColumnVos = this.columnsToValueObjects(this.columnController.getPivotColumns());\n        var sortModelDifferent = !agGridCommunity._.jsonEquals(this.storeParams.sortModel, this.sortController.getSortModel());\n        var rowGroupDifferent = !agGridCommunity._.jsonEquals(this.storeParams.rowGroupCols, rowGroupColumnVos);\n        var pivotDifferent = !agGridCommunity._.jsonEquals(this.storeParams.pivotCols, pivotColumnVos);\n        var valuesDifferent = !agGridCommunity._.jsonEquals(this.storeParams.valueCols, valueColumnVos);\n        var resetRequired = sortModelDifferent || rowGroupDifferent || pivotDifferent || valuesDifferent;\n        if (resetRequired) {\n            this.resetRootStore();\n        }\n    };\n    ServerSideRowModel.prototype.destroyRootStore = function () {\n        if (!this.rootNode || !this.rootNode.childStore) {\n            return;\n        }\n        this.rootNode.childStore = this.destroyBean(this.rootNode.childStore);\n        this.nodeManager.clear();\n    };\n    ServerSideRowModel.prototype.refreshAfterSort = function (newSortModel, params) {\n        if (this.storeParams) {\n            this.storeParams.sortModel = newSortModel;\n        }\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        rootStore.refreshAfterSort(params);\n        this.onStoreUpdated();\n    };\n    ServerSideRowModel.prototype.resetRootStore = function () {\n        this.destroyRootStore();\n        this.rootNode = new agGridCommunity.RowNode();\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n        this.createBean(this.rootNode);\n        if (this.datasource) {\n            this.storeParams = this.createStoreParams();\n            this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode));\n            this.updateRowIndexesAndBounds();\n        }\n        // this event: 1) clears selection 2) updates filters 3) shows/hides 'no rows' overlay\n        var rowDataChangedEvent = {\n            type: agGridCommunity.Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).\n        // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer\n        // to treat the rows as new rows, as it's all new data\n        this.dispatchModelUpdated(true);\n    };\n    ServerSideRowModel.prototype.columnsToValueObjects = function (columns) {\n        var _this = this;\n        return columns.map(function (col) { return ({\n            id: col.getId(),\n            aggFunc: col.getAggFunc(),\n            displayName: _this.columnController.getDisplayNameForColumn(col, 'model'),\n            field: col.getColDef().field\n        }); });\n    };\n    ServerSideRowModel.prototype.createStoreParams = function () {\n        var rowGroupColumnVos = this.columnsToValueObjects(this.columnController.getRowGroupColumns());\n        var valueColumnVos = this.columnsToValueObjects(this.columnController.getValueColumns());\n        var pivotColumnVos = this.columnsToValueObjects(this.columnController.getPivotColumns());\n        var dynamicRowHeight = this.gridOptionsWrapper.isDynamicRowHeight();\n        var params = {\n            // the columns the user has grouped and aggregated by\n            valueCols: valueColumnVos,\n            rowGroupCols: rowGroupColumnVos,\n            pivotCols: pivotColumnVos,\n            pivotMode: this.columnController.isPivotMode(),\n            // sort and filter model\n            filterModel: this.filterManager.getFilterModel(),\n            sortModel: this.sortListener.extractSortModel(),\n            datasource: this.datasource,\n            lastAccessedSequence: new agGridCommunity.NumberSequence(),\n            // blockSize: blockSize == null ? 100 : blockSize,\n            dynamicRowHeight: dynamicRowHeight\n        };\n        return params;\n    };\n    ServerSideRowModel.prototype.getParams = function () {\n        return this.storeParams;\n    };\n    ServerSideRowModel.prototype.dispatchModelUpdated = function (reset) {\n        if (reset === void 0) { reset = false; }\n        var modelUpdatedEvent = {\n            type: agGridCommunity.Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: !reset,\n            keepRenderedRows: !reset,\n            newPage: false,\n            newData: false\n        };\n        this.eventService.dispatchEvent(modelUpdatedEvent);\n    };\n    ServerSideRowModel.prototype.onStoreUpdated = function () {\n        // sometimes if doing a batch update, we do the batch first,\n        // then call onStoreUpdated manually. eg expandAll() method.\n        if (this.pauseStoreUpdateListening) {\n            return;\n        }\n        this.updateRowIndexesAndBounds();\n        this.dispatchModelUpdated();\n    };\n    ServerSideRowModel.prototype.onRowHeightChanged = function () {\n        this.updateRowIndexesAndBounds();\n        this.dispatchModelUpdated();\n    };\n    ServerSideRowModel.prototype.updateRowIndexesAndBounds = function () {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        rootStore.setDisplayIndexes(new agGridCommunity.NumberSequence(), { value: 0 });\n    };\n    ServerSideRowModel.prototype.retryLoads = function () {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        rootStore.retryLoads();\n        this.onStoreUpdated();\n    };\n    ServerSideRowModel.prototype.getRow = function (index) {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return null;\n        }\n        return rootStore.getRowUsingDisplayIndex(index);\n    };\n    ServerSideRowModel.prototype.expandAll = function (value) {\n        // if we don't pause store updating, we are needlessly\n        // recalculating row-indexes etc, and also getting rendering\n        // engine to re-render (listens on ModelUpdated event)\n        this.pauseStoreUpdateListening = true;\n        this.forEachNode(function (node) {\n            if (node.group) {\n                node.setExpanded(value);\n            }\n        });\n        this.pauseStoreUpdateListening = false;\n        this.onStoreUpdated();\n    };\n    ServerSideRowModel.prototype.refreshAfterFilter = function (newFilterModel, params) {\n        if (this.storeParams) {\n            this.storeParams.filterModel = newFilterModel;\n        }\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        rootStore.refreshAfterFilter(params);\n        this.onStoreUpdated();\n    };\n    ServerSideRowModel.prototype.getRootStore = function () {\n        if (this.rootNode && this.rootNode.childStore) {\n            return this.rootNode.childStore;\n        }\n    };\n    ServerSideRowModel.prototype.getRowCount = function () {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return 1;\n        }\n        return rootStore.getDisplayIndexEnd();\n    };\n    ServerSideRowModel.prototype.getTopLevelRowCount = function () {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return 1;\n        }\n        return rootStore.getRowCount();\n    };\n    ServerSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return topLevelIndex;\n        }\n        return rootStore.getTopLevelRowDisplayedIndex(topLevelIndex);\n    };\n    ServerSideRowModel.prototype.getRowBounds = function (index) {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            var rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n            return {\n                rowTop: 0,\n                rowHeight: rowHeight\n            };\n        }\n        return rootStore.getRowBounds(index);\n    };\n    ServerSideRowModel.prototype.getRowIndexAtPixel = function (pixel) {\n        var rootStore = this.getRootStore();\n        if (pixel <= 0 || !rootStore) {\n            return 0;\n        }\n        return rootStore.getRowIndexAtPixel(pixel);\n    };\n    ServerSideRowModel.prototype.isEmpty = function () {\n        return false;\n    };\n    ServerSideRowModel.prototype.isRowsToRender = function () {\n        return this.getRootStore() != null && this.getRowCount() > 0;\n    };\n    ServerSideRowModel.prototype.getType = function () {\n        return agGridCommunity.Constants.ROW_MODEL_TYPE_SERVER_SIDE;\n    };\n    ServerSideRowModel.prototype.forEachNode = function (callback) {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        rootStore.forEachNodeDeep(callback);\n    };\n    ServerSideRowModel.prototype.executeOnStore = function (route, callback) {\n        var rootStore = this.getRootStore();\n        if (!rootStore) {\n            return;\n        }\n        var storeToExecuteOn = rootStore.getChildStore(route);\n        if (storeToExecuteOn) {\n            callback(storeToExecuteOn);\n        }\n    };\n    ServerSideRowModel.prototype.refreshStore = function (params) {\n        if (params === void 0) { params = {}; }\n        var route = params.route ? params.route : [];\n        this.executeOnStore(route, function (store) { return store.refreshStore(params.purge == true); });\n    };\n    ServerSideRowModel.prototype.getStoreState = function () {\n        var res = [];\n        var rootStore = this.getRootStore();\n        if (rootStore) {\n            rootStore.addStoreStates(res);\n        }\n        return res;\n    };\n    ServerSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        if (agGridCommunity._.exists(lastInRange) && firstInRange.parent !== lastInRange.parent) {\n            return [];\n        }\n        return firstInRange.parent.childStore.getRowNodesInRange(lastInRange, firstInRange);\n    };\n    ServerSideRowModel.prototype.getRowNode = function (id) {\n        var result = null;\n        this.forEachNode(function (rowNode) {\n            if (rowNode.id === id) {\n                result = rowNode;\n            }\n            if (rowNode.detailNode && rowNode.detailNode.id === id) {\n                result = rowNode.detailNode;\n            }\n        });\n        return result;\n    };\n    ServerSideRowModel.prototype.isRowPresent = function (rowNode) {\n        var foundRowNode = this.getRowNode(rowNode.id);\n        return !!foundRowNode;\n    };\n    __decorate$1C([\n        agGridCommunity.Autowired('columnController')\n    ], ServerSideRowModel.prototype, \"columnController\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('filterManager')\n    ], ServerSideRowModel.prototype, \"filterManager\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('sortController')\n    ], ServerSideRowModel.prototype, \"sortController\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('gridApi')\n    ], ServerSideRowModel.prototype, \"gridApi\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('columnApi')\n    ], ServerSideRowModel.prototype, \"columnApi\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('rowRenderer')\n    ], ServerSideRowModel.prototype, \"rowRenderer\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('ssrmSortService')\n    ], ServerSideRowModel.prototype, \"sortListener\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('ssrmNodeManager')\n    ], ServerSideRowModel.prototype, \"nodeManager\", void 0);\n    __decorate$1C([\n        agGridCommunity.Autowired('ssrmStoreFactory')\n    ], ServerSideRowModel.prototype, \"storeFactory\", void 0);\n    __decorate$1C([\n        agGridCommunity.PreDestroy\n    ], ServerSideRowModel.prototype, \"destroyDatasource\", null);\n    __decorate$1C([\n        __param(0, agGridCommunity.Qualifier('loggerFactory'))\n    ], ServerSideRowModel.prototype, \"setBeans\", null);\n    __decorate$1C([\n        agGridCommunity.PostConstruct\n    ], ServerSideRowModel.prototype, \"addEventListeners\", null);\n    __decorate$1C([\n        agGridCommunity.PreDestroy\n    ], ServerSideRowModel.prototype, \"destroyRootStore\", null);\n    ServerSideRowModel = __decorate$1C([\n        agGridCommunity.Bean('rowModel')\n    ], ServerSideRowModel);\n    return ServerSideRowModel;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2N = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar StoreUtils = /** @class */ (function (_super) {\n    __extends$2N(StoreUtils, _super);\n    function StoreUtils() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StoreUtils.prototype.createGroupKeys = function (groupNode) {\n        var keys = [];\n        var pointer = groupNode;\n        while (pointer && pointer.level >= 0) {\n            keys.push(pointer.key);\n            pointer = pointer.parent;\n        }\n        keys.reverse();\n        return keys;\n    };\n    StoreUtils.prototype.loadFromDatasource = function (p) {\n        var groupKeys = this.createGroupKeys(p.parentNode);\n        var storeParams = p.storeParams;\n        if (!storeParams.datasource) {\n            return;\n        }\n        var request = {\n            startRow: p.startRow,\n            endRow: p.endRow,\n            rowGroupCols: storeParams.rowGroupCols,\n            valueCols: storeParams.valueCols,\n            pivotCols: storeParams.pivotCols,\n            pivotMode: storeParams.pivotMode,\n            groupKeys: groupKeys,\n            filterModel: storeParams.filterModel,\n            sortModel: storeParams.sortModel\n        };\n        var getRowsParams = {\n            successCallback: p.successCallback,\n            success: p.success,\n            failCallback: p.failCallback,\n            fail: p.fail,\n            request: request,\n            parentNode: p.parentNode,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        window.setTimeout(function () {\n            if (storeParams.datasource) {\n                storeParams.datasource.getRows(getRowsParams);\n            }\n        }, 0);\n    };\n    StoreUtils.prototype.getChildStore = function (keys, currentCache, findNodeFunc) {\n        if (agGridCommunity._.missingOrEmpty(keys)) {\n            return currentCache;\n        }\n        var nextKey = keys[0];\n        var nextNode = findNodeFunc(nextKey);\n        if (nextNode) {\n            var keyListForNextLevel = keys.slice(1, keys.length);\n            var nextStore = nextNode.childStore;\n            return nextStore ? nextStore.getChildStore(keyListForNextLevel) : null;\n        }\n        return null;\n    };\n    StoreUtils.prototype.isServerRefreshNeeded = function (parentRowNode, rowGroupCols, params) {\n        if (params.alwaysReset || params.valueColChanged || params.secondaryColChanged) {\n            return true;\n        }\n        var level = parentRowNode.level + 1;\n        var grouping = level < rowGroupCols.length;\n        var leafNodes = !grouping;\n        if (leafNodes) {\n            return true;\n        }\n        var colIdThisGroup = rowGroupCols[level].id;\n        var actionOnThisGroup = params.changedColumns.indexOf(colIdThisGroup) > -1;\n        if (actionOnThisGroup) {\n            return true;\n        }\n        return false;\n    };\n    __decorate$1D([\n        agGridCommunity.Autowired('columnApi')\n    ], StoreUtils.prototype, \"columnApi\", void 0);\n    __decorate$1D([\n        agGridCommunity.Autowired('gridApi')\n    ], StoreUtils.prototype, \"gridApi\", void 0);\n    StoreUtils = __decorate$1D([\n        agGridCommunity.Bean('ssrmCacheUtils')\n    ], StoreUtils);\n    return StoreUtils;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2O = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar BlockUtils = /** @class */ (function (_super) {\n    __extends$2O(BlockUtils, _super);\n    function BlockUtils() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BlockUtils.prototype.postConstruct = function () {\n        this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        this.usingMasterDetail = this.gridOptionsWrapper.isMasterDetail();\n    };\n    BlockUtils.prototype.createRowNode = function (params) {\n        var rowNode = this.getContext().createBean(new agGridCommunity.RowNode());\n        rowNode.setRowHeight(this.rowHeight);\n        rowNode.group = params.group;\n        rowNode.leafGroup = params.leafGroup;\n        rowNode.level = params.level;\n        rowNode.uiLevel = params.level;\n        rowNode.parent = params.parent;\n        // stub gets set to true here, and then false when this rowNode gets it's data\n        rowNode.stub = true;\n        if (rowNode.group) {\n            rowNode.expanded = false;\n            rowNode.field = params.field;\n            rowNode.rowGroupColumn = params.rowGroupColumn;\n        }\n        return rowNode;\n    };\n    BlockUtils.prototype.destroyRowNodes = function (rowNodes) {\n        if (rowNodes) {\n            rowNodes.forEach(this.destroyRowNode.bind(this));\n        }\n    };\n    BlockUtils.prototype.destroyRowNode = function (rowNode) {\n        if (rowNode.childStore) {\n            this.destroyBean(rowNode.childStore);\n            rowNode.childStore = null;\n        }\n        // this is needed, so row render knows to fade out the row, otherwise it\n        // sees row top is present, and thinks the row should be shown. maybe\n        // rowNode should have a flag on whether it is visible???\n        rowNode.clearRowTopAndRowIndex();\n        if (rowNode.id != null) {\n            this.nodeManager.removeNode(rowNode);\n        }\n    };\n    BlockUtils.prototype.setDataIntoRowNode = function (rowNode, data, defaultId) {\n        rowNode.stub = false;\n        if (agGridCommunity._.exists(data)) {\n            rowNode.setDataAndId(data, defaultId);\n            if (this.usingTreeData) {\n                var isGroupFunc = this.gridOptionsWrapper.getIsServerSideGroupFunc();\n                var getKeyFunc = this.gridOptionsWrapper.getServerSideGroupKeyFunc();\n                if (isGroupFunc != null) {\n                    rowNode.group = isGroupFunc(rowNode.data);\n                    if (rowNode.group && getKeyFunc != null) {\n                        rowNode.key = getKeyFunc(rowNode.data);\n                    }\n                }\n            }\n            else if (rowNode.group) {\n                rowNode.key = this.valueService.getValue(rowNode.rowGroupColumn, rowNode);\n                if (rowNode.key === null || rowNode.key === undefined) {\n                    agGridCommunity._.doOnce(function () {\n                        console.warn(\"null and undefined values are not allowed for server side row model keys\");\n                        if (rowNode.rowGroupColumn) {\n                            console.warn(\"column = \" + rowNode.rowGroupColumn.getId());\n                        }\n                        console.warn(\"data is \", rowNode.data);\n                    }, 'ServerSideBlock-CannotHaveNullOrUndefinedForKey');\n                }\n            }\n            else if (this.usingMasterDetail) {\n                var isMasterFunc = this.gridOptionsWrapper.getIsRowMasterFunc();\n                if (isMasterFunc != null) {\n                    rowNode.master = isMasterFunc(rowNode.data);\n                }\n                else {\n                    rowNode.master = true;\n                }\n            }\n        }\n        else {\n            rowNode.setDataAndId(undefined, undefined);\n            rowNode.key = null;\n        }\n        if (this.usingTreeData || rowNode.group) {\n            this.setGroupDataIntoRowNode(rowNode);\n            this.setChildCountIntoRowNode(rowNode);\n        }\n        // this needs to be done AFTER setGroupDataIntoRowNode(), as the height can depend on the group data\n        // getting set, if it's a group node and colDef.autoHeight=true\n        if (agGridCommunity._.exists(data)) {\n            rowNode.setRowHeight(this.gridOptionsWrapper.getRowHeightForNode(rowNode).height);\n        }\n    };\n    BlockUtils.prototype.setChildCountIntoRowNode = function (rowNode) {\n        var getChildCount = this.gridOptionsWrapper.getChildCountFunc();\n        if (getChildCount) {\n            rowNode.allChildrenCount = getChildCount(rowNode.data);\n        }\n    };\n    BlockUtils.prototype.setGroupDataIntoRowNode = function (rowNode) {\n        var _this = this;\n        var groupDisplayCols = this.columnController.getGroupDisplayColumns();\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        groupDisplayCols.forEach(function (col) {\n            if (rowNode.groupData == null) {\n                rowNode.groupData = {};\n            }\n            if (usingTreeData) {\n                rowNode.groupData[col.getColId()] = rowNode.key;\n            }\n            else if (col.isRowGroupDisplayed(rowNode.rowGroupColumn.getId())) {\n                var groupValue = _this.valueService.getValue(rowNode.rowGroupColumn, rowNode);\n                rowNode.groupData[col.getColId()] = groupValue;\n            }\n        });\n    };\n    BlockUtils.prototype.clearDisplayIndex = function (rowNode) {\n        rowNode.clearRowTopAndRowIndex();\n        var hasChildStore = rowNode.group && agGridCommunity._.exists(rowNode.childStore);\n        if (hasChildStore) {\n            var childStore = rowNode.childStore;\n            childStore.clearDisplayIndexes();\n        }\n        var hasDetailNode = rowNode.master && rowNode.detailNode;\n        if (hasDetailNode) {\n            rowNode.detailNode.clearRowTopAndRowIndex();\n        }\n    };\n    BlockUtils.prototype.setDisplayIndex = function (rowNode, displayIndexSeq, nextRowTop) {\n        // set this row\n        rowNode.setRowIndex(displayIndexSeq.next());\n        rowNode.setRowTop(nextRowTop.value);\n        nextRowTop.value += rowNode.rowHeight;\n        // set child for master / detail\n        var hasDetailRow = rowNode.master;\n        if (hasDetailRow) {\n            if (rowNode.expanded && rowNode.detailNode) {\n                rowNode.detailNode.setRowIndex(displayIndexSeq.next());\n                rowNode.detailNode.setRowTop(nextRowTop.value);\n                nextRowTop.value += rowNode.detailNode.rowHeight;\n            }\n            else if (rowNode.detailNode) {\n                rowNode.detailNode.clearRowTopAndRowIndex();\n            }\n        }\n        // set children for SSRM child rows\n        var hasChildStore = rowNode.group && agGridCommunity._.exists(rowNode.childStore);\n        if (hasChildStore) {\n            var childStore = rowNode.childStore;\n            if (rowNode.expanded) {\n                childStore.setDisplayIndexes(displayIndexSeq, nextRowTop);\n            }\n            else {\n                // we need to clear the row tops, as the row renderer depends on\n                // this to know if the row should be faded out\n                childStore.clearDisplayIndexes();\n            }\n        }\n    };\n    BlockUtils.prototype.binarySearchForDisplayIndex = function (displayRowIndex, rowNodes) {\n        var bottomPointer = 0;\n        var topPointer = rowNodes.length - 1;\n        if (agGridCommunity._.missing(topPointer) || agGridCommunity._.missing(bottomPointer)) {\n            console.warn(\"ag-grid: error: topPointer = \" + topPointer + \", bottomPointer = \" + bottomPointer);\n            return null;\n        }\n        while (true) {\n            var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            var currentRowNode = rowNodes[midPointer];\n            // first check current row for index\n            if (currentRowNode.rowIndex === displayRowIndex) {\n                return currentRowNode;\n            }\n            // then check if current row contains a detail row with the index\n            var expandedMasterRow = currentRowNode.master && currentRowNode.expanded;\n            if (expandedMasterRow && currentRowNode.detailNode.rowIndex === displayRowIndex) {\n                return currentRowNode.detailNode;\n            }\n            // then check if child cache contains index\n            var childStore = currentRowNode.childStore;\n            if (currentRowNode.expanded && childStore && childStore.isDisplayIndexInStore(displayRowIndex)) {\n                return childStore.getRowUsingDisplayIndex(displayRowIndex);\n            }\n            // otherwise adjust pointers to continue searching for index\n            if (currentRowNode.rowIndex < displayRowIndex) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowIndex > displayRowIndex) {\n                topPointer = midPointer - 1;\n            }\n            else {\n                console.warn(\"AG Grid: error: unable to locate rowIndex = \" + displayRowIndex + \" in cache\");\n                return null;\n            }\n        }\n    };\n    BlockUtils.prototype.extractRowBounds = function (rowNode, index) {\n        var extractRowBounds = function (currentRowNode) { return ({\n            rowHeight: currentRowNode.rowHeight,\n            rowTop: currentRowNode.rowTop\n        }); };\n        if (rowNode.rowIndex === index) {\n            return extractRowBounds(rowNode);\n        }\n        if (rowNode.group && rowNode.expanded && agGridCommunity._.exists(rowNode.childStore)) {\n            var childStore = rowNode.childStore;\n            if (childStore.isDisplayIndexInStore(index)) {\n                return childStore.getRowBounds(index);\n            }\n        }\n        else if (rowNode.master && rowNode.expanded && agGridCommunity._.exists(rowNode.detailNode)) {\n            if (rowNode.detailNode.rowIndex === index) {\n                return extractRowBounds(rowNode.detailNode);\n            }\n        }\n    };\n    BlockUtils.prototype.getIndexAtPixel = function (rowNode, pixel) {\n        // first check if pixel is in range of current row\n        if (rowNode.isPixelInRange(pixel)) {\n            return rowNode.rowIndex;\n        }\n        // then check if current row contains a detail row with pixel in range\n        var expandedMasterRow = rowNode.master && rowNode.expanded;\n        if (expandedMasterRow && rowNode.detailNode.isPixelInRange(pixel)) {\n            return rowNode.detailNode.rowIndex;\n        }\n        // then check if it's a group row with a child cache with pixel in range\n        if (rowNode.group && rowNode.expanded && agGridCommunity._.exists(rowNode.childStore)) {\n            var childStore = rowNode.childStore;\n            if (childStore.isPixelInRange(pixel)) {\n                return childStore.getRowIndexAtPixel(pixel);\n            }\n        }\n        return null;\n        // pixel is not within this row node or it's children / detail, so return undefined\n    };\n    BlockUtils.prototype.createNodeIdPrefix = function (parentRowNode) {\n        var parts = [];\n        var rowNode = parentRowNode;\n        // pull keys from all parent nodes, but do not include the root node\n        while (rowNode && rowNode.level >= 0) {\n            parts.push(rowNode.key);\n            rowNode = rowNode.parent;\n        }\n        if (parts.length > 0) {\n            return parts.reverse().join('-');\n        }\n        else {\n            // no prefix, so node id's are left as they are\n            return undefined;\n        }\n    };\n    BlockUtils.prototype.checkOpenByDefault = function (rowNode) {\n        if (!rowNode.isExpandable()) {\n            return;\n        }\n        var userFunc = this.gridOptionsWrapper.getIsServerSideGroupOpenByDefaultFunc();\n        if (!userFunc) {\n            return;\n        }\n        var params = {\n            data: rowNode.data,\n            rowNode: rowNode\n        };\n        var userFuncRes = userFunc(params);\n        if (userFuncRes) {\n            // we do this in a timeout, so that we don't expand a row node while in the middle\n            // of setting up rows, setting up rows is complex enough without another chunk of work\n            // getting added to the call stack. this is also helpful as openByDefault may or may\n            // not happen (so makes setting up rows more deterministic by expands never happening)\n            // and also checkOpenByDefault is shard with both store types, so easier control how it\n            // impacts things by keeping it in new VM turn.\n            window.setTimeout(function () { return rowNode.setExpanded(true); }, 0);\n        }\n    };\n    __decorate$1E([\n        agGridCommunity.Autowired('valueService')\n    ], BlockUtils.prototype, \"valueService\", void 0);\n    __decorate$1E([\n        agGridCommunity.Autowired('columnController')\n    ], BlockUtils.prototype, \"columnController\", void 0);\n    __decorate$1E([\n        agGridCommunity.Autowired('ssrmNodeManager')\n    ], BlockUtils.prototype, \"nodeManager\", void 0);\n    __decorate$1E([\n        agGridCommunity.PostConstruct\n    ], BlockUtils.prototype, \"postConstruct\", null);\n    BlockUtils = __decorate$1E([\n        agGridCommunity.Bean('ssrmBlockUtils')\n    ], BlockUtils);\n    return BlockUtils;\n}(agGridCommunity.BeanStub));\n\nvar __decorate$1F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar NodeManager = /** @class */ (function () {\n    function NodeManager() {\n        this.rowNodes = {};\n    }\n    NodeManager.prototype.addRowNode = function (rowNode) {\n        var id = rowNode.id;\n        if (this.rowNodes[id]) {\n            console.warn('AG Grid: duplicate node id ' + rowNode.id);\n            console.warn('first instance', this.rowNodes[id].data);\n            console.warn('second instance', rowNode.data);\n        }\n        this.rowNodes[id] = rowNode;\n    };\n    NodeManager.prototype.removeNode = function (rowNode) {\n        var id = rowNode.id;\n        if (this.rowNodes[id]) {\n            this.rowNodes[id] = undefined;\n        }\n    };\n    NodeManager.prototype.clear = function () {\n        this.rowNodes = {};\n    };\n    __decorate$1F([\n        agGridCommunity.PreDestroy\n    ], NodeManager.prototype, \"clear\", null);\n    NodeManager = __decorate$1F([\n        agGridCommunity.Bean('ssrmNodeManager')\n    ], NodeManager);\n    return NodeManager;\n}());\n\nvar __extends$2P = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TransactionManager = /** @class */ (function (_super) {\n    __extends$2P(TransactionManager, _super);\n    function TransactionManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.asyncTransactions = [];\n        return _this;\n    }\n    TransactionManager.prototype.postConstruct = function () {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsWrapper.isRowModelServerSide()) {\n            return;\n        }\n    };\n    TransactionManager.prototype.applyTransactionAsync = function (transaction, callback) {\n        if (this.asyncTransactionsTimeout == null) {\n            this.scheduleExecuteAsync();\n        }\n        this.asyncTransactions.push({ transaction: transaction, callback: callback });\n    };\n    TransactionManager.prototype.scheduleExecuteAsync = function () {\n        var _this = this;\n        var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n        this.asyncTransactionsTimeout = window.setTimeout(function () {\n            _this.executeAsyncTransactions();\n        }, waitMillis);\n    };\n    TransactionManager.prototype.executeAsyncTransactions = function () {\n        var _this = this;\n        if (!this.asyncTransactions) {\n            return;\n        }\n        var resultFuncs = [];\n        var resultsForEvent = [];\n        var transactionsToRetry = [];\n        var atLeastOneTransactionApplied = false;\n        this.asyncTransactions.forEach(function (txWrapper) {\n            var result;\n            _this.serverSideRowModel.executeOnStore(txWrapper.transaction.route, function (cache) {\n                result = cache.applyTransaction(txWrapper.transaction);\n            });\n            if (result == undefined) {\n                result = { status: agGridCommunity.ServerSideTransactionResultStatus.StoreNotFound };\n            }\n            resultsForEvent.push(result);\n            var retryTransaction = result.status == agGridCommunity.ServerSideTransactionResultStatus.StoreLoading;\n            if (retryTransaction) {\n                transactionsToRetry.push(txWrapper);\n                return;\n            }\n            if (txWrapper.callback) {\n                resultFuncs.push(function () { return txWrapper.callback(result); });\n            }\n            if (result.status === agGridCommunity.ServerSideTransactionResultStatus.Applied) {\n                atLeastOneTransactionApplied = true;\n            }\n        });\n        // do callbacks in next VM turn so it's async\n        if (resultFuncs.length > 0) {\n            window.setTimeout(function () {\n                resultFuncs.forEach(function (func) { return func(); });\n            }, 0);\n        }\n        this.asyncTransactionsTimeout = undefined;\n        // this will be empty list if nothing to retry\n        this.asyncTransactions = transactionsToRetry;\n        if (atLeastOneTransactionApplied) {\n            this.valueCache.onDataChanged();\n            this.eventService.dispatchEvent({ type: agGridCommunity.Events.EVENT_STORE_UPDATED });\n        }\n        if (resultsForEvent.length > 0) {\n            var event_1 = {\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                type: agGridCommunity.Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: resultsForEvent\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n    };\n    TransactionManager.prototype.flushAsyncTransactions = function () {\n        // the timeout could be missing, if we are flushing due to row data loaded\n        if (this.asyncTransactionsTimeout != null) {\n            clearTimeout(this.asyncTransactionsTimeout);\n        }\n        this.executeAsyncTransactions();\n    };\n    TransactionManager.prototype.applyTransaction = function (transaction) {\n        var res;\n        this.serverSideRowModel.executeOnStore(transaction.route, function (cache) {\n            res = cache.applyTransaction(transaction);\n        });\n        if (res) {\n            this.valueCache.onDataChanged();\n            this.eventService.dispatchEvent({ type: agGridCommunity.Events.EVENT_STORE_UPDATED });\n            return res;\n        }\n        else {\n            return { status: agGridCommunity.ServerSideTransactionResultStatus.StoreNotFound };\n        }\n    };\n    __decorate$1G([\n        agGridCommunity.Autowired('rowNodeBlockLoader')\n    ], TransactionManager.prototype, \"rowNodeBlockLoader\", void 0);\n    __decorate$1G([\n        agGridCommunity.Autowired('valueCache')\n    ], TransactionManager.prototype, \"valueCache\", void 0);\n    __decorate$1G([\n        agGridCommunity.Autowired('rowModel')\n    ], TransactionManager.prototype, \"serverSideRowModel\", void 0);\n    __decorate$1G([\n        agGridCommunity.PostConstruct\n    ], TransactionManager.prototype, \"postConstruct\", null);\n    TransactionManager = __decorate$1G([\n        agGridCommunity.Bean('ssrmTransactionManager')\n    ], TransactionManager);\n    return TransactionManager;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2Q = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ExpandListener = /** @class */ (function (_super) {\n    __extends$2Q(ExpandListener, _super);\n    function ExpandListener() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ExpandListener.prototype.postConstruct = function () {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsWrapper.isRowModelServerSide()) {\n            return;\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n    };\n    ExpandListener.prototype.onRowGroupOpened = function (event) {\n        var rowNode = event.node;\n        if (rowNode.expanded) {\n            if (rowNode.master) {\n                this.createDetailNode(rowNode);\n            }\n            else if (agGridCommunity._.missing(rowNode.childStore)) {\n                var storeParams = this.serverSideRowModel.getParams();\n                rowNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, rowNode));\n            }\n        }\n        else if (this.gridOptionsWrapper.isPurgeClosedRowNodes() && agGridCommunity._.exists(rowNode.childStore)) {\n            rowNode.childStore = this.destroyBean(rowNode.childStore);\n        }\n        var storeUpdatedEvent = { type: agGridCommunity.Events.EVENT_STORE_UPDATED };\n        this.eventService.dispatchEvent(storeUpdatedEvent);\n    };\n    ExpandListener.prototype.createDetailNode = function (masterNode) {\n        if (agGridCommunity._.exists(masterNode.detailNode)) {\n            return masterNode.detailNode;\n        }\n        var detailNode = new agGridCommunity.RowNode();\n        this.getContext().createBean(detailNode);\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n        if (agGridCommunity._.exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n        var defaultDetailRowHeight = 200;\n        var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(detailNode).height;\n        detailNode.rowHeight = rowHeight ? rowHeight : defaultDetailRowHeight;\n        masterNode.detailNode = detailNode;\n        return detailNode;\n    };\n    __decorate$1H([\n        agGridCommunity.Autowired('rowModel')\n    ], ExpandListener.prototype, \"serverSideRowModel\", void 0);\n    __decorate$1H([\n        agGridCommunity.Autowired('ssrmStoreFactory')\n    ], ExpandListener.prototype, \"storeFactory\", void 0);\n    __decorate$1H([\n        agGridCommunity.PostConstruct\n    ], ExpandListener.prototype, \"postConstruct\", null);\n    ExpandListener = __decorate$1H([\n        agGridCommunity.Bean('ssrmExpandListener')\n    ], ExpandListener);\n    return ExpandListener;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2R = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SortListener = /** @class */ (function (_super) {\n    __extends$2R(SortListener, _super);\n    function SortListener() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SortListener.prototype.postConstruct = function () {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsWrapper.isRowModelServerSide()) {\n            return;\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    };\n    SortListener.prototype.extractSortModel = function () {\n        var sortModel = this.sortController.getSortModel();\n        // when using tree data we just return the sort model with the 'ag-Grid-AutoColumn' as is, i.e not broken out\n        // into it's constitute group columns as they are not defined up front and can vary per node.\n        if (this.gridOptionsWrapper.isTreeData()) {\n            return sortModel;\n        }\n        // it autoCol is active, we don't want to send this to the server. instead we want to\n        // send the\n        this.replaceAutoGroupColumnWithActualRowGroupColumns(sortModel);\n        this.removeMultiColumnPrefixOnColumnIds(sortModel);\n        return sortModel;\n    };\n    SortListener.prototype.removeMultiColumnPrefixOnColumnIds = function (sortModel) {\n        if (this.gridOptionsWrapper.isGroupMultiAutoColumn()) {\n            var multiColumnPrefix = agGridCommunity.Constants.GROUP_AUTO_COLUMN_ID + \"-\";\n            for (var i = 0; i < sortModel.length; ++i) {\n                if (sortModel[i].colId.indexOf(multiColumnPrefix) > -1) {\n                    sortModel[i].colId = sortModel[i].colId.substr(multiColumnPrefix.length);\n                }\n            }\n        }\n    };\n    SortListener.prototype.replaceAutoGroupColumnWithActualRowGroupColumns = function (sortModel) {\n        // find index of auto group column in sort model\n        var autoGroupSortModel = agGridCommunity._.find(sortModel, function (sm) { return sm.colId == agGridCommunity.Constants.GROUP_AUTO_COLUMN_ID; });\n        // replace auto column with individual group columns\n        if (autoGroupSortModel) {\n            // remove auto group column\n            var autoGroupIndex = sortModel.indexOf(autoGroupSortModel);\n            agGridCommunity._.removeFromArray(sortModel, autoGroupSortModel);\n            var isNotInSortModel = function (col) { return sortModel.filter(function (sm) { return sm.colId === col.getColId(); }).length == 0; };\n            var mapColumnToSortModel = function (col) { return ({ colId: col.getId(), sort: autoGroupSortModel.sort }); };\n            var newModels = this.columnController.getRowGroupColumns()\n                .filter(isNotInSortModel)\n                .map(mapColumnToSortModel);\n            agGridCommunity._.insertArrayIntoArray(sortModel, newModels, autoGroupIndex);\n        }\n    };\n    SortListener.prototype.onSortChanged = function () {\n        var storeParams = this.serverSideRowModel.getParams();\n        var newSortModel = this.extractSortModel();\n        var oldSortModel = storeParams.sortModel;\n        var changedColumns = this.findChangedColumnsInSort(newSortModel, oldSortModel);\n        var valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);\n        var secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);\n        var alwaysReset = this.gridOptionsWrapper.isServerSideSortingAlwaysResets();\n        var params = {\n            valueColChanged: valueColChanged,\n            secondaryColChanged: secondaryColChanged,\n            alwaysReset: alwaysReset,\n            changedColumns: changedColumns\n        };\n        this.serverSideRowModel.refreshAfterSort(newSortModel, params);\n    };\n    // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,\n    // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache\n    // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache\n    // was previously sorted by A and then the A sort now needs to be cleared.\n    SortListener.prototype.findChangedColumnsInSort = function (newSortModel, oldSortModel) {\n        var allColsInBothSorts = [];\n        [newSortModel, oldSortModel].forEach(function (sortModel) {\n            if (sortModel) {\n                var ids = sortModel.map(function (sm) { return sm.colId; });\n                allColsInBothSorts = allColsInBothSorts.concat(ids);\n            }\n        });\n        var differentSorts = function (oldSortItem, newSortItem) {\n            var oldSort = oldSortItem ? oldSortItem.sort : null;\n            var newSort = newSortItem ? newSortItem.sort : null;\n            return oldSort !== newSort;\n        };\n        var differentIndexes = function (oldSortItem, newSortItem) {\n            var oldIndex = oldSortModel.indexOf(oldSortItem);\n            var newIndex = newSortModel.indexOf(newSortItem);\n            return oldIndex !== newIndex;\n        };\n        return allColsInBothSorts.filter(function (colId) {\n            var oldSortItem = agGridCommunity._.find(oldSortModel, function (sm) { return sm.colId === colId; });\n            var newSortItem = agGridCommunity._.find(newSortModel, function (sm) { return sm.colId === colId; });\n            return differentSorts(oldSortItem, newSortItem) || differentIndexes(oldSortItem, newSortItem);\n        });\n    };\n    __decorate$1I([\n        agGridCommunity.Autowired('sortController')\n    ], SortListener.prototype, \"sortController\", void 0);\n    __decorate$1I([\n        agGridCommunity.Autowired('columnController')\n    ], SortListener.prototype, \"columnController\", void 0);\n    __decorate$1I([\n        agGridCommunity.Autowired('rowModel')\n    ], SortListener.prototype, \"serverSideRowModel\", void 0);\n    __decorate$1I([\n        agGridCommunity.Autowired('ssrmListenerUtils')\n    ], SortListener.prototype, \"listenerUtils\", void 0);\n    __decorate$1I([\n        agGridCommunity.PostConstruct\n    ], SortListener.prototype, \"postConstruct\", null);\n    SortListener = __decorate$1I([\n        agGridCommunity.Bean('ssrmSortService')\n    ], SortListener);\n    return SortListener;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2S = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FilterListener = /** @class */ (function (_super) {\n    __extends$2S(FilterListener, _super);\n    function FilterListener() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FilterListener.prototype.postConstruct = function () {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsWrapper.isRowModelServerSide()) {\n            return;\n        }\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    };\n    FilterListener.prototype.onFilterChanged = function () {\n        var newModel = this.filterManager.getFilterModel();\n        var storeParams = this.serverSideRowModel.getParams();\n        var oldModel = storeParams ? storeParams.filterModel : {};\n        var changedColumns = this.findChangedColumns(newModel, oldModel);\n        var valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);\n        var secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);\n        var alwaysReset = this.gridOptionsWrapper.isServerSideFilteringAlwaysResets();\n        var params = {\n            valueColChanged: valueColChanged,\n            secondaryColChanged: secondaryColChanged,\n            alwaysReset: alwaysReset,\n            changedColumns: changedColumns\n        };\n        this.serverSideRowModel.refreshAfterFilter(newModel, params);\n    };\n    FilterListener.prototype.findChangedColumns = function (oldModel, newModel) {\n        var allColKeysMap = {};\n        Object.keys(oldModel).forEach(function (key) { return allColKeysMap[key] = true; });\n        Object.keys(newModel).forEach(function (key) { return allColKeysMap[key] = true; });\n        var res = [];\n        Object.keys(allColKeysMap).forEach(function (key) {\n            var oldJson = JSON.stringify(oldModel[key]);\n            var newJson = JSON.stringify(newModel[key]);\n            var filterChanged = oldJson != newJson;\n            if (filterChanged) {\n                res.push(key);\n            }\n        });\n        return res;\n    };\n    __decorate$1J([\n        agGridCommunity.Autowired('rowModel')\n    ], FilterListener.prototype, \"serverSideRowModel\", void 0);\n    __decorate$1J([\n        agGridCommunity.Autowired('filterManager')\n    ], FilterListener.prototype, \"filterManager\", void 0);\n    __decorate$1J([\n        agGridCommunity.Autowired('ssrmListenerUtils')\n    ], FilterListener.prototype, \"listenerUtils\", void 0);\n    __decorate$1J([\n        agGridCommunity.PostConstruct\n    ], FilterListener.prototype, \"postConstruct\", null);\n    FilterListener = __decorate$1J([\n        agGridCommunity.Bean('ssrmFilterListener')\n    ], FilterListener);\n    return FilterListener;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2T = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param$1 = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar PartialStoreBlock = /** @class */ (function (_super) {\n    __extends$2T(PartialStoreBlock, _super);\n    function PartialStoreBlock(blockNumber, parentRowNode, ssrmParams, storeParams, parentStore) {\n        var _this = _super.call(this, blockNumber) || this;\n        _this.ssrmParams = ssrmParams;\n        _this.storeParams = storeParams;\n        _this.parentRowNode = parentRowNode;\n        // we don't need to calculate these now, as the inputs don't change,\n        // however it makes the code easier to read if we work them out up front\n        _this.startRow = blockNumber * storeParams.cacheBlockSize;\n        _this.parentStore = parentStore;\n        _this.level = parentRowNode.level + 1;\n        _this.groupLevel = ssrmParams.rowGroupCols ? _this.level < ssrmParams.rowGroupCols.length : undefined;\n        _this.leafGroup = ssrmParams.rowGroupCols ? _this.level === ssrmParams.rowGroupCols.length - 1 : false;\n        return _this;\n    }\n    PartialStoreBlock.prototype.postConstruct = function () {\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        this.usingMasterDetail = this.gridOptionsWrapper.isMasterDetail();\n        this.defaultRowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n        if (!this.usingTreeData && this.groupLevel) {\n            var groupColVo = this.ssrmParams.rowGroupCols[this.level];\n            this.groupField = groupColVo.field;\n            this.rowGroupColumn = this.columnController.getRowGroupColumns()[this.level];\n        }\n        this.nodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.parentRowNode);\n        this.setData([]);\n    };\n    PartialStoreBlock.prototype.isDisplayIndexInBlock = function (displayIndex) {\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    PartialStoreBlock.prototype.isBlockBefore = function (displayIndex) {\n        return displayIndex >= this.displayIndexEnd;\n    };\n    PartialStoreBlock.prototype.getDisplayIndexStart = function () {\n        return this.displayIndexStart;\n    };\n    PartialStoreBlock.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    PartialStoreBlock.prototype.getBlockHeightPx = function () {\n        return this.blockHeightPx;\n    };\n    PartialStoreBlock.prototype.getBlockTopPx = function () {\n        return this.blockTopPx;\n    };\n    PartialStoreBlock.prototype.isGroupLevel = function () {\n        return this.groupLevel;\n    };\n    PartialStoreBlock.prototype.getGroupField = function () {\n        return this.groupField;\n    };\n    PartialStoreBlock.prototype.prefixId = function (id) {\n        if (this.nodeIdPrefix) {\n            return this.nodeIdPrefix + '-' + id;\n        }\n        else {\n            return id.toString();\n        }\n    };\n    PartialStoreBlock.prototype.getBlockStateJson = function () {\n        return {\n            id: this.prefixId(this.getId()),\n            state: {\n                blockNumber: this.getId(),\n                startRow: this.startRow,\n                endRow: this.startRow + this.storeParams.cacheBlockSize,\n                pageStatus: this.getState()\n            }\n        };\n    };\n    PartialStoreBlock.prototype.isAnyNodeOpen = function () {\n        var openNodeCount = this.rowNodes.filter(function (node) { return node.expanded; }).length;\n        return openNodeCount > 0;\n    };\n    // this method is repeated, see forEachRowNode, why?\n    PartialStoreBlock.prototype.forEachNode = function (callback, sequence, includeChildren) {\n        if (sequence === void 0) { sequence = new agGridCommunity.NumberSequence(); }\n        this.rowNodes.forEach(function (rowNode) {\n            callback(rowNode, sequence.next());\n            // this will only every happen for server side row model, as infinite\n            // row model doesn't have groups\n            if (includeChildren && rowNode.childStore) {\n                var childStore = rowNode.childStore;\n                childStore.forEachNodeDeep(callback, sequence);\n            }\n        });\n    };\n    PartialStoreBlock.prototype.forEachNodeDeep = function (callback, sequence) {\n        this.forEachNode(callback, sequence, true);\n    };\n    PartialStoreBlock.prototype.forEachNodeShallow = function (callback, sequence) {\n        this.forEachNode(callback, sequence, false);\n    };\n    PartialStoreBlock.prototype.getLastAccessed = function () {\n        return this.lastAccessed;\n    };\n    PartialStoreBlock.prototype.getRowUsingLocalIndex = function (rowIndex) {\n        return this.rowNodes[rowIndex - this.startRow];\n    };\n    PartialStoreBlock.prototype.touchLastAccessed = function () {\n        this.lastAccessed = this.ssrmParams.lastAccessedSequence.next();\n    };\n    PartialStoreBlock.prototype.processServerFail = function () {\n        this.parentStore.onBlockLoadFailed(this);\n    };\n    PartialStoreBlock.prototype.retryLoads = function () {\n        if (this.getState() === agGridCommunity.RowNodeBlock.STATE_FAILED) {\n            this.setStateWaitingToLoad();\n            this.rowNodeBlockLoader.checkBlockToLoad();\n            this.setData();\n        }\n        this.forEachNodeShallow(function (node) {\n            if (node.childStore) {\n                node.childStore.retryLoads();\n            }\n        });\n    };\n    PartialStoreBlock.prototype.processServerResult = function (params) {\n        this.parentStore.onBlockLoaded(this, params);\n    };\n    PartialStoreBlock.prototype.setData = function (rows, failedLoad) {\n        if (rows === void 0) { rows = []; }\n        if (failedLoad === void 0) { failedLoad = false; }\n        this.destroyRowNodes();\n        var storeRowCount = this.parentStore.getRowCount();\n        var startRow = this.getId() * this.storeParams.cacheBlockSize;\n        var endRow = Math.min(startRow + this.storeParams.cacheBlockSize, storeRowCount);\n        var rowsToCreate = endRow - startRow;\n        for (var i = 0; i < rowsToCreate; i++) {\n            var rowNode = this.blockUtils.createRowNode({ field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,\n                level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn });\n            var dataLoadedForThisRow = i < rows.length;\n            if (dataLoadedForThisRow) {\n                var data = rows[i];\n                var defaultId = this.prefixId(this.startRow + i);\n                this.blockUtils.setDataIntoRowNode(rowNode, data, defaultId);\n                var newId = rowNode.id;\n                this.parentStore.removeDuplicateNode(newId);\n                this.nodeManager.addRowNode(rowNode);\n                this.allNodesMap[rowNode.id] = rowNode;\n            }\n            this.rowNodes.push(rowNode);\n            if (failedLoad) {\n                rowNode.failedLoad = true;\n            }\n        }\n    };\n    // to safeguard the grid against duplicate nodes, when a row is loaded, we check\n    // for another row in the same cache. if another row does exist, we delete it.\n    // this covers for when user refreshes the store (which typically happens after a\n    // data change) and the same row ends up coming back in a different block, and the\n    // new block finishes refreshing before the old block has finished refreshing.\n    PartialStoreBlock.prototype.removeDuplicateNode = function (id) {\n        var rowNode = this.allNodesMap[id];\n        if (!rowNode) {\n            return;\n        }\n        this.blockUtils.destroyRowNode(rowNode);\n        var index = this.rowNodes.indexOf(rowNode);\n        var stubRowNode = this.blockUtils.createRowNode({ field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,\n            level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn });\n        this.rowNodes[index] = stubRowNode;\n    };\n    PartialStoreBlock.prototype.refresh = function () {\n        if (this.getState() !== agGridCommunity.RowNodeBlock.STATE_WAITING_TO_LOAD) {\n            this.setStateWaitingToLoad();\n        }\n    };\n    PartialStoreBlock.prototype.destroyRowNodes = function () {\n        this.blockUtils.destroyRowNodes(this.rowNodes);\n        this.rowNodes = [];\n        this.allNodesMap = {};\n    };\n    PartialStoreBlock.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ServerSideBlock');\n    };\n    PartialStoreBlock.prototype.getRowUsingDisplayIndex = function (displayRowIndex) {\n        this.touchLastAccessed();\n        var res = this.blockUtils.binarySearchForDisplayIndex(displayRowIndex, this.rowNodes);\n        return res;\n    };\n    PartialStoreBlock.prototype.loadFromDatasource = function () {\n        this.cacheUtils.loadFromDatasource({\n            startRow: this.startRow,\n            endRow: this.startRow + this.storeParams.cacheBlockSize,\n            parentNode: this.parentRowNode,\n            storeParams: this.ssrmParams,\n            successCallback: this.pageLoaded.bind(this, this.getVersion()),\n            success: this.success.bind(this, this.getVersion()),\n            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n            fail: this.pageLoadFailed.bind(this, this.getVersion())\n        });\n    };\n    PartialStoreBlock.prototype.isPixelInRange = function (pixel) {\n        return pixel >= this.blockTopPx && pixel < (this.blockTopPx + this.blockHeightPx);\n    };\n    PartialStoreBlock.prototype.getRowBounds = function (index) {\n        var _this = this;\n        this.touchLastAccessed();\n        var res;\n        agGridCommunity._.find(this.rowNodes, function (rowNode) {\n            res = _this.blockUtils.extractRowBounds(rowNode, index);\n            return res != null;\n        });\n        return res;\n    };\n    PartialStoreBlock.prototype.getRowIndexAtPixel = function (pixel) {\n        var _this = this;\n        this.touchLastAccessed();\n        var res = null;\n        agGridCommunity._.find(this.rowNodes, function (rowNode) {\n            res = _this.blockUtils.getIndexAtPixel(rowNode, pixel);\n            return res != null;\n        });\n        return res;\n    };\n    PartialStoreBlock.prototype.clearDisplayIndexes = function () {\n        var _this = this;\n        this.displayIndexEnd = undefined;\n        this.displayIndexStart = undefined;\n        this.rowNodes.forEach(function (rowNode) { return _this.blockUtils.clearDisplayIndex(rowNode); });\n    };\n    PartialStoreBlock.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.blockTopPx = nextRowTop.value;\n        this.rowNodes.forEach(function (rowNode) { return _this.blockUtils.setDisplayIndex(rowNode, displayIndexSeq, nextRowTop); });\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.blockHeightPx = nextRowTop.value - this.blockTopPx;\n    };\n    __decorate$1K([\n        agGridCommunity.Autowired('rowRenderer')\n    ], PartialStoreBlock.prototype, \"rowRenderer\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('columnController')\n    ], PartialStoreBlock.prototype, \"columnController\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('valueService')\n    ], PartialStoreBlock.prototype, \"valueService\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('columnApi')\n    ], PartialStoreBlock.prototype, \"columnApi\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('gridApi')\n    ], PartialStoreBlock.prototype, \"gridApi\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('ssrmCacheUtils')\n    ], PartialStoreBlock.prototype, \"cacheUtils\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('ssrmBlockUtils')\n    ], PartialStoreBlock.prototype, \"blockUtils\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('ssrmNodeManager')\n    ], PartialStoreBlock.prototype, \"nodeManager\", void 0);\n    __decorate$1K([\n        agGridCommunity.Autowired('rowNodeBlockLoader')\n    ], PartialStoreBlock.prototype, \"rowNodeBlockLoader\", void 0);\n    __decorate$1K([\n        agGridCommunity.PostConstruct\n    ], PartialStoreBlock.prototype, \"postConstruct\", null);\n    __decorate$1K([\n        agGridCommunity.PreDestroy\n    ], PartialStoreBlock.prototype, \"destroyRowNodes\", null);\n    __decorate$1K([\n        __param$1(0, agGridCommunity.Qualifier('loggerFactory'))\n    ], PartialStoreBlock.prototype, \"setBeans\", null);\n    return PartialStoreBlock;\n}(agGridCommunity.RowNodeBlock));\n\nvar __extends$2U = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param$2 = (undefined && undefined.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar FindResult;\n(function (FindResult) {\n    FindResult[FindResult[\"FOUND\"] = 0] = \"FOUND\";\n    FindResult[FindResult[\"CONTINUE_FIND\"] = 1] = \"CONTINUE_FIND\";\n    FindResult[FindResult[\"BREAK_FIND\"] = 2] = \"BREAK_FIND\";\n})(FindResult || (FindResult = {}));\nvar PartialStore = /** @class */ (function (_super) {\n    __extends$2U(PartialStore, _super);\n    function PartialStore(ssrmParams, storeParams, parentRowNode) {\n        var _this = _super.call(this) || this;\n        _this.blocks = {};\n        _this.blockHeights = {};\n        _this.blockCount = 0;\n        _this.lastRowIndexKnown = false;\n        // this will always be zero for the top level cache only,\n        // all the other ones change as the groups open and close\n        _this.displayIndexStart = 0;\n        _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n        _this.cacheTopPixel = 0;\n        _this.info = {};\n        _this.ssrmParams = ssrmParams;\n        _this.storeParams = storeParams;\n        _this.parentRowNode = parentRowNode;\n        _this.rowCount = PartialStore.INITIAL_ROW_COUNT;\n        return _this;\n    }\n    PartialStore.prototype.postConstruct = function () {\n        this.defaultRowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n    };\n    PartialStore.prototype.destroyAllBlocks = function () {\n        var _this = this;\n        this.getBlocksInOrder().forEach(function (block) { return _this.destroyBlock(block); });\n    };\n    PartialStore.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ServerSideCache');\n    };\n    PartialStore.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n    PartialStore.prototype.isLastRowIndexKnown = function () {\n        return this.lastRowIndexKnown;\n    };\n    PartialStore.prototype.retryLoads = function () {\n        this.getBlocksInOrder().forEach(function (block) { return block.retryLoads(); });\n    };\n    PartialStore.prototype.onBlockLoadFailed = function (block) {\n        block.setData([], true);\n        this.fireCacheUpdatedEvent();\n    };\n    PartialStore.prototype.onBlockLoaded = function (block, params) {\n        this.logger.log(\"onPageLoaded: page = \" + block.getId() + \", lastRow = \" + params.rowCount);\n        if (params.storeInfo) {\n            agGridCommunity._.assign(this.info, params.storeInfo);\n        }\n        if (!params.rowData) {\n            var message_1 = 'AG Grid: \"params.rowData\" is missing from Server-Side Row Model success() callback. Please use the \"rowData\" attribute. If no data is returned, set an empty list.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_1, params); }, 'InfiniteStore.noData');\n        }\n        var finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : undefined;\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isAlive()) {\n            return;\n        }\n        this.checkRowCount(block, finalRowCount);\n        block.setData(params.rowData);\n        // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n        // in the valid range. so we must remove these. this can happen if the datasource returns a\n        // result and sets lastRow to something less than virtualRowCount (can happen if user scrolls\n        // down, server reduces dataset size).\n        this.destroyAllBlocksPastVirtualRowCount();\n        this.fireCacheUpdatedEvent();\n    };\n    PartialStore.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n        var _this = this;\n        // we exclude checking for the page just created, as this has yet to be accessed and hence\n        // the lastAccessed stamp will not be updated for the first time yet\n        var blocksForPurging = this.getBlocksInOrder().filter(function (b) { return b != blockToExclude; });\n        var lastAccessedComparator = function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); };\n        blocksForPurging.sort(lastAccessedComparator);\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        var maxBlocksProvided = this.storeParams.maxBlocksInCache > 0;\n        var blocksToKeep = maxBlocksProvided ? this.storeParams.maxBlocksInCache - 1 : null;\n        var emptyBlocksToKeep = PartialStore.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n        blocksForPurging.forEach(function (block, index) {\n            var purgeBecauseBlockEmpty = block.getState() === PartialStoreBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;\n            var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n                // we never purge blocks if they are open, as purging them would mess up with\n                // our indexes, it would be very messy to restore the purged block to it's\n                // previous state if it had open children.\n                if (block.isAnyNodeOpen()) {\n                    return;\n                }\n                // if the block currently has rows been displayed, then don't remove it either.\n                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n                // but the screen is showing 20 rows, so at least 4 blocks are needed.\n                if (_this.isBlockCurrentlyDisplayed(block)) {\n                    return;\n                }\n                // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.\n                if (_this.isBlockFocused(block)) {\n                    return;\n                }\n                // at this point, block is not needed, and no open nodes, so burn baby burn\n                _this.destroyBlock(block);\n            }\n        });\n    };\n    PartialStore.prototype.isBlockFocused = function (block) {\n        var focusedCell = this.focusController.getFocusCellToUseAfterRefresh();\n        if (!focusedCell) {\n            return false;\n        }\n        if (focusedCell.rowPinned != null) {\n            return false;\n        }\n        var blockIndexStart = block.getDisplayIndexStart();\n        var blockIndexEnd = block.getDisplayIndexEnd();\n        if (blockIndexEnd == null || blockIndexStart == null) {\n            return false;\n        }\n        var hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n        return hasFocus;\n    };\n    PartialStore.prototype.isBlockCurrentlyDisplayed = function (block) {\n        var startIndex = block.getDisplayIndexStart();\n        var endIndex = block.getDisplayIndexEnd() - 1;\n        return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n    };\n    PartialStore.prototype.removeDuplicateNode = function (id) {\n        this.getBlocksInOrder().forEach(function (block) { return block.removeDuplicateNode(id); });\n    };\n    PartialStore.prototype.checkRowCount = function (block, lastRow) {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.rowCount = lastRow;\n            this.lastRowIndexKnown = true;\n        }\n        else if (!this.lastRowIndexKnown) {\n            // otherwise, see if we need to add some virtual rows\n            var lastRowIndex = (block.getId() + 1) * this.storeParams.cacheBlockSize;\n            var lastRowIndexPlusOverflow = lastRowIndex + PartialStore.OVERFLOW_SIZE;\n            if (this.rowCount < lastRowIndexPlusOverflow) {\n                this.rowCount = lastRowIndexPlusOverflow;\n            }\n        }\n    };\n    PartialStore.prototype.forEachNodeDeep = function (callback, sequence) {\n        if (sequence === void 0) { sequence = new agGridCommunity.NumberSequence(); }\n        this.getBlocksInOrder().forEach(function (block) { return block.forEachNodeDeep(callback, sequence); });\n    };\n    PartialStore.prototype.getBlocksInOrder = function () {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        var blockComparator = function (a, b) { return a.getId() - b.getId(); };\n        var blocks = agGridCommunity._.getAllValuesInObject(this.blocks).sort(blockComparator);\n        return blocks;\n    };\n    PartialStore.prototype.destroyBlock = function (block) {\n        delete this.blocks[block.getId()];\n        this.destroyBean(block);\n        this.blockCount--;\n        this.rowNodeBlockLoader.removeBlock(block);\n    };\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    PartialStore.prototype.fireCacheUpdatedEvent = function () {\n        // this results in row model firing ModelUpdated.\n        // server side row model also updates the row indexes first\n        var event = {\n            type: agGridCommunity.Events.EVENT_STORE_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    PartialStore.prototype.destroyAllBlocksPastVirtualRowCount = function () {\n        var _this = this;\n        var blocksToDestroy = [];\n        this.getBlocksInOrder().forEach(function (block) {\n            var startRow = block.getId() * _this.storeParams.cacheBlockSize;\n            if (startRow >= _this.rowCount) {\n                blocksToDestroy.push(block);\n            }\n        });\n        if (blocksToDestroy.length > 0) {\n            blocksToDestroy.forEach(function (block) { return _this.destroyBlock(block); });\n        }\n    };\n    PartialStore.prototype.refreshStore = function (showLoading) {\n        if (showLoading) {\n            this.resetStore();\n        }\n        else {\n            this.refreshBlocks();\n        }\n        this.fireCacheUpdatedEvent();\n    };\n    PartialStore.prototype.refreshBlocks = function () {\n        this.getBlocksInOrder().forEach(function (block) {\n            block.refresh();\n        });\n        this.lastRowIndexKnown = false;\n        this.rowNodeBlockLoader.checkBlockToLoad();\n    };\n    PartialStore.prototype.resetStore = function () {\n        this.destroyAllBlocks();\n        this.lastRowIndexKnown = false;\n        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n        // otherwise if set to zero rows last time, and we don't update the row count, then after\n        // the purge there will still be zero rows, meaning the SSRM won't request any rows.\n        // to kick things off, at least one row needs to be asked for.\n        if (this.rowCount === 0) {\n            this.rowCount = PartialStore.INITIAL_ROW_COUNT;\n        }\n    };\n    PartialStore.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n        var result = [];\n        var lastBlockId = -1;\n        var inActiveRange = false;\n        // if only one node passed, we start the selection at the top\n        if (agGridCommunity._.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n        var foundGapInSelection = false;\n        this.getBlocksInOrder().forEach(function (block) {\n            if (foundGapInSelection) {\n                return;\n            }\n            if (inActiveRange && (lastBlockId + 1 !== block.getId())) {\n                foundGapInSelection = true;\n                return;\n            }\n            lastBlockId = block.getId();\n            block.forEachNodeShallow(function (rowNode) {\n                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n            });\n        });\n        // inActiveRange will be still true if we never hit the second rowNode\n        var invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    };\n    PartialStore.prototype.findBlockAndExecute = function (matchBlockFunc, blockFoundFunc, blockNotFoundFunc) {\n        var blockFound = false;\n        var breakSearch = false;\n        var lastBlock = null;\n        var res;\n        this.getBlocksInOrder().forEach(function (block) {\n            if (blockFound || breakSearch) {\n                return;\n            }\n            var comparatorResult = matchBlockFunc(block);\n            if (comparatorResult == FindResult.FOUND) {\n                res = blockFoundFunc(block);\n                blockFound = true;\n            }\n            else if (comparatorResult == FindResult.CONTINUE_FIND) {\n                lastBlock = block;\n            }\n            else if (comparatorResult == FindResult.BREAK_FIND) {\n                breakSearch = true;\n            }\n        });\n        if (!blockFound) {\n            res = blockNotFoundFunc(lastBlock);\n        }\n        return res;\n    };\n    PartialStore.prototype.getRowBounds = function (index) {\n        var _this = this;\n        var matchBlockFunc = function (block) {\n            if (block.isDisplayIndexInBlock(index)) {\n                return FindResult.FOUND;\n            }\n            else {\n                return block.isBlockBefore(index) ? FindResult.CONTINUE_FIND : FindResult.BREAK_FIND;\n            }\n        };\n        var blockFoundFunc = function (foundBlock) {\n            return foundBlock.getRowBounds(index);\n        };\n        var blockNotFoundFunc = function (previousBlock) {\n            var nextRowTop;\n            var nextRowIndex;\n            if (previousBlock !== null) {\n                nextRowTop = previousBlock.getBlockTopPx() + previousBlock.getBlockHeightPx();\n                nextRowIndex = previousBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = _this.cacheTopPixel;\n                nextRowIndex = _this.displayIndexStart;\n            }\n            var rowsBetween = index - nextRowIndex;\n            return {\n                rowHeight: _this.defaultRowHeight,\n                rowTop: nextRowTop + rowsBetween * _this.defaultRowHeight\n            };\n        };\n        return this.findBlockAndExecute(matchBlockFunc, blockFoundFunc, blockNotFoundFunc);\n    };\n    PartialStore.prototype.getRowIndexAtPixel = function (pixel) {\n        var _this = this;\n        var matchBlockFunc = function (block) {\n            if (block.isPixelInRange(pixel)) {\n                return FindResult.FOUND;\n            }\n            else {\n                return block.getBlockTopPx() < pixel ? FindResult.CONTINUE_FIND : FindResult.BREAK_FIND;\n            }\n        };\n        var blockFoundFunc = function (foundBlock) {\n            return foundBlock.getRowIndexAtPixel(pixel);\n        };\n        var blockNotFoundFunc = function (previousBlock) {\n            var nextRowTop;\n            var nextRowIndex;\n            if (previousBlock) {\n                nextRowTop = previousBlock.getBlockTopPx() + previousBlock.getBlockHeightPx();\n                nextRowIndex = previousBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = _this.cacheTopPixel;\n                nextRowIndex = _this.displayIndexStart;\n            }\n            var pixelsBetween = pixel - nextRowTop;\n            var rowsBetween = (pixelsBetween / _this.defaultRowHeight) | 0;\n            return nextRowIndex + rowsBetween;\n        };\n        var result = this.findBlockAndExecute(matchBlockFunc, blockFoundFunc, blockNotFoundFunc);\n        var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n        result = Math.min(result, lastAllowedIndex);\n        return result;\n    };\n    PartialStore.prototype.clearDisplayIndexes = function () {\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.getBlocksInOrder().forEach(function (block) { return block.clearDisplayIndexes(); });\n    };\n    PartialStore.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.cacheTopPixel = nextRowTop.value;\n        var lastBlockId = -1;\n        var blockSize = this.storeParams.cacheBlockSize;\n        this.getBlocksInOrder().forEach(function (currentBlock) {\n            // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n            // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n            // the cache if any row nodes are open.\n            var blockId = currentBlock.getId();\n            var blocksSkippedCount = blockId - lastBlockId - 1;\n            var rowsSkippedCount = blocksSkippedCount * blockSize;\n            if (rowsSkippedCount > 0) {\n                displayIndexSeq.skip(rowsSkippedCount);\n            }\n            for (var i = 1; i <= blocksSkippedCount; i++) {\n                var blockToAddId = blockId - i;\n                if (agGridCommunity._.exists(_this.blockHeights[blockToAddId])) {\n                    nextRowTop.value += _this.blockHeights[blockToAddId];\n                }\n                else {\n                    nextRowTop.value += blockSize * _this.defaultRowHeight;\n                }\n            }\n            lastBlockId = blockId;\n            currentBlock.setDisplayIndexes(displayIndexSeq, nextRowTop);\n            _this.blockHeights[blockId] = currentBlock.getBlockHeightPx();\n        });\n        // if any blocks missing at the end, need to increase the row index for them also\n        // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n        // last row was ejected from cache), then:\n        // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n        var lastVisitedRow = ((lastBlockId + 1) * blockSize) - 1;\n        var rowCount = this.getRowCount();\n        var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n        if (rowsNotAccountedFor > 0) {\n            displayIndexSeq.skip(rowsNotAccountedFor);\n            nextRowTop.value += rowsNotAccountedFor * this.defaultRowHeight;\n        }\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.cacheHeightPixels = nextRowTop.value - this.cacheTopPixel;\n    };\n    // gets called in a) init() above and b) by the grid\n    PartialStore.prototype.getRowUsingDisplayIndex = function (displayRowIndex, dontCreateBlock) {\n        var _this = this;\n        if (dontCreateBlock === void 0) { dontCreateBlock = false; }\n        // this can happen if asking for a row that doesn't exist in the model,\n        // eg if a cell range is selected, and the user filters so rows no longer exists\n        if (!this.isDisplayIndexInStore(displayRowIndex)) {\n            return null;\n        }\n        var matchBlockFunc = function (block) {\n            if (block.isDisplayIndexInBlock(displayRowIndex)) {\n                return FindResult.FOUND;\n            }\n            else {\n                return block.isBlockBefore(displayRowIndex) ? FindResult.CONTINUE_FIND : FindResult.BREAK_FIND;\n            }\n        };\n        var blockFoundFunc = function (foundBlock) {\n            return foundBlock.getRowUsingDisplayIndex(displayRowIndex);\n        };\n        var blockNotFoundFunc = function (previousBlock) {\n            if (dontCreateBlock) {\n                return;\n            }\n            var blockNumber;\n            var displayIndexStart;\n            var nextRowTop;\n            var blockSize = _this.storeParams.cacheBlockSize;\n            // because missing blocks are always fully closed, we can work out\n            // the start index of the block we want by hopping from the closest block,\n            // as we know the row count in closed blocks is equal to the page size\n            if (previousBlock) {\n                blockNumber = previousBlock.getId() + 1;\n                displayIndexStart = previousBlock.getDisplayIndexEnd();\n                nextRowTop = previousBlock.getBlockHeightPx() + previousBlock.getBlockTopPx();\n                var isInRange = function () {\n                    return displayRowIndex >= displayIndexStart && displayRowIndex < (displayIndexStart + blockSize);\n                };\n                while (!isInRange()) {\n                    displayIndexStart += blockSize;\n                    var cachedBlockHeight = _this.blockHeights[blockNumber];\n                    if (agGridCommunity._.exists(cachedBlockHeight)) {\n                        nextRowTop += cachedBlockHeight;\n                    }\n                    else {\n                        nextRowTop += _this.defaultRowHeight * blockSize;\n                    }\n                    blockNumber++;\n                }\n            }\n            else {\n                var localIndex = displayRowIndex - _this.displayIndexStart;\n                blockNumber = Math.floor(localIndex / blockSize);\n                displayIndexStart = _this.displayIndexStart + (blockNumber * blockSize);\n                nextRowTop = _this.cacheTopPixel + (blockNumber * blockSize * _this.defaultRowHeight);\n            }\n            _this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart);\n            var newBlock = _this.createBlock(blockNumber, displayIndexStart, { value: nextRowTop });\n            return newBlock.getRowUsingDisplayIndex(displayRowIndex);\n        };\n        return this.findBlockAndExecute(matchBlockFunc, blockFoundFunc, blockNotFoundFunc);\n    };\n    PartialStore.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var blockSize = this.storeParams.cacheBlockSize;\n        var blockId = Math.floor(topLevelIndex / blockSize);\n        var matchBlockFunc = function (block) {\n            if (block.getId() === blockId) {\n                return FindResult.FOUND;\n            }\n            return block.getId() < blockId ? FindResult.CONTINUE_FIND : FindResult.BREAK_FIND;\n        };\n        var blockFoundFunc = function (foundBlock) {\n            var rowNode = foundBlock.getRowUsingLocalIndex(topLevelIndex);\n            return rowNode.rowIndex;\n        };\n        var blockNotFoundFunc = function (previousBlock) {\n            if (!previousBlock) {\n                return topLevelIndex;\n            }\n            // note: the local index is the same as the top level index, two terms for same thing\n            //\n            // get index of the last row before this row\n            // eg if blocksize = 100, then:\n            //   last row of first block is 99 (100 * 1) -1;\n            //   last row of second block is 199 (100 * 2) -1;\n            var lastRowTopLevelIndex = (blockSize * (previousBlock.getId() + 1)) - 1;\n            // get the last top level node in the block before the wanted block. this will be the last\n            // loaded displayed top level node.\n            var lastRowNode = previousBlock.getRowUsingLocalIndex(lastRowTopLevelIndex);\n            // we want the index of the last displayed node, not just the top level node, so if the last top level node\n            // is open, we get the index of the last displayed child node.\n            var lastDisplayedNodeIndexInBlockBefore;\n            if (lastRowNode.expanded && lastRowNode.childStore) {\n                var serverSideCache = lastRowNode.childStore;\n                lastDisplayedNodeIndexInBlockBefore = serverSideCache.getDisplayIndexEnd() - 1;\n            }\n            else if (lastRowNode.expanded && lastRowNode.detailNode) {\n                lastDisplayedNodeIndexInBlockBefore = lastRowNode.detailNode.rowIndex;\n            }\n            else {\n                lastDisplayedNodeIndexInBlockBefore = lastRowNode.rowIndex;\n            }\n            // we are guaranteed no rows are open. so the difference between the topTopIndex will be the\n            // same as the difference between the displayed index\n            var indexDiff = topLevelIndex - lastRowTopLevelIndex;\n            return lastDisplayedNodeIndexInBlockBefore + indexDiff;\n        };\n        return this.findBlockAndExecute(matchBlockFunc, blockFoundFunc, blockNotFoundFunc);\n    };\n    PartialStore.prototype.addStoreStates = function (result) {\n        result.push({\n            type: agGridCommunity.ServerSideStoreType.Partial,\n            route: this.storeUtils.createGroupKeys(this.parentRowNode),\n            rowCount: this.rowCount,\n            lastRowIndexKnown: this.lastRowIndexKnown,\n            info: this.info,\n            maxBlocksInCache: this.storeParams.maxBlocksInCache,\n            cacheBlockSize: this.storeParams.cacheBlockSize\n        });\n        this.forEachChildStoreShallow(function (childStore) { return childStore.addStoreStates(result); });\n    };\n    PartialStore.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n        var block = this.createBean(new PartialStoreBlock(blockNumber, this.parentRowNode, this.ssrmParams, this.storeParams, this));\n        block.setDisplayIndexes(new agGridCommunity.NumberSequence(displayIndex), nextRowTop);\n        this.blocks[block.getId()] = block;\n        this.blockCount++;\n        this.purgeBlocksIfNeeded(block);\n        this.rowNodeBlockLoader.addBlock(block);\n        return block;\n    };\n    PartialStore.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    PartialStore.prototype.isDisplayIndexInStore = function (displayIndex) {\n        if (this.getRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    PartialStore.prototype.applyTransaction = function (transaction) {\n        return { status: agGridCommunity.ServerSideTransactionResultStatus.StoreWrongType };\n    };\n    PartialStore.prototype.getChildStore = function (keys) {\n        var _this = this;\n        var findNodeCallback = function (key) {\n            var nextNode = null;\n            _this.getBlocksInOrder().forEach(function (block) {\n                block.forEachNodeShallow(function (rowNode) {\n                    if (rowNode.key === key) {\n                        nextNode = rowNode;\n                    }\n                }, new agGridCommunity.NumberSequence());\n            });\n            return nextNode;\n        };\n        return this.storeUtils.getChildStore(keys, this, findNodeCallback);\n    };\n    PartialStore.prototype.isPixelInRange = function (pixel) {\n        if (this.getRowCount() === 0) {\n            return false;\n        }\n        return pixel >= this.cacheTopPixel && pixel < (this.cacheTopPixel + this.cacheHeightPixels);\n    };\n    PartialStore.prototype.refreshAfterFilter = function (params) {\n        this.resetStore();\n    };\n    PartialStore.prototype.refreshAfterSort = function (params) {\n        if (this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {\n            this.resetStore();\n            return;\n        }\n        // call refreshAfterSort on children, as we did not purge.\n        // if we did purge, no need to do this as all children were destroyed\n        this.forEachChildStoreShallow(function (store) { return store.refreshAfterSort(params); });\n    };\n    PartialStore.prototype.forEachChildStoreShallow = function (callback) {\n        this.getBlocksInOrder().forEach(function (block) {\n            if (block.isGroupLevel()) {\n                var innerCallback = function (rowNode) {\n                    var nextCache = rowNode.childStore;\n                    if (nextCache) {\n                        callback(nextCache);\n                    }\n                };\n                block.forEachNodeShallow(innerCallback, new agGridCommunity.NumberSequence());\n            }\n        });\n    };\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    PartialStore.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n    PartialStore.INITIAL_ROW_COUNT = 1;\n    PartialStore.OVERFLOW_SIZE = 1;\n    __decorate$1L([\n        agGridCommunity.Autowired('rowRenderer')\n    ], PartialStore.prototype, \"rowRenderer\", void 0);\n    __decorate$1L([\n        agGridCommunity.Autowired('rowNodeBlockLoader')\n    ], PartialStore.prototype, \"rowNodeBlockLoader\", void 0);\n    __decorate$1L([\n        agGridCommunity.Autowired('ssrmCacheUtils')\n    ], PartialStore.prototype, \"storeUtils\", void 0);\n    __decorate$1L([\n        agGridCommunity.Autowired('columnController')\n    ], PartialStore.prototype, \"columnController\", void 0);\n    __decorate$1L([\n        agGridCommunity.Autowired(\"focusController\")\n    ], PartialStore.prototype, \"focusController\", void 0);\n    __decorate$1L([\n        agGridCommunity.PostConstruct\n    ], PartialStore.prototype, \"postConstruct\", null);\n    __decorate$1L([\n        agGridCommunity.PreDestroy\n    ], PartialStore.prototype, \"destroyAllBlocks\", null);\n    __decorate$1L([\n        __param$2(0, agGridCommunity.Qualifier('loggerFactory'))\n    ], PartialStore.prototype, \"setBeans\", null);\n    return PartialStore;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2V = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FullStore = /** @class */ (function (_super) {\n    __extends$2V(FullStore, _super);\n    function FullStore(ssrmParams, storeParams, parentRowNode) {\n        var _this = \n        // finite block represents a cache with just one block, thus 0 is the id, it's the first block\n        _super.call(this, 0) || this;\n        _this.nodeIdSequence = new agGridCommunity.NumberSequence();\n        _this.info = {};\n        _this.ssrmParams = ssrmParams;\n        _this.storeParams = storeParams;\n        _this.parentRowNode = parentRowNode;\n        _this.level = parentRowNode.level + 1;\n        _this.groupLevel = ssrmParams.rowGroupCols ? _this.level < ssrmParams.rowGroupCols.length : undefined;\n        _this.leafGroup = ssrmParams.rowGroupCols ? _this.level === ssrmParams.rowGroupCols.length - 1 : false;\n        return _this;\n    }\n    FullStore.prototype.postConstruct = function () {\n        var _this = this;\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        this.usingMasterDetail = this.gridOptionsWrapper.isMasterDetail();\n        this.nodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.parentRowNode);\n        if (!this.usingTreeData && this.groupLevel) {\n            var groupColVo = this.ssrmParams.rowGroupCols[this.level];\n            this.groupField = groupColVo.field;\n            this.rowGroupColumn = this.columnController.getRowGroupColumns()[this.level];\n        }\n        this.initialiseRowNodes();\n        this.rowNodeBlockLoader.addBlock(this);\n        this.addDestroyFunc(function () { return _this.rowNodeBlockLoader.removeBlock(_this); });\n    };\n    FullStore.prototype.destroyRowNodes = function () {\n        this.blockUtils.destroyRowNodes(this.allRowNodes);\n        this.allRowNodes = [];\n        this.nodesAfterSort = [];\n        this.nodesAfterFilter = [];\n        this.allNodesMap = {};\n    };\n    FullStore.prototype.initialiseRowNodes = function (loadingRowsCount, failedLoad) {\n        if (loadingRowsCount === void 0) { loadingRowsCount = 1; }\n        if (failedLoad === void 0) { failedLoad = false; }\n        this.destroyRowNodes();\n        for (var i = 0; i < loadingRowsCount; i++) {\n            var loadingRowNode = this.blockUtils.createRowNode({ field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,\n                level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn });\n            if (failedLoad) {\n                loadingRowNode.failedLoad = true;\n            }\n            this.allRowNodes.push(loadingRowNode);\n            this.nodesAfterFilter.push(loadingRowNode);\n            this.nodesAfterSort.push(loadingRowNode);\n        }\n    };\n    FullStore.prototype.getBlockStateJson = function () {\n        return {\n            id: this.nodeIdPrefix ? this.nodeIdPrefix : '',\n            state: this.getState()\n        };\n    };\n    FullStore.prototype.loadFromDatasource = function () {\n        this.storeUtils.loadFromDatasource({\n            startRow: undefined,\n            endRow: undefined,\n            parentNode: this.parentRowNode,\n            storeParams: this.ssrmParams,\n            successCallback: this.pageLoaded.bind(this, this.getVersion()),\n            success: this.success.bind(this, this.getVersion()),\n            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n            fail: this.pageLoadFailed.bind(this, this.getVersion())\n        });\n    };\n    FullStore.prototype.getStartRow = function () {\n        return 0; // always zero as not in a cache\n    };\n    FullStore.prototype.getEndRow = function () {\n        return this.nodesAfterSort.length;\n    };\n    FullStore.prototype.createDataNode = function (data, index) {\n        var rowNode = this.blockUtils.createRowNode({ field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,\n            level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn });\n        if (index != null) {\n            agGridCommunity._.insertIntoArray(this.allRowNodes, rowNode, index);\n        }\n        else {\n            this.allRowNodes.push(rowNode);\n        }\n        var defaultId = this.prefixId(this.nodeIdSequence.next());\n        this.blockUtils.setDataIntoRowNode(rowNode, data, defaultId);\n        this.nodeManager.addRowNode(rowNode);\n        this.blockUtils.checkOpenByDefault(rowNode);\n        this.allNodesMap[rowNode.id] = rowNode;\n        return rowNode;\n    };\n    FullStore.prototype.prefixId = function (id) {\n        if (this.nodeIdPrefix) {\n            return this.nodeIdPrefix + '-' + id;\n        }\n        else {\n            return id.toString();\n        }\n    };\n    FullStore.prototype.processServerFail = function () {\n        this.initialiseRowNodes(1, true);\n        this.fireStoreUpdatedEvent();\n        this.flushAsyncTransactions();\n    };\n    FullStore.prototype.processServerResult = function (params) {\n        if (!this.isAlive()) {\n            return;\n        }\n        if (params.storeInfo) {\n            agGridCommunity._.assign(this.info, params.storeInfo);\n        }\n        var nodesToRecycle = this.allRowNodes.length > 0 ? this.allNodesMap : undefined;\n        this.allRowNodes = [];\n        this.nodesAfterSort = [];\n        this.nodesAfterFilter = [];\n        this.allNodesMap = {};\n        if (!params.rowData) {\n            var message_1 = 'AG Grid: \"params.data\" is missing from Server-Side Row Model success() callback. Please use the \"data\" attribute. If no data is returned, set an empty list.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_1, params); }, 'FullStore.noData');\n        }\n        this.createOrRecycleNodes(nodesToRecycle, params.rowData);\n        if (nodesToRecycle) {\n            this.blockUtils.destroyRowNodes(agGridCommunity._.getAllValuesInObject(nodesToRecycle));\n        }\n        this.filterAndSortNodes();\n        this.fireStoreUpdatedEvent();\n        this.flushAsyncTransactions();\n    };\n    FullStore.prototype.createOrRecycleNodes = function (nodesToRecycle, rowData) {\n        var _this = this;\n        if (!rowData) {\n            return;\n        }\n        var lookupNodeToRecycle = function (dataItem) {\n            if (!nodesToRecycle) {\n                return undefined;\n            }\n            var userIdFunc = _this.gridOptionsWrapper.getRowNodeIdFunc();\n            if (!userIdFunc) {\n                return undefined;\n            }\n            var id = userIdFunc(dataItem);\n            var foundNode = nodesToRecycle[id];\n            if (!foundNode) {\n                return undefined;\n            }\n            delete nodesToRecycle[id];\n            return foundNode;\n        };\n        var recycleNode = function (rowNode, dataItem) {\n            _this.allNodesMap[rowNode.id] = rowNode;\n            rowNode.updateData(dataItem);\n            _this.allRowNodes.push(rowNode);\n        };\n        rowData.forEach(function (dataItem) {\n            var nodeToRecycle = lookupNodeToRecycle(dataItem);\n            if (nodeToRecycle) {\n                recycleNode(nodeToRecycle, dataItem);\n            }\n            else {\n                _this.createDataNode(dataItem);\n            }\n        });\n    };\n    FullStore.prototype.flushAsyncTransactions = function () {\n        var _this = this;\n        // we want to update the store with any outstanding transactions straight away,\n        // as otherwise if waitTimeMillis is large (eg 5s), then the user could be looking\n        // at old data for a few seconds before the transactions is applied, which isn't what\n        // you would expect when we advertise 'transaction is applied when data is loaded'.\n        // we do this in a timeout as flushAsyncTransactions expects the grid to be in a settled\n        // state, not in the middle of loading rows! keeps the VM Turns more simple and deterministic.\n        window.setTimeout(function () { return _this.transactionManager.flushAsyncTransactions(); }, 0);\n    };\n    FullStore.prototype.filterAndSortNodes = function () {\n        this.filterRowNodes();\n        this.sortRowNodes();\n    };\n    FullStore.prototype.sortRowNodes = function () {\n        var sortOptions = this.sortController.getSortOptions();\n        var noSortApplied = !sortOptions || sortOptions.length == 0;\n        if (noSortApplied) {\n            this.nodesAfterSort = this.nodesAfterFilter;\n            return;\n        }\n        this.nodesAfterSort = this.rowNodeSorter.doFullSort(this.nodesAfterFilter, sortOptions);\n    };\n    FullStore.prototype.filterRowNodes = function () {\n        var _this = this;\n        // filtering for InFullStore only words at lowest level details.\n        // reason is the logic for group filtering was to difficult to work out how it should work at time of writing.\n        if (this.groupLevel) {\n            this.nodesAfterFilter = this.allRowNodes;\n            return;\n        }\n        this.nodesAfterFilter = this.allRowNodes.filter(function (rowNode) { return _this.filterManager.doesRowPassFilter({ rowNode: rowNode }); });\n    };\n    FullStore.prototype.clearDisplayIndexes = function () {\n        var _this = this;\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.allRowNodes.forEach(function (rowNode) { return _this.blockUtils.clearDisplayIndex(rowNode); });\n    };\n    FullStore.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    FullStore.prototype.isDisplayIndexInStore = function (displayIndex) {\n        if (this.getRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    FullStore.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.topPx = nextRowTop.value;\n        var visibleNodeIds = {};\n        // set on all visible nodes\n        this.nodesAfterSort.forEach(function (rowNode) {\n            _this.blockUtils.setDisplayIndex(rowNode, displayIndexSeq, nextRowTop);\n            visibleNodeIds[rowNode.id] = true;\n        });\n        // and clear on all non-visible nodes\n        this.allRowNodes.forEach(function (rowNode) {\n            if (!visibleNodeIds[rowNode.id]) {\n                _this.blockUtils.clearDisplayIndex(rowNode);\n            }\n        });\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.heightPx = nextRowTop.value - this.topPx;\n    };\n    FullStore.prototype.forEachNodeDeep = function (callback, sequence) {\n        if (sequence === void 0) { sequence = new agGridCommunity.NumberSequence(); }\n        this.allRowNodes.forEach(function (rowNode) {\n            callback(rowNode, sequence.next());\n            var childCache = rowNode.childStore;\n            if (childCache) {\n                childCache.forEachNodeDeep(callback, sequence);\n            }\n        });\n    };\n    FullStore.prototype.getRowUsingDisplayIndex = function (displayRowIndex) {\n        var res = this.blockUtils.binarySearchForDisplayIndex(displayRowIndex, this.nodesAfterSort);\n        return res;\n    };\n    FullStore.prototype.getRowBounds = function (index) {\n        for (var i = 0; i < this.nodesAfterSort.length; i++) {\n            var rowNode = this.nodesAfterSort[i];\n            var res = this.blockUtils.extractRowBounds(rowNode, index);\n            if (res) {\n                return res;\n            }\n        }\n        return null;\n    };\n    FullStore.prototype.isPixelInRange = function (pixel) {\n        return pixel >= this.topPx && pixel < (this.topPx + this.heightPx);\n    };\n    FullStore.prototype.getRowIndexAtPixel = function (pixel) {\n        var _this = this;\n        // if pixel before block, return first row\n        var pixelBeforeThisStore = pixel <= this.topPx;\n        if (pixelBeforeThisStore) {\n            return this.nodesAfterSort[0].rowIndex;\n        }\n        // if pixel after store, return last row, however the last\n        // row could be a child store\n        var pixelAfterThisStore = pixel >= (this.topPx + this.heightPx);\n        if (pixelAfterThisStore) {\n            var lastRowNode = this.nodesAfterSort[this.nodesAfterSort.length - 1];\n            var lastRowNodeBottomPx = lastRowNode.rowTop + lastRowNode.rowHeight;\n            if (pixel >= lastRowNodeBottomPx && lastRowNode.expanded && lastRowNode.childStore) {\n                return lastRowNode.childStore.getRowIndexAtPixel(pixel);\n            }\n            return lastRowNode.rowIndex;\n        }\n        var res = null;\n        this.nodesAfterSort.forEach(function (rowNode) {\n            var res2 = _this.blockUtils.getIndexAtPixel(rowNode, pixel);\n            if (res2 != null) {\n                res = res2;\n            }\n        });\n        var pixelIsPastLastRow = res == null;\n        if (pixelIsPastLastRow) {\n            return this.displayIndexEnd - 1;\n        }\n        return res;\n    };\n    FullStore.prototype.getChildStore = function (keys) {\n        var _this = this;\n        return this.storeUtils.getChildStore(keys, this, function (key) {\n            var rowNode = agGridCommunity._.find(_this.allRowNodes, function (currentRowNode) { return currentRowNode.key === key; });\n            return rowNode;\n        });\n    };\n    FullStore.prototype.forEachChildStoreShallow = function (callback) {\n        this.allRowNodes.forEach(function (rowNode) {\n            var childStore = rowNode.childStore;\n            if (childStore) {\n                callback(childStore);\n            }\n        });\n    };\n    FullStore.prototype.refreshAfterFilter = function (params) {\n        if (params.alwaysReset || this.gridOptionsWrapper.isTreeData()) {\n            this.refreshStore(true);\n            return;\n        }\n        this.filterAndSortNodes();\n        this.forEachChildStoreShallow(function (store) { return store.refreshAfterFilter(params); });\n    };\n    FullStore.prototype.refreshAfterSort = function (params) {\n        if (params.alwaysReset) {\n            this.refreshStore(true);\n            return;\n        }\n        this.sortRowNodes();\n        this.forEachChildStoreShallow(function (store) { return store.refreshAfterSort(params); });\n    };\n    FullStore.prototype.applyTransaction = function (transaction) {\n        // we only apply transactions to loaded state\n        switch (this.getState()) {\n            case agGridCommunity.RowNodeBlock.STATE_FAILED:\n                return { status: agGridCommunity.ServerSideTransactionResultStatus.StoreLoadingFailed };\n            case agGridCommunity.RowNodeBlock.STATE_LOADING:\n                return { status: agGridCommunity.ServerSideTransactionResultStatus.StoreLoading };\n            case agGridCommunity.RowNodeBlock.STATE_WAITING_TO_LOAD:\n                return { status: agGridCommunity.ServerSideTransactionResultStatus.StoreWaitingToLoad };\n        }\n        var applyCallback = this.gridOptionsWrapper.getIsApplyServerSideTransactionFunc();\n        if (applyCallback) {\n            var params = {\n                transaction: transaction,\n                parentNode: this.parentRowNode,\n                storeInfo: this.info\n            };\n            var apply = applyCallback(params);\n            if (!apply) {\n                return { status: agGridCommunity.ServerSideTransactionResultStatus.Cancelled };\n            }\n        }\n        var res = {\n            status: agGridCommunity.ServerSideTransactionResultStatus.Applied,\n            remove: [],\n            update: [],\n            add: []\n        };\n        var nodesToUnselect = [];\n        this.executeAdd(transaction, res);\n        this.executeRemove(transaction, res, nodesToUnselect);\n        this.executeUpdate(transaction, res, nodesToUnselect);\n        this.filterAndSortNodes();\n        this.updateSelection(nodesToUnselect);\n        return res;\n    };\n    FullStore.prototype.updateSelection = function (nodesToUnselect) {\n        var selectionChanged = nodesToUnselect.length > 0;\n        if (selectionChanged) {\n            nodesToUnselect.forEach(function (rowNode) {\n                rowNode.setSelected(false, false, true);\n            });\n            var event_1 = {\n                type: agGridCommunity.Events.EVENT_SELECTION_CHANGED,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi()\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n    };\n    FullStore.prototype.executeAdd = function (rowDataTran, rowNodeTransaction) {\n        var _this = this;\n        var add = rowDataTran.add, addIndex = rowDataTran.addIndex;\n        if (agGridCommunity._.missingOrEmpty(add)) {\n            return;\n        }\n        var useIndex = typeof addIndex === 'number' && addIndex >= 0;\n        if (useIndex) {\n            // items get inserted in reverse order for index insertion\n            add.reverse().forEach(function (item) {\n                var newRowNode = _this.createDataNode(item, addIndex);\n                rowNodeTransaction.add.push(newRowNode);\n            });\n        }\n        else {\n            add.forEach(function (item) {\n                var newRowNode = _this.createDataNode(item);\n                rowNodeTransaction.add.push(newRowNode);\n            });\n        }\n    };\n    FullStore.prototype.executeRemove = function (rowDataTran, rowNodeTransaction, nodesToUnselect) {\n        var _this = this;\n        var remove = rowDataTran.remove;\n        if (remove == null) {\n            return;\n        }\n        var rowIdsRemoved = {};\n        remove.forEach(function (item) {\n            var rowNode = _this.lookupRowNode(item);\n            if (!rowNode) {\n                return;\n            }\n            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n            if (rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n            // so row renderer knows to fade row out (and not reposition it)\n            rowNode.clearRowTopAndRowIndex();\n            // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially\n            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n            rowIdsRemoved[rowNode.id] = true;\n            // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n            delete _this.allNodesMap[rowNode.id];\n            rowNodeTransaction.remove.push(rowNode);\n        });\n        this.allRowNodes = this.allRowNodes.filter(function (rowNode) { return !rowIdsRemoved[rowNode.id]; });\n    };\n    FullStore.prototype.executeUpdate = function (rowDataTran, rowNodeTransaction, nodesToUnselect) {\n        var _this = this;\n        var update = rowDataTran.update;\n        if (update == null) {\n            return;\n        }\n        update.forEach(function (item) {\n            var rowNode = _this.lookupRowNode(item);\n            if (!rowNode) {\n                return;\n            }\n            rowNode.updateData(item);\n            if (!rowNode.selectable && rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n            rowNodeTransaction.update.push(rowNode);\n        });\n    };\n    FullStore.prototype.lookupRowNode = function (data) {\n        var rowNodeIdFunc = this.gridOptionsWrapper.getRowNodeIdFunc();\n        var rowNode;\n        if (agGridCommunity._.exists(rowNodeIdFunc)) {\n            // find rowNode using id\n            var id = rowNodeIdFunc(data);\n            rowNode = this.allNodesMap[id];\n            if (!rowNode) {\n                console.error(\"AG Grid: could not find row id=\" + id + \", data item was not found for this id\");\n                return null;\n            }\n        }\n        else {\n            // find rowNode using object references\n            rowNode = agGridCommunity._.find(this.allRowNodes, function (currentRowNode) { return currentRowNode.data === data; });\n            if (!rowNode) {\n                console.error(\"AG Grid: could not find data item as object was not found\", data);\n                return null;\n            }\n        }\n        return rowNode;\n    };\n    FullStore.prototype.addStoreStates = function (result) {\n        result.push({\n            type: agGridCommunity.ServerSideStoreType.Full,\n            route: this.storeUtils.createGroupKeys(this.parentRowNode),\n            rowCount: this.allRowNodes.length,\n            info: this.info\n        });\n        this.forEachChildStoreShallow(function (childStore) { return childStore.addStoreStates(result); });\n    };\n    FullStore.prototype.refreshStore = function (purge) {\n        if (purge) {\n            var loadingRowsToShow = this.nodesAfterSort ? this.nodesAfterSort.length : 1;\n            this.initialiseRowNodes(loadingRowsToShow);\n        }\n        this.scheduleLoad();\n        this.fireStoreUpdatedEvent();\n    };\n    FullStore.prototype.retryLoads = function () {\n        if (this.getState() === agGridCommunity.RowNodeBlock.STATE_FAILED) {\n            this.initialiseRowNodes(1);\n            this.scheduleLoad();\n        }\n        this.forEachChildStoreShallow(function (store) { return store.retryLoads(); });\n    };\n    FullStore.prototype.scheduleLoad = function () {\n        this.setStateWaitingToLoad();\n        this.rowNodeBlockLoader.checkBlockToLoad();\n    };\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    FullStore.prototype.fireStoreUpdatedEvent = function () {\n        // this results in row model firing ModelUpdated.\n        // server side row model also updates the row indexes first\n        var event = {\n            type: agGridCommunity.Events.EVENT_STORE_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    FullStore.prototype.getRowCount = function () {\n        return this.nodesAfterSort.length;\n    };\n    FullStore.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var rowNode = this.nodesAfterSort[topLevelIndex];\n        return rowNode.rowIndex;\n    };\n    FullStore.prototype.isLastRowIndexKnown = function () {\n        return this.getState() == agGridCommunity.RowNodeBlock.STATE_LOADED;\n    };\n    FullStore.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n        var result = [];\n        var inActiveRange = false;\n        // if only one node passed, we start the selection at the top\n        if (agGridCommunity._.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n        this.nodesAfterSort.forEach(function (rowNode) {\n            var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n            if (inActiveRange || hitFirstOrLast) {\n                result.push(rowNode);\n            }\n            if (hitFirstOrLast) {\n                inActiveRange = !inActiveRange;\n            }\n        });\n        // inActiveRange will be still true if we never hit the second rowNode\n        var invalidRange = inActiveRange;\n        return invalidRange ? [] : result;\n    };\n    __decorate$1M([\n        agGridCommunity.Autowired('ssrmCacheUtils')\n    ], FullStore.prototype, \"storeUtils\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('ssrmBlockUtils')\n    ], FullStore.prototype, \"blockUtils\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('columnController')\n    ], FullStore.prototype, \"columnController\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('rowRenderer')\n    ], FullStore.prototype, \"rowRenderer\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('rowNodeBlockLoader')\n    ], FullStore.prototype, \"rowNodeBlockLoader\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('rowNodeSorter')\n    ], FullStore.prototype, \"rowNodeSorter\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('sortController')\n    ], FullStore.prototype, \"sortController\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('ssrmNodeManager')\n    ], FullStore.prototype, \"nodeManager\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('filterManager')\n    ], FullStore.prototype, \"filterManager\", void 0);\n    __decorate$1M([\n        agGridCommunity.Autowired('ssrmTransactionManager')\n    ], FullStore.prototype, \"transactionManager\", void 0);\n    __decorate$1M([\n        agGridCommunity.PostConstruct\n    ], FullStore.prototype, \"postConstruct\", null);\n    __decorate$1M([\n        agGridCommunity.PreDestroy\n    ], FullStore.prototype, \"destroyRowNodes\", null);\n    return FullStore;\n}(agGridCommunity.RowNodeBlock));\n\nvar __decorate$1N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar StoreFactory = /** @class */ (function () {\n    function StoreFactory() {\n    }\n    StoreFactory.prototype.createStore = function (ssrmParams, parentNode) {\n        var storeParams = this.getStoreParams(ssrmParams, parentNode);\n        var CacheClass = storeParams.storeType === agGridCommunity.ServerSideStoreType.Partial ? PartialStore : FullStore;\n        return new CacheClass(ssrmParams, storeParams, parentNode);\n    };\n    StoreFactory.prototype.getStoreParams = function (ssrmParams, parentNode) {\n        var userStoreParams = this.getLevelSpecificParams(parentNode);\n        // if user provided overrideParams, we take storeType from there if it exists\n        var storeType = this.getStoreType(userStoreParams);\n        var cacheBlockSize = this.getBlockSize(storeType, userStoreParams);\n        var maxBlocksInCache = this.getMaxBlocksInCache(storeType, ssrmParams, userStoreParams);\n        var storeParams = {\n            storeType: storeType,\n            cacheBlockSize: cacheBlockSize,\n            maxBlocksInCache: maxBlocksInCache\n        };\n        return storeParams;\n    };\n    StoreFactory.prototype.getMaxBlocksInCache = function (storeType, ssrmParams, userStoreParams) {\n        if (storeType == agGridCommunity.ServerSideStoreType.Full) {\n            return undefined;\n        }\n        var maxBlocksInCache = (userStoreParams && userStoreParams.maxBlocksInCache != null)\n            ? userStoreParams.maxBlocksInCache\n            : this.gridOptionsWrapper.getMaxBlocksInCache();\n        var maxBlocksActive = maxBlocksInCache != null && maxBlocksInCache >= 0;\n        if (!maxBlocksActive) {\n            return undefined;\n        }\n        if (ssrmParams.dynamicRowHeight) {\n            var message_1 = 'AG Grid: Server Side Row Model does not support Dynamic Row Height and Cache Purging. ' +\n                'Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_1); }, 'storeFactory.maxBlocksInCache.dynamicRowHeight');\n            return undefined;\n        }\n        if (this.columnController.isAutoRowHeightActive()) {\n            var message_2 = 'AG Grid: Server Side Row Model does not support Auto Row Height and Cache Purging. ' +\n                'Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_2); }, 'storeFactory.maxBlocksInCache.autoRowHeightActive');\n            return undefined;\n        }\n        return maxBlocksInCache;\n    };\n    StoreFactory.prototype.getBlockSize = function (storeType, userStoreParams) {\n        if (storeType == agGridCommunity.ServerSideStoreType.Full) {\n            return undefined;\n        }\n        var blockSize = (userStoreParams && userStoreParams.cacheBlockSize != null)\n            ? userStoreParams.cacheBlockSize\n            : this.gridOptionsWrapper.getCacheBlockSize();\n        if (blockSize != null && blockSize > 0) {\n            return blockSize;\n        }\n        else {\n            return 100;\n        }\n    };\n    StoreFactory.prototype.getLevelSpecificParams = function (parentNode) {\n        var callback = this.gridOptionsWrapper.getServerSideStoreParamsFunc();\n        if (!callback) {\n            return undefined;\n        }\n        var params = {\n            level: parentNode.level + 1,\n            parentRowNode: parentNode.level >= 0 ? parentNode : undefined,\n            rowGroupColumns: this.columnController.getRowGroupColumns(),\n            pivotColumns: this.columnController.getPivotColumns(),\n            pivotMode: this.columnController.isPivotMode()\n        };\n        return callback(params);\n    };\n    StoreFactory.prototype.getStoreType = function (storeParams) {\n        var storeType = (storeParams && storeParams.storeType != null)\n            ? storeParams.storeType\n            : this.gridOptionsWrapper.getServerSideStoreType();\n        switch (storeType) {\n            case agGridCommunity.ServerSideStoreType.Partial:\n            case agGridCommunity.ServerSideStoreType.Full:\n                return storeType;\n            case null:\n            case undefined:\n                return agGridCommunity.ServerSideStoreType.Full;\n            default:\n                var types = Object.keys(agGridCommunity.ServerSideStoreType).join(', ');\n                console.warn(\"AG Grid: invalid Server Side Store Type \" + storeType + \", valid types are [\" + types + \"]\");\n                return agGridCommunity.ServerSideStoreType.Partial;\n        }\n    };\n    __decorate$1N([\n        agGridCommunity.Autowired('gridOptionsWrapper')\n    ], StoreFactory.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate$1N([\n        agGridCommunity.Autowired('columnController')\n    ], StoreFactory.prototype, \"columnController\", void 0);\n    StoreFactory = __decorate$1N([\n        agGridCommunity.Bean('ssrmStoreFactory')\n    ], StoreFactory);\n    return StoreFactory;\n}());\n\nvar __decorate$1O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ListenerUtils = /** @class */ (function () {\n    function ListenerUtils() {\n    }\n    ListenerUtils.prototype.isSortingWithValueColumn = function (changedColumnsInSort) {\n        var valueColIds = this.columnController.getValueColumns().map(function (col) { return col.getColId(); });\n        for (var i = 0; i < changedColumnsInSort.length; i++) {\n            if (valueColIds.indexOf(changedColumnsInSort[i]) > -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    ListenerUtils.prototype.isSortingWithSecondaryColumn = function (changedColumnsInSort) {\n        if (!this.columnController.getSecondaryColumns()) {\n            return false;\n        }\n        var secondaryColIds = this.columnController.getSecondaryColumns().map(function (col) { return col.getColId(); });\n        for (var i = 0; i < changedColumnsInSort.length; i++) {\n            if (secondaryColIds.indexOf(changedColumnsInSort[i]) > -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    __decorate$1O([\n        agGridCommunity.Autowired('columnController')\n    ], ListenerUtils.prototype, \"columnController\", void 0);\n    ListenerUtils = __decorate$1O([\n        agGridCommunity.Bean('ssrmListenerUtils')\n    ], ListenerUtils);\n    return ListenerUtils;\n}());\n\nvar ServerSideRowModelModule = {\n    moduleName: agGridCommunity.ModuleNames.ServerSideRowModelModule,\n    rowModels: { serverSide: ServerSideRowModel },\n    beans: [ExpandListener, SortListener, StoreUtils, BlockUtils, NodeManager, TransactionManager,\n        FilterListener, StoreFactory, ListenerUtils],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar ClientSideValuesExtractor = /** @class */ (function () {\n    function ClientSideValuesExtractor(rowModel, colDef, valueGetter) {\n        this.rowModel = rowModel;\n        this.colDef = colDef;\n        this.valueGetter = valueGetter;\n    }\n    ClientSideValuesExtractor.prototype.extractUniqueValues = function (predicate) {\n        var _this = this;\n        var values = new Set();\n        var keyCreator = this.colDef.keyCreator;\n        this.rowModel.forEachLeafNode(function (node) {\n            // only pull values from rows that have data. this means we skip filler group nodes.\n            if (!node.data || !predicate(node)) {\n                return;\n            }\n            var value = _this.valueGetter(node);\n            if (keyCreator) {\n                value = keyCreator({ value: value });\n            }\n            value = agGridCommunity._.makeNull(value);\n            if (value != null && Array.isArray(value)) {\n                agGridCommunity._.forEach(value, function (x) {\n                    var formatted = agGridCommunity._.toStringOrNull(agGridCommunity._.makeNull(x));\n                    values.add(formatted);\n                });\n            }\n            else {\n                values.add(agGridCommunity._.toStringOrNull(value));\n            }\n        });\n        return agGridCommunity._.values(values);\n    };\n    return ClientSideValuesExtractor;\n}());\n\nvar SetFilterModelValuesType;\n(function (SetFilterModelValuesType) {\n    SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_LIST\"] = 0] = \"PROVIDED_LIST\";\n    SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_CALLBACK\"] = 1] = \"PROVIDED_CALLBACK\";\n    SetFilterModelValuesType[SetFilterModelValuesType[\"TAKEN_FROM_GRID_VALUES\"] = 2] = \"TAKEN_FROM_GRID_VALUES\";\n})(SetFilterModelValuesType || (SetFilterModelValuesType = {}));\nvar SetValueModel = /** @class */ (function () {\n    function SetValueModel(filterParams, setIsLoading, valueFormatterService, translate) {\n        var _this = this;\n        this.filterParams = filterParams;\n        this.setIsLoading = setIsLoading;\n        this.valueFormatterService = valueFormatterService;\n        this.translate = translate;\n        this.localEventService = new agGridCommunity.EventService();\n        this.miniFilterText = null;\n        // The lookup for a set is much faster than the lookup for an array, especially when the length of the array is\n        // thousands of records long, so where lookups are important we use a set.\n        /** Values provided to the filter for use. */\n        this.providedValues = null;\n        /** All possible values for the filter, sorted if required. */\n        this.allValues = [];\n        /** Remaining values when filters from other columns have been applied. */\n        this.availableValues = new Set();\n        /** All values that are currently displayed, after the mini-filter has been applied. */\n        this.displayedValues = [];\n        /** Values that have been selected for this filter. */\n        this.selectedValues = new Set();\n        this.initialised = false;\n        var column = filterParams.column, colDef = filterParams.colDef, textFormatter = filterParams.textFormatter, doesRowPassOtherFilter = filterParams.doesRowPassOtherFilter, suppressSorting = filterParams.suppressSorting, comparator = filterParams.comparator, rowModel = filterParams.rowModel, valueGetter = filterParams.valueGetter, values = filterParams.values;\n        this.column = column;\n        this.colDef = colDef;\n        this.formatter = textFormatter || agGridCommunity.TextFilter.DEFAULT_FORMATTER;\n        this.doesRowPassOtherFilters = doesRowPassOtherFilter;\n        this.suppressSorting = suppressSorting || false;\n        this.comparator = comparator || colDef.comparator || agGridCommunity._.defaultComparator;\n        if (rowModel.getType() === agGridCommunity.Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            this.clientSideValuesExtractor = new ClientSideValuesExtractor(rowModel, colDef, valueGetter);\n        }\n        if (values == null) {\n            this.valuesType = SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;\n        }\n        else {\n            this.valuesType = Array.isArray(values) ?\n                SetFilterModelValuesType.PROVIDED_LIST :\n                SetFilterModelValuesType.PROVIDED_CALLBACK;\n            this.providedValues = values;\n        }\n        this.updateAllValues().then(function (updatedValues) { return _this.resetSelectionState(updatedValues || []); });\n    }\n    SetValueModel.prototype.addEventListener = function (eventType, listener, async) {\n        this.localEventService.addEventListener(eventType, listener, async);\n    };\n    SetValueModel.prototype.removeEventListener = function (eventType, listener, async) {\n        this.localEventService.removeEventListener(eventType, listener, async);\n    };\n    /**\n     * Re-fetches the values used in the filter from the value source.\n     * If keepSelection is false, the filter selection will be reset to everything selected,\n     * otherwise the current selection will be preserved.\n     */\n    SetValueModel.prototype.refreshValues = function (keepSelection) {\n        if (keepSelection === void 0) { keepSelection = true; }\n        var currentModel = this.getModel();\n        this.updateAllValues();\n        // ensure model is updated for new values\n        return this.setModel(keepSelection ? currentModel : null);\n    };\n    /**\n     * Overrides the current values being used for the set filter.\n     * If keepSelection is false, the filter selection will be reset to everything selected,\n     * otherwise the current selection will be preserved.\n     */\n    SetValueModel.prototype.overrideValues = function (valuesToUse, keepSelection) {\n        var _this = this;\n        if (keepSelection === void 0) { keepSelection = true; }\n        return new agGridCommunity.AgPromise(function (resolve) {\n            // wait for any existing values to be populated before overriding\n            _this.allValuesPromise.then(function () {\n                _this.valuesType = SetFilterModelValuesType.PROVIDED_LIST;\n                _this.providedValues = valuesToUse;\n                _this.refreshValues(keepSelection).then(function () { return resolve(); });\n            });\n        });\n    };\n    SetValueModel.prototype.refreshAfterAnyFilterChanged = function () {\n        var _this = this;\n        return this.showAvailableOnly() ?\n            this.allValuesPromise.then(function (values) { return _this.updateAvailableValues(values || []); }) :\n            agGridCommunity.AgPromise.resolve();\n    };\n    SetValueModel.prototype.isInitialised = function () {\n        return this.initialised;\n    };\n    SetValueModel.prototype.updateAllValues = function () {\n        var _this = this;\n        this.allValuesPromise = new agGridCommunity.AgPromise(function (resolve) {\n            switch (_this.valuesType) {\n                case SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES:\n                case SetFilterModelValuesType.PROVIDED_LIST: {\n                    var values = _this.valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES ?\n                        _this.getValuesFromRows(false) : agGridCommunity._.toStrings(_this.providedValues);\n                    var sortedValues = _this.sortValues(values || []);\n                    _this.allValues = sortedValues;\n                    resolve(sortedValues);\n                    break;\n                }\n                case SetFilterModelValuesType.PROVIDED_CALLBACK: {\n                    _this.setIsLoading(true);\n                    var callback_1 = _this.providedValues;\n                    var params_1 = {\n                        success: function (values) {\n                            var processedValues = agGridCommunity._.toStrings(values);\n                            _this.setIsLoading(false);\n                            var sortedValues = _this.sortValues(processedValues || []);\n                            _this.allValues = sortedValues;\n                            resolve(sortedValues);\n                        },\n                        colDef: _this.colDef\n                    };\n                    window.setTimeout(function () { return callback_1(params_1); }, 0);\n                    break;\n                }\n                default:\n                    throw new Error('Unrecognised valuesType');\n            }\n        });\n        this.allValuesPromise.then(function (values) { return _this.updateAvailableValues(values || []); }).then(function () { return _this.initialised = true; });\n        return this.allValuesPromise;\n    };\n    SetValueModel.prototype.setValuesType = function (value) {\n        this.valuesType = value;\n    };\n    SetValueModel.prototype.getValuesType = function () {\n        return this.valuesType;\n    };\n    SetValueModel.prototype.isValueAvailable = function (value) {\n        return this.availableValues.has(value);\n    };\n    SetValueModel.prototype.showAvailableOnly = function () {\n        return this.valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES &&\n            !this.filterParams.suppressRemoveEntries;\n    };\n    SetValueModel.prototype.updateAvailableValues = function (allValues) {\n        var availableValues = this.showAvailableOnly() ? this.sortValues(this.getValuesFromRows(true)) : allValues;\n        this.availableValues = agGridCommunity._.convertToSet(availableValues);\n        this.localEventService.dispatchEvent({ type: SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED });\n        this.updateDisplayedValues();\n    };\n    SetValueModel.prototype.sortValues = function (values) {\n        if (this.suppressSorting) {\n            return values;\n        }\n        if (!this.filterParams.excelMode || values.indexOf(null) < 0) {\n            return values.sort(this.comparator);\n        }\n        // ensure the blank value always appears last\n        return agGridCommunity._.filter(values, function (v) { return v != null; }).sort(this.comparator).concat(null);\n    };\n    SetValueModel.prototype.getValuesFromRows = function (removeUnavailableValues) {\n        var _this = this;\n        if (removeUnavailableValues === void 0) { removeUnavailableValues = false; }\n        if (!this.clientSideValuesExtractor) {\n            console.error('AG Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values');\n            return [];\n        }\n        var predicate = function (node) { return (!removeUnavailableValues || _this.doesRowPassOtherFilters(node)); };\n        return this.clientSideValuesExtractor.extractUniqueValues(predicate);\n    };\n    /** Sets mini filter value. Returns true if it changed from last value, otherwise false. */\n    SetValueModel.prototype.setMiniFilter = function (value) {\n        value = agGridCommunity._.makeNull(value);\n        if (this.miniFilterText === value) {\n            //do nothing if filter has not changed\n            return false;\n        }\n        this.miniFilterText = value;\n        this.updateDisplayedValues();\n        return true;\n    };\n    SetValueModel.prototype.getMiniFilter = function () {\n        return this.miniFilterText;\n    };\n    SetValueModel.prototype.updateDisplayedValues = function () {\n        var _this = this;\n        // if no filter, just display all available values\n        if (this.miniFilterText == null) {\n            this.displayedValues = agGridCommunity._.values(this.availableValues);\n            return;\n        }\n        // if filter present, we filter down the list\n        this.displayedValues = [];\n        // to allow for case insensitive searches, upper-case both filter text and value\n        var formattedFilterText = (this.formatter(this.miniFilterText) || '').toUpperCase();\n        var matchesFilter = function (valueToCheck) {\n            return valueToCheck != null && valueToCheck.toUpperCase().indexOf(formattedFilterText) >= 0;\n        };\n        this.availableValues.forEach(function (value) {\n            if (value == null) {\n                if (_this.filterParams.excelMode && matchesFilter(_this.translate('blanks'))) {\n                    _this.displayedValues.push(value);\n                }\n            }\n            else {\n                var textFormatterValue = _this.formatter(value);\n                // TODO: should this be applying the text formatter *after* the value formatter?\n                var valueFormatterValue = _this.valueFormatterService.formatValue(_this.column, null, null, textFormatterValue, _this.filterParams.valueFormatter, false);\n                if (matchesFilter(textFormatterValue) || matchesFilter(valueFormatterValue)) {\n                    _this.displayedValues.push(value);\n                }\n            }\n        });\n    };\n    SetValueModel.prototype.getDisplayedValueCount = function () {\n        return this.displayedValues.length;\n    };\n    SetValueModel.prototype.getDisplayedValue = function (index) {\n        return this.displayedValues[index];\n    };\n    SetValueModel.prototype.hasSelections = function () {\n        return this.filterParams.defaultToNothingSelected ?\n            this.selectedValues.size > 0 :\n            this.allValues.length !== this.selectedValues.size;\n    };\n    SetValueModel.prototype.getUniqueValueCount = function () {\n        return this.allValues.length;\n    };\n    SetValueModel.prototype.getUniqueValue = function (index) {\n        return this.allValues[index];\n    };\n    SetValueModel.prototype.getValues = function () {\n        return this.allValues.slice();\n    };\n    SetValueModel.prototype.selectAllMatchingMiniFilter = function (clearExistingSelection) {\n        var _this = this;\n        if (clearExistingSelection === void 0) { clearExistingSelection = false; }\n        if (this.miniFilterText == null) {\n            // ensure everything is selected\n            this.selectedValues = agGridCommunity._.convertToSet(this.allValues);\n        }\n        else {\n            // ensure everything that matches the mini filter is selected\n            if (clearExistingSelection) {\n                this.selectedValues.clear();\n            }\n            agGridCommunity._.forEach(this.displayedValues, function (value) { return _this.selectedValues.add(value); });\n        }\n    };\n    SetValueModel.prototype.deselectAllMatchingMiniFilter = function () {\n        var _this = this;\n        if (this.miniFilterText == null) {\n            // ensure everything is deselected\n            this.selectedValues.clear();\n        }\n        else {\n            // ensure everything that matches the mini filter is deselected\n            agGridCommunity._.forEach(this.displayedValues, function (value) { return _this.selectedValues.delete(value); });\n        }\n    };\n    SetValueModel.prototype.selectValue = function (value) {\n        this.selectedValues.add(value);\n    };\n    SetValueModel.prototype.deselectValue = function (value) {\n        if (this.filterParams.excelMode && this.isEverythingVisibleSelected()) {\n            // ensure we're starting from the correct \"everything selected\" state\n            this.resetSelectionState(this.displayedValues);\n        }\n        this.selectedValues.delete(value);\n    };\n    SetValueModel.prototype.isValueSelected = function (value) {\n        return this.selectedValues.has(value);\n    };\n    SetValueModel.prototype.isEverythingVisibleSelected = function () {\n        var _this = this;\n        return agGridCommunity._.filter(this.displayedValues, function (it) { return _this.isValueSelected(it); }).length === this.displayedValues.length;\n    };\n    SetValueModel.prototype.isNothingVisibleSelected = function () {\n        var _this = this;\n        return agGridCommunity._.filter(this.displayedValues, function (it) { return _this.isValueSelected(it); }).length === 0;\n    };\n    SetValueModel.prototype.getModel = function () {\n        return this.hasSelections() ? agGridCommunity._.values(this.selectedValues) : null;\n    };\n    SetValueModel.prototype.setModel = function (model) {\n        var _this = this;\n        return this.allValuesPromise.then(function (values) {\n            if (model == null) {\n                _this.resetSelectionState(values || []);\n            }\n            else {\n                // select all values from the model that exist in the filter\n                _this.selectedValues.clear();\n                var allValues_1 = agGridCommunity._.convertToSet(values || []);\n                agGridCommunity._.forEach(model, function (value) {\n                    if (allValues_1.has(value)) {\n                        _this.selectedValues.add(value);\n                    }\n                });\n            }\n        });\n    };\n    SetValueModel.prototype.resetSelectionState = function (values) {\n        if (this.filterParams.defaultToNothingSelected) {\n            this.selectedValues.clear();\n        }\n        else {\n            this.selectedValues = agGridCommunity._.convertToSet(values || []);\n        }\n    };\n    SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED = 'availableValuesChanged';\n    return SetValueModel;\n}());\n\nvar __extends$2W = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SetFilterListItem = /** @class */ (function (_super) {\n    __extends$2W(SetFilterListItem, _super);\n    function SetFilterListItem(value, params, translate, isSelected) {\n        var _this = _super.call(this, SetFilterListItem.TEMPLATE) || this;\n        _this.value = value;\n        _this.params = params;\n        _this.translate = translate;\n        _this.isSelected = isSelected;\n        return _this;\n    }\n    SetFilterListItem.prototype.init = function () {\n        var _this = this;\n        this.render();\n        this.eCheckbox.setValue(this.isSelected, true);\n        this.eCheckbox.onValueChange(function (value) {\n            var parsedValue = value || false;\n            _this.isSelected = parsedValue;\n            var event = {\n                type: SetFilterListItem.EVENT_SELECTION_CHANGED,\n                isSelected: parsedValue,\n            };\n            _this.dispatchEvent(event);\n        });\n    };\n    SetFilterListItem.prototype.toggleSelected = function () {\n        this.isSelected = !this.isSelected;\n        this.eCheckbox.setValue(this.isSelected);\n    };\n    SetFilterListItem.prototype.render = function () {\n        var column = this.params.column;\n        var value = this.value;\n        var formattedValue = null;\n        if (typeof value === 'function') {\n            value = value();\n        }\n        else {\n            formattedValue = this.getFormattedValue(this.params, column, value);\n        }\n        if (this.params.showTooltips) {\n            var tooltipText = agGridCommunity._.escapeString(formattedValue != null ? formattedValue : value);\n            if (tooltipText == null) {\n                this.setTooltip(undefined);\n            }\n            else {\n                this.setTooltip(tooltipText);\n            }\n        }\n        var params = {\n            value: value,\n            valueFormatted: formattedValue,\n            api: this.gridOptionsWrapper.getApi(),\n            context: this.gridOptionsWrapper.getContext()\n        };\n        this.renderCell(params);\n    };\n    SetFilterListItem.prototype.getTooltipParams = function () {\n        var res = _super.prototype.getTooltipParams.call(this);\n        res.location = 'setFilterValue';\n        res.colDef = this.getComponentHolder();\n        return res;\n    };\n    SetFilterListItem.prototype.getFormattedValue = function (filterParams, column, value) {\n        var formatter = filterParams && filterParams.valueFormatter;\n        return this.valueFormatterService.formatValue(column, null, null, value, formatter, false);\n    };\n    SetFilterListItem.prototype.renderCell = function (params) {\n        var _this = this;\n        var cellRendererPromise = this.userComponentFactory.newSetFilterCellRenderer(this.params, params);\n        if (cellRendererPromise == null) {\n            var valueToRender = params.valueFormatted == null ? params.value : params.valueFormatted;\n            this.eCheckbox.setLabel(valueToRender == null ? this.translate('blanks') : valueToRender);\n            return;\n        }\n        cellRendererPromise.then(function (component) {\n            if (component) {\n                _this.eCheckbox.setLabel(component.getGui());\n                _this.addDestroyFunc(function () { return _this.destroyBean(component); });\n            }\n        });\n    };\n    SetFilterListItem.prototype.getComponentHolder = function () {\n        return this.params.column.getColDef();\n    };\n    SetFilterListItem.EVENT_SELECTION_CHANGED = 'selectionChanged';\n    SetFilterListItem.TEMPLATE = \"\\n        <div class=\\\"ag-set-filter-item\\\">\\n            <ag-checkbox ref=\\\"eCheckbox\\\" class=\\\"ag-set-filter-item-checkbox\\\"></ag-checkbox>\\n        </div>\";\n    __decorate$1P([\n        agGridCommunity.Autowired('valueFormatterService')\n    ], SetFilterListItem.prototype, \"valueFormatterService\", void 0);\n    __decorate$1P([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], SetFilterListItem.prototype, \"userComponentFactory\", void 0);\n    __decorate$1P([\n        agGridCommunity.RefSelector('eCheckbox')\n    ], SetFilterListItem.prototype, \"eCheckbox\", void 0);\n    __decorate$1P([\n        agGridCommunity.PostConstruct\n    ], SetFilterListItem.prototype, \"init\", null);\n    return SetFilterListItem;\n}(agGridCommunity.Component));\n\nvar DEFAULT_LOCALE_TEXT = {\n    loadingOoo: 'Loading...',\n    blanks: '(Blanks)',\n    searchOoo: 'Search...',\n    selectAll: '(Select All)',\n    selectAllSearchResults: '(Select All Search Results)',\n    noMatches: 'No matches.'\n};\n\nvar __extends$2X = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SetFilter = /** @class */ (function (_super) {\n    __extends$2X(SetFilter, _super);\n    function SetFilter() {\n        var _this = _super.call(this, 'setFilter') || this;\n        _this.valueModel = null;\n        _this.setFilterParams = null;\n        _this.virtualList = null;\n        // To make the filtering super fast, we store the values in an object, and check for the boolean value.\n        // Although Set would be a more natural choice of data structure, its performance across browsers is\n        // significantly worse than using an object: https://jsbench.me/hdk91jbw1h/\n        _this.appliedModelValues = null;\n        return _this;\n    }\n    // unlike the simple filters, nothing in the set filter UI shows/hides.\n    // maybe this method belongs in abstractSimpleFilter???\n    SetFilter.prototype.updateUiVisibility = function () { };\n    SetFilter.prototype.createBodyTemplate = function () {\n        return /* html */ \"\\n            <div class=\\\"ag-set-filter\\\">\\n                <div ref=\\\"eFilterLoading\\\" class=\\\"ag-filter-loading ag-hidden\\\">\" + this.translateForSetFilter('loadingOoo') + \"</div>\\n                <ag-input-text-field class=\\\"ag-mini-filter\\\" ref=\\\"eMiniFilter\\\"></ag-input-text-field>\\n                <div ref=\\\"eFilterNoMatches\\\" class=\\\"ag-filter-no-matches ag-hidden\\\">\" + this.translateForSetFilter('noMatches') + \"</div>\\n                <div ref=\\\"eSetFilterList\\\" class=\\\"ag-set-filter-list\\\" role=\\\"presentation\\\"></div>\\n            </div>\";\n    };\n    SetFilter.prototype.handleKeyDown = function (e) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        switch (e.which || e.keyCode) {\n            case agGridCommunity.KeyCode.SPACE:\n                this.handleKeySpace(e);\n                break;\n            case agGridCommunity.KeyCode.ENTER:\n                this.handleKeyEnter(e);\n                break;\n        }\n    };\n    SetFilter.prototype.handleKeySpace = function (e) {\n        if (!this.eSetFilterList.contains(document.activeElement) || !this.virtualList) {\n            return;\n        }\n        var currentItem = this.virtualList.getLastFocusedRow();\n        if (currentItem != null) {\n            var component = this.virtualList.getComponentAt(currentItem);\n            if (component) {\n                e.preventDefault();\n                component.toggleSelected();\n            }\n        }\n    };\n    SetFilter.prototype.handleKeyEnter = function (e) {\n        if (!this.setFilterParams) {\n            return;\n        }\n        if (this.setFilterParams.excelMode) {\n            e.preventDefault();\n            // in Excel Mode, hitting Enter is the same as pressing the Apply button\n            this.onBtApply(false, false, e);\n            if (this.setFilterParams.excelMode === 'mac') {\n                // in Mac version, select all the input text\n                this.eMiniFilter.getInputElement().select();\n            }\n        }\n    };\n    SetFilter.prototype.getCssIdentifier = function () {\n        return 'set-filter';\n    };\n    SetFilter.prototype.setModelAndRefresh = function (values) {\n        var _this = this;\n        return this.valueModel ? this.valueModel.setModel(values).then(function () { return _this.refresh(); }) : agGridCommunity.AgPromise.resolve();\n    };\n    SetFilter.prototype.resetUiToDefaults = function () {\n        this.setMiniFilter(null);\n        return this.setModelAndRefresh(null);\n    };\n    SetFilter.prototype.setModelIntoUi = function (model) {\n        this.setMiniFilter(null);\n        if (model instanceof Array) {\n            var message_1 = 'AG Grid: The Set Filter Model is no longer an array and models as arrays are ' +\n                'deprecated. Please check the docs on what the set filter model looks like. Future versions of ' +\n                'AG Grid will have the array version of the model removed.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_1); }, 'setFilter.modelAsArray');\n        }\n        // also supporting old filter model for backwards compatibility\n        var values = model == null ? null : (model instanceof Array ? model : model.values);\n        return this.setModelAndRefresh(values);\n    };\n    SetFilter.prototype.getModelFromUi = function () {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var values = this.valueModel.getModel();\n        if (!values) {\n            return null;\n        }\n        if (this.gridOptionsWrapper.isEnableOldSetFilterModel()) {\n            // this is a hack, it breaks casting rules, to apply with old model\n            return values;\n        }\n        return { values: values, filterType: this.getFilterType() };\n    };\n    SetFilter.prototype.getModel = function () {\n        return _super.prototype.getModel.call(this);\n    };\n    SetFilter.prototype.getFilterType = function () {\n        return 'set';\n    };\n    SetFilter.prototype.getValueModel = function () {\n        return this.valueModel;\n    };\n    SetFilter.prototype.areModelsEqual = function (a, b) {\n        // both are missing\n        if (a == null && b == null) {\n            return true;\n        }\n        return a != null && b != null && agGridCommunity._.areEqual(a.values, b.values);\n    };\n    SetFilter.prototype.setParams = function (params) {\n        var _this = this;\n        this.applyExcelModeOptions(params);\n        _super.prototype.setParams.call(this, params);\n        this.checkSetFilterDeprecatedParams(params);\n        this.setFilterParams = params;\n        this.valueModel = new SetValueModel(params, function (loading) { return _this.showOrHideLoadingScreen(loading); }, this.valueFormatterService, function (key) { return _this.translateForSetFilter(key); });\n        this.initialiseFilterBodyUi();\n        if (params.rowModel.getType() === agGridCommunity.Constants.ROW_MODEL_TYPE_CLIENT_SIDE &&\n            !params.values &&\n            !params.suppressSyncValuesAfterDataChange) {\n            this.addEventListenersForDataChanges();\n        }\n    };\n    SetFilter.prototype.applyExcelModeOptions = function (params) {\n        // apply default options to match Excel behaviour, unless they have already been specified\n        if (params.excelMode === 'windows') {\n            if (!params.buttons) {\n                params.buttons = ['apply', 'cancel'];\n            }\n            if (params.closeOnApply == null) {\n                params.closeOnApply = true;\n            }\n        }\n        else if (params.excelMode === 'mac') {\n            if (!params.buttons) {\n                params.buttons = ['reset'];\n            }\n            if (params.applyMiniFilterWhileTyping == null) {\n                params.applyMiniFilterWhileTyping = true;\n            }\n            if (params.debounceMs == null) {\n                params.debounceMs = 500;\n            }\n        }\n    };\n    SetFilter.prototype.checkSetFilterDeprecatedParams = function (params) {\n        if (params.syncValuesLikeExcel) {\n            var message_2 = 'AG Grid: since version 22.x, the Set Filter param syncValuesLikeExcel is no longer' +\n                ' used as this is the default behaviour. To turn this default behaviour off, use the' +\n                ' param suppressSyncValuesAfterDataChange';\n            agGridCommunity._.doOnce(function () { return console.warn(message_2); }, 'syncValuesLikeExcel deprecated');\n        }\n        if (params.selectAllOnMiniFilter) {\n            var message_3 = 'AG Grid: since version 22.x, the Set Filter param selectAllOnMiniFilter is no longer' +\n                ' used as this is the default behaviour.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_3); }, 'selectAllOnMiniFilter deprecated');\n        }\n        if (params.suppressSyncValuesAfterDataChange) {\n            var message_4 = 'AG Grid: since version 23.1, the Set Filter param suppressSyncValuesAfterDataChange has' +\n                ' been deprecated and will be removed in a future major release.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_4); }, 'suppressSyncValuesAfterDataChange deprecated');\n        }\n        if (params.suppressRemoveEntries) {\n            var message_5 = 'AG Grid: since version 23.1, the Set Filter param suppressRemoveEntries has' +\n                ' been deprecated and will be removed in a future major release.';\n            agGridCommunity._.doOnce(function () { return console.warn(message_5); }, 'suppressRemoveEntries deprecated');\n        }\n    };\n    SetFilter.prototype.addEventListenersForDataChanges = function () {\n        var _this = this;\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_ROW_DATA_UPDATED, function () { return _this.syncAfterDataChange(); });\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_CELL_VALUE_CHANGED, function (event) {\n            // only interested in changes to do with this column\n            if (_this.setFilterParams && event.column === _this.setFilterParams.column) {\n                _this.syncAfterDataChange();\n            }\n        });\n    };\n    SetFilter.prototype.syncAfterDataChange = function (refreshValues, keepSelection) {\n        var _this = this;\n        if (refreshValues === void 0) { refreshValues = true; }\n        if (keepSelection === void 0) { keepSelection = true; }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var promise = agGridCommunity.AgPromise.resolve();\n        if (refreshValues) {\n            promise = this.valueModel.refreshValues(keepSelection);\n        }\n        else if (!keepSelection) {\n            promise = this.valueModel.setModel(null);\n        }\n        return promise.then(function () {\n            _this.refresh();\n            _this.onBtApply(false, true);\n        });\n    };\n    /** @deprecated since version 23.2. The loading screen is displayed automatically when the set filter is retrieving values. */\n    SetFilter.prototype.setLoading = function (loading) {\n        var message = 'AG Grid: since version 23.2, setLoading has been deprecated. The loading screen is displayed automatically when the set filter is retrieving values.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.setLoading');\n        this.showOrHideLoadingScreen(loading);\n    };\n    SetFilter.prototype.showOrHideLoadingScreen = function (isLoading) {\n        agGridCommunity._.setDisplayed(this.eFilterLoading, isLoading);\n    };\n    SetFilter.prototype.initialiseFilterBodyUi = function () {\n        this.initVirtualList();\n        this.initMiniFilter();\n    };\n    SetFilter.prototype.initVirtualList = function () {\n        var _this = this;\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var virtualList = this.virtualList = this.createBean(new agGridCommunity.VirtualList('filter'));\n        var eSetFilterList = this.getRefElement('eSetFilterList');\n        if (eSetFilterList) {\n            eSetFilterList.appendChild(virtualList.getGui());\n        }\n        var cellHeight = this.setFilterParams.cellHeight;\n        if (cellHeight != null) {\n            virtualList.setRowHeight(cellHeight);\n        }\n        virtualList.setComponentCreator(function (value) { return _this.createSetListItem(value); });\n        var model;\n        if (this.setFilterParams.suppressSelectAll) {\n            model = new ModelWrapper(this.valueModel);\n        }\n        else {\n            model = new ModelWrapperWithSelectAll(this.valueModel, function () { return _this.isSelectAllSelected(); });\n        }\n        virtualList.setModel(model);\n    };\n    SetFilter.prototype.getSelectAllLabel = function () {\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var key = this.valueModel.getMiniFilter() == null || !this.setFilterParams.excelMode ?\n            'selectAll' : 'selectAllSearchResults';\n        return this.translateForSetFilter(key);\n    };\n    SetFilter.prototype.createSetListItem = function (value) {\n        var _this = this;\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var listItem;\n        if (value === SetFilter.SELECT_ALL_VALUE) {\n            listItem = this.createBean(new SetFilterListItem(function () { return _this.getSelectAllLabel(); }, this.setFilterParams, function (key) { return _this.translateForSetFilter(key); }, this.isSelectAllSelected()));\n            listItem.addEventListener(SetFilterListItem.EVENT_SELECTION_CHANGED, function (e) { return _this.onSelectAll(e.isSelected); });\n            return listItem;\n        }\n        listItem = this.createBean(new SetFilterListItem(value, this.setFilterParams, function (key) { return _this.translateForSetFilter(key); }, this.valueModel.isValueSelected(value)));\n        listItem.addEventListener(SetFilterListItem.EVENT_SELECTION_CHANGED, function (e) { return _this.onItemSelected(value, e.isSelected); });\n        return listItem;\n    };\n    SetFilter.prototype.initMiniFilter = function () {\n        var _this = this;\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var _a = this, eMiniFilter = _a.eMiniFilter, gridOptionsWrapper = _a.gridOptionsWrapper;\n        var translate = gridOptionsWrapper.getLocaleTextFunc();\n        agGridCommunity._.setDisplayed(eMiniFilter.getGui(), !this.setFilterParams.suppressMiniFilter);\n        eMiniFilter.setValue(this.valueModel.getMiniFilter());\n        eMiniFilter.onValueChange(function () { return _this.onMiniFilterInput(); });\n        eMiniFilter.setInputAriaLabel(translate('ariaSearchFilterValues', 'Search filter values'));\n        this.addManagedListener(eMiniFilter.getInputElement(), 'keypress', function (e) { return _this.onMiniFilterKeyPress(e); });\n    };\n    // we need to have the GUI attached before we can draw the virtual rows, as the\n    // virtual row logic needs info about the GUI state\n    SetFilter.prototype.afterGuiAttached = function (params) {\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        _super.prototype.afterGuiAttached.call(this, params);\n        this.refreshVirtualList();\n        if (this.setFilterParams.excelMode) {\n            this.resetUiToActiveModel();\n        }\n        var eMiniFilter = this.eMiniFilter;\n        eMiniFilter.setInputPlaceholder(this.translateForSetFilter('searchOoo'));\n        if (!params || !params.suppressFocus) {\n            eMiniFilter.getFocusableElement().focus();\n        }\n    };\n    SetFilter.prototype.applyModel = function () {\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        if (this.setFilterParams.excelMode && this.valueModel.isEverythingVisibleSelected()) {\n            // In Excel, if the filter is applied with all visible values selected, then any active filter on the\n            // column is removed. This ensures the filter is removed in this situation.\n            this.valueModel.selectAllMatchingMiniFilter();\n        }\n        var result = _super.prototype.applyModel.call(this);\n        // keep appliedModelValues in sync with the applied model\n        var appliedModel = this.getModel();\n        if (appliedModel) {\n            this.appliedModelValues = agGridCommunity._.reduce(appliedModel.values, function (values, value) {\n                values[String(value)] = true;\n                return values;\n            }, {});\n        }\n        else {\n            this.appliedModelValues = null;\n        }\n        return result;\n    };\n    SetFilter.prototype.isModelValid = function (model) {\n        return this.setFilterParams && this.setFilterParams.excelMode ? model == null || model.values.length > 0 : true;\n    };\n    SetFilter.prototype.doesFilterPass = function (params) {\n        var _this = this;\n        if (!this.setFilterParams || !this.valueModel || !this.appliedModelValues) {\n            return true;\n        }\n        var _a = this.setFilterParams, valueGetter = _a.valueGetter, keyCreator = _a.colDef.keyCreator;\n        var value = valueGetter(params.node);\n        if (keyCreator) {\n            value = keyCreator({ value: value });\n        }\n        value = agGridCommunity._.makeNull(value);\n        if (Array.isArray(value)) {\n            return agGridCommunity._.some(value, function (v) { return _this.appliedModelValues[agGridCommunity._.makeNull(v)] === true; });\n        }\n        // Comparing against a value performs better than just checking for undefined\n        // https://jsbench.me/hdk91jbw1h/\n        return this.appliedModelValues[value] === true;\n    };\n    SetFilter.prototype.onNewRowsLoaded = function () {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var valuesType = this.valueModel.getValuesType();\n        var keepSelection = this.isNewRowsActionKeep();\n        this.syncAfterDataChange(valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES, keepSelection);\n    };\n    //noinspection JSUnusedGlobalSymbols\n    /**\n     * Public method provided so the user can change the value of the filter once\n     * the filter has been already started\n     * @param options The options to use.\n     */\n    SetFilter.prototype.setFilterValues = function (options) {\n        var _this = this;\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.overrideValues(options, this.isNewRowsActionKeep()).then(function () {\n            _this.refresh();\n            _this.onUiChanged();\n        });\n    };\n    //noinspection JSUnusedGlobalSymbols\n    /**\n     * Public method provided so the user can reset the values of the filter once that it has started.\n     */\n    SetFilter.prototype.resetFilterValues = function () {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.setValuesType(SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES);\n        this.syncAfterDataChange(true, this.isNewRowsActionKeep());\n    };\n    SetFilter.prototype.refreshFilterValues = function () {\n        var _this = this;\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        // the model is still being initialised\n        if (!this.valueModel.isInitialised()) {\n            return;\n        }\n        this.valueModel.refreshValues().then(function () {\n            _this.refresh();\n            _this.onUiChanged();\n        });\n    };\n    SetFilter.prototype.onAnyFilterChanged = function () {\n        var _this = this;\n        // don't block the current action when updating the values for this filter\n        setTimeout(function () {\n            if (!_this.valueModel) {\n                throw new Error('Value model has not been created.');\n            }\n            _this.valueModel.refreshAfterAnyFilterChanged().then(function () { return _this.refresh(); });\n        }, 0);\n    };\n    SetFilter.prototype.onMiniFilterInput = function () {\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        if (this.valueModel.setMiniFilter(this.eMiniFilter.getValue())) {\n            if (this.setFilterParams.applyMiniFilterWhileTyping) {\n                this.filterOnAllVisibleValues(false);\n            }\n            else {\n                this.updateUiAfterMiniFilterChange();\n            }\n        }\n    };\n    SetFilter.prototype.updateUiAfterMiniFilterChange = function () {\n        if (!this.setFilterParams) {\n            throw new Error('Set filter params have not been provided.');\n        }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        if (this.setFilterParams.excelMode) {\n            if (this.valueModel.getMiniFilter() == null) {\n                this.resetUiToActiveModel();\n            }\n            else {\n                this.valueModel.selectAllMatchingMiniFilter(true);\n                this.refresh();\n                this.onUiChanged();\n            }\n        }\n        else {\n            this.refresh();\n        }\n        this.showOrHideResults();\n    };\n    SetFilter.prototype.showOrHideResults = function () {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        var hideResults = this.valueModel.getMiniFilter() != null && this.valueModel.getDisplayedValueCount() < 1;\n        agGridCommunity._.setDisplayed(this.eNoMatches, hideResults);\n        agGridCommunity._.setDisplayed(this.eSetFilterList, !hideResults);\n    };\n    SetFilter.prototype.resetUiToActiveModel = function () {\n        var _this = this;\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.eMiniFilter.setValue(null, true);\n        this.valueModel.setMiniFilter(null);\n        this.setModelIntoUi(this.getModel()).then(function () { return _this.onUiChanged(false, 'prevent'); });\n    };\n    SetFilter.prototype.onMiniFilterKeyPress = function (e) {\n        if (agGridCommunity._.isKeyPressed(e, agGridCommunity.KeyCode.ENTER) && (!this.setFilterParams || !this.setFilterParams.excelMode)) {\n            this.filterOnAllVisibleValues();\n        }\n    };\n    SetFilter.prototype.filterOnAllVisibleValues = function (applyImmediately) {\n        if (applyImmediately === void 0) { applyImmediately = true; }\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.selectAllMatchingMiniFilter(true);\n        this.refresh();\n        this.onUiChanged(false, applyImmediately ? 'immediately' : 'debounce');\n        this.showOrHideResults();\n    };\n    SetFilter.prototype.focusRowIfAlive = function (rowIndex) {\n        var _this = this;\n        if (rowIndex == null) {\n            return;\n        }\n        window.setTimeout(function () {\n            if (!_this.virtualList) {\n                throw new Error('Virtual list has not been created.');\n            }\n            if (_this.isAlive()) {\n                _this.virtualList.focusRow(rowIndex);\n            }\n        }, 0);\n    };\n    SetFilter.prototype.onSelectAll = function (isSelected) {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        if (!this.virtualList) {\n            throw new Error('Virtual list has not been created.');\n        }\n        if (isSelected) {\n            this.valueModel.selectAllMatchingMiniFilter();\n        }\n        else {\n            this.valueModel.deselectAllMatchingMiniFilter();\n        }\n        var focusedRow = this.virtualList.getLastFocusedRow();\n        this.refresh();\n        this.onUiChanged();\n        this.focusRowIfAlive(focusedRow);\n    };\n    SetFilter.prototype.onItemSelected = function (value, isSelected) {\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        if (!this.virtualList) {\n            throw new Error('Virtual list has not been created.');\n        }\n        if (isSelected) {\n            this.valueModel.selectValue(value);\n        }\n        else {\n            this.valueModel.deselectValue(value);\n        }\n        var focusedRow = this.virtualList.getLastFocusedRow();\n        this.refresh();\n        this.onUiChanged();\n        this.focusRowIfAlive(focusedRow);\n    };\n    SetFilter.prototype.setMiniFilter = function (newMiniFilter) {\n        this.eMiniFilter.setValue(newMiniFilter);\n        this.onMiniFilterInput();\n    };\n    SetFilter.prototype.getMiniFilter = function () {\n        return this.valueModel ? this.valueModel.getMiniFilter() : null;\n    };\n    /** @deprecated since version 23.2. Please use setModel instead. */\n    SetFilter.prototype.selectEverything = function () {\n        var message = 'AG Grid: since version 23.2, selectEverything has been deprecated. Please use setModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.selectEverything');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.selectAllMatchingMiniFilter();\n        this.refresh();\n    };\n    /** @deprecated since version 23.2. Please use setModel instead. */\n    SetFilter.prototype.selectNothing = function () {\n        var message = 'AG Grid: since version 23.2, selectNothing has been deprecated. Please use setModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.selectNothing');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.deselectAllMatchingMiniFilter();\n        this.refresh();\n    };\n    /** @deprecated since version 23.2. Please use setModel instead. */\n    SetFilter.prototype.unselectValue = function (value) {\n        var message = 'AG Grid: since version 23.2, unselectValue has been deprecated. Please use setModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.unselectValue');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.deselectValue(value);\n        this.refresh();\n    };\n    /** @deprecated since version 23.2. Please use setModel instead. */\n    SetFilter.prototype.selectValue = function (value) {\n        var message = 'AG Grid: since version 23.2, selectValue has been deprecated. Please use setModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.selectValue');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        this.valueModel.selectValue(value);\n        this.refresh();\n    };\n    SetFilter.prototype.refresh = function () {\n        if (!this.virtualList) {\n            throw new Error('Virtual list has not been created.');\n        }\n        this.virtualList.refresh();\n    };\n    /** @deprecated since version 23.2. Please use getModel instead. */\n    SetFilter.prototype.isValueSelected = function (value) {\n        var message = 'AG Grid: since version 23.2, isValueSelected has been deprecated. Please use getModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.isValueSelected');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        return this.valueModel.isValueSelected(value);\n    };\n    /** @deprecated since version 23.2. Please use getModel instead. */\n    SetFilter.prototype.isEverythingSelected = function () {\n        var message = 'AG Grid: since version 23.2, isEverythingSelected has been deprecated. Please use getModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.isEverythingSelected');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        return this.valueModel.isEverythingVisibleSelected();\n    };\n    /** @deprecated since version 23.2. Please use getModel instead. */\n    SetFilter.prototype.isNothingSelected = function () {\n        var message = 'AG Grid: since version 23.2, isNothingSelected has been deprecated. Please use getModel instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.isNothingSelected');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        return this.valueModel.isNothingVisibleSelected();\n    };\n    /** @deprecated since version 23.2. Please use getValues instead. */\n    SetFilter.prototype.getUniqueValueCount = function () {\n        var message = 'AG Grid: since version 23.2, getUniqueValueCount has been deprecated. Please use getValues instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.getUniqueValueCount');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        return this.valueModel.getUniqueValueCount();\n    };\n    /** @deprecated since version 23.2. Please use getValues instead. */\n    SetFilter.prototype.getUniqueValue = function (index) {\n        var message = 'AG Grid: since version 23.2, getUniqueValue has been deprecated. Please use getValues instead.';\n        agGridCommunity._.doOnce(function () { return console.warn(message); }, 'setFilter.getUniqueValue');\n        if (!this.valueModel) {\n            throw new Error('Value model has not been created.');\n        }\n        return this.valueModel.getUniqueValue(index);\n    };\n    SetFilter.prototype.getValues = function () {\n        return this.valueModel ? this.valueModel.getValues() : [];\n    };\n    SetFilter.prototype.refreshVirtualList = function () {\n        if (this.setFilterParams && this.setFilterParams.refreshValuesOnOpen) {\n            this.refreshFilterValues();\n        }\n        else {\n            this.refresh();\n        }\n    };\n    SetFilter.prototype.translateForSetFilter = function (key) {\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        return translate(key, DEFAULT_LOCALE_TEXT[key]);\n    };\n    SetFilter.prototype.isSelectAllSelected = function () {\n        if (!this.setFilterParams || !this.valueModel) {\n            return false;\n        }\n        if (!this.setFilterParams.defaultToNothingSelected) {\n            // everything selected by default\n            if (this.valueModel.hasSelections() && this.valueModel.isNothingVisibleSelected()) {\n                return false;\n            }\n            if (this.valueModel.isEverythingVisibleSelected()) {\n                return true;\n            }\n        }\n        else {\n            // nothing selected by default\n            if (this.valueModel.hasSelections() && this.valueModel.isEverythingVisibleSelected()) {\n                return true;\n            }\n            if (this.valueModel.isNothingVisibleSelected()) {\n                return false;\n            }\n        }\n        // returning `undefined` means the checkbox status is indeterminate.\n        return undefined;\n    };\n    SetFilter.prototype.destroy = function () {\n        if (this.virtualList != null) {\n            this.virtualList.destroy();\n            this.virtualList = null;\n        }\n        _super.prototype.destroy.call(this);\n    };\n    SetFilter.SELECT_ALL_VALUE = '__AG_SELECT_ALL__';\n    __decorate$1Q([\n        agGridCommunity.RefSelector('eMiniFilter')\n    ], SetFilter.prototype, \"eMiniFilter\", void 0);\n    __decorate$1Q([\n        agGridCommunity.RefSelector('eFilterLoading')\n    ], SetFilter.prototype, \"eFilterLoading\", void 0);\n    __decorate$1Q([\n        agGridCommunity.RefSelector('eSetFilterList')\n    ], SetFilter.prototype, \"eSetFilterList\", void 0);\n    __decorate$1Q([\n        agGridCommunity.RefSelector('eFilterNoMatches')\n    ], SetFilter.prototype, \"eNoMatches\", void 0);\n    __decorate$1Q([\n        agGridCommunity.Autowired('valueFormatterService')\n    ], SetFilter.prototype, \"valueFormatterService\", void 0);\n    return SetFilter;\n}(agGridCommunity.ProvidedFilter));\nvar ModelWrapper = /** @class */ (function () {\n    function ModelWrapper(model) {\n        this.model = model;\n    }\n    ModelWrapper.prototype.getRowCount = function () {\n        return this.model.getDisplayedValueCount();\n    };\n    ModelWrapper.prototype.getRow = function (index) {\n        return this.model.getDisplayedValue(index);\n    };\n    ModelWrapper.prototype.isRowSelected = function (index) {\n        return this.model.isValueSelected(this.getRow(index));\n    };\n    return ModelWrapper;\n}());\nvar ModelWrapperWithSelectAll = /** @class */ (function () {\n    function ModelWrapperWithSelectAll(model, isSelectAllSelected) {\n        this.model = model;\n        this.isSelectAllSelected = isSelectAllSelected;\n    }\n    ModelWrapperWithSelectAll.prototype.getRowCount = function () {\n        return this.model.getDisplayedValueCount() + 1;\n    };\n    ModelWrapperWithSelectAll.prototype.getRow = function (index) {\n        return index === 0 ? SetFilter.SELECT_ALL_VALUE : this.model.getDisplayedValue(index - 1);\n    };\n    ModelWrapperWithSelectAll.prototype.isRowSelected = function (index) {\n        return index === 0 ? this.isSelectAllSelected() : this.model.isValueSelected(this.getRow(index - 1));\n    };\n    return ModelWrapperWithSelectAll;\n}());\n\nvar __extends$2Y = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SetFloatingFilterComp = /** @class */ (function (_super) {\n    __extends$2Y(SetFloatingFilterComp, _super);\n    function SetFloatingFilterComp() {\n        var _this = _super.call(this, /* html */ \"\\n            <div class=\\\"ag-floating-filter-input\\\" role=\\\"presentation\\\">\\n                <ag-input-text-field ref=\\\"eFloatingFilterText\\\"></ag-input-text-field>\\n            </div>\") || this;\n        _this.availableValuesListenerAdded = false;\n        return _this;\n    }\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    SetFloatingFilterComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    SetFloatingFilterComp.prototype.init = function (params) {\n        var displayName = this.columnController.getDisplayNameForColumn(params.column, 'header', true);\n        var translate = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eFloatingFilterText\n            .setDisabled(true)\n            .setInputAriaLabel(displayName + \" \" + translate('ariaFilterInput', 'Filter Input'))\n            .addGuiEventListener('click', function () { return params.showParentFilter(); });\n        this.params = params;\n    };\n    SetFloatingFilterComp.prototype.onParentModelChanged = function (parentModel) {\n        this.lastKnownModel = parentModel;\n        this.updateFloatingFilterText();\n    };\n    SetFloatingFilterComp.prototype.addAvailableValuesListener = function () {\n        var _this = this;\n        this.params.parentFilterInstance(function (setFilter) {\n            var setValueModel = setFilter.getValueModel();\n            if (!setValueModel) {\n                return;\n            }\n            // unlike other filters, what we show in the floating filter can be different, even\n            // if another filter changes. this is due to how set filter restricts its values based\n            // on selections in other filters, e.g. if you filter Language to English, then the set filter\n            // on Country will only show English speaking countries. Thus the list of items to show\n            // in the floating filter can change.\n            _this.addManagedListener(setValueModel, SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED, function () { return _this.updateFloatingFilterText(); });\n        });\n        this.availableValuesListenerAdded = true;\n    };\n    SetFloatingFilterComp.prototype.updateFloatingFilterText = function () {\n        var _this = this;\n        if (!this.lastKnownModel) {\n            this.eFloatingFilterText.setValue('');\n            return;\n        }\n        if (!this.availableValuesListenerAdded) {\n            this.addAvailableValuesListener();\n        }\n        // also supporting old filter model for backwards compatibility\n        var values = this.lastKnownModel instanceof Array ? this.lastKnownModel : this.lastKnownModel.values;\n        if (!values) {\n            this.eFloatingFilterText.setValue('');\n            return;\n        }\n        this.params.parentFilterInstance(function (setFilter) {\n            var valueModel = setFilter.getValueModel();\n            if (!valueModel) {\n                return;\n            }\n            var availableValues = agGridCommunity._.filter(values, function (v) { return valueModel.isValueAvailable(v); });\n            var localeTextFunc = _this.gridOptionsWrapper.getLocaleTextFunc();\n            // format all the values, if a formatter is provided\n            var formattedValues = agGridCommunity._.map(availableValues, function (value) {\n                var _a = _this.params, column = _a.column, filterParams = _a.filterParams;\n                var formattedValue = _this.valueFormatterService.formatValue(column, null, null, value, filterParams.valueFormatter, false);\n                var valueToRender = formattedValue != null ? formattedValue : value;\n                return valueToRender == null ? localeTextFunc('blanks', DEFAULT_LOCALE_TEXT.blanks) : valueToRender;\n            });\n            var arrayToDisplay = formattedValues.length > 10 ? formattedValues.slice(0, 10).concat('...') : formattedValues;\n            var valuesString = \"(\" + formattedValues.length + \") \" + arrayToDisplay.join(',');\n            _this.eFloatingFilterText.setValue(valuesString);\n        });\n    };\n    __decorate$1R([\n        agGridCommunity.RefSelector('eFloatingFilterText')\n    ], SetFloatingFilterComp.prototype, \"eFloatingFilterText\", void 0);\n    __decorate$1R([\n        agGridCommunity.Autowired('valueFormatterService')\n    ], SetFloatingFilterComp.prototype, \"valueFormatterService\", void 0);\n    __decorate$1R([\n        agGridCommunity.Autowired('columnController')\n    ], SetFloatingFilterComp.prototype, \"columnController\", void 0);\n    return SetFloatingFilterComp;\n}(agGridCommunity.Component));\n\nvar SetFilterModule = {\n    moduleName: agGridCommunity.ModuleNames.SetFilterModule,\n    beans: [],\n    userComponents: [\n        { componentName: 'agSetColumnFilter', componentClass: SetFilter },\n        { componentName: 'agSetColumnFloatingFilter', componentClass: SetFloatingFilterComp },\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$2Z = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar StatusBarService = /** @class */ (function (_super) {\n    __extends$2Z(StatusBarService, _super);\n    // tslint:disable-next-line\n    function StatusBarService() {\n        var _this = _super.call(this) || this;\n        _this.allComponents = {};\n        return _this;\n    }\n    StatusBarService.prototype.registerStatusPanel = function (key, component) {\n        this.allComponents[key] = component;\n    };\n    StatusBarService.prototype.getStatusPanel = function (key) {\n        return this.allComponents[key];\n    };\n    StatusBarService = __decorate$1S([\n        agGridCommunity.Bean('statusBarService')\n    ], StatusBarService);\n    return StatusBarService;\n}(agGridCommunity.BeanStub));\n\nvar __extends$2_ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar StatusBar = /** @class */ (function (_super) {\n    __extends$2_(StatusBar, _super);\n    function StatusBar() {\n        return _super.call(this, StatusBar.TEMPLATE) || this;\n    }\n    StatusBar.prototype.postConstruct = function () {\n        if (this.gridOptions.statusBar && this.gridOptions.statusBar.statusPanels) {\n            var leftStatusPanelComponents = this.gridOptions.statusBar.statusPanels\n                .filter(function (componentConfig) { return componentConfig.align === 'left'; });\n            this.createAndRenderComponents(leftStatusPanelComponents, this.eStatusBarLeft);\n            var centerStatusPanelComponents = this.gridOptions.statusBar.statusPanels\n                .filter(function (componentConfig) { return componentConfig.align === 'center'; });\n            this.createAndRenderComponents(centerStatusPanelComponents, this.eStatusBarCenter);\n            var rightStatusPanelComponents = this.gridOptions.statusBar.statusPanels\n                .filter(function (componentConfig) { return (!componentConfig.align || componentConfig.align === 'right'); });\n            this.createAndRenderComponents(rightStatusPanelComponents, this.eStatusBarRight);\n        }\n        else {\n            this.setDisplayed(false);\n        }\n    };\n    StatusBar.prototype.createAndRenderComponents = function (statusBarComponents, ePanelComponent) {\n        var _this = this;\n        var componentDetails = [];\n        statusBarComponents.forEach(function (componentConfig) {\n            var params = {\n                api: _this.gridOptionsWrapper.getApi(),\n                columnApi: _this.gridOptionsWrapper.getColumnApi(),\n                context: _this.gridOptionsWrapper.getContext()\n            };\n            var promise = _this.userComponentFactory.newStatusPanelComponent(componentConfig, params);\n            componentDetails.push({\n                // default to the component name if no key supplied\n                key: componentConfig.key || componentConfig.statusPanel,\n                promise: promise\n            });\n        });\n        agGridCommunity.AgPromise.all(componentDetails.map(function (details) { return details.promise; }))\n            .then(function () {\n            componentDetails.forEach(function (componentDetail) {\n                componentDetail.promise.then(function (component) {\n                    var destroyFunc = function () {\n                        _this.getContext().destroyBean(component);\n                    };\n                    if (_this.isAlive()) {\n                        _this.statusBarService.registerStatusPanel(componentDetail.key, component);\n                        ePanelComponent.appendChild(component.getGui());\n                        _this.addDestroyFunc(destroyFunc);\n                    }\n                    else {\n                        destroyFunc();\n                    }\n                });\n            });\n        });\n    };\n    StatusBar.TEMPLATE = \"<div class=\\\"ag-status-bar\\\">\\n            <div ref=\\\"eStatusBarLeft\\\" class=\\\"ag-status-bar-left\\\"></div>\\n            <div ref=\\\"eStatusBarCenter\\\" class=\\\"ag-status-bar-center\\\"></div>\\n            <div ref=\\\"eStatusBarRight\\\" class=\\\"ag-status-bar-right\\\"></div>\\n        </div>\";\n    __decorate$1T([\n        agGridCommunity.Autowired('gridOptions')\n    ], StatusBar.prototype, \"gridOptions\", void 0);\n    __decorate$1T([\n        agGridCommunity.Autowired('userComponentFactory')\n    ], StatusBar.prototype, \"userComponentFactory\", void 0);\n    __decorate$1T([\n        agGridCommunity.Autowired('statusBarService')\n    ], StatusBar.prototype, \"statusBarService\", void 0);\n    __decorate$1T([\n        agGridCommunity.RefSelector('eStatusBarLeft')\n    ], StatusBar.prototype, \"eStatusBarLeft\", void 0);\n    __decorate$1T([\n        agGridCommunity.RefSelector('eStatusBarCenter')\n    ], StatusBar.prototype, \"eStatusBarCenter\", void 0);\n    __decorate$1T([\n        agGridCommunity.RefSelector('eStatusBarRight')\n    ], StatusBar.prototype, \"eStatusBarRight\", void 0);\n    __decorate$1T([\n        agGridCommunity.PostConstruct\n    ], StatusBar.prototype, \"postConstruct\", null);\n    return StatusBar;\n}(agGridCommunity.Component));\n\nvar __extends$2$ = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar NameValueComp = /** @class */ (function (_super) {\n    __extends$2$(NameValueComp, _super);\n    function NameValueComp() {\n        return _super.call(this, NameValueComp.TEMPLATE) || this;\n    }\n    NameValueComp.prototype.setLabel = function (key, defaultValue) {\n        // we want to hide until the first value comes in\n        this.setDisplayed(false);\n        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n        this.eLabel.innerHTML = localeTextFunc(key, defaultValue);\n    };\n    NameValueComp.prototype.setValue = function (value) {\n        this.eValue.innerHTML = value;\n    };\n    NameValueComp.TEMPLATE = \"<div class=\\\"ag-status-name-value\\\">\\n            <span ref=\\\"eLabel\\\"></span>:&nbsp;\\n            <span ref=\\\"eValue\\\" class=\\\"ag-status-name-value-value\\\"></span>\\n        </div>\";\n    __decorate$1U([\n        agGridCommunity.RefSelector('eLabel')\n    ], NameValueComp.prototype, \"eLabel\", void 0);\n    __decorate$1U([\n        agGridCommunity.RefSelector('eValue')\n    ], NameValueComp.prototype, \"eValue\", void 0);\n    return NameValueComp;\n}(agGridCommunity.Component));\n\nvar __extends$30 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TotalAndFilteredRowsComp = /** @class */ (function (_super) {\n    __extends$30(TotalAndFilteredRowsComp, _super);\n    function TotalAndFilteredRowsComp() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TotalAndFilteredRowsComp.prototype.postConstruct = function () {\n        // this component is only really useful with client side row model\n        if (this.gridApi.getModel().getType() !== 'clientSide') {\n            console.warn(\"AG Grid: agTotalAndFilteredRowCountComponent should only be used with the client side row model.\");\n            return;\n        }\n        this.setLabel('totalAndFilteredRows', 'Rows');\n        this.addCssClass('ag-status-panel');\n        this.addCssClass('ag-status-panel-total-and-filtered-row-count');\n        this.setDisplayed(true);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this));\n    };\n    TotalAndFilteredRowsComp.prototype.onDataChanged = function () {\n        var rowCount = agGridCommunity._.formatNumberCommas(this.getFilteredRowCountValue());\n        var totalRowCount = agGridCommunity._.formatNumberCommas(this.getTotalRowCount());\n        if (rowCount === totalRowCount) {\n            this.setValue(rowCount);\n        }\n        else {\n            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            this.setValue(rowCount + \" \" + localeTextFunc('of', 'of') + \" \" + totalRowCount);\n        }\n    };\n    TotalAndFilteredRowsComp.prototype.getFilteredRowCountValue = function () {\n        var filteredRowCount = 0;\n        this.gridApi.forEachNodeAfterFilter(function (node) {\n            if (!node.group) {\n                filteredRowCount++;\n            }\n        });\n        return filteredRowCount;\n    };\n    TotalAndFilteredRowsComp.prototype.getTotalRowCount = function () {\n        var totalRowCount = 0;\n        this.gridApi.forEachNode(function (node) {\n            if (!node.group) {\n                totalRowCount++;\n            }\n        });\n        return totalRowCount;\n    };\n    TotalAndFilteredRowsComp.prototype.init = function () { };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    TotalAndFilteredRowsComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    __decorate$1V([\n        agGridCommunity.Autowired('gridApi')\n    ], TotalAndFilteredRowsComp.prototype, \"gridApi\", void 0);\n    __decorate$1V([\n        agGridCommunity.PostConstruct\n    ], TotalAndFilteredRowsComp.prototype, \"postConstruct\", null);\n    return TotalAndFilteredRowsComp;\n}(NameValueComp));\n\nvar __extends$31 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar FilteredRowsComp = /** @class */ (function (_super) {\n    __extends$31(FilteredRowsComp, _super);\n    function FilteredRowsComp() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FilteredRowsComp.prototype.postConstruct = function () {\n        this.setLabel('filteredRows', 'Filtered');\n        // this component is only really useful with client side row model\n        if (this.gridApi.getModel().getType() !== 'clientSide') {\n            console.warn(\"AG Grid: agFilteredRowCountComponent should only be used with the client side row model.\");\n            return;\n        }\n        this.addCssClass('ag-status-panel');\n        this.addCssClass('ag-status-panel-filtered-row-count');\n        this.setDisplayed(true);\n        var listener = this.onDataChanged.bind(this);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, listener);\n    };\n    FilteredRowsComp.prototype.onDataChanged = function () {\n        var totalRowCountValue = this.getTotalRowCountValue();\n        var filteredRowCountValue = this.getFilteredRowCountValue();\n        this.setValue(agGridCommunity._.formatNumberCommas(filteredRowCountValue));\n        this.setDisplayed(totalRowCountValue !== filteredRowCountValue);\n    };\n    FilteredRowsComp.prototype.getTotalRowCountValue = function () {\n        var totalRowCount = 0;\n        this.gridApi.forEachNode(function (node) { return totalRowCount += 1; });\n        return totalRowCount;\n    };\n    FilteredRowsComp.prototype.getFilteredRowCountValue = function () {\n        var filteredRowCount = 0;\n        this.gridApi.forEachNodeAfterFilter(function (node) {\n            if (!node.group) {\n                filteredRowCount += 1;\n            }\n        });\n        return filteredRowCount;\n    };\n    FilteredRowsComp.prototype.init = function () { };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    FilteredRowsComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    __decorate$1W([\n        agGridCommunity.Autowired('gridApi')\n    ], FilteredRowsComp.prototype, \"gridApi\", void 0);\n    __decorate$1W([\n        agGridCommunity.PostConstruct\n    ], FilteredRowsComp.prototype, \"postConstruct\", null);\n    return FilteredRowsComp;\n}(NameValueComp));\n\nvar __extends$32 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TotalRowsComp = /** @class */ (function (_super) {\n    __extends$32(TotalRowsComp, _super);\n    function TotalRowsComp() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TotalRowsComp.prototype.postConstruct = function () {\n        this.setLabel('totalRows', 'Total Rows');\n        // this component is only really useful with client side row model\n        if (this.gridApi.getModel().getType() !== 'clientSide') {\n            console.warn(\"AG Grid: agTotalRowCountComponent should only be used with the client side row model.\");\n            return;\n        }\n        this.addCssClass('ag-status-panel');\n        this.addCssClass('ag-status-panel-total-row-count');\n        this.setDisplayed(true);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this));\n    };\n    TotalRowsComp.prototype.onDataChanged = function () {\n        this.setValue(agGridCommunity._.formatNumberCommas(this.getRowCountValue()));\n    };\n    TotalRowsComp.prototype.getRowCountValue = function () {\n        var totalRowCount = 0;\n        this.gridApi.forEachLeafNode(function (node) { return totalRowCount += 1; });\n        return totalRowCount;\n    };\n    TotalRowsComp.prototype.init = function () {\n    };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    TotalRowsComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    __decorate$1X([\n        agGridCommunity.Autowired('gridApi')\n    ], TotalRowsComp.prototype, \"gridApi\", void 0);\n    __decorate$1X([\n        agGridCommunity.PostConstruct\n    ], TotalRowsComp.prototype, \"postConstruct\", null);\n    return TotalRowsComp;\n}(NameValueComp));\n\nvar __extends$33 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SelectedRowsComp = /** @class */ (function (_super) {\n    __extends$33(SelectedRowsComp, _super);\n    function SelectedRowsComp() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SelectedRowsComp.prototype.postConstruct = function () {\n        if (!this.isValidRowModel()) {\n            console.warn(\"AG Grid: agSelectedRowCountComponent should only be used with the client and server side row model.\");\n            return;\n        }\n        this.setLabel('selectedRows', 'Selected');\n        this.addCssClass('ag-status-panel');\n        this.addCssClass('ag-status-panel-selected-row-count');\n        var selectedRowCount = this.gridApi.getSelectedRows().length;\n        this.setValue(agGridCommunity._.formatNumberCommas(selectedRowCount));\n        this.setDisplayed(selectedRowCount > 0);\n        var eventListener = this.onRowSelectionChanged.bind(this);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, eventListener);\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_SELECTION_CHANGED, eventListener);\n    };\n    SelectedRowsComp.prototype.isValidRowModel = function () {\n        // this component is only really useful with client or server side rowmodels\n        var rowModelType = this.gridApi.getModel().getType();\n        return rowModelType === 'clientSide' || rowModelType === 'serverSide';\n    };\n    SelectedRowsComp.prototype.onRowSelectionChanged = function () {\n        var selectedRowCount = this.gridApi.getSelectedRows().length;\n        this.setValue(agGridCommunity._.formatNumberCommas(selectedRowCount));\n        this.setDisplayed(selectedRowCount > 0);\n    };\n    SelectedRowsComp.prototype.init = function () {\n    };\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    SelectedRowsComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    __decorate$1Y([\n        agGridCommunity.Autowired('gridApi')\n    ], SelectedRowsComp.prototype, \"gridApi\", void 0);\n    __decorate$1Y([\n        agGridCommunity.PostConstruct\n    ], SelectedRowsComp.prototype, \"postConstruct\", null);\n    return SelectedRowsComp;\n}(NameValueComp));\n\nvar __extends$34 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar AggregationComp = /** @class */ (function (_super) {\n    __extends$34(AggregationComp, _super);\n    function AggregationComp() {\n        return _super.call(this, AggregationComp.TEMPLATE) || this;\n    }\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    AggregationComp.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    AggregationComp.prototype.postConstruct = function () {\n        if (!this.isValidRowModel()) {\n            console.warn(\"AG Grid: agAggregationComponent should only be used with the client and server side row model.\");\n            return;\n        }\n        this.avgAggregationComp.setLabel('average', 'Average');\n        this.countAggregationComp.setLabel('count', 'Count');\n        this.minAggregationComp.setLabel('min', 'Min');\n        this.maxAggregationComp.setLabel('max', 'Max');\n        this.sumAggregationComp.setLabel('sum', 'Sum');\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_MODEL_UPDATED, this.onRangeSelectionChanged.bind(this));\n    };\n    AggregationComp.prototype.isValidRowModel = function () {\n        // this component is only really useful with client or server side rowmodels\n        var rowModelType = this.gridApi.getModel().getType();\n        return rowModelType === 'clientSide' || rowModelType === 'serverSide';\n    };\n    AggregationComp.prototype.init = function () {\n    };\n    AggregationComp.prototype.setAggregationComponentValue = function (aggFuncName, value, visible) {\n        var statusBarValueComponent = this.getAggregationValueComponent(aggFuncName);\n        if (agGridCommunity._.exists(statusBarValueComponent) && statusBarValueComponent) {\n            statusBarValueComponent.setValue(agGridCommunity._.formatNumberTwoDecimalPlacesAndCommas(value));\n            statusBarValueComponent.setDisplayed(visible);\n        }\n    };\n    AggregationComp.prototype.getAggregationValueComponent = function (aggFuncName) {\n        // converts user supplied agg name to our reference - eg: sum => sumAggregationComp\n        var refComponentName = aggFuncName + \"AggregationComp\";\n        // if the user has specified the agAggregationPanelComp but no aggFuncs we show the all\n        // if the user has specified the agAggregationPanelComp and aggFuncs, then we only show the aggFuncs listed\n        var statusBarValueComponent = null;\n        var aggregationPanelConfig = agGridCommunity._.exists(this.gridOptions.statusBar) && this.gridOptions.statusBar ? agGridCommunity._.find(this.gridOptions.statusBar.statusPanels, function (panel) { return panel.statusPanel === 'agAggregationComponent'; }) : null;\n        if (agGridCommunity._.exists(aggregationPanelConfig) && aggregationPanelConfig) {\n            // a little defensive here - if no statusPanelParams show it, if componentParams we also expect aggFuncs\n            if (!agGridCommunity._.exists(aggregationPanelConfig.statusPanelParams) ||\n                (agGridCommunity._.exists(aggregationPanelConfig.statusPanelParams) &&\n                    agGridCommunity._.exists(aggregationPanelConfig.statusPanelParams.aggFuncs) &&\n                    agGridCommunity._.exists(agGridCommunity._.find(aggregationPanelConfig.statusPanelParams.aggFuncs, function (func) { return func === aggFuncName; })))) {\n                statusBarValueComponent = this[refComponentName];\n            }\n        }\n        else {\n            // components not specified - assume we can show this component\n            statusBarValueComponent = this[refComponentName];\n        }\n        // either we can't find it (which would indicate a typo or similar user side), or the user has deliberately\n        // not listed the component in aggFuncs\n        return statusBarValueComponent;\n    };\n    AggregationComp.prototype.onRangeSelectionChanged = function () {\n        var _this = this;\n        var cellRanges = this.rangeController ? this.rangeController.getCellRanges() : undefined;\n        var sum = 0;\n        var count = 0;\n        var numberCount = 0;\n        var min = null;\n        var max = null;\n        var cellsSoFar = {};\n        if (cellRanges && !agGridCommunity._.missingOrEmpty(cellRanges)) {\n            cellRanges.forEach(function (cellRange) {\n                var currentRow = _this.rangeController.getRangeStartRow(cellRange);\n                var lastRow = _this.rangeController.getRangeEndRow(cellRange);\n                while (true) {\n                    var finishedAllRows = agGridCommunity._.missing(currentRow) || !currentRow || _this.rowPositionUtils.before(lastRow, currentRow);\n                    if (finishedAllRows || !currentRow || !cellRange.columns) {\n                        break;\n                    }\n                    cellRange.columns.forEach(function (col) {\n                        if (currentRow === null) {\n                            return;\n                        }\n                        // we only want to include each cell once, in case a cell is in multiple ranges\n                        var cellId = _this.cellPositionUtils.createId({\n                            rowPinned: currentRow.rowPinned,\n                            column: col,\n                            rowIndex: currentRow.rowIndex\n                        });\n                        if (cellsSoFar[cellId]) {\n                            return;\n                        }\n                        cellsSoFar[cellId] = true;\n                        var rowNode = _this.rowRenderer.getRowNode(currentRow);\n                        if (agGridCommunity._.missing(rowNode)) {\n                            return;\n                        }\n                        var value = _this.valueService.getValue(col, rowNode);\n                        // if empty cell, skip it, doesn't impact count or anything\n                        if (agGridCommunity._.missing(value) || value === '') {\n                            return;\n                        }\n                        // see if value is wrapped, can happen when doing count() or avg() functions\n                        if (value.value) {\n                            value = value.value;\n                        }\n                        if (typeof value === 'string') {\n                            value = Number(value);\n                        }\n                        if (typeof value === 'number' && !isNaN(value)) {\n                            sum += value;\n                            if (max === null || value > max) {\n                                max = value;\n                            }\n                            if (min === null || value < min) {\n                                min = value;\n                            }\n                            numberCount++;\n                        }\n                        count++;\n                    });\n                    currentRow = _this.cellNavigationService.getRowBelow(currentRow);\n                }\n            });\n        }\n        var gotResult = count > 1;\n        var gotNumberResult = numberCount > 1;\n        // we show count even if no numbers\n        this.setAggregationComponentValue('count', count, gotResult);\n        // show if numbers found\n        this.setAggregationComponentValue('sum', sum, gotNumberResult);\n        this.setAggregationComponentValue('min', min, gotNumberResult);\n        this.setAggregationComponentValue('max', max, gotNumberResult);\n        this.setAggregationComponentValue('avg', (sum / numberCount), gotNumberResult);\n    };\n    AggregationComp.TEMPLATE = \"<div class=\\\"ag-status-panel ag-status-panel-aggregations\\\">\\n            <ag-name-value ref=\\\"avgAggregationComp\\\"></ag-name-value>\\n            <ag-name-value ref=\\\"countAggregationComp\\\"></ag-name-value>\\n            <ag-name-value ref=\\\"minAggregationComp\\\"></ag-name-value>\\n            <ag-name-value ref=\\\"maxAggregationComp\\\"></ag-name-value>\\n            <ag-name-value ref=\\\"sumAggregationComp\\\"></ag-name-value>\\n        </div>\";\n    __decorate$1Z([\n        agGridCommunity.Optional('rangeController')\n    ], AggregationComp.prototype, \"rangeController\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('valueService')\n    ], AggregationComp.prototype, \"valueService\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('cellNavigationService')\n    ], AggregationComp.prototype, \"cellNavigationService\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('rowRenderer')\n    ], AggregationComp.prototype, \"rowRenderer\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('gridOptions')\n    ], AggregationComp.prototype, \"gridOptions\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('gridApi')\n    ], AggregationComp.prototype, \"gridApi\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('cellPositionUtils')\n    ], AggregationComp.prototype, \"cellPositionUtils\", void 0);\n    __decorate$1Z([\n        agGridCommunity.Autowired('rowPositionUtils')\n    ], AggregationComp.prototype, \"rowPositionUtils\", void 0);\n    __decorate$1Z([\n        agGridCommunity.RefSelector('sumAggregationComp')\n    ], AggregationComp.prototype, \"sumAggregationComp\", void 0);\n    __decorate$1Z([\n        agGridCommunity.RefSelector('countAggregationComp')\n    ], AggregationComp.prototype, \"countAggregationComp\", void 0);\n    __decorate$1Z([\n        agGridCommunity.RefSelector('minAggregationComp')\n    ], AggregationComp.prototype, \"minAggregationComp\", void 0);\n    __decorate$1Z([\n        agGridCommunity.RefSelector('maxAggregationComp')\n    ], AggregationComp.prototype, \"maxAggregationComp\", void 0);\n    __decorate$1Z([\n        agGridCommunity.RefSelector('avgAggregationComp')\n    ], AggregationComp.prototype, \"avgAggregationComp\", void 0);\n    __decorate$1Z([\n        agGridCommunity.PostConstruct\n    ], AggregationComp.prototype, \"postConstruct\", null);\n    return AggregationComp;\n}(agGridCommunity.Component));\n\nvar StatusBarModule = {\n    moduleName: agGridCommunity.ModuleNames.StatusBarModule,\n    beans: [StatusBarService],\n    agStackComponents: [\n        { componentName: 'AgStatusBar', componentClass: StatusBar },\n        { componentName: 'AgNameValue', componentClass: NameValueComp },\n    ],\n    userComponents: [\n        { componentName: 'agAggregationComponent', componentClass: AggregationComp },\n        { componentName: 'agSelectedRowCountComponent', componentClass: SelectedRowsComp },\n        { componentName: 'agTotalRowCountComponent', componentClass: TotalRowsComp },\n        { componentName: 'agFilteredRowCountComponent', componentClass: FilteredRowsComp },\n        { componentName: 'agTotalAndFilteredRowCountComponent', componentClass: TotalAndFilteredRowsComp }\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$35 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ViewportRowModel = /** @class */ (function (_super) {\n    __extends$35(ViewportRowModel, _super);\n    function ViewportRowModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // rowRenderer tells us these\n        _this.firstRow = -1;\n        _this.lastRow = -1;\n        // datasource tells us this\n        _this.rowCount = -1;\n        _this.rowNodesByIndex = {};\n        return _this;\n    }\n    // we don't implement as lazy row heights is not supported in this row model\n    ViewportRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) { return false; };\n    ViewportRowModel.prototype.init = function () {\n        this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n        this.addManagedListener(this.eventService, agGridCommunity.Events.EVENT_VIEWPORT_CHANGED, this.onViewportChanged.bind(this));\n    };\n    ViewportRowModel.prototype.start = function () {\n        if (this.gridOptionsWrapper.getViewportDatasource()) {\n            this.setViewportDatasource(this.gridOptionsWrapper.getViewportDatasource());\n        }\n    };\n    ViewportRowModel.prototype.isLastRowIndexKnown = function () {\n        return true;\n    };\n    ViewportRowModel.prototype.destroyDatasource = function () {\n        if (!this.viewportDatasource) {\n            return;\n        }\n        if (this.viewportDatasource.destroy) {\n            this.viewportDatasource.destroy();\n        }\n        this.rowRenderer.datasourceChanged();\n        this.firstRow = -1;\n        this.lastRow = -1;\n    };\n    ViewportRowModel.prototype.calculateFirstRow = function (firstRenderedRow) {\n        var bufferSize = this.gridOptionsWrapper.getViewportRowModelBufferSize();\n        var pageSize = this.gridOptionsWrapper.getViewportRowModelPageSize();\n        var afterBuffer = firstRenderedRow - bufferSize;\n        if (afterBuffer < 0) {\n            return 0;\n        }\n        return Math.floor(afterBuffer / pageSize) * pageSize;\n    };\n    ViewportRowModel.prototype.calculateLastRow = function (lastRenderedRow) {\n        if (lastRenderedRow === -1) {\n            return lastRenderedRow;\n        }\n        var bufferSize = this.gridOptionsWrapper.getViewportRowModelBufferSize();\n        var pageSize = this.gridOptionsWrapper.getViewportRowModelPageSize();\n        var afterBuffer = lastRenderedRow + bufferSize;\n        var result = Math.ceil(afterBuffer / pageSize) * pageSize;\n        var lastRowIndex = this.rowCount - 1;\n        return Math.min(result, lastRowIndex);\n    };\n    ViewportRowModel.prototype.onViewportChanged = function (event) {\n        var newFirst = this.calculateFirstRow(event.firstRow);\n        var newLast = this.calculateLastRow(event.lastRow);\n        if (this.firstRow !== newFirst || this.lastRow !== newLast) {\n            this.firstRow = newFirst;\n            this.lastRow = newLast;\n            this.purgeRowsNotInViewport();\n            if (this.viewportDatasource) {\n                this.viewportDatasource.setViewportRange(this.firstRow, this.lastRow);\n            }\n        }\n    };\n    ViewportRowModel.prototype.purgeRowsNotInViewport = function () {\n        var _this = this;\n        Object.keys(this.rowNodesByIndex).forEach(function (indexStr) {\n            var index = parseInt(indexStr, 10);\n            if (index < _this.firstRow || index > _this.lastRow) {\n                delete _this.rowNodesByIndex[index];\n            }\n        });\n    };\n    ViewportRowModel.prototype.setViewportDatasource = function (viewportDatasource) {\n        this.destroyDatasource();\n        this.viewportDatasource = viewportDatasource;\n        this.rowCount = 0;\n        if (!viewportDatasource.init) {\n            console.warn('AG Grid: viewport is missing init method.');\n        }\n        else {\n            viewportDatasource.init({\n                setRowCount: this.setRowCount.bind(this),\n                setRowData: this.setRowData.bind(this),\n                getRow: this.getRow.bind(this)\n            });\n        }\n    };\n    ViewportRowModel.prototype.getType = function () {\n        return agGridCommunity.Constants.ROW_MODEL_TYPE_VIEWPORT;\n    };\n    ViewportRowModel.prototype.getRow = function (rowIndex) {\n        if (!this.rowNodesByIndex[rowIndex]) {\n            this.rowNodesByIndex[rowIndex] = this.createBlankRowNode(rowIndex);\n        }\n        return this.rowNodesByIndex[rowIndex];\n    };\n    ViewportRowModel.prototype.getRowNode = function (id) {\n        var result = null;\n        this.forEachNode(function (rowNode) {\n            if (rowNode.id === id) {\n                result = rowNode;\n            }\n        });\n        return result;\n    };\n    ViewportRowModel.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n    ViewportRowModel.prototype.getRowIndexAtPixel = function (pixel) {\n        if (this.rowHeight !== 0) { // avoid divide by zero error\n            return Math.floor(pixel / this.rowHeight);\n        }\n        return 0;\n    };\n    ViewportRowModel.prototype.getRowBounds = function (index) {\n        return {\n            rowHeight: this.rowHeight,\n            rowTop: this.rowHeight * index\n        };\n    };\n    ViewportRowModel.prototype.getTopLevelRowCount = function () {\n        return this.getRowCount();\n    };\n    ViewportRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        return topLevelIndex;\n    };\n    ViewportRowModel.prototype.isEmpty = function () {\n        return this.rowCount > 0;\n    };\n    ViewportRowModel.prototype.isRowsToRender = function () {\n        return this.rowCount > 0;\n    };\n    ViewportRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        var firstIndex = agGridCommunity._.missing(firstInRange) ? 0 : firstInRange.rowIndex;\n        var lastIndex = lastInRange.rowIndex;\n        var firstNodeOutOfRange = firstIndex < this.firstRow || firstIndex > this.lastRow;\n        var lastNodeOutOfRange = lastIndex < this.firstRow || lastIndex > this.lastRow;\n        if (firstNodeOutOfRange || lastNodeOutOfRange) {\n            return [];\n        }\n        var result = [];\n        var startIndex = firstIndex <= lastIndex ? firstIndex : lastIndex;\n        var endIndex = firstIndex <= lastIndex ? lastIndex : firstIndex;\n        for (var i = startIndex; i <= endIndex; i++) {\n            result.push(this.rowNodesByIndex[i]);\n        }\n        return result;\n    };\n    ViewportRowModel.prototype.forEachNode = function (callback) {\n        var _this = this;\n        var callbackCount = 0;\n        Object.keys(this.rowNodesByIndex).forEach(function (indexStr) {\n            var index = parseInt(indexStr, 10);\n            var rowNode = _this.rowNodesByIndex[index];\n            callback(rowNode, callbackCount);\n            callbackCount++;\n        });\n    };\n    ViewportRowModel.prototype.setRowData = function (rowData) {\n        var _this = this;\n        agGridCommunity._.iterateObject(rowData, function (indexStr, dataItem) {\n            var index = parseInt(indexStr, 10);\n            // we should never keep rows that we didn't specifically ask for, this\n            // guarantees the contract we have with the server.\n            if (index >= _this.firstRow && index <= _this.lastRow) {\n                var rowNode = _this.rowNodesByIndex[index];\n                // the abnormal case is we requested a row even though the grid didn't need it\n                // as a result of the paging and buffer (ie the row is off screen), in which\n                // case we need to create a new node now\n                if (agGridCommunity._.missing(rowNode)) {\n                    rowNode = _this.createBlankRowNode(index);\n                    _this.rowNodesByIndex[index] = rowNode;\n                }\n                // now we deffo have a row node, so set in the details\n                // if the grid already asked for this row (the normal case), then we would\n                // of put a placeholder node in place.\n                rowNode.setDataAndId(dataItem, index.toString());\n            }\n        });\n    };\n    ViewportRowModel.prototype.createBlankRowNode = function (rowIndex) {\n        var rowNode = new agGridCommunity.RowNode();\n        this.createBean(rowNode);\n        rowNode.setRowHeight(this.rowHeight);\n        rowNode.setRowTop(this.rowHeight * rowIndex);\n        rowNode.setRowIndex(rowIndex);\n        return rowNode;\n    };\n    ViewportRowModel.prototype.setRowCount = function (rowCount, keepRenderedRows) {\n        if (keepRenderedRows === void 0) { keepRenderedRows = false; }\n        if (rowCount === this.rowCount) {\n            return;\n        }\n        this.rowCount = rowCount;\n        var event = {\n            type: agGridCommunity.Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            newData: false,\n            newPage: false,\n            keepRenderedRows: keepRenderedRows,\n            animate: false\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ViewportRowModel.prototype.isRowPresent = function (rowNode) {\n        return false;\n    };\n    __decorate$1_([\n        agGridCommunity.Autowired('gridApi')\n    ], ViewportRowModel.prototype, \"gridApi\", void 0);\n    __decorate$1_([\n        agGridCommunity.Autowired('columnApi')\n    ], ViewportRowModel.prototype, \"columnApi\", void 0);\n    __decorate$1_([\n        agGridCommunity.Autowired('rowRenderer')\n    ], ViewportRowModel.prototype, \"rowRenderer\", void 0);\n    __decorate$1_([\n        agGridCommunity.PostConstruct\n    ], ViewportRowModel.prototype, \"init\", null);\n    __decorate$1_([\n        agGridCommunity.PreDestroy\n    ], ViewportRowModel.prototype, \"destroyDatasource\", null);\n    ViewportRowModel = __decorate$1_([\n        agGridCommunity.Bean('rowModel')\n    ], ViewportRowModel);\n    return ViewportRowModel;\n}(agGridCommunity.BeanStub));\n\nvar ViewportRowModelModule = {\n    moduleName: agGridCommunity.ModuleNames.ViewportRowModelModule,\n    rowModels: { viewport: ViewportRowModel },\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n\nvar __extends$36 = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate$1$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ClipboardService = /** @class */ (function (_super) {\n    __extends$36(ClipboardService, _super);\n    function ClipboardService() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ClipboardService.prototype.registerGridCore = function (gridCore) {\n        this.gridCore = gridCore;\n    };\n    ClipboardService.prototype.init = function () {\n        this.logger = this.loggerFactory.create('ClipboardService');\n        if (this.rowModel.getType() === agGridCommunity.Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            this.clientSideRowModel = this.rowModel;\n        }\n    };\n    ClipboardService.prototype.pasteFromClipboard = function () {\n        var _this = this;\n        this.logger.log('pasteFromClipboard');\n        // Method 1 - native clipboard API, available in modern chrome browsers\n        var allowNavigator = !this.gridOptionsWrapper.isSuppressClipboardApi();\n        // Some browsers (Firefox) do not allow Web Applications to read from\n        // the clipboard so verify if not only the ClipboardAPI is available,\n        // but also if the `readText` method is public.\n        if (allowNavigator && navigator.clipboard && navigator.clipboard.readText) {\n            navigator.clipboard.readText()\n                .then(this.processClipboardData.bind(this))\n                .catch(function (e) {\n                agGridCommunity._.doOnce(function () {\n                    console.warn(e);\n                    console.warn('AG Grid: Unable to use the Clipboard API (navigator.clipboard.readText()). ' +\n                        'The reason why it could not be used has been logged in the previous line. ' +\n                        'For this reason the grid has defaulted to using a workaround which doesn\\'t perform as well. ' +\n                        'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +\n                        'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API');\n                }, 'clipboardApiError');\n                _this.pasteFromClipboardLegacy();\n            });\n        }\n        else {\n            this.pasteFromClipboardLegacy();\n        }\n    };\n    ClipboardService.prototype.pasteFromClipboardLegacy = function () {\n        var _this = this;\n        // Method 2 - if modern API fails, the old school hack\n        this.executeOnTempElement(function (textArea) { return textArea.focus({ preventScroll: true }); }, function (element) {\n            var data = element.value;\n            _this.processClipboardData(data);\n        });\n    };\n    ClipboardService.prototype.processClipboardData = function (data) {\n        var _this = this;\n        if (data == null) {\n            return;\n        }\n        var parsedData = agGridCommunity._.stringToArray(data, this.gridOptionsWrapper.getClipboardDeliminator());\n        var userFunc = this.gridOptionsWrapper.getProcessDataFromClipboardFunc();\n        if (userFunc) {\n            parsedData = userFunc({ data: parsedData });\n        }\n        if (parsedData == null) {\n            return;\n        }\n        if (this.gridOptionsWrapper.isSuppressLastEmptyLineOnPaste()) {\n            this.removeLastLineIfBlank(parsedData);\n        }\n        var pasteOperation = function (cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n            var rangeActive = _this.rangeController && _this.rangeController.isMoreThanOneCell();\n            var pasteIntoRange = rangeActive && !_this.hasOnlyOneValueToPaste(parsedData);\n            if (pasteIntoRange) {\n                _this.pasteIntoActiveRange(parsedData, cellsToFlash, updatedRowNodes, changedPath);\n            }\n            else {\n                _this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n            }\n        };\n        this.doPasteOperation(pasteOperation);\n    };\n    // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n    ClipboardService.prototype.doPasteOperation = function (pasteOperationFunc) {\n        var api = this.gridOptionsWrapper.getApi();\n        var columnApi = this.gridOptionsWrapper.getColumnApi();\n        var source = 'clipboard';\n        this.eventService.dispatchEvent({\n            type: agGridCommunity.Events.EVENT_PASTE_START,\n            api: api,\n            columnApi: columnApi,\n            source: source\n        });\n        var changedPath;\n        if (this.clientSideRowModel) {\n            var onlyChangedColumns = this.gridOptionsWrapper.isAggregateOnlyChangedColumns();\n            changedPath = new agGridCommunity.ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n        }\n        var cellsToFlash = {};\n        var updatedRowNodes = [];\n        var focusedCell = this.focusController.getFocusedCell();\n        pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n        if (changedPath) {\n            this.clientSideRowModel.doAggregate(changedPath);\n        }\n        this.rowRenderer.refreshCells();\n        this.dispatchFlashCells(cellsToFlash);\n        this.fireRowChanged(updatedRowNodes);\n        // if using the clipboard hack with a temp element, then the focus has been lost,\n        // so need to put it back. otherwise paste operation loosed focus on cell and keyboard\n        // navigation stops.\n        if (focusedCell) {\n            this.focusController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.rowPinned, true);\n        }\n        this.eventService.dispatchEvent({\n            type: agGridCommunity.Events.EVENT_PASTE_END,\n            api: api,\n            columnApi: columnApi,\n            source: source\n        });\n    };\n    ClipboardService.prototype.pasteIntoActiveRange = function (clipboardData, cellsToFlash, updatedRowNodes, changedPath) {\n        var _this = this;\n        // true if clipboard data can be evenly pasted into range, otherwise false\n        var abortRepeatingPasteIntoRows = this.getRangeSize() % clipboardData.length != 0;\n        var indexOffset = 0;\n        var dataRowIndex = 0;\n        var rowCallback = function (currentRow, rowNode, columns, index) {\n            var atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n            if (atEndOfClipboardData) {\n                if (abortRepeatingPasteIntoRows) {\n                    return;\n                }\n                // increment offset and reset data index to repeat paste of data\n                indexOffset += dataRowIndex;\n                dataRowIndex = 0;\n            }\n            var currentRowData = clipboardData[index - indexOffset];\n            // otherwise we are not the first row, so copy\n            updatedRowNodes.push(rowNode);\n            var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n            columns.forEach(function (column, idx) {\n                if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n                    return;\n                }\n                // repeat data for columns we don't have data for - happens when to range is bigger than copied data range\n                if (idx >= currentRowData.length) {\n                    idx = idx % currentRowData.length;\n                }\n                var newValue = _this.processCell(rowNode, column, currentRowData[idx], agGridCommunity.Constants.EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc);\n                _this.valueService.setValue(rowNode, column, newValue, agGridCommunity.Constants.SOURCE_PASTE);\n                if (changedPath) {\n                    changedPath.addParentNode(rowNode.parent, [column]);\n                }\n                var cellId = _this.cellPositionUtils.createIdFromValues(currentRow.rowIndex, column, currentRow.rowPinned);\n                cellsToFlash[cellId] = true;\n            });\n            dataRowIndex++;\n        };\n        this.iterateActiveRanges(false, rowCallback);\n    };\n    ClipboardService.prototype.pasteStartingFromFocusedCell = function (parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n        if (!focusedCell) {\n            return;\n        }\n        var currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n        var columnsToPasteInto = this.columnController.getDisplayedColumnsStartingAt(focusedCell.column);\n        if (this.isPasteSingleValueIntoRange(parsedData)) {\n            this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n        }\n        else {\n            this.pasteMultipleValues(parsedData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, agGridCommunity.Constants.EXPORT_TYPE_CLIPBOARD, changedPath);\n        }\n    };\n    // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n    ClipboardService.prototype.isPasteSingleValueIntoRange = function (parsedData) {\n        return this.hasOnlyOneValueToPaste(parsedData)\n            && this.rangeController != null\n            && !this.rangeController.isEmpty();\n    };\n    ClipboardService.prototype.pasteSingleValueIntoRange = function (parsedData, updatedRowNodes, cellsToFlash, changedPath) {\n        var _this = this;\n        var value = parsedData[0][0];\n        var rowCallback = function (currentRow, rowNode, columns) {\n            updatedRowNodes.push(rowNode);\n            columns.forEach(function (column) {\n                return _this.updateCellValue(rowNode, column, value, currentRow, cellsToFlash, agGridCommunity.Constants.EXPORT_TYPE_CLIPBOARD, changedPath);\n            });\n        };\n        this.iterateActiveRanges(false, rowCallback);\n    };\n    ClipboardService.prototype.hasOnlyOneValueToPaste = function (parsedData) {\n        return parsedData.length === 1 && parsedData[0].length === 1;\n    };\n    ClipboardService.prototype.copyRangeDown = function () {\n        var _this = this;\n        if (!this.rangeController || this.rangeController.isEmpty()) {\n            return;\n        }\n        var firstRowValues = [];\n        var pasteOperation = function (cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n            var processCellForClipboardFunc = _this.gridOptionsWrapper.getProcessCellForClipboardFunc();\n            var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n            var rowCallback = function (currentRow, rowNode, columns) {\n                // take reference of first row, this is the one we will be using to copy from\n                if (!firstRowValues.length) {\n                    // two reasons for looping through columns\n                    columns.forEach(function (column) {\n                        // get the initial values to copy down\n                        var value = _this.processCell(rowNode, column, _this.valueService.getValue(column, rowNode), agGridCommunity.Constants.EXPORT_TYPE_DRAG_COPY, processCellForClipboardFunc);\n                        firstRowValues.push(value);\n                    });\n                }\n                else {\n                    // otherwise we are not the first row, so copy\n                    updatedRowNodes.push(rowNode);\n                    columns.forEach(function (column, index) {\n                        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n                            return;\n                        }\n                        var firstRowValue = _this.processCell(rowNode, column, firstRowValues[index], agGridCommunity.Constants.EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc);\n                        _this.valueService.setValue(rowNode, column, firstRowValue, agGridCommunity.Constants.SOURCE_PASTE);\n                        if (changedPath) {\n                            changedPath.addParentNode(rowNode.parent, [column]);\n                        }\n                        var cellId = _this.cellPositionUtils.createIdFromValues(currentRow.rowIndex, column, currentRow.rowPinned);\n                        cellsToFlash[cellId] = true;\n                    });\n                }\n            };\n            _this.iterateActiveRanges(true, rowCallback);\n        };\n        this.doPasteOperation(pasteOperation);\n    };\n    ClipboardService.prototype.removeLastLineIfBlank = function (parsedData) {\n        // remove last row if empty, excel puts empty last row in\n        var lastLine = agGridCommunity._.last(parsedData);\n        var lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === '';\n        if (lastLineIsBlank) {\n            agGridCommunity._.removeFromArray(parsedData, lastLine);\n        }\n    };\n    ClipboardService.prototype.fireRowChanged = function (rowNodes) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isFullRowEdit()) {\n            return;\n        }\n        rowNodes.forEach(function (rowNode) {\n            var event = {\n                type: agGridCommunity.Events.EVENT_ROW_VALUE_CHANGED,\n                node: rowNode,\n                data: rowNode.data,\n                rowIndex: rowNode.rowIndex,\n                rowPinned: rowNode.rowPinned,\n                context: _this.gridOptionsWrapper.getContext(),\n                api: _this.gridOptionsWrapper.getApi(),\n                columnApi: _this.gridOptionsWrapper.getColumnApi()\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n    };\n    ClipboardService.prototype.pasteMultipleValues = function (clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {\n        var _this = this;\n        var rowPointer = currentRow;\n        clipboardGridData.forEach(function (clipboardRowData) {\n            // if we have come to end of rows in grid, then skip\n            if (!rowPointer) {\n                return;\n            }\n            var rowNode = _this.rowPositionUtils.getRowNode(rowPointer);\n            if (rowNode) {\n                updatedRowNodes.push(rowNode);\n                clipboardRowData.forEach(function (value, index) {\n                    return _this.updateCellValue(rowNode, columnsToPasteInto[index], value, rowPointer, cellsToFlash, type, changedPath);\n                });\n                // move to next row down for next set of values\n                rowPointer = _this.cellNavigationService.getRowBelow({ rowPinned: rowPointer.rowPinned, rowIndex: rowPointer.rowIndex });\n            }\n        });\n        return rowPointer;\n    };\n    ClipboardService.prototype.updateCellValue = function (rowNode, column, value, currentRow, cellsToFlash, type, changedPath) {\n        if (!rowNode ||\n            !currentRow ||\n            !column ||\n            !column.isCellEditable(rowNode) ||\n            column.isSuppressPaste(rowNode)) {\n            return;\n        }\n        var processedValue = this.processCell(rowNode, column, value, type, this.gridOptionsWrapper.getProcessCellFromClipboardFunc());\n        this.valueService.setValue(rowNode, column, processedValue, agGridCommunity.Constants.SOURCE_PASTE);\n        var cellId = this.cellPositionUtils.createIdFromValues(currentRow.rowIndex, column, currentRow.rowPinned);\n        cellsToFlash[cellId] = true;\n        if (changedPath) {\n            changedPath.addParentNode(rowNode.parent, [column]);\n        }\n    };\n    ClipboardService.prototype.copyToClipboard = function (includeHeaders) {\n        this.logger.log(\"copyToClipboard: includeHeaders = \" + includeHeaders);\n        // don't override 'includeHeaders' if it has been explicitly set to 'false'\n        if (includeHeaders == null) {\n            includeHeaders = this.gridOptionsWrapper.isCopyHeadersToClipboard();\n        }\n        var selectedRowsToCopy = !this.selectionController.isEmpty()\n            && !this.gridOptionsWrapper.isSuppressCopyRowsToClipboard();\n        // default is copy range if exists, otherwise rows\n        if (this.rangeController && this.rangeController.isMoreThanOneCell()) {\n            this.copySelectedRangeToClipboard(includeHeaders);\n        }\n        else if (selectedRowsToCopy) {\n            // otherwise copy selected rows if they exist\n            this.copySelectedRowsToClipboard(includeHeaders);\n        }\n        else if (this.focusController.isAnyCellFocused()) {\n            // if there is a focused cell, copy this\n            this.copyFocusedCellToClipboard(includeHeaders);\n        }\n        else {\n            // lastly if no focused cell, try range again. this can happen\n            // if use has cellSelection turned off (so no focused cell)\n            // but has a cell clicked, so there exists a cell range\n            // of exactly one cell (hence the first 'if' above didn't\n            // get executed).\n            this.copySelectedRangeToClipboard(includeHeaders);\n        }\n    };\n    ClipboardService.prototype.iterateActiveRanges = function (onlyFirst, rowCallback, columnCallback) {\n        var _this = this;\n        if (!this.rangeController || this.rangeController.isEmpty()) {\n            return;\n        }\n        var cellRanges = this.rangeController.getCellRanges();\n        if (onlyFirst) {\n            this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n        }\n        else {\n            cellRanges.forEach(function (range, idx) { return _this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1); });\n        }\n    };\n    ClipboardService.prototype.iterateActiveRange = function (range, rowCallback, columnCallback, isLastRange) {\n        if (!this.rangeController) {\n            return;\n        }\n        var currentRow = this.rangeController.getRangeStartRow(range);\n        var lastRow = this.rangeController.getRangeEndRow(range);\n        if (columnCallback && range.columns) {\n            columnCallback(range.columns);\n        }\n        var rangeIndex = 0;\n        var isLastRow = false;\n        // the currentRow could be missing if the user sets the active range manually, and sets a range\n        // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).\n        while (!isLastRow && currentRow != null) {\n            var rowNode = this.rowPositionUtils.getRowNode(currentRow);\n            isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n            rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n            currentRow = this.cellNavigationService.getRowBelow(currentRow);\n        }\n    };\n    ClipboardService.prototype.copySelectedRangeToClipboard = function (includeHeaders) {\n        var _this = this;\n        if (includeHeaders === void 0) { includeHeaders = false; }\n        if (!this.rangeController || this.rangeController.isEmpty()) {\n            return;\n        }\n        var deliminator = this.gridOptionsWrapper.getClipboardDeliminator();\n        var data = '';\n        var cellsToFlash = {};\n        // adds columns to the data\n        var columnCallback = function (columns) {\n            if (!includeHeaders) {\n                return;\n            }\n            var processHeaderForClipboardFunc = _this.gridOptionsWrapper.getProcessHeaderForClipboardFunc();\n            var columnNames = columns.map(function (column) {\n                var name = _this.columnController.getDisplayNameForColumn(column, 'clipboard', true);\n                return _this.processHeader(column, name, processHeaderForClipboardFunc) || '';\n            });\n            data += columnNames.join(deliminator) + '\\r\\n';\n        };\n        // adds cell values to the data\n        var rowCallback = function (currentRow, rowNode, columns, _2, isLastRow) {\n            var processCellForClipboardFunc = _this.gridOptionsWrapper.getProcessCellForClipboardFunc();\n            columns.forEach(function (column, index) {\n                var value = _this.valueService.getValue(column, rowNode);\n                var processedValue = _this.processCell(rowNode, column, value, agGridCommunity.Constants.EXPORT_TYPE_CLIPBOARD, processCellForClipboardFunc);\n                if (index != 0) {\n                    data += deliminator;\n                }\n                if (agGridCommunity._.exists(processedValue)) {\n                    data += processedValue;\n                }\n                var cellId = _this.cellPositionUtils.createIdFromValues(currentRow.rowIndex, column, currentRow.rowPinned);\n                cellsToFlash[cellId] = true;\n            });\n            if (!isLastRow) {\n                data += '\\r\\n';\n            }\n        };\n        this.iterateActiveRanges(false, rowCallback, columnCallback);\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells(cellsToFlash);\n    };\n    ClipboardService.prototype.copyFocusedCellToClipboard = function (includeHeaders) {\n        var _a;\n        if (includeHeaders === void 0) { includeHeaders = false; }\n        var focusedCell = this.focusController.getFocusedCell();\n        if (focusedCell == null) {\n            return;\n        }\n        var cellId = this.cellPositionUtils.createId(focusedCell);\n        var currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n        var rowNode = this.rowPositionUtils.getRowNode(currentRow);\n        var column = focusedCell.column;\n        var value = this.valueService.getValue(column, rowNode);\n        var processedValue = this.processCell(rowNode, column, value, agGridCommunity.Constants.EXPORT_TYPE_CLIPBOARD, this.gridOptionsWrapper.getProcessCellForClipboardFunc());\n        processedValue = agGridCommunity._.missing(processedValue) ? '' : processedValue.toString();\n        var data;\n        if (includeHeaders) {\n            var headerValue = this.columnController.getDisplayNameForColumn(column, 'clipboard', true);\n            data = this.processHeader(column, headerValue, this.gridOptionsWrapper.getProcessHeaderForClipboardFunc()) + '\\r\\n' + processedValue;\n        }\n        else {\n            data = processedValue;\n        }\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells((_a = {}, _a[cellId] = true, _a));\n    };\n    ClipboardService.prototype.dispatchFlashCells = function (cellsToFlash) {\n        var _this = this;\n        window.setTimeout(function () {\n            var event = {\n                type: agGridCommunity.Events.EVENT_FLASH_CELLS,\n                cells: cellsToFlash,\n                api: _this.gridApi,\n                columnApi: _this.columnApi\n            };\n            _this.eventService.dispatchEvent(event);\n        }, 0);\n    };\n    ClipboardService.prototype.processCell = function (rowNode, column, value, type, func) {\n        if (func) {\n            var params = {\n                column: column,\n                node: rowNode,\n                value: value,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n                type: type,\n            };\n            return func(params);\n        }\n        return value;\n    };\n    ClipboardService.prototype.processHeader = function (column, value, func) {\n        if (func) {\n            var params = {\n                column: column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            return func(params);\n        }\n        return value;\n    };\n    ClipboardService.prototype.copySelectedRowsToClipboard = function (includeHeaders, columnKeys) {\n        if (includeHeaders === void 0) { includeHeaders = false; }\n        var params = {\n            columnKeys: columnKeys,\n            skipHeader: !includeHeaders,\n            skipFooters: true,\n            suppressQuotes: true,\n            columnSeparator: this.gridOptionsWrapper.getClipboardDeliminator(),\n            onlySelected: true,\n            processCellCallback: this.gridOptionsWrapper.getProcessCellForClipboardFunc(),\n            processHeaderCallback: this.gridOptionsWrapper.getProcessHeaderForClipboardFunc()\n        };\n        var data = this.csvCreator.getDataAsCsv(params);\n        this.copyDataToClipboard(data);\n    };\n    ClipboardService.prototype.copyDataToClipboard = function (data) {\n        var _this = this;\n        var userProvidedFunc = this.gridOptionsWrapper.getSendToClipboardFunc();\n        // method 1 - user provided func\n        if (userProvidedFunc) {\n            userProvidedFunc({ data: data });\n            return;\n        }\n        // method 2 - native clipboard API, available in modern chrome browsers\n        var allowNavigator = !this.gridOptionsWrapper.isSuppressClipboardApi();\n        if (allowNavigator && navigator.clipboard) {\n            navigator.clipboard.writeText(data).catch(function (e) {\n                agGridCommunity._.doOnce(function () {\n                    console.warn(e);\n                    console.warn('AG Grid: Unable to use the Clipboard API (navigator.clipboard.writeText()). ' +\n                        'The reason why it could not be used has been logged in the previous line. ' +\n                        'For this reason the grid has defaulted to using a workaround which doesn\\'t perform as well. ' +\n                        'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +\n                        'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.');\n                }, 'clipboardApiError');\n                _this.copyDataToClipboardLegacy(data);\n            });\n            return;\n        }\n        this.copyDataToClipboardLegacy(data);\n    };\n    ClipboardService.prototype.copyDataToClipboardLegacy = function (data) {\n        var _this = this;\n        // method 3 - if all else fails, the old school hack\n        this.executeOnTempElement(function (element) {\n            var focusedElementBefore = _this.gridOptionsWrapper.getDocument().activeElement;\n            element.value = data || ' '; // has to be non-empty value or execCommand will not do anything\n            element.select();\n            element.focus({ preventScroll: true });\n            var result = document.execCommand('copy');\n            if (!result) {\n                console.warn('ag-grid: Browser did not allow document.execCommand(\\'copy\\'). Ensure ' +\n                    'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise ' +\n                    'the browser will prevent it for security reasons.');\n            }\n            if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n                focusedElementBefore.focus({ preventScroll: true });\n            }\n        });\n    };\n    ClipboardService.prototype.executeOnTempElement = function (callbackNow, callbackAfter) {\n        var eDoc = this.gridOptionsWrapper.getDocument();\n        var eTempInput = eDoc.createElement('textarea');\n        eTempInput.style.width = '1px';\n        eTempInput.style.height = '1px';\n        // removing items from the DOM causes the document element to scroll to the\n        // position where the element was positioned. Here we set scrollTop / scrollLeft\n        // to prevent the document element from scrolling when we remove it from the DOM.\n        eTempInput.style.top = eDoc.documentElement.scrollTop + 'px';\n        eTempInput.style.left = eDoc.documentElement.scrollLeft + 'px';\n        eTempInput.style.position = 'absolute';\n        eTempInput.style.opacity = '0';\n        var guiRoot = this.gridCore.getRootGui();\n        guiRoot.appendChild(eTempInput);\n        try {\n            callbackNow(eTempInput);\n        }\n        catch (err) {\n            console.warn('ag-grid: Browser does not support document.execCommand(\\'copy\\') for clipboard operations');\n        }\n        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...\n        if (callbackAfter) {\n            window.setTimeout(function () {\n                callbackAfter(eTempInput);\n                guiRoot.removeChild(eTempInput);\n            }, 100);\n        }\n        else {\n            guiRoot.removeChild(eTempInput);\n        }\n    };\n    ClipboardService.prototype.getRangeSize = function () {\n        var ranges = this.rangeController.getCellRanges();\n        var startRangeIndex = 0;\n        var endRangeIndex = 0;\n        if (ranges.length > 0) {\n            startRangeIndex = this.rangeController.getRangeStartRow(ranges[0]).rowIndex;\n            endRangeIndex = this.rangeController.getRangeEndRow(ranges[0]).rowIndex;\n        }\n        return startRangeIndex - endRangeIndex + 1;\n    };\n    __decorate$1$([\n        agGridCommunity.Autowired('csvCreator')\n    ], ClipboardService.prototype, \"csvCreator\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('loggerFactory')\n    ], ClipboardService.prototype, \"loggerFactory\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('selectionController')\n    ], ClipboardService.prototype, \"selectionController\", void 0);\n    __decorate$1$([\n        agGridCommunity.Optional('rangeController')\n    ], ClipboardService.prototype, \"rangeController\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('rowModel')\n    ], ClipboardService.prototype, \"rowModel\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('valueService')\n    ], ClipboardService.prototype, \"valueService\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('focusController')\n    ], ClipboardService.prototype, \"focusController\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('rowRenderer')\n    ], ClipboardService.prototype, \"rowRenderer\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('columnController')\n    ], ClipboardService.prototype, \"columnController\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('cellNavigationService')\n    ], ClipboardService.prototype, \"cellNavigationService\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('columnApi')\n    ], ClipboardService.prototype, \"columnApi\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('gridApi')\n    ], ClipboardService.prototype, \"gridApi\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('cellPositionUtils')\n    ], ClipboardService.prototype, \"cellPositionUtils\", void 0);\n    __decorate$1$([\n        agGridCommunity.Autowired('rowPositionUtils')\n    ], ClipboardService.prototype, \"rowPositionUtils\", void 0);\n    __decorate$1$([\n        agGridCommunity.PostConstruct\n    ], ClipboardService.prototype, \"init\", null);\n    ClipboardService = __decorate$1$([\n        agGridCommunity.Bean('clipboardService')\n    ], ClipboardService);\n    return ClipboardService;\n}(agGridCommunity.BeanStub));\n\nvar ClipboardModule = {\n    moduleName: agGridCommunity.ModuleNames.ClipboardModule,\n    beans: [ClipboardService],\n    dependantModules: [\n        EnterpriseCoreModule,\n        CsvExportModule\n    ]\n};\n\nagGridCommunity.ModuleRegistry.register(ColumnsToolPanelModule, false);\nagGridCommunity.ModuleRegistry.register(ExcelExportModule, false);\nagGridCommunity.ModuleRegistry.register(FiltersToolPanelModule, false);\nagGridCommunity.ModuleRegistry.register(GridChartsModule, false);\nagGridCommunity.ModuleRegistry.register(MasterDetailModule, false);\nagGridCommunity.ModuleRegistry.register(MenuModule, false);\nagGridCommunity.ModuleRegistry.register(MultiFilterModule, false);\nagGridCommunity.ModuleRegistry.register(RangeSelectionModule, false);\nagGridCommunity.ModuleRegistry.register(RichSelectModule, false);\nagGridCommunity.ModuleRegistry.register(RowGroupingModule, false);\nagGridCommunity.ModuleRegistry.register(ServerSideRowModelModule, false);\nagGridCommunity.ModuleRegistry.register(SetFilterModule, false);\nagGridCommunity.ModuleRegistry.register(SideBarModule, false);\nagGridCommunity.ModuleRegistry.register(StatusBarModule, false);\nagGridCommunity.ModuleRegistry.register(ViewportRowModelModule, false);\nagGridCommunity.ModuleRegistry.register(ClipboardModule, false);\n\nObject.defineProperty(exports, 'VirtualList', {\n    enumerable: true,\n    get: function () {\n        return agGridCommunity.VirtualList;\n    }\n});\nexports.LicenseManager = LicenseManager;\nexports.SetFilter = SetFilter;\n\n\n//# sourceURL=webpack:///./node_modules/ag-grid-enterprise/dist/ag-grid-enterprise.cjs.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/date-to-iso-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-iso-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar padStart = __webpack_require__(/*! ../internals/string-pad */ \"./node_modules/core-js/internals/string-pad.js\").start;\n\nvar abs = Math.abs;\nvar DatePrototype = Date.prototype;\nvar getTime = DatePrototype.getTime;\nvar nativeDateToISOString = DatePrototype.toISOString;\n\n// `Date.prototype.toISOString` method implementation\n// https://tc39.es/ecma262/#sec-date.prototype.toisostring\n// PhantomJS / old WebKit fails here:\nmodule.exports = (fails(function () {\n  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';\n}) || !fails(function () {\n  nativeDateToISOString.call(new Date(NaN));\n})) ? function toISOString() {\n  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');\n  var date = this;\n  var year = date.getUTCFullYear();\n  var milliseconds = date.getUTCMilliseconds();\n  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';\n  return sign + padStart(abs(year), sign ? 6 : 4, 0) +\n    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +\n    '-' + padStart(date.getUTCDate(), 2, 0) +\n    'T' + padStart(date.getUTCHours(), 2, 0) +\n    ':' + padStart(date.getUTCMinutes(), 2, 0) +\n    ':' + padStart(date.getUTCSeconds(), 2, 0) +\n    '.' + padStart(milliseconds, 3, 0) +\n    'Z';\n} : nativeDateToISOString;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/date-to-iso-string.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-iso-string.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-iso-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var $ = __webpack_require__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\nvar toISOString = __webpack_require__(/*! ../internals/date-to-iso-string */ \"./node_modules/core-js/internals/date-to-iso-string.js\");\n\n// `Date.prototype.toISOString` method\n// https://tc39.es/ecma262/#sec-date.prototype.toisostring\n// PhantomJS / old WebKit has a broken implementations\n$({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== toISOString }, {\n  toISOString: toISOString\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.date.to-iso-string.js?");

/***/ })

}]);